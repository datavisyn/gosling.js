var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _dataPromise, _chromSizes, _parsedData, _assembly, _filter, _file, _fetchCsv, fetchCsv_fn, _processCsvRow, processCsvRow_fn, _calcCumulativePos, calcCumulativePos_fn, _generateTilesetInfo, generateTilesetInfo_fn, _tile, tile_fn, _generateChomSizeInfo, generateChomSizeInfo_fn, _table;
import * as PIXI from "pixi.js";
import { color } from "d3-color";
import { group, max, min, sum } from "d3-array";
import { Bezier } from "bezier-js";
import { scaleLinear, scaleSequential, scaleOrdinal, scaleBand } from "d3-scale";
import { isUndefined, sampleSize, isEqual, uniqBy, cloneDeepWith } from "lodash-es";
import { interpolateViridis, interpolateGreys, interpolateWarm, interpolateSpectral, interpolateCividis, interpolateBuPu, interpolateRdBu, interpolateYlOrBr, interpolateRdPu } from "d3-scale-chromatic";
import higlassRegister from "higlass-register";
import { TextTrack } from "higlass-text";
import RBush from "rbush";
import { precisionPrefix, format as format$1, formatPrefix } from "d3-format";
import { c as computeChromSizes, R as RemoteFile, s as sanitizeChrName, f as filterUsingGenoPos, g as getAutoCompleteId, a as getRelativeGenomicPosition, G as GenomicPositionHelper } from "./exported-utils-068d7b17.js";
import { arc } from "d3-shape";
import { createNanoEvents } from "nanoevents";
import { spawn } from "threads";
import { Buffer as Buffer2 } from "buffer";
import QuickLRU from "quick-lru";
import { RemoteFile as RemoteFile$1, LocalFile } from "generic-filehandle";
import { dsvFormat } from "d3-dsv";
import PubSub$1 from "pubsub-js";
import React, { forwardRef, useState, useEffect, useMemo, useRef, useImperativeHandle, useCallback } from "react";
import require$$0 from "react-dom";
import { HiGlassComponent } from "higlass";
import { ResizeSensor } from "css-element-queries";
const name = "gosling.js";
const version = "0.13.1";
const DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM = 6;
const DEFAULT_TRACK_HEIGHT_LINEAR = 130;
const DEFAULT_TRACK_WIDTH_LINEAR = 600;
const DEFAULT_TRACK_SIZE_2D = 600;
const DEFAULT_VIEW_SPACING = 10;
const DEFAULT_INNER_RADIUS_PROP = 0.3;
const DEFAULT_CIRCULAR_VIEW_PADDING = 0;
const DEFAULT_BACKUP_COLOR = "gray";
const colorToHex = (colorStr) => {
  let c = color(colorStr);
  if (!c) {
    c = color(DEFAULT_BACKUP_COLOR);
  }
  const hex = PIXI.utils.rgb2hex([c.rgb().r / 255, c.rgb().g / 255, c.rgb().b / 255]);
  return hex;
};
const RADIAN_GAP = 0;
function valueToRadian(v, max2, sa, ea, g) {
  const safeVal = Math.max(Math.min(max2, v), 0);
  const gap = g != null ? g : RADIAN_GAP;
  const radExtent = (ea - sa) / 360 * Math.PI * 2 - gap * 2;
  const radStart = sa / 360 * Math.PI * 2;
  return -(radStart + safeVal / max2 * radExtent) - Math.PI / 2 - gap;
}
function cartesianToPolar(x, max2, r, cx, cy, sa, ea) {
  return {
    x: cx + r * Math.cos(valueToRadian(x, max2, sa, ea)),
    y: cy + r * Math.sin(valueToRadian(x, max2, sa, ea))
  };
}
function positionToRadian(x, y, cx, cy) {
  if (cx <= x) {
    return Math.atan((y - cy) / (x - cx));
  } else {
    return Math.atan((y - cy) / (x - cx)) - Math.PI;
  }
}
function pointsToDegree(x, y, cx, cy) {
  return (Math.atan2(-(y - cy), x - cx) / Math.PI * 180 + 270) % 360;
}
function drawPoint(track, g, model) {
  var _a, _b, _c, _d, _e;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = track.dimensions;
  const zoomLevel = model.getChannelScale("x").invert(trackWidth) - model.getChannelScale("x").invert(0);
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter(
      (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
    ).forEach((d) => {
      const cx = model.encodedPIXIProperty("x-center", d);
      const cy = model.encodedPIXIProperty("y-center", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const radius = model.encodedPIXIProperty("p-size", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      const alphaTransition = model.markVisibility(d, { width: radius, zoomLevel });
      const actualOpacity = Math.min(alphaTransition, opacity);
      if (radius <= 0.1 || actualOpacity === 0 || cx + radius < 0 || cx - radius > trackWidth) {
        return;
      }
      g.lineStyle(
        strokeWidth,
        colorToHex(stroke),
        actualOpacity,
        // alpha
        1
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      if (circular) {
        const r = trackOuterRadius - (rowPosition + rowHeight - cy) / trackHeight * trackRingSize;
        const pos = cartesianToPolar(cx, trackWidth, r, tcx, tcy, startAngle, endAngle);
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawCircle(pos.x, pos.y, radius);
        model.getMouseEventModel().addPointBasedEvent(d, [pos.x, pos.y, radius]);
      } else {
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawCircle(cx, rowPosition + rowHeight - cy, radius);
        model.getMouseEventModel().addPointBasedEvent(d, [cx, rowPosition + rowHeight - cy, radius]);
      }
    });
  });
}
function pointProperty(model, propertyKey, datum) {
  const xe = model.visualPropertyByChannel("xe", datum);
  const x = model.visualPropertyByChannel("x", datum);
  const size = model.visualPropertyByChannel("size", datum);
  switch (propertyKey) {
    case "x-center":
      return xe ? (xe + x) / 2 : x;
    case "y-center": {
      const ye = model.visualPropertyByChannel("ye", datum);
      const y = model.visualPropertyByChannel("y", datum);
      return ye ? (ye + y) / 2 : y;
    }
    case "p-size":
      return xe && model.spec().stretch ? (xe - x) / 2 : size;
    default:
      return void 0;
  }
}
function drawLine(g, model, trackWidth, trackHeight) {
  var _a, _b, _c, _d, _e, _f;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const trackCenterX = trackWidth / 2;
  const trackCenterY = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const colorCategories = (_f = model.getChannelDomainArray("color")) != null ? _f : ["___SINGLE_COLOR___"];
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    colorCategories.forEach((colorCategory) => {
      data2.filter(
        (d) => (!getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory) && (!getValueUsingChannel(d, spec.color) || getValueUsingChannel(d, spec.color) === colorCategory)
      ).sort(
        (d1, d2) => (
          // draw from the left to right
          getValueUsingChannel(d1, spec.x) - getValueUsingChannel(d2, spec.x)
        )
      ).forEach((d, i) => {
        const cx = model.encodedPIXIProperty("x", d);
        const y = model.encodedPIXIProperty("y", d);
        const size = model.encodedPIXIProperty("size", d);
        const color2 = model.encodedPIXIProperty("color", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        g.lineStyle(
          size,
          colorToHex(color2),
          opacity,
          0.5
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        if (circular) {
          const r = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
          const pos = cartesianToPolar(
            cx,
            trackWidth,
            r,
            trackCenterX,
            trackCenterY,
            startAngle,
            endAngle
          );
          if (i === 0) {
            g.moveTo(pos.x, pos.y);
          } else {
            g.lineTo(pos.x, pos.y);
          }
          model.getMouseEventModel().addPointBasedEvent(d, [pos.x, pos.y, 1]);
        } else {
          if (i === 0) {
            g.moveTo(cx, rowPosition + rowHeight - y);
          } else {
            g.lineTo(cx, rowPosition + rowHeight - y);
          }
          model.getMouseEventModel().addPointBasedEvent(d, [cx, rowPosition + rowHeight - y, 1]);
        }
      });
    });
  });
}
function drawBar(track, tile, model) {
  var _a, _b, _c, _d, _e, _f, _g;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = track.dimensions;
  const tileSize = track.tilesetInfo.tile_size;
  const zoomLevel = model.getChannelScale("x").invert(trackWidth) - model.getChannelScale("x").invert(0);
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const xScale = model.getChannelScale("x");
  let tileUnitWidth;
  if (tile.tileData.tilePos) {
    const { tileX, tileWidth } = track.getTilePosAndDimensions(
      tile.tileData.zoomLevel,
      tile.tileData.tilePos,
      tileSize
    );
    tileUnitWidth = xScale(tileX + tileWidth / tileSize) - xScale(tileX);
  }
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const clipRow = !IsChannelDeep(spec.row) || IsChannelDeep(spec.row) && typeof spec.row.clip === "undefined" || spec.row.clip;
  const baselineValue = IsChannelDeep(spec.y) ? (_f = spec.y) == null ? void 0 : _f.baseline : void 0;
  const staticBaseY = (_g = model.encodedValue("y", baselineValue)) != null ? _g : 0;
  const g = tile.graphics;
  if (IsStackedMark(spec)) {
    const genomicChannel = model.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    const pivotedData = group(data2, (d) => d[genomicChannel.field]);
    const xKeys = [...pivotedData.keys()];
    xKeys.forEach((k) => {
      var _a2;
      let prevYEnd = 0;
      (_a2 = pivotedData.get(k)) == null ? void 0 : _a2.forEach((d) => {
        const color2 = model.encodedPIXIProperty("color", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        const y = model.encodedPIXIProperty("y", d);
        const barWidth = model.encodedPIXIProperty("width", d, { tileUnitWidth });
        const xs = model.encodedPIXIProperty("x-start", d, { markWidth: barWidth });
        const xe = xs + barWidth;
        const alphaTransition = model.markVisibility(d, { width: barWidth, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (actualOpacity === 0 || barWidth <= 0 || y <= 0) {
          return;
        }
        g.lineStyle(
          strokeWidth,
          colorToHex(stroke),
          actualOpacity,
          0
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        let polygonForMouseEvents = [];
        if (circular) {
          const farR = trackOuterRadius - (rowHeight - prevYEnd) / trackHeight * trackRingSize;
          const nearR = trackOuterRadius - (rowHeight - y - prevYEnd) / trackHeight * trackRingSize;
          const sPos = cartesianToPolar(xs, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(xs, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(xs + barWidth, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          polygonForMouseEvents = Array.from(g.currentPath.points);
          g.closePath();
        } else {
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.drawRect(xs, rowHeight - y - prevYEnd, barWidth, y);
          const ys = rowHeight - y - prevYEnd;
          const ye = ys + y;
          polygonForMouseEvents = [xs, ys, xs, ye, xe, ye, xe, ys];
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvents);
        prevYEnd += y;
      });
    });
  } else {
    rowCategories.forEach((rowCategory) => {
      const rowPosition = model.encodedValue("row", rowCategory);
      data2.filter((d) => {
        const rowValue = getValueUsingChannel(d, spec.row);
        return !rowValue || rowValue === rowCategory;
      }).forEach((d) => {
        const color2 = model.encodedPIXIProperty("color", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity");
        let y = model.encodedPIXIProperty("y", d);
        let ye = model.encodedPIXIProperty("ye", d);
        if (typeof ye !== "undefined" && y > ye) {
          [y, ye] = [ye, y];
        }
        const barWidth = model.encodedPIXIProperty("width", d, { tileUnitWidth });
        const xs = model.encodedPIXIProperty("x-start", d, { markWidth: barWidth });
        const xe = xs + barWidth;
        let ys;
        if (typeof ye === "undefined") {
          ys = rowPosition + rowHeight - staticBaseY - y;
          ye = rowPosition + rowHeight - staticBaseY;
          if (IsChannelDeep(spec.y) && spec.y.flip || spec.flipY) {
            ye = ys;
            ys = rowPosition;
          }
        } else {
          ys = rowPosition + rowHeight - ye;
          ye = rowPosition + rowHeight - y;
        }
        if (clipRow) {
          ys = Math.max(rowPosition, ys);
          ys = Math.min(ys, rowPosition + rowHeight);
          ye = Math.max(rowPosition, ye);
          ye = Math.min(ye, rowPosition + rowHeight);
        }
        const alphaTransition = model.markVisibility(d, { width: barWidth, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (actualOpacity === 0 || barWidth === 0 || ye - ys === 0) {
          return;
        }
        g.lineStyle(
          strokeWidth,
          colorToHex(stroke),
          actualOpacity,
          0
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        let polygonForMouseEvents = [];
        if (circular) {
          const farR = trackOuterRadius - ys / trackHeight * trackRingSize;
          const nearR = trackOuterRadius - ye / trackHeight * trackRingSize;
          const sPos = cartesianToPolar(xs, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(xs, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(xs + barWidth, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          polygonForMouseEvents = Array.from(g.currentPath.points);
          g.closePath();
        } else {
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.drawRect(xs, ys, barWidth, ye - ys);
          polygonForMouseEvents = [xs, ys, xs, ye, xe, ye, xe, ys];
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvents);
      });
    });
  }
}
function barProperty(gm, propertyKey, datum, additionalInfo) {
  const x = gm.visualPropertyByChannel("x", datum);
  const xe = gm.visualPropertyByChannel("xe", datum);
  const size = gm.visualPropertyByChannel("size", datum);
  switch (propertyKey) {
    case "width":
      return size != null ? size : xe ? xe - x : additionalInfo == null ? void 0 : additionalInfo.tileUnitWidth;
    case "x-start":
      if (!(additionalInfo == null ? void 0 : additionalInfo.markWidth)) {
        return void 0;
      }
      return xe ? (x + xe - (additionalInfo == null ? void 0 : additionalInfo.markWidth)) / 2 : x - (additionalInfo == null ? void 0 : additionalInfo.markWidth) / 2;
    default:
      return void 0;
  }
}
function drawArea(HGC, track, tile, model) {
  var _a, _b, _c, _d, _e, _f;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = track.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const trackCenterX = trackWidth / 2;
  const trackCenterY = trackHeight / 2;
  const xScale = track._xScale;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const colorCategories = (_f = model.getChannelDomainArray("color")) != null ? _f : ["___SINGLE_COLOR___"];
  const constantOpacity = model.encodedPIXIProperty("opacity");
  const constantStrokeWidth = model.encodedPIXIProperty("strokeWidth");
  const constantStroke = model.encodedPIXIProperty("stroke");
  const graphics = tile.graphics;
  if (IsStackedMark(spec)) {
    const genomicChannel = model.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    const pivotedData = group(data2, (d) => d[genomicChannel.field]);
    const genomicPosCategories = [...pivotedData.keys()];
    graphics.lineStyle(
      constantStrokeWidth,
      colorToHex(constantStroke),
      constantOpacity,
      1
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    const prevYEndByGPos = {};
    colorCategories.forEach((colorCategory) => {
      const areaPointsTop = [];
      const areaPointsBottom = [];
      genomicPosCategories.forEach((genomicPosCategory, i, array) => {
        var _a2, _b2;
        (_b2 = (_a2 = pivotedData.get(genomicPosCategory)) == null ? void 0 : _a2.filter((d) => getValueUsingChannel(d, spec.color) === colorCategory)) == null ? void 0 : _b2.forEach((d) => {
          const xValue = +genomicPosCategory;
          const cx = xScale(xValue);
          const cy = max([model.encodedPIXIProperty("y", d), 0]);
          if (typeof prevYEndByGPos[genomicPosCategory] === "undefined") {
            prevYEndByGPos[genomicPosCategory] = 0;
          }
          const ys = rowHeight - cy - prevYEndByGPos[genomicPosCategory];
          const ye = rowHeight - prevYEndByGPos[genomicPosCategory];
          if (circular) {
            if (i === 0) {
              const r = trackOuterRadius - rowHeight / trackHeight * trackRingSize;
              const pos = cartesianToPolar(
                cx,
                trackWidth,
                r,
                trackCenterX,
                trackCenterY,
                startAngle,
                endAngle
              );
              areaPointsTop.push([pos.x, pos.y]);
              areaPointsBottom.push([pos.x, pos.y]);
            }
            const rTop = trackOuterRadius - ys / trackHeight * trackRingSize;
            const posTop = cartesianToPolar(
              cx,
              trackWidth,
              rTop,
              trackCenterX,
              trackCenterY,
              startAngle,
              endAngle
            );
            areaPointsTop.push([posTop.x, posTop.y]);
            const rBot = trackOuterRadius - ye / trackHeight * trackRingSize;
            const posBot = cartesianToPolar(
              cx,
              trackWidth,
              rBot,
              trackCenterX,
              trackCenterY,
              startAngle,
              endAngle
            );
            areaPointsBottom.push([posBot.x, posBot.y]);
            if (i === array.length - 1) {
              const r = trackOuterRadius - rowHeight / trackHeight * trackRingSize;
              const pos = cartesianToPolar(
                cx,
                trackWidth,
                r,
                trackCenterX,
                trackCenterY,
                startAngle,
                endAngle
              );
              areaPointsTop.push([pos.x, pos.y]);
              areaPointsBottom.push([pos.x, pos.y]);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [posBot.x, posBot.y, 1]);
          } else {
            if (i === 0) {
              areaPointsTop.push([cx, rowHeight]);
              areaPointsBottom.push([cx, rowHeight]);
            }
            areaPointsTop.push([cx, ys]);
            areaPointsBottom.push([cx, ye]);
            if (i === array.length - 1) {
              areaPointsTop.push([cx, rowHeight]);
              areaPointsBottom.push([cx, rowHeight]);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [cx, ys, 1]);
          }
          prevYEndByGPos[genomicPosCategory] += cy;
        });
      });
      const color2 = model.encodedValue("color", colorCategory);
      graphics.beginFill(colorToHex(color2), constantOpacity);
      graphics.drawPolygon([
        ...areaPointsTop.reduce((a, b) => a.concat(b)),
        ...areaPointsBottom.reverse().reduce((a, b) => a.concat(b))
      ]);
      graphics.endFill();
    });
  } else {
    rowCategories.forEach((rowCategory) => {
      const rowPosition = model.encodedValue("row", rowCategory);
      graphics.lineStyle(
        constantStrokeWidth,
        colorToHex(constantStroke),
        constantOpacity,
        0
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      colorCategories.forEach((colorCategory) => {
        const baselinePoints = [];
        const areaPoints = [];
        const baselineR = trackOuterRadius - (rowPosition + rowHeight) / trackHeight * trackRingSize;
        let startX = 0;
        data2.filter(
          (d) => (typeof getValueUsingChannel(d, spec.row) === "undefined" || getValueUsingChannel(d, spec.row) === rowCategory) && (typeof getValueUsingChannel(d, spec.color) === "undefined" || getValueUsingChannel(d, spec.color) === colorCategory)
        ).sort(
          // should sort properly before visualizing it so that the path is correctly drawn
          (a, b) => model.encodedPIXIProperty("x", a) - model.encodedPIXIProperty("x", b)
        ).forEach((d, i, array) => {
          const cy = min([max([model.encodedPIXIProperty("y", d), 0]), rowHeight]);
          const cx = model.encodedPIXIProperty("x", d);
          if (circular) {
            const baselinePos = cartesianToPolar(
              cx,
              trackWidth,
              baselineR,
              trackCenterX,
              trackCenterY,
              startAngle,
              endAngle
            );
            baselinePoints.push([baselinePos.x, baselinePos.y]);
            if (i === 0) {
              areaPoints.push(baselinePos.x, baselinePos.y);
            }
            const r = trackOuterRadius - (rowPosition + rowHeight - cy) / trackHeight * trackRingSize;
            const pos = cartesianToPolar(
              cx,
              trackWidth,
              r,
              trackCenterX,
              trackCenterY,
              startAngle,
              endAngle
            );
            areaPoints.push(pos.x, pos.y);
            if (i === array.length - 1) {
              const startR = trackOuterRadius - (rowPosition + rowHeight) / trackHeight * trackRingSize;
              const curPos = cartesianToPolar(
                cx,
                trackWidth,
                startR,
                trackCenterX,
                trackCenterY,
                startAngle,
                endAngle
              );
              areaPoints.push(curPos.x, curPos.y);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [pos.x, pos.y, 1]);
          } else {
            if (i === 0) {
              areaPoints.push(cx, rowPosition + rowHeight);
              startX = cx;
            }
            areaPoints.push(cx, rowPosition + rowHeight - cy);
            if (i === array.length - 1) {
              areaPoints.push(cx, rowPosition + rowHeight);
              areaPoints.push(startX, rowPosition + rowHeight);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [cx, rowPosition + rowHeight - cy, 1]);
          }
        });
        if (circular && baselinePoints.length !== 0) {
          areaPoints.push(...baselinePoints.reverse().reduce((a, b) => a.concat(b)));
        }
        const color2 = model.encodedValue("color", colorCategory);
        graphics.beginFill(colorToHex(color2), constantOpacity);
        graphics.drawPolygon(areaPoints);
        graphics.endFill();
      });
    });
  }
}
function drawRect(HGC, track, tile, model) {
  var _a, _b, _c, _d, _e, _f;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = track.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const xScale = track._xScale;
  let tileUnitWidth;
  if (tile.tileData.tilePos) {
    const tileSize = track.tilesetInfo.tile_size;
    const { tileX, tileWidth } = track.getTilePosAndDimensions(
      tile.tileData.zoomLevel,
      tile.tileData.tilePos,
      // TODO: required parameter. Typing out `track` should address this issue.
      tileSize
    );
    tileUnitWidth = xScale(tileX + tileWidth / tileSize) - xScale(tileX);
  }
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const RPAD = IsChannelDeep(spec.row) && spec.row.padding ? spec.row.padding : 0;
  const yCategories = (_f = model.getChannelDomainArray("y")) != null ? _f : ["___SINGLE_Y_POSITION___"];
  const cellHeight = rowHeight / yCategories.length - RPAD * 2;
  const g = tile.graphics;
  data2.forEach((d) => {
    var _a2;
    const rowPosition = model.encodedPIXIProperty("row", d) + RPAD;
    const x = model.encodedPIXIProperty("x", d);
    const color2 = model.encodedPIXIProperty("color", d);
    const stroke = model.encodedPIXIProperty("stroke", d);
    const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
    const opacity = model.encodedPIXIProperty("opacity", d);
    const rectWidth = model.encodedPIXIProperty("width", d, { markWidth: tileUnitWidth });
    const rectHeight = model.encodedPIXIProperty("height", d, { markHeight: cellHeight });
    const y = model.encodedPIXIProperty("y", d);
    const alphaTransition = model.markVisibility(d, {
      width: rectWidth,
      zoomLevel: track._xScale.invert(trackWidth) - track._xScale.invert(0)
    });
    const actualOpacity = Math.min(alphaTransition, opacity);
    if (actualOpacity === 0 || rectHeight === 0 || rectWidth <= 1e-4) {
      return;
    }
    const [xs, xe, ys, ye] = [
      x,
      x + rectWidth,
      rowPosition + rowHeight - y - rectHeight / 2,
      rowPosition + rowHeight - y + rectHeight / 2
    ];
    const absoluteHeight = (_a2 = model.visualPropertyByChannel("size", d)) != null ? _a2 : void 0;
    g.lineStyle(
      strokeWidth,
      colorToHex(stroke),
      actualOpacity,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    let polygonForMouseEvent = [];
    if (circular) {
      if (xe < 0 || trackWidth < xs) {
        return;
      }
      let farR = trackOuterRadius - ys / trackHeight * trackRingSize;
      let nearR = trackOuterRadius - ye / trackHeight * trackRingSize;
      if (absoluteHeight) {
        const midR = trackOuterRadius - (rowPosition + y) / trackHeight * trackRingSize;
        farR = midR - absoluteHeight / 2;
        nearR = midR + absoluteHeight / 2;
      }
      const sPos = cartesianToPolar(xs, trackWidth, nearR, cx, cy, startAngle, endAngle);
      const startRad = valueToRadian(xs, trackWidth, startAngle, endAngle);
      const endRad = valueToRadian(xe, trackWidth, startAngle, endAngle);
      g.beginFill(colorToHex(color2 === "none" ? "white" : color2), color2 === "none" ? 0 : actualOpacity);
      g.moveTo(sPos.x, sPos.y);
      g.arc(cx, cy, nearR, startRad, endRad, true);
      g.arc(cx, cy, farR, endRad, startRad, false);
      polygonForMouseEvent = Array.from(g.currentPath.points);
      g.closePath();
    } else {
      g.beginFill(colorToHex(color2 === "none" ? "white" : color2), color2 === "none" ? 0 : actualOpacity);
      g.drawRect(xs, ys, xe - xs, ye - ys);
      polygonForMouseEvent = [xs, ys, xs, ye, xe, ye, xe, ys];
    }
    model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvent);
  });
}
function rectProperty(gm, propertyKey, datum, additionalInfo) {
  var _a;
  switch (propertyKey) {
    case "width":
      const width = (
        // (1) size
        gm.visualPropertyByChannel("xe", datum) ? gm.visualPropertyByChannel("xe", datum) - gm.visualPropertyByChannel("x", datum) : (
          // (2) unit mark height
          additionalInfo == null ? void 0 : additionalInfo.markWidth
        )
      );
      return width === 0 ? 0.1 : width;
    case "height":
      return (
        // (1) size
        (_a = gm.visualPropertyByChannel("size", datum)) != null ? _a : (
          // (2) unit mark height
          additionalInfo == null ? void 0 : additionalInfo.markHeight
        )
      );
    default:
      return void 0;
  }
}
function drawTriangle(g, model, trackWidth, trackHeight) {
  var _a, _b, _c, _d, _e, _f, _g;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const zoomLevel = model.getChannelScale("x").invert(trackWidth) - model.getChannelScale("x").invert(0);
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const yCategories = (_f = model.getChannelDomainArray("y")) != null ? _f : ["___SINGLE_Y___"];
  const triHeight = (_g = model.encodedValue("size")) != null ? _g : circular ? trackRingSize / rowCategories.length / yCategories.length : rowHeight / yCategories.length;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter(
      (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
    ).forEach((d) => {
      var _a2, _b2, _c2;
      const x = model.encodedPIXIProperty("x", d);
      const xe = model.encodedPIXIProperty("xe", d);
      const markWidth = (_a2 = model.encodedPIXIProperty("size", d)) != null ? _a2 : xe === void 0 ? triHeight : xe - x;
      const y = model.encodedPIXIProperty("y", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      let polygon = [];
      if (circular) {
        let x0 = x ? x : xe - markWidth;
        let x1 = xe ? xe : x + markWidth;
        let xm = (x0 + x1) / 2;
        const rm = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
        const r0 = rm - triHeight / 2;
        const r1 = rm + triHeight / 2;
        if (((_b2 = spec.style) == null ? void 0 : _b2.align) === "right" && !xe) {
          x0 -= markWidth;
          x1 -= markWidth;
          xm -= markWidth;
        }
        if (spec.mark === "triangleLeft") {
          const p0 = cartesianToPolar(x1, trackWidth, r0, cx, cy, startAngle, endAngle);
          const p1 = cartesianToPolar(x0, trackWidth, rm, cx, cy, startAngle, endAngle);
          const p2 = cartesianToPolar(x1, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p3 = cartesianToPolar(x1, trackWidth, r0, cx, cy, startAngle, endAngle);
          polygon = [p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
        } else if (spec.mark === "triangleRight") {
          const p0 = cartesianToPolar(x0, trackWidth, r0, cx, cy, startAngle, endAngle);
          const p1 = cartesianToPolar(x1, trackWidth, rm, cx, cy, startAngle, endAngle);
          const p2 = cartesianToPolar(x0, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p3 = cartesianToPolar(x0, trackWidth, r0, cx, cy, startAngle, endAngle);
          polygon = [p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
        } else if (spec.mark === "triangleBottom") {
          x0 = xm - markWidth / 2;
          x1 = xm + markWidth / 2;
          const p0 = cartesianToPolar(x0, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p1 = cartesianToPolar(x1, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p2 = cartesianToPolar(xm, trackWidth, r0, cx, cy, startAngle, endAngle);
          const p3 = cartesianToPolar(x0, trackWidth, r1, cx, cy, startAngle, endAngle);
          polygon = [p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
        }
        const alphaTransition = model.markVisibility(d, { width: x1 - x0, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        g.lineStyle(
          strokeWidth,
          colorToHex(stroke),
          // too narrow triangle's stroke is becoming too sharp
          x1 - x0 > 2 ? actualOpacity : 0,
          // alpha
          0
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawPolygon(polygon);
        g.endFill();
      } else {
        let x0 = x ? x : xe - markWidth;
        let x1 = xe ? xe : x + markWidth;
        let xm = x0 + (x1 - x0) / 2;
        const ym = rowPosition + rowHeight - y;
        const y0 = rowPosition + rowHeight - y - triHeight / 2;
        const y1 = rowPosition + rowHeight - y + triHeight / 2;
        if (((_c2 = spec.style) == null ? void 0 : _c2.align) === "right" && !xe) {
          x0 -= markWidth;
          x1 -= markWidth;
          xm -= markWidth;
        }
        polygon = {
          triangleLeft: [x1, y0, x0, ym, x1, y1, x1, y0],
          triangleRight: [x0, y0, x1, ym, x0, y1, x0, y0],
          triangleBottom: [x0, y0, x1, y0, xm, y1, x0, y0]
        }[spec.mark];
        const alphaTransition = model.markVisibility(d, { width: x1 - x0, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        g.lineStyle(
          strokeWidth,
          colorToHex(stroke),
          // too narrow triangle's stroke is becoming too sharp
          x1 - x0 > 2 ? actualOpacity : 0,
          // alpha
          0.5
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawPolygon(polygon);
        g.endFill();
      }
      model.getMouseEventModel().addPolygonBasedEvent(d, polygon);
    });
  });
}
const TEXT_STYLE_GLOBAL = {
  fontSize: "12px",
  fontFamily: "sans-serif",
  // 'Arial',
  fontWeight: "normal",
  fill: "black",
  background: "white",
  lineJoin: "round",
  stroke: "#ffffff",
  strokeThickness: 0
};
function drawText(HGC, trackInfo, tile, model) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const dx = (_g = (_f = spec.style) == null ? void 0 : _f.dx) != null ? _g : 0;
  const dy = (_i = (_h = spec.style) == null ? void 0 : _h.dy) != null ? _i : 0;
  const textAnchor = !((_j = spec.style) == null ? void 0 : _j.textAnchor) ? "middle" : spec.style.textAnchor;
  if (IsStackedMark(spec)) {
    if (circular) {
      return;
    }
    const rowGraphics = tile.graphics;
    const genomicChannel = model.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    const pivotedData = group(data2, (d) => d[genomicChannel.field]);
    const xKeys = [...pivotedData.keys()];
    xKeys.forEach((k) => {
      var _a2;
      let prevYEnd = 0;
      (_a2 = pivotedData.get(k)) == null ? void 0 : _a2.forEach((d) => {
        var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
        const text = model.encodedPIXIProperty("text", d);
        const color2 = model.encodedPIXIProperty("color", d);
        const x = model.encodedPIXIProperty("x", d) + dx;
        const xe = model.encodedPIXIProperty("xe", d) + dx;
        const cx = model.encodedPIXIProperty("x-center", d) + dx;
        const y = model.encodedPIXIProperty("y", d) + dy;
        const size = model.encodedPIXIProperty("size", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        if (cx < 0 || cx > trackWidth) {
          return;
        }
        if (trackInfo.textsBeingUsed > 1e3) {
          return;
        }
        const localTextStyle = {
          ...TEXT_STYLE_GLOBAL,
          fontSize: size != null ? size : ((_a3 = spec.style) == null ? void 0 : _a3.textFontSize) ? `${(_b2 = spec.style) == null ? void 0 : _b2.textFontSize}px` : TEXT_STYLE_GLOBAL.fontSize,
          stroke: (_d2 = stroke != null ? stroke : (_c2 = spec.style) == null ? void 0 : _c2.textStroke) != null ? _d2 : TEXT_STYLE_GLOBAL.stroke,
          strokeThickness: (_f2 = strokeWidth != null ? strokeWidth : (_e2 = spec.style) == null ? void 0 : _e2.textStrokeWidth) != null ? _f2 : TEXT_STYLE_GLOBAL.strokeThickness,
          fontWeight: (_h2 = (_g2 = spec.style) == null ? void 0 : _g2.textFontWeight) != null ? _h2 : TEXT_STYLE_GLOBAL.fontWeight
        };
        const textStyleObj = new HGC.libraries.PIXI.TextStyle(localTextStyle);
        let textGraphic;
        if (trackInfo.textGraphics.length > trackInfo.textsBeingUsed) {
          textGraphic = trackInfo.textGraphics[trackInfo.textsBeingUsed];
          textGraphic.style.fill = color2;
          textGraphic.visible = true;
          textGraphic.text = text;
          textGraphic.alpha = 1;
        } else {
          textGraphic = new HGC.libraries.PIXI.Text(text, {
            ...localTextStyle,
            fill: color2
          });
          trackInfo.textGraphics.push(textGraphic);
        }
        const metric = HGC.libraries.PIXI.TextMetrics.measureText(text, textStyleObj);
        trackInfo.textsBeingUsed++;
        const alphaTransition = model.markVisibility(d, {
          ...metric,
          zoomLevel: trackInfo._xScale.invert(trackWidth) - trackInfo._xScale.invert(0)
        });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (!text || actualOpacity === 0) {
          trackInfo.textsBeingUsed--;
          textGraphic.visible = false;
          return;
        }
        textGraphic.alpha = actualOpacity;
        textGraphic.resolution = 8;
        textGraphic.updateText();
        textGraphic.texture.baseTexture.scaleMode = HGC.libraries.PIXI.SCALE_MODES.LINEAR;
        const sprite = new HGC.libraries.PIXI.Sprite(textGraphic.texture);
        sprite.x = x;
        sprite.y = rowHeight - y - prevYEnd;
        sprite.width = xe - x;
        sprite.height = y;
        rowGraphics.addChild(sprite);
        prevYEnd += y;
      });
    });
  } else {
    rowCategories.forEach((rowCategory) => {
      const rowGraphics = tile.graphics;
      const rowPosition = model.encodedValue("row", rowCategory);
      data2.filter(
        (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
      ).forEach((d) => {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
        const text = model.encodedPIXIProperty("text", d);
        const color2 = model.encodedPIXIProperty("color", d);
        const cx = model.encodedPIXIProperty("x-center", d) + dx;
        const y = model.encodedPIXIProperty("y", d) + dy;
        const size = model.encodedPIXIProperty("size", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        if (cx < 0 || cx > trackWidth) {
          return;
        }
        if (trackInfo.textsBeingUsed > 1e3) {
          return;
        }
        const localTextStyle = {
          ...TEXT_STYLE_GLOBAL,
          fontSize: size != null ? size : ((_a2 = spec.style) == null ? void 0 : _a2.textFontSize) ? `${(_b2 = spec.style) == null ? void 0 : _b2.textFontSize}px` : TEXT_STYLE_GLOBAL.fontSize,
          stroke: (_d2 = stroke != null ? stroke : (_c2 = spec.style) == null ? void 0 : _c2.textStroke) != null ? _d2 : TEXT_STYLE_GLOBAL.stroke,
          strokeThickness: (_f2 = strokeWidth != null ? strokeWidth : (_e2 = spec.style) == null ? void 0 : _e2.textStrokeWidth) != null ? _f2 : TEXT_STYLE_GLOBAL.strokeThickness,
          fontWeight: (_h2 = (_g2 = spec.style) == null ? void 0 : _g2.textFontWeight) != null ? _h2 : TEXT_STYLE_GLOBAL.fontWeight
        };
        const textStyleObj = new HGC.libraries.PIXI.TextStyle(localTextStyle);
        let textGraphic;
        if (trackInfo.textGraphics.length > trackInfo.textsBeingUsed) {
          textGraphic = trackInfo.textGraphics[trackInfo.textsBeingUsed];
          textGraphic.style.fill = color2;
          textGraphic.visible = true;
          textGraphic.text = text;
          textGraphic.alpha = 1;
        } else {
          textGraphic = new HGC.libraries.PIXI.Text(text, {
            ...localTextStyle,
            fill: color2
          });
          trackInfo.textGraphics.push(textGraphic);
        }
        const metric = HGC.libraries.PIXI.TextMetrics.measureText(text, textStyleObj);
        trackInfo.textsBeingUsed++;
        const alphaTransition = model.markVisibility(d, {
          ...metric,
          zoomLevel: trackInfo._xScale.invert(trackWidth) - trackInfo._xScale.invert(0)
        });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (!text || actualOpacity === 0) {
          trackInfo.textsBeingUsed--;
          textGraphic.visible = false;
          return;
        }
        textGraphic.alpha = actualOpacity;
        textGraphic.anchor.y = 0.5;
        textGraphic.anchor.x = textAnchor === "middle" ? 0.5 : textAnchor === "start" ? 0 : 1;
        let polygonForMouseEvents = [];
        if (circular) {
          const r = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
          const centerPos = cartesianToPolar(cx, trackWidth, r, tcx, tcy, startAngle, endAngle);
          textGraphic.x = centerPos.x;
          textGraphic.y = centerPos.y;
          textGraphic.resolution = 4;
          const tw = metric.width / (2 * r * Math.PI) * trackWidth;
          let [minX, maxX] = [cx - tw / 2, cx + tw / 2];
          if (minX < 0) {
            const gap = -minX;
            minX = 0;
            maxX += gap;
          } else if (maxX > trackWidth) {
            const gap = maxX - trackWidth;
            maxX = trackWidth;
            minX -= gap;
          }
          const ropePoints = [];
          const eventPointsFar = [];
          const eventPointsNear = [];
          for (let i = maxX; i >= minX; i -= tw / 10) {
            const p = cartesianToPolar(i, trackWidth, r, tcx, tcy, startAngle, endAngle);
            ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
            const pFar = cartesianToPolar(
              i,
              trackWidth,
              r + metric.height / 2,
              tcx,
              tcy,
              startAngle,
              endAngle
            );
            const pNear = cartesianToPolar(
              i,
              trackWidth,
              r - metric.height / 2,
              tcx,
              tcy,
              startAngle,
              endAngle
            );
            eventPointsFar.push(pFar.x, pFar.y);
            if (i === maxX) {
              eventPointsNear.push(pFar.y, pFar.x);
            }
            eventPointsNear.push(pNear.y, pNear.x);
          }
          textGraphic.updateText();
          const rope = new HGC.libraries.PIXI.SimpleRope(textGraphic.texture, ropePoints);
          rope.alpha = actualOpacity;
          rowGraphics.addChild(rope);
          eventPointsNear.reverse();
          polygonForMouseEvents = eventPointsFar.concat(eventPointsNear);
        } else {
          textGraphic.position.x = cx;
          textGraphic.position.y = rowPosition + rowHeight - y;
          rowGraphics.addChild(textGraphic);
          const { height: h, width: w } = metric;
          const ys = textGraphic.position.y - h / 2;
          const ye = ys + h;
          let xs = 0;
          let xe = 0;
          if (textAnchor === "start") {
            xs = cx;
            xe = cx + w;
          } else if (textAnchor === "middle") {
            xs = cx - w / 2;
            xe = cx + w / 2;
          } else {
            xs = cx - w;
            xe = cx;
          }
          polygonForMouseEvents = [xs, ys, xs, ye, xe, ye, xe, ys];
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvents);
      });
    });
  }
}
function drawRule(HGC, trackInfo, tile, model) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const dashed = (_f = spec.style) == null ? void 0 : _f.dashed;
  const linePattern = (_g = spec.style) == null ? void 0 : _g.linePattern;
  const curved = (_h = spec.style) == null ? void 0 : _h.curve;
  const g = tile.graphics;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter(
      (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
    ).forEach((d) => {
      const x = model.encodedPIXIProperty("x", d);
      const xe = model.encodedPIXIProperty("xe", d);
      const y = model.encodedPIXIProperty("y", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      const alphaTransition = model.markVisibility(d, {
        width: xe - x,
        zoomLevel: trackInfo._xScale.invert(trackWidth) - trackInfo._xScale.invert(0)
      });
      const actualOpacity = Math.min(alphaTransition, opacity);
      g.lineStyle(
        strokeWidth,
        colorToHex(color2),
        actualOpacity,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      if (!xe && (!spec.y || !("field" in spec.y))) {
        if (circular) {
          return;
        } else {
          if (dashed) {
            const [dashSize, gapSize] = dashed;
            let curPos = 0;
            do {
              g.moveTo(x, curPos);
              g.lineTo(x, curPos + dashSize);
              curPos += dashSize + gapSize;
            } while (curPos < trackHeight);
          } else {
            g.moveTo(x, 0);
            g.lineTo(x, trackHeight);
          }
        }
      } else if (!xe && y) {
        if (circular) {
          g.lineStyle(
            strokeWidth,
            colorToHex(color2),
            0,
            // alpha
            0.5
            // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
          );
          const midR = trackOuterRadius - (rowPosition + y) / trackHeight * trackRingSize;
          const farR = midR + strokeWidth / 2;
          const nearR = midR - strokeWidth / 2;
          const sPos = cartesianToPolar(0, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          g.closePath();
        } else {
          if (dashed) {
            const [dashSize, gapSize] = dashed;
            let curPos = 0;
            do {
              g.moveTo(curPos, rowPosition + rowHeight - y);
              g.lineTo(curPos + dashSize, rowPosition + rowHeight - y);
              curPos += dashSize + gapSize;
            } while (curPos < trackWidth);
          } else {
            g.moveTo(0, rowPosition + rowHeight - y);
            g.lineTo(trackWidth, rowPosition + rowHeight - y);
          }
        }
      } else {
        if (circular) {
          if (strokeWidth === 0) {
            return;
          }
          g.lineStyle(
            strokeWidth,
            colorToHex(color2),
            0,
            // alpha
            0.5
            // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
          );
          const midR = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
          const farR = midR + strokeWidth / 2;
          const nearR = midR - strokeWidth / 2;
          const sPos = cartesianToPolar(x, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(x, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(xe, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          g.closePath();
        } else if (dashed) {
          const [dashSize, gapSize] = dashed;
          let curPos = x;
          do {
            g.moveTo(curPos, rowPosition + rowHeight - y);
            g.lineTo(curPos + dashSize, rowPosition + rowHeight - y);
            curPos += dashSize + gapSize;
          } while (curPos < xe);
        } else {
          if (curved === void 0) {
            g.moveTo(x, rowPosition + rowHeight - y);
            g.lineTo(xe, rowPosition + rowHeight - y);
          } else if (curved === "top") {
            const CURVE_HEIGHT = 2;
            const xm = x + (xe - x) / 2;
            g.moveTo(x, rowPosition + rowHeight - y + CURVE_HEIGHT / 2);
            g.lineTo(xm, rowPosition + rowHeight - y - CURVE_HEIGHT / 2);
            g.moveTo(xm, rowPosition + rowHeight - y - CURVE_HEIGHT / 2);
            g.lineTo(xe, rowPosition + rowHeight - y + CURVE_HEIGHT / 2);
          }
        }
        if (linePattern && curved === void 0 && !circular) {
          const { type: pType, size: pSize } = linePattern;
          let curPos = Math.max(x, 0);
          g.lineStyle(0);
          const PATTERN_GAP_SIZE = pSize * 2;
          let count = 0;
          while (curPos < Math.min(xe, trackWidth) && count < 100) {
            const x0 = curPos;
            const x1 = curPos + pSize;
            const ym = rowPosition + rowHeight - y;
            const y0 = ym - pSize / 2;
            const y1 = ym + pSize / 2;
            g.beginFill(colorToHex(color2), actualOpacity);
            g.drawPolygon(
              pType === "triangleLeft" ? [x1, y0, x0, ym, x1, y1, x1, y0] : [x0, y0, x1, ym, x0, y1, x0, y0]
            );
            g.endFill();
            curPos += pSize + PATTERN_GAP_SIZE;
            count++;
          }
        }
      }
    });
  });
}
function drawWithinLink(g, trackInfo, model) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const MIN_HEIGHT = (_g = (_f = spec.style) == null ? void 0 : _f.linkMinHeight) != null ? _g : 0.5;
  const NUM_STEPS = ((_h = spec.experimental) == null ? void 0 : _h.performanceMode) ? 10 : 50;
  const showVerticalLines = (_j = (_i = spec.style) == null ? void 0 : _i.withinLinkVerticalLines) != null ? _j : false;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter(
      (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
    ).forEach((d) => {
      var _a2, _b2, _c2, _d2, _e2;
      let x = model.encodedPIXIProperty("x", d);
      let xe = model.encodedPIXIProperty("xe", d);
      let x1 = model.encodedPIXIProperty("x1", d);
      let x1e = model.encodedPIXIProperty("x1e", d);
      const y = model.encodedPIXIProperty("y", d);
      const ye = model.encodedPIXIProperty("ye", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      if (typeof xe !== "undefined") {
        [x, xe] = [x, xe].sort((a, b) => a - b);
      }
      if (typeof x1 !== "undefined" && typeof x1e !== "undefined") {
        [x1, x1e] = [x1, x1e].sort((a, b) => a - b);
      }
      const isRibbon = typeof xe !== "undefined" && typeof x1 !== "undefined" && typeof x1e !== "undefined" && // This means the strokeWidth of a band is too small, so we just need to draw a line instead
      Math.abs(x - xe) > 0.1 && Math.abs(x1 - x1e) > 0.1;
      if (!isRibbon && xe === void 0 && !Is2DTrack(spec)) {
        if (x1 === void 0 && x1e === void 0) {
          return;
        }
        xe = x1 !== void 0 ? x1 : x1e;
      }
      if (!isRibbon && Math.abs(x - xe) <= 0.1 && Math.abs(x1 - x1e) <= 0.1) {
        x = (x + xe) / 2;
        xe = (x1 + x1e) / 2;
      }
      g.lineStyle(
        strokeWidth,
        colorToHex(stroke),
        opacity,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      const flipY = IsChannelDeep(spec.y) && spec.y.flip || spec.flipY;
      const baseY = (_a2 = spec.baselineY) != null ? _a2 : rowPosition + (flipY ? 0 : rowHeight);
      let pathForMouseEvent = [];
      if (isRibbon) {
        g.beginFill(color2 === "none" ? colorToHex("white") : colorToHex(color2), color2 === "none" ? 0 : opacity);
        let [_x1, _x2, _x3, _x4] = [x, xe, x1, x1e];
        [_x1, _x2, _x3, _x4] = [_x1, _x2, _x3, _x4].sort((a, b) => a - b);
        if (_x1 > trackWidth || _x4 < 0 || Math.abs(_x4 - _x1) < 0.5) {
          return;
        }
        if (circular) {
          if (_x1 < 0 || _x4 > trackWidth) {
            return;
          }
          const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
          const posX = cartesianToPolar(_x1, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posXE = cartesianToPolar(_x2, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1 = cartesianToPolar(_x3, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1E = cartesianToPolar(_x4, trackWidth, r, tcx, tcy, startAngle, endAngle);
          g.moveTo(posX.x, posX.y);
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posX1E.x, posX1E.y);
          g.arc(
            tcx,
            tcy,
            trackOuterRadius,
            positionToRadian(posX1E.x, posX1E.y, tcx, tcy),
            positionToRadian(posX1.x, posX1.y, tcx, tcy),
            false
          );
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posXE.x, posXE.y);
          g.arc(
            tcx,
            tcy,
            trackOuterRadius,
            positionToRadian(posXE.x, posXE.y, tcx, tcy),
            positionToRadian(posX.x, posX.y, tcx, tcy),
            false
          );
          pathForMouseEvent = Array.from(g.currentPath.points);
          g.endFill();
        } else {
          g.moveTo(_x1, baseY);
          if (!((_b2 = spec.style) == null ? void 0 : _b2.linkStyle) || ((_c2 = spec.style) == null ? void 0 : _c2.linkStyle) === "circular") {
            g.arc(
              (_x1 + _x4) / 2,
              // cx
              baseY,
              // cy
              (_x4 - _x1) / 2,
              // radius
              -Math.PI,
              // start angle
              Math.PI,
              // end angle
              false
            );
            g.arc((_x2 + _x3) / 2, baseY, (_x3 - _x2) / 2, Math.PI, -Math.PI, true);
            pathForMouseEvent = Array.from(g.currentPath.points);
            g.closePath();
          } else {
            g.lineTo(_x3, rowPosition + rowHeight);
            g.bezierCurveTo(
              _x3 + (_x2 - _x3) / 3,
              // rowPosition + (x1 - x),
              rowPosition + rowHeight - (_x2 - _x3) / 2,
              //Math.min(rowHeight - (x1 - x), (xe - x1) / 2.0),
              _x3 + (_x2 - _x3) / 3 * 2,
              // rowPosition + (x1 - x),
              rowPosition + rowHeight - (_x2 - _x3) / 2,
              //Math.min(rowHeight - (x1 - x), (xe - x1) / 2.0),
              _x2,
              rowPosition + rowHeight
            );
            g.lineTo(_x4, rowPosition + rowHeight);
            g.bezierCurveTo(
              _x1 + (_x4 - _x1) / 3 * 2,
              // rowPosition,
              rowPosition + rowHeight - (_x4 - _x1) / 2,
              //Math.min(rowHeight, (x1e - x) / 2.0),
              _x1 + (_x4 - _x1) / 3,
              // rowPosition,
              rowPosition + rowHeight - (_x4 - _x1) / 2,
              //Math.min(rowHeight, (x1e - x) / 2.0),
              _x1,
              rowPosition + rowHeight
            );
            pathForMouseEvent = Array.from(g.currentPath.points);
            g.endFill();
          }
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, pathForMouseEvent);
      } else {
        const midX = (x + xe) / 2;
        g.beginFill(colorToHex("white"), 0);
        if (circular) {
          if (x < 0 || xe > trackWidth) {
            return;
          }
          if (((_d2 = spec.style) == null ? void 0 : _d2.linkStyle) === "straight") {
            const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
            const posS = cartesianToPolar(x, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const posE = cartesianToPolar(xe, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const x12 = posS.x;
            const y1 = posS.y;
            const x4 = posE.x;
            const y4 = posE.y;
            g.moveTo(x12, y1);
            g.lineTo(x4, y4);
            const length = 100;
            const eventPoints = Array.from({ length }, (d2, i) => {
              return {
                x: (x4 - x12) / (length - 1) * i + x12,
                y: (y4 - y1) / (length - 1) * i + y1
              };
            });
            pathForMouseEvent = eventPoints.flatMap((d2) => [d2.x, d2.y]);
          } else {
            const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
            const posS = cartesianToPolar(x, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const posE = cartesianToPolar(xe, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const x12 = posS.x;
            const y1 = posS.y;
            const x2 = posS.x;
            const y2 = posS.y;
            const x3 = trackWidth / 2;
            const y3 = trackHeight / 2;
            const x4 = posE.x;
            const y4 = posE.y;
            g.moveTo(x12, y1);
            const bezier = new Bezier(x12, y1, x2, y2, x3, y3, x4, y4);
            const points = bezier.getLUT(14);
            points.forEach((d2) => g.lineTo(d2.x, d2.y));
            const morePoints = bezier.getLUT(1e3);
            pathForMouseEvent = morePoints.flatMap((d2) => [d2.x, d2.y]);
          }
        } else {
          if (((_e2 = spec.style) == null ? void 0 : _e2.linkStyle) === "elliptical") {
            if (!(0 <= x && x <= trackWidth) && !(0 <= xe && xe <= trackWidth)) {
              return;
            }
            const points = [];
            const isYSpecified = IsChannelDeep(spec.y);
            for (let step = 0; step <= NUM_STEPS; step++) {
              const theta = Math.PI * (step / NUM_STEPS);
              const mx = (xe - x) / 2 * Math.cos(theta) + (x + xe) / 2;
              let my = baseY - y * Math.sin(theta) * (isYSpecified ? 1 : Math.min(xe - x + trackWidth * MIN_HEIGHT, trackWidth) / trackWidth) * (flipY ? -1 : 1);
              if (typeof y !== "undefined" && typeof ye !== "undefined") {
                const linkHeight = Math.abs(ye - y);
                const flipShape = ye > y;
                my = y - linkHeight * Math.sin(theta) * (flipShape ? -1 : 1);
              }
              if (step === 0) {
                if (showVerticalLines) {
                  const _y = flipY ? baseY - trackHeight : baseY;
                  g.moveTo(mx, _y);
                  points.push({ x: mx, y: _y });
                  g.lineTo(mx, my);
                } else {
                  g.moveTo(mx, my);
                }
              } else {
                g.lineTo(mx, my);
              }
              points.push({ x: mx, y: my });
              if (step === NUM_STEPS && showVerticalLines) {
                const _y = flipY ? baseY - trackHeight : baseY;
                g.lineTo(mx, _y);
                points.push({ x: mx, y: _y });
              }
            }
            pathForMouseEvent = points.flatMap((d2) => [d2.x, d2.y]);
          } else {
            if (xe < 0 || x > trackWidth) {
              return;
            }
            g.arc(midX, baseY, (xe - x) / 2, -Math.PI, Math.PI);
            pathForMouseEvent = Array.from(g.currentPath.points);
            g.closePath();
          }
        }
        model.getMouseEventModel().addLineBasedEvent(d, pathForMouseEvent);
      }
    });
  });
}
function insertItemToArray(array, index, item) {
  return [...array.slice(0, index), item, ...array.slice(index)];
}
function flatArrayToPairArray(array) {
  const output = [];
  for (let i = 0; i < array.length; i += 2) {
    output.push([array[i], array[i + 1]]);
  }
  return output;
}
function isEvery(array, is) {
  return array.every(is);
}
function isNumberArray(array) {
  return isEvery(array, (x) => typeof x === "number");
}
function isStringArray(array) {
  return isEvery(array, (x) => typeof x === "string");
}
function drawGrid(trackInfo, tm, theme) {
  drawYGridQuantitative(trackInfo, tm, theme);
  drawRowGrid(trackInfo, tm, theme);
}
function drawRowGrid(trackInfo, tm, theme) {
  var _a, _b, _c, _d;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.row) || spec.row.grid !== true) {
    return;
  }
  const [trackX, trackY] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = tm.spec().layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = tm.getChannelDomainArray("row");
  if (!rowCategories) {
    return;
  }
  const rowHeight = trackHeight / rowCategories.length;
  if (circular && trackRingSize <= 20 || !circular && rowHeight <= 20) {
    return;
  }
  const graphics = trackInfo.pBackground;
  const strokeWidth = theme.axis.gridStrokeWidth;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = tm.encodedValue("row", rowCategory);
    if (!circular) {
      graphics.lineStyle(
        strokeWidth,
        colorToHex(theme.axis.gridColor),
        1,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      const y = trackY + rowPosition + rowHeight / 2;
      graphics.moveTo(trackX, y);
      graphics.lineTo(trackX + trackWidth, y);
    } else {
      const y = rowPosition + rowHeight / 2;
      const midR = trackOuterRadius - y / trackHeight * trackRingSize;
      const farR = midR + strokeWidth / 2;
      const nearR = midR - strokeWidth / 2;
      const sPos = cartesianToPolar(0, trackWidth, nearR, cx, cy, startAngle, endAngle);
      const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
      const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
      graphics.lineStyle(
        strokeWidth,
        colorToHex("black"),
        0,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      graphics.beginFill(colorToHex(theme.axis.gridColor), 1);
      graphics.moveTo(trackX + sPos.x, trackY + sPos.y);
      graphics.arc(trackX + cx, trackY + cy, nearR, startRad, endRad, true);
      graphics.arc(trackX + cx, trackY + cy, farR, endRad, startRad, false);
      graphics.closePath();
    }
  });
}
function drawYGridQuantitative(trackInfo, tm, theme) {
  var _a, _b, _c, _d, _e;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.y) || spec.y.grid !== true) {
    return;
  }
  const [trackX, trackY] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const startX = trackX;
  const endX = trackX + trackWidth;
  const circular = tm.spec().layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = (_e = tm.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  if (!isStringArray(rowCategories)) {
    return;
  }
  const scale = tm.getChannelScale("y");
  const domain = tm.getChannelDomainArray("y");
  if (!scale || !domain || !isNumberArray(domain)) {
    return;
  }
  if (circular && rowHeight / trackHeight * trackRingSize <= 20 || !circular && rowHeight <= 20) {
    return;
  }
  const graphics = trackInfo.pBackground;
  const strokeWidth = theme.axis.gridStrokeWidth;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = tm.encodedValue("row", rowCategory);
    const assignedHeight = circular ? rowHeight / trackHeight * trackRingSize : rowHeight;
    const tickCount = Math.max(Math.ceil(assignedHeight / 40), 1);
    let ticks = scale.ticks(tickCount).filter((v) => domain[0] <= v && v <= domain[1]);
    if (ticks.length === 1) {
      ticks = scale.ticks(tickCount + 1).filter((v) => domain[0] <= v && v <= domain[1]);
    }
    if (!circular) {
      graphics.lineStyle(
        strokeWidth,
        colorToHex(theme.axis.gridColor),
        1,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      ticks.forEach((value) => {
        var _a2;
        const y = trackY + rowPosition + rowHeight - scale(value);
        if (theme.axis.gridStrokeType === "solid") {
          graphics.moveTo(startX, y);
          graphics.lineTo(endX, y);
        } else if (theme.axis.gridStrokeType === "dashed") {
          const [line, gap] = (_a2 = theme.axis.gridStrokeDash) != null ? _a2 : [1, 1];
          for (let i = startX; i < endX; i += line + gap) {
            graphics.moveTo(i, y);
            graphics.lineTo(i + line, y);
          }
        }
      });
    } else {
      ticks.forEach((value) => {
        const y = scale(value);
        const midR = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
        const farR = midR + strokeWidth / 2;
        const nearR = midR - strokeWidth / 2;
        const sPos = cartesianToPolar(0, trackWidth, nearR, cx, cy, startAngle, endAngle);
        const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
        const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
        graphics.lineStyle(
          strokeWidth,
          colorToHex("black"),
          0,
          // alpha
          0.5
          // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
        );
        graphics.beginFill(colorToHex(theme.axis.gridColor), 1);
        graphics.moveTo(trackX + sPos.x, trackY + sPos.y);
        graphics.arc(trackX + cx, trackY + cy, nearR, startRad, endRad, true);
        graphics.arc(trackX + cx, trackY + cy, farR, endRad, startRad, false);
        graphics.closePath();
      });
    }
  });
}
const DEFAULT_TEXT_STYLE = {
  color: "black",
  size: 10,
  fontFamily: "Arial",
  fontWeight: "normal",
  stroke: "#ffffff",
  strokeThickness: 0
};
function getTextStyle(style = {}) {
  const merged = { ...DEFAULT_TEXT_STYLE, ...style };
  const pixiTextStyle = {
    fontSize: `${merged.size}px`,
    fontFamily: merged.fontFamily,
    fontWeight: merged.fontWeight === "light" ? "lighter" : merged.fontWeight,
    fill: merged.color,
    lineJoin: "round",
    stroke: merged.stroke,
    strokeThickness: merged.strokeThickness
  };
  return pixiTextStyle;
}
function drawCircularTitle(HGC, trackInfo, tile, model, theme) {
  var _a, _b, _c;
  const spec = model.spec();
  const { title: title2 } = spec;
  if (spec.layout !== "circular") {
    return;
  }
  if (!title2) {
    return;
  }
  const [tw, th] = trackInfo.dimensions;
  const trackOuterRadius = (_a = spec.outerRadius) != null ? _a : 300;
  const startAngle = (_b = spec.startAngle) != null ? _b : 0;
  const endAngle = (_c = spec.endAngle) != null ? _c : 360;
  const cx = tw / 2;
  const cy = th / 2;
  const g = tile.graphics;
  const titleR = trackOuterRadius - 1;
  const padding = 1;
  const pos = cartesianToPolar(padding, tw, titleR, cx, cy, startAngle, endAngle);
  const styleConfig = getTextStyle({
    color: theme.track.titleColor,
    size: 12,
    // `theme.track.titleFontSize` seems to use much larger fonts
    fontFamily: theme.axis.labelFontFamily,
    // TODO: support
    fontWeight: theme.axis.labelFontWeight
    // TODO: support
  });
  const textGraphic = new HGC.libraries.PIXI.Text(title2, styleConfig);
  textGraphic.anchor.x = 1;
  textGraphic.anchor.y = 0.5;
  textGraphic.position.x = pos.x;
  textGraphic.position.y = pos.y;
  textGraphic.resolution = 4;
  const txtStyle = new HGC.libraries.PIXI.TextStyle(styleConfig);
  const metric = HGC.libraries.PIXI.TextMetrics.measureText(textGraphic.text, txtStyle);
  const txtWidth = metric.width / (2 * titleR * Math.PI) * tw * 360 / (endAngle - startAngle);
  const scaledStartX = padding;
  const scaledEndX = padding + txtWidth;
  const ropePoints = [];
  for (let i = scaledEndX; i >= scaledStartX; i -= txtWidth / 10) {
    const p = cartesianToPolar(i, tw, titleR - metric.height / 2, cx, cy, startAngle, endAngle);
    ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
  }
  const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
  const endRad = valueToRadian(scaledEndX + padding, tw, startAngle, endAngle);
  g.lineStyle(1, colorToHex("red"), 0, 0.5);
  g.beginFill(colorToHex(theme.track.titleBackground), 0.5);
  g.moveTo(pos.x, pos.y);
  g.arc(cx, cy, titleR - metric.height, startRad, endRad, true);
  g.arc(cx, cy, titleR, endRad, startRad, false);
  g.closePath();
  textGraphic.updateText();
  const rope = new HGC.libraries.PIXI.SimpleRope(textGraphic.texture, ropePoints);
  g.addChild(rope);
}
function drawChartOutlines(trackInfo, tm, theme) {
  var _a, _b, _c, _d;
  const g = trackInfo.pBorder;
  const [l, t] = trackInfo.position;
  const [w, h] = trackInfo.dimensions;
  g.lineStyle(
    (_b = (_a = tm.spec().style) == null ? void 0 : _a.outlineWidth) != null ? _b : 1,
    // TODO: outline not working
    colorToHex((_d = (_c = tm.spec().style) == null ? void 0 : _c.outline) != null ? _d : theme.track.outline),
    1,
    // alpha
    0.5
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  g.beginFill(colorToHex("white"), 0);
  g.drawRect(l, t, w, h);
  const x = tm.spec().x;
  g.lineStyle(
    1,
    colorToHex(theme.axis.baselineColor),
    1,
    // alpha
    0.5
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  if (IsChannelDeep(x) && x.axis === "top") {
    g.moveTo(l, t);
    g.lineTo(l + w, t);
  } else if (IsChannelDeep(x) && x.axis === "bottom") {
    g.moveTo(l, t + h);
    g.lineTo(l + w, t + h);
  }
}
function drawColorLegend(HGC, trackInfo, _tile2, model, theme) {
  if (!trackInfo.gLegend) {
    return;
  }
  trackInfo.gLegend.selectAll(".brush").remove();
  const spec = model.spec();
  const offset = { offsetRight: 0 };
  if (IsChannelDeep(spec.color) && spec.color.legend) {
    switch (spec.color.type) {
      case "nominal":
        drawColorLegendCategories(HGC, trackInfo, _tile2, model, theme);
        break;
      case "quantitative":
        drawColorLegendQuantitative(HGC, trackInfo, _tile2, model, theme, "color", offset);
        break;
    }
  }
  if (IsChannelDeep(spec.stroke) && spec.stroke.legend) {
    switch (spec.stroke.type) {
      case "quantitative":
        drawColorLegendQuantitative(HGC, trackInfo, _tile2, model, theme, "stroke", offset);
        break;
    }
  }
}
function drawColorLegendQuantitative(HGC, trackInfo, _tile2, model, theme, channelKey, offset) {
  const spec = model.spec();
  const channel = spec[channelKey];
  if (!IsChannelDeep(channel) || channel.type !== "quantitative" || !channel.legend) {
    return;
  }
  const [trackX, trackY] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const legendWidth = 80;
  const legendHeight = trackHeight - 2 > 110 ? 110 : Math.max(trackHeight - 2, 40 - 2);
  const colorBarDim = {
    top: 10,
    left: 55,
    width: 20,
    height: legendHeight - 20
  };
  const legendX = trackX + trackWidth - legendWidth - 1 - offset.offsetRight;
  const legendY = trackY + 1;
  const colorScale = model.getChannelScale(channelKey);
  const colorDomain = model.getChannelDomainArray(channelKey);
  if (!colorScale || !colorDomain) {
    return;
  }
  const graphics = trackInfo.pBorder;
  graphics.beginFill(colorToHex(theme.legend.background), theme.legend.backgroundOpacity);
  graphics.lineStyle(
    1,
    colorToHex(theme.legend.backgroundStroke),
    theme.legend.backgroundOpacity,
    // alpha
    0
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  graphics.drawRect(legendX, legendY, legendWidth, legendHeight);
  if (channel.title) {
    const titleStr = channel.title;
    const labelTextStyle2 = getTextStyle({
      color: theme.legend.labelColor,
      size: theme.legend.labelFontSize,
      fontWeight: theme.legend.labelFontWeight,
      fontFamily: theme.legend.labelFontFamily
    });
    const textGraphic = new HGC.libraries.PIXI.Text(titleStr, {
      ...labelTextStyle2,
      fontWeight: "bold"
    });
    textGraphic.anchor.x = 0;
    textGraphic.anchor.y = 0;
    textGraphic.position.x = legendX + 10;
    textGraphic.position.y = legendY + 10;
    const textStyleObj = new HGC.libraries.PIXI.TextStyle({ ...labelTextStyle2, fontWeight: "bold" });
    const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(titleStr, textStyleObj);
    graphics.addChild(textGraphic);
    colorBarDim.top += textMetrics.height + 4;
    colorBarDim.height -= textMetrics.height + 4;
  }
  const [startValue, endValue] = colorDomain;
  const extent = endValue - startValue;
  const scaleOffset = IsChannelDeep(channel) && channel.scaleOffset ? channel.scaleOffset : [0, 1];
  [...Array(colorBarDim.height).keys()].forEach((y) => {
    let value;
    const scaleOffsetSorted = Array.from(scaleOffset).sort();
    if (y / colorBarDim.height >= scaleOffsetSorted[1]) {
      value = endValue;
    } else if (y / colorBarDim.height <= scaleOffsetSorted[0]) {
      value = startValue;
    } else {
      const s1 = scaleLinear().domain([colorBarDim.height * scaleOffsetSorted[0], colorBarDim.height * scaleOffsetSorted[1]]).range([0, colorBarDim.height]);
      const s2 = scaleLinear().domain([0, colorBarDim.height]).range([startValue, endValue]);
      value = s2(s1(y));
    }
    graphics.beginFill(
      colorToHex(colorScale(value)),
      1
      // alpha
    );
    graphics.lineStyle(
      1,
      colorToHex(theme.legend.backgroundStroke),
      0,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    graphics.drawRect(
      legendX + colorBarDim.left,
      legendY + colorBarDim.top + colorBarDim.height - y,
      colorBarDim.width,
      1
    );
  });
  const BRUSH_HEIGHT = 4;
  trackInfo.colorBrushes = trackInfo.gLegend.append("g").attr("class", channelKey).selectAll(`.brush`).data(
    scaleOffset.map((d, i) => {
      return { y: d, id: i };
    })
  ).enter().append("rect").attr("class", `brush`).attr("pointer-events", "all").attr("cursor", "ns-resize").attr(
    "transform",
    (d) => `translate(${legendX + colorBarDim.left}, ${legendY + colorBarDim.top - BRUSH_HEIGHT / 2 + colorBarDim.height - colorBarDim.height * d.y})`
  ).attr("width", `${colorBarDim.width}px`).attr("height", `${BRUSH_HEIGHT}px`).attr("fill", "lightgrey").attr("stroke", "black").attr("stroke-width", "0.5px").call(
    HGC.libraries.d3Drag.drag().on("start", (event) => {
      trackInfo.startEvent = event.sourceEvent;
    }).on("drag", (event, d) => {
      if (channel && channel.scaleOffset) {
        const endEvent = event.sourceEvent;
        const diffY = trackInfo.startEvent.clientY - endEvent.clientY;
        const newScaleOffset = [channel.scaleOffset[0], channel.scaleOffset[1]];
        if (d.id === 0) {
          newScaleOffset[0] += diffY / colorBarDim.height;
        } else {
          newScaleOffset[1] += diffY / colorBarDim.height;
        }
        newScaleOffset[0] = Math.min(1, Math.max(0, newScaleOffset[0]));
        newScaleOffset[1] = Math.min(1, Math.max(0, newScaleOffset[1]));
        trackInfo.updateScaleOffsetFromOriginalSpec(spec._renderingId, newScaleOffset, channelKey);
        trackInfo.shareScaleOffsetAcrossTracksAndTiles(newScaleOffset, channelKey);
        trackInfo.draw();
        trackInfo.startEvent = event.sourceEvent;
      }
    })
  );
  const tickCount = Math.max(Math.ceil(colorBarDim.height / 30), 2);
  let ticks = colorScale.ticks(tickCount).filter((v) => colorDomain[0] <= v && v <= colorDomain[1]);
  if (ticks.length === 1) {
    ticks = colorScale.ticks(tickCount + 1).filter((v) => colorDomain[0] <= v && v <= colorDomain[1]);
  }
  const TICK_STROKE_SIZE = 1;
  graphics.lineStyle(
    TICK_STROKE_SIZE,
    colorToHex(theme.legend.tickColor),
    1,
    // alpha
    0.5
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  const labelTextStyle = getTextStyle({
    color: theme.legend.labelColor,
    size: theme.legend.labelFontSize,
    fontWeight: theme.legend.labelFontWeight,
    fontFamily: theme.legend.labelFontFamily
  });
  const tickEnd = legendX + colorBarDim.left;
  ticks.forEach((value) => {
    let y = legendY + colorBarDim.top + colorBarDim.height - (value - startValue) / extent * colorBarDim.height;
    if (y === legendY + colorBarDim.top) {
      y += TICK_STROKE_SIZE / 2;
    } else if (y === legendY + colorBarDim.top + colorBarDim.height) {
      y -= TICK_STROKE_SIZE / 2;
    }
    graphics.moveTo(tickEnd - 3, y);
    graphics.lineTo(tickEnd, y);
    const textGraphic = new HGC.libraries.PIXI.Text(value, labelTextStyle);
    textGraphic.anchor.x = 1;
    textGraphic.anchor.y = 0.5;
    textGraphic.position.x = tickEnd - 6;
    textGraphic.position.y = y;
    graphics.addChild(textGraphic);
  });
  offset.offsetRight = trackWidth - legendX;
}
function drawColorLegendCategories(HGC, track, _tile2, tm, theme) {
  var _a, _b, _c, _d, _e;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.color) || spec.color.type !== "nominal" || !spec.color.legend) {
    return;
  }
  const colorCategories = (_a = tm.getChannelDomainArray("color")) != null ? _a : ["___SINGLE_COLOR___"];
  if (colorCategories.length === 0) {
    return;
  }
  const domain = spec.color.domain;
  const range = spec.color.range;
  const existingLegends = track.displayedLegends;
  const toStr = (_) => {
    return typeof _ === "string" ? _ : _.join();
  };
  if (existingLegends.find((d) => toStr(d.domain) === toStr(domain) && toStr(d.range) === toStr(range))) {
    return;
  } else {
    existingLegends.push({ domain, range });
  }
  const graphics = track.pBorder;
  const paddingX = 10;
  const paddingY = 4;
  let cumY = paddingY;
  let maxWidth = 0;
  const recipe = [];
  const labelTextStyle = getTextStyle({
    color: theme.legend.labelColor,
    size: theme.legend.labelFontSize,
    fontWeight: theme.legend.labelFontWeight,
    fontFamily: theme.legend.labelFontFamily
  });
  if ((_b = spec.style) == null ? void 0 : _b.inlineLegend) {
    colorCategories.map((d) => d).reverse().forEach((category) => {
      if (maxWidth > track.dimensions[0]) {
        return;
      }
      const color2 = tm.encodedValue("color", category);
      const textGraphic = new HGC.libraries.PIXI.Text(category, labelTextStyle);
      textGraphic.anchor.x = 1;
      textGraphic.anchor.y = 0;
      textGraphic.position.x = track.position[0] + track.dimensions[0] - maxWidth - paddingX;
      textGraphic.position.y = track.position[1] + paddingY;
      graphics.addChild(textGraphic);
      const textStyleObj = new HGC.libraries.PIXI.TextStyle(labelTextStyle);
      const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(category, textStyleObj);
      if (cumY < textMetrics.height + paddingY * 3) {
        cumY = textMetrics.height + paddingY * 3;
      }
      recipe.push({
        x: track.position[0] + track.dimensions[0] - textMetrics.width - maxWidth - paddingX * 2,
        y: track.position[1] + paddingY + textMetrics.height / 2,
        color: color2
      });
      maxWidth += textMetrics.width + paddingX * 3;
    });
  } else {
    if ((_c = spec.style) == null ? void 0 : _c.legendTitle) {
      const textGraphic = new HGC.libraries.PIXI.Text((_d = spec.style) == null ? void 0 : _d.legendTitle, {
        ...labelTextStyle,
        fontWeight: "bold"
      });
      textGraphic.anchor.x = 1;
      textGraphic.anchor.y = 0;
      textGraphic.position.x = track.position[0] + track.dimensions[0] - paddingX;
      textGraphic.position.y = track.position[1] + cumY;
      const textStyleObj = new HGC.libraries.PIXI.TextStyle({ ...labelTextStyle, fontWeight: "bold" });
      const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText((_e = spec.style) == null ? void 0 : _e.legendTitle, textStyleObj);
      graphics.addChild(textGraphic);
      cumY += textMetrics.height + paddingY * 2;
    }
    colorCategories.forEach((category) => {
      if (cumY > track.dimensions[1]) {
        return;
      }
      const color2 = tm.encodedValue("color", category);
      const textGraphic = new HGC.libraries.PIXI.Text(category, labelTextStyle);
      textGraphic.anchor.x = 1;
      textGraphic.anchor.y = 0;
      textGraphic.position.x = track.position[0] + track.dimensions[0] - paddingX;
      textGraphic.position.y = track.position[1] + cumY;
      graphics.addChild(textGraphic);
      const textStyleObj = new HGC.libraries.PIXI.TextStyle(labelTextStyle);
      const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(category, textStyleObj);
      if (maxWidth < textMetrics.width + paddingX * 3) {
        maxWidth = textMetrics.width + paddingX * 3;
      }
      recipe.push({
        x: track.position[0] + track.dimensions[0] - textMetrics.width - paddingX * 2,
        y: track.position[1] + cumY + textMetrics.height / 2,
        color: color2
      });
      cumY += textMetrics.height + paddingY * 2;
    });
  }
  graphics.beginFill(colorToHex(theme.legend.background), theme.legend.backgroundOpacity);
  graphics.lineStyle(
    1,
    colorToHex(theme.legend.backgroundStroke),
    theme.legend.backgroundOpacity,
    // alpha
    0
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  graphics.drawRect(
    track.position[0] + track.dimensions[0] - maxWidth - 1,
    track.position[1] + 1,
    maxWidth,
    cumY - paddingY
  );
  recipe.forEach((r) => {
    graphics.lineStyle(
      1,
      colorToHex("black"),
      0,
      // alpha
      0
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    graphics.beginFill(colorToHex(r.color), 1);
    graphics.drawCircle(r.x, r.y, 4);
  });
}
function drawRowLegend(HGC, trackInfo, _tile2, tm, theme) {
  var _a;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.row) || spec.row.type !== "nominal" || !spec.row.legend) {
    return;
  }
  const rowCategories = (_a = tm.getChannelDomainArray("row")) != null ? _a : ["___SINGLE_ROW___"];
  if (rowCategories.length === 0) {
    return;
  }
  const graphics = trackInfo.pBorder;
  const paddingX = 4;
  const paddingY = 2;
  const labelTextStyle = getTextStyle({
    color: theme.legend.labelColor,
    size: theme.legend.labelFontSize,
    fontWeight: theme.legend.labelFontWeight,
    fontFamily: theme.legend.labelFontFamily
  });
  rowCategories.forEach((category) => {
    const rowPosition = tm.encodedValue("row", category);
    const textGraphic = new HGC.libraries.PIXI.Text(category, labelTextStyle);
    textGraphic.anchor.x = 0;
    textGraphic.anchor.y = 0;
    textGraphic.position.x = trackInfo.position[0] + paddingX;
    textGraphic.position.y = trackInfo.position[1] + rowPosition + paddingY;
    graphics.addChild(textGraphic);
    const textStyleObj = new HGC.libraries.PIXI.TextStyle(labelTextStyle);
    const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(category, textStyleObj);
    graphics.beginFill(colorToHex(theme.legend.background), theme.legend.backgroundOpacity);
    graphics.lineStyle(
      1,
      colorToHex(theme.legend.backgroundStroke),
      0,
      // alpha
      0
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    graphics.drawRect(
      trackInfo.position[0] + 1,
      trackInfo.position[1] + rowPosition + 1,
      textMetrics.width + paddingX * 2,
      textMetrics.height + paddingY * 2
    );
  });
}
const EXTENT_TICK_SIZE = 8;
const TICK_SIZE = 6;
function drawLinearYAxis(HGC, trackInfo, _tile2, model, theme) {
  var _a;
  const spec = model.spec();
  const CIRCULAR = spec.layout === "circular";
  const yDomain = model.getChannelDomainArray("y");
  const yRange = model.getChannelRangeArray("y");
  if (CIRCULAR) {
    return;
  }
  if (!model.isShowYAxis() || !yDomain || !yRange) {
    return;
  }
  if (!isNumberArray(yDomain)) {
    return;
  }
  const [tw, th] = trackInfo.dimensions;
  const [tx, ty] = trackInfo.position;
  const rowCategories = (_a = model.getChannelDomainArray("row")) != null ? _a : ["___SINGLE_ROW___"];
  if (!isStringArray(rowCategories)) {
    return;
  }
  const rowHeight = th / rowCategories.length;
  if (rowHeight <= 20) {
    return;
  }
  const yChannel = model.spec().y;
  const isLeft = IsChannelDeep(yChannel) && "axis" in yChannel && yChannel.axis === "right" ? false : true;
  const yScale = scaleLinear().domain(yDomain).range(yRange);
  const graphics = trackInfo.pBorder;
  rowCategories.forEach((category) => {
    const rowPosition = model.encodedValue("row", category);
    const dx = isLeft ? tx : tx + tw;
    const dy = ty + rowPosition;
    graphics.lineStyle(
      1,
      colorToHex(theme.axis.baselineColor),
      1,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    graphics.moveTo(dx, dy);
    graphics.lineTo(dx, dy + rowHeight);
    const tickCount = Math.max(Math.ceil(rowHeight / 40), 1);
    let ticks = yScale.ticks(tickCount).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    if (ticks.length === 1) {
      ticks = yScale.ticks(tickCount + 1).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    }
    graphics.lineStyle(
      1,
      colorToHex(theme.axis.tickColor),
      1,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    let tickEnd = isLeft ? dx + TICK_SIZE : dx - TICK_SIZE;
    ticks.forEach((t) => {
      const y = yScale(t);
      graphics.moveTo(dx, dy + rowHeight - y);
      graphics.lineTo(tickEnd, dy + rowHeight - y);
    });
    tickEnd = isLeft ? dx + EXTENT_TICK_SIZE : dx - EXTENT_TICK_SIZE;
    graphics.moveTo(dx, dy);
    graphics.lineTo(tickEnd, dy);
    graphics.moveTo(dx, dy + rowHeight);
    graphics.lineTo(tickEnd, dy + rowHeight);
    const styleConfig = getTextStyle({
      color: theme.axis.labelColor,
      size: theme.axis.labelFontSize,
      fontFamily: theme.axis.labelFontFamily,
      fontWeight: theme.axis.labelFontWeight
    });
    ticks.forEach((t) => {
      const y = yScale(t);
      tickEnd = isLeft ? dx + TICK_SIZE * 2 : dx - TICK_SIZE * 2;
      const textGraphic = new HGC.libraries.PIXI.Text(t, styleConfig);
      textGraphic.anchor.x = isLeft ? 0 : 1;
      textGraphic.anchor.y = y === 0 ? 0.9 : 0.5;
      textGraphic.position.x = tickEnd;
      textGraphic.position.y = dy + rowHeight - y;
      if (spec.orientation === "vertical") {
        textGraphic.anchor.x = isLeft ? 1 : 0;
        textGraphic.scale.x *= -1;
      }
      graphics.addChild(textGraphic);
    });
  });
}
function drawCircularYAxis(HGC, trackInfo, tile, model, theme) {
  var _a, _b, _c, _d, _e;
  const spec = model.spec();
  const CIRCULAR = spec.layout === "circular";
  const yDomain = model.getChannelDomainArray("y");
  const yRange = model.getChannelRangeArray("y");
  if (!CIRCULAR) {
    return;
  }
  if (!model.isShowYAxis() || !yDomain || !yRange) {
    return;
  }
  if (!isNumberArray(yDomain)) {
    return;
  }
  const [tw, th] = trackInfo.dimensions;
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const cx = tw / 2;
  const cy = th / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = th / rowCategories.length;
  if (rowHeight / th * trackRingSize <= 20) {
    return;
  }
  const yChannel = model.spec().y;
  const isLeft = IsChannelDeep(yChannel) && "axis" in yChannel && yChannel.axis === "right" ? false : true;
  const yScale = scaleLinear().domain(yDomain).range(yRange);
  const graphics = tile.graphics;
  rowCategories.forEach((category) => {
    const rowPosition = model.encodedValue("row", category);
    const innerR = trackOuterRadius - (rowPosition + rowHeight) / th * trackRingSize;
    const outerR = trackOuterRadius - rowPosition / th * trackRingSize;
    const innerPos = cartesianToPolar(isLeft ? 0 : tw, tw, innerR, cx, cy, startAngle, endAngle);
    const outerPos = cartesianToPolar(isLeft ? 0 : tw, tw, outerR, cx, cy, startAngle, endAngle);
    graphics.lineStyle(
      1,
      colorToHex(theme.axis.baselineColor),
      1,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    graphics.moveTo(innerPos.x, innerPos.y);
    graphics.lineTo(outerPos.x, outerPos.y);
    const SCALED_TICK_SIZE = (r) => TICK_SIZE * tw / 2 / Math.PI / r;
    const SCALED_EXTENT_TICK_SIZE = (r) => EXTENT_TICK_SIZE * tw / 2 / Math.PI / r;
    const axisHeight = rowHeight / th * trackRingSize;
    const tickCount = Math.max(Math.ceil(axisHeight / 40), 1);
    let ticks = yScale.ticks(tickCount).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    if (ticks.length === 1) {
      ticks = yScale.ticks(tickCount + 1).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    }
    graphics.lineStyle(
      1,
      colorToHex(theme.axis.tickColor),
      1,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    ticks.forEach((t) => {
      const y = yScale(t);
      const currentR = trackOuterRadius - (rowPosition + rowHeight - y) / th * trackRingSize;
      const scaledStartX = isLeft ? 0 : tw - SCALED_TICK_SIZE(currentR);
      const scaledEndX = isLeft ? SCALED_TICK_SIZE(currentR) : tw;
      const pos = cartesianToPolar(scaledStartX, tw, currentR, cx, cy, startAngle, endAngle);
      const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
      const endRad = valueToRadian(scaledEndX, tw, startAngle, endAngle);
      graphics.moveTo(pos.x, pos.y);
      graphics.arc(cx, cy, currentR, startRad, endRad, true);
      graphics.arc(cx, cy, currentR, endRad, startRad, false);
      graphics.closePath();
    });
    {
      const scaledStartX = isLeft ? 0 : tw - SCALED_EXTENT_TICK_SIZE(trackInnerRadius);
      const scaledEndX = isLeft ? SCALED_EXTENT_TICK_SIZE(trackInnerRadius) : tw;
      const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
      const endRad = valueToRadian(scaledEndX, tw, startAngle, endAngle);
      graphics.moveTo(innerPos.x, innerPos.y);
      graphics.arc(cx, cy, trackInnerRadius, startRad, endRad, true);
      graphics.arc(cx, cy, trackInnerRadius, endRad, startRad, false);
      graphics.closePath();
    }
    {
      const scaledStartX = isLeft ? 0 : tw - SCALED_EXTENT_TICK_SIZE(trackOuterRadius);
      const scaledEndX = isLeft ? SCALED_EXTENT_TICK_SIZE(trackOuterRadius) : tw;
      const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
      const endRad = valueToRadian(scaledEndX, tw, startAngle, endAngle);
      graphics.moveTo(outerPos.x, outerPos.y);
      graphics.arc(cx, cy, trackOuterRadius, startRad, endRad, true);
      graphics.arc(cx, cy, trackOuterRadius, endRad, startRad, false);
      graphics.closePath();
    }
    ticks.forEach((t) => {
      const y = yScale(t);
      const currentR = trackOuterRadius - (rowPosition + rowHeight - y) / th * trackRingSize;
      const pos = cartesianToPolar(SCALED_TICK_SIZE(currentR) * 2, tw, currentR, cx, cy, startAngle, endAngle);
      const styleConfig = getTextStyle({
        color: theme.axis.labelColor,
        size: theme.axis.labelFontSize,
        fontFamily: theme.axis.labelFontFamily,
        fontWeight: theme.axis.labelFontWeight
      });
      const textGraphic = new HGC.libraries.PIXI.Text(t, styleConfig);
      textGraphic.anchor.x = isLeft ? 1 : 0;
      textGraphic.anchor.y = 0.5;
      textGraphic.position.x = pos.x;
      textGraphic.position.y = pos.y;
      textGraphic.resolution = 4;
      const txtStyle = new HGC.libraries.PIXI.TextStyle(styleConfig);
      const metric = HGC.libraries.PIXI.TextMetrics.measureText(textGraphic.text, txtStyle);
      const txtWidth = metric.width / (2 * currentR * Math.PI) * tw * 360 / (endAngle - startAngle);
      const scaledStartX = isLeft ? SCALED_TICK_SIZE(currentR) * 2 : tw - SCALED_TICK_SIZE(currentR) * 2 - txtWidth;
      const scaledEndX = isLeft ? SCALED_TICK_SIZE(currentR) * 2 + txtWidth : tw - SCALED_TICK_SIZE(currentR) * 2;
      const ropePoints = [];
      for (let i = scaledEndX; i >= scaledStartX; i -= txtWidth / 10) {
        const p = cartesianToPolar(i, tw, currentR, cx, cy, startAngle, endAngle);
        ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
      }
      textGraphic.updateText();
      const rope = new HGC.libraries.PIXI.SimpleRope(textGraphic.texture, ropePoints);
      graphics.addChild(rope);
    });
  });
}
function drawCircularOutlines(trackInfo, tm, theme) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const spec = tm.spec();
  const [l, t] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const cx = l + trackWidth / 2;
  const cy = t + trackHeight / 2;
  const posStartInner = cartesianToPolar(0, trackWidth, trackInnerRadius, cx, cy, startAngle, endAngle);
  const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
  const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
  const g = trackInfo.pBackground;
  if (!(spec.layout === "circular" && spec.mark === "withinLink")) {
    g.lineStyle(
      ((_e = spec.style) == null ? void 0 : _e.outlineWidth) ? ((_f = spec.style) == null ? void 0 : _f.outlineWidth) / 2.5 : 0,
      colorToHex((_h = (_g = spec.style) == null ? void 0 : _g.outline) != null ? _h : "#DBDBDB"),
      1,
      // 0.4, // alpha
      1
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    g.beginFill(
      colorToHex((_j = (_i = tm.spec().style) == null ? void 0 : _i.background) != null ? _j : theme.track.background),
      (_l = (_k = tm.spec().style) == null ? void 0 : _k.backgroundOpacity) != null ? _l : !theme.track.background || theme.track.background === "transparent" ? 0 : 1
    );
    g.moveTo(posStartInner.x, posStartInner.y);
    g.arc(cx, cy, trackInnerRadius, startRad, endRad, true);
    g.arc(cx, cy, trackOuterRadius, endRad, startRad, false);
    g.closePath();
  }
  if (IsChannelDeep(spec.x) && spec.x.axis === "top") {
    g.lineStyle(
      0.5,
      colorToHex("black"),
      0,
      // 1, // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    g.beginFill(colorToHex("white"), 0);
    g.moveTo(posStartInner.x, posStartInner.y);
    g.arc(cx, cy, trackOuterRadius - 0.5, startRad, endRad, true);
    g.arc(cx, cy, trackOuterRadius, endRad, startRad, false);
    g.closePath();
  }
  g.lineStyle(
    0.5,
    colorToHex("black"),
    0,
    // alpha
    0.5
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  g.beginFill(colorToHex("white"), 0);
  g.moveTo(cx, cy);
  g.arc(cx, cy, trackOuterRadius + 3, startRad, endRad, false);
  g.closePath();
  g.lineStyle(
    1,
    colorToHex("#DBDBDB"),
    0,
    // alpha
    0
    // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
  );
  g.beginFill(colorToHex("white"), 0);
  g.drawCircle(cx, cy, trackInnerRadius - 1);
}
function drawBackground(trackInfo, tm, theme) {
  var _a, _b, _c, _d, _e, _f;
  const [l, t] = trackInfo.position;
  const [w, h] = trackInfo.dimensions;
  const g = trackInfo.pBackground;
  if (((_a = tm.spec().style) == null ? void 0 : _a.background) || theme.track.background && theme.track.background !== "transparent") {
    g.clear();
    const bg = (_c = (_b = tm.spec().style) == null ? void 0 : _b.background) != null ? _c : theme.track.background;
    const alpha = isUndefined((_d = tm.spec().style) == null ? void 0 : _d.backgroundOpacity) ? 1 : (_e = tm.spec().style) == null ? void 0 : _e.backgroundOpacity;
    g.lineStyle(
      1,
      colorToHex("white"),
      0,
      // alpha
      0
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    g.beginFill(colorToHex(bg), alpha);
    g.drawRect(l, t, w, h);
  }
  if (theme.track.alternatingBackground && theme.track.alternatingBackground !== "transparent") {
    const spec = tm.spec();
    if (!IsChannelDeep(spec.row) || spec.row.type !== "nominal") {
      return;
    }
    const rowCategories = (_f = tm.getChannelDomainArray("row")) != null ? _f : ["___SINGLE_ROW___"];
    if (rowCategories.length === 0) {
      return;
    }
    rowCategories.forEach((category, i) => {
      var _a2, _b2, _c2, _d2;
      if (i % 2 === 0) {
        return;
      }
      const rowPosition = tm.encodedValue("row", category);
      const bg = (_b2 = (_a2 = tm.spec().style) == null ? void 0 : _a2.background) != null ? _b2 : theme.track.alternatingBackground;
      const alpha = isUndefined((_c2 = tm.spec().style) == null ? void 0 : _c2.backgroundOpacity) ? 1 : (_d2 = tm.spec().style) == null ? void 0 : _d2.backgroundOpacity;
      g.lineStyle(
        1,
        colorToHex("white"),
        0,
        // alpha
        0
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      g.beginFill(colorToHex(bg), alpha);
      g.drawRect(trackInfo.position[0], trackInfo.position[1] + rowPosition, w, h / rowCategories.length);
    });
  }
}
function drawBetweenLink(g, trackInfo, model) {
  var _a, _b, _c, _d, _e;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter(
      (d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory
    ).forEach((d) => {
      var _a2, _b2;
      let x = model.encodedPIXIProperty("x", d);
      let xe = model.encodedPIXIProperty("xe", d);
      let x1 = model.encodedPIXIProperty("x1", d);
      let x1e = model.encodedPIXIProperty("x1e", d);
      const y = model.encodedPIXIProperty("y", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      if (typeof xe !== "undefined") {
        [x, xe] = [x, xe].sort((a, b) => a - b);
      }
      if (typeof x1 !== "undefined" && typeof x1e !== "undefined") {
        [x1, x1e] = [x1, x1e].sort((a, b) => a - b);
      }
      const isRibon = typeof xe !== "undefined" && typeof x1 !== "undefined" && typeof x1e !== "undefined" && // This means the strokeWidth of a band is too small, so we just need to draw a line instead
      Math.abs(x - xe) > 0.1 && Math.abs(x1 - x1e) > 0.1;
      if (!isRibon && xe === void 0 && !Is2DTrack(spec)) {
        if (x1 === void 0 && x1e === void 0) {
          return;
        }
        xe = x1 !== void 0 ? x1 : x1e;
      }
      if (!isRibon && Math.abs(x - xe) <= 0.1 && Math.abs(x1 - x1e) <= 0.1) {
        x = (x + xe) / 2;
        xe = (x1 + x1e) / 2;
      }
      g.lineStyle(
        strokeWidth,
        colorToHex(stroke),
        opacity,
        // alpha
        0.5
        // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
      );
      if (isRibon) {
        g.beginFill(color2 === "none" ? colorToHex("white") : colorToHex(color2), color2 === "none" ? 0 : opacity);
        let [_x1, _x2, _x3, _x4] = [x, xe, x1, x1e];
        [_x1, _x2] = [_x1, _x2].sort((a, b) => a - b);
        [_x3, _x4] = [_x3, _x4].sort((a, b) => a - b);
        if (_x1 > trackWidth || _x4 < 0 || Math.abs(_x4 - _x1) < 0.5) {
          return;
        }
        if (circular) {
          if (_x1 < 0 || _x4 > trackWidth) {
            return;
          }
          const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
          const posX = cartesianToPolar(_x1, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posXE = cartesianToPolar(_x2, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1 = cartesianToPolar(_x3, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1E = cartesianToPolar(_x4, trackWidth, r, tcx, tcy, startAngle, endAngle);
          g.moveTo(posX.x, posX.y);
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posX1E.x, posX1E.y);
          g.arc(
            tcx,
            tcy,
            trackOuterRadius,
            positionToRadian(posX1E.x, posX1E.y, tcx, tcy),
            positionToRadian(posX1.x, posX1.y, tcx, tcy),
            false
          );
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posXE.x, posXE.y);
          g.arc(
            tcx,
            tcy,
            trackOuterRadius,
            positionToRadian(posXE.x, posXE.y, tcx, tcy),
            positionToRadian(posX.x, posX.y, tcx, tcy),
            false
          );
          g.endFill();
        } else {
          g.moveTo(_x1, rowPosition);
          g.lineTo(_x2, rowPosition);
          g.lineTo(_x4, rowPosition + rowHeight);
          g.lineTo(_x3, rowPosition + rowHeight);
          g.lineTo(_x1, rowPosition);
          g.closePath();
        }
      } else {
        if (Is2DTrack(spec)) {
          if (((_a2 = spec.style) == null ? void 0 : _a2.linkConnectionType) === "curve") {
            g.moveTo(x, 0);
            g.bezierCurveTo(
              x / 5 * 4,
              (rowPosition + rowHeight - y) / 2,
              x / 2,
              (rowPosition + rowHeight - y) / 5 * 4,
              0,
              rowPosition + rowHeight - y
            );
          } else if (((_b2 = spec.style) == null ? void 0 : _b2.linkConnectionType) === "straight") {
            g.moveTo(x, 0);
            g.lineTo(0, rowPosition + rowHeight - y);
          } else {
            g.moveTo(x, 0);
            g.lineTo(x, rowPosition + rowHeight - y);
            g.lineTo(0, rowPosition + rowHeight - y);
          }
          return;
        }
        if (circular) {
          let prevX, prevY;
          for (let t = 0; t <= 1; t += 0.02) {
            const logodds = (t2) => Math.log(t2 / (1 - t2));
            const movingRadius = (t2) => trackOuterRadius - 1 / (1 + Math.exp(logodds(t2))) * trackRingSize + 3;
            const getRadian = (t2, s, e) => ((e - s) * t2 + s) / trackWidth;
            const _x = tcx + movingRadius(t) * Math.cos(-getRadian(t, x, xe) * 2 * Math.PI - Math.PI / 2);
            const _y = tcy + movingRadius(t) * Math.sin(-getRadian(t, x, xe) * 2 * Math.PI - Math.PI / 2);
            if (prevX && prevY) {
              g.lineStyle(
                strokeWidth,
                colorToHex(stroke),
                opacity,
                // alpha
                0.5
                // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
              );
              g.moveTo(prevX, prevY);
              g.lineTo(_x, _y);
            }
            prevX = _x;
            prevY = _y;
          }
          return;
        }
        g.moveTo(xe, rowPosition + rowHeight);
        g.lineTo(x, rowPosition);
      }
    });
  });
}
const SUPPORTED_CHANNELS = [
  "x",
  "xe",
  "x1",
  "x1e",
  "y",
  "ye",
  "y1",
  "y1e",
  "color",
  "size",
  "row",
  "stroke",
  "strokeWidth",
  "opacity",
  "text"
  // ...
];
function drawMark(HGC, trackInfo, tile, model) {
  if (!HGC || !trackInfo || !tile) {
    return;
  }
  if (model.spec().mark === "brush") {
    return;
  }
  ["x", "x1", "x1e", "xe"].forEach((d) => {
    model.setChannelScale(d, trackInfo._xScale);
  });
  if (Is2DTrack(model.spec()) || IsVerticalRule(model.spec())) {
    const yScale = trackInfo._yScale.copy();
    yScale.range([yScale.range()[1], yScale.range()[0]]);
    ["y", "y1", "y1e", "ye"].forEach((d) => {
      model.setChannelScale(d, yScale);
    });
  }
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  switch (model.spec().mark) {
    case "point":
      drawPoint(trackInfo, tile.graphics, model);
      break;
    case "bar":
      drawBar(trackInfo, tile, model);
      break;
    case "line":
      drawLine(tile.graphics, model, trackWidth, trackHeight);
      break;
    case "area":
      drawArea(HGC, trackInfo, tile, model);
      break;
    case "rect":
      drawRect(HGC, trackInfo, tile, model);
      break;
    case "triangleLeft":
    case "triangleRight":
    case "triangleBottom":
      drawTriangle(tile.graphics, model, trackWidth, trackHeight);
      break;
    case "text":
      drawText(HGC, trackInfo, tile, model);
      break;
    case "rule":
      drawRule(HGC, trackInfo, tile, model);
      break;
    case "betweenLink":
      drawBetweenLink(tile.graphics, trackInfo, model);
      break;
    case "withinLink":
      drawWithinLink(tile.graphics, trackInfo, model);
      break;
    default:
      console.warn("Unsupported mark type");
      break;
  }
}
function drawPreEmbellishment(HGC, trackInfo, tile, model, theme) {
  if (!HGC || !trackInfo || !tile) {
    return;
  }
  if (model.spec().mark === "brush") {
    return;
  }
  ["x", "x1", "x1e", "xe"].forEach((d) => {
    model.setChannelScale(d, trackInfo._xScale);
  });
  const isCircular = model.spec().layout === "circular";
  if (isCircular) {
    drawCircularOutlines(trackInfo, model, theme);
  } else {
    drawBackground(trackInfo, model, theme);
    drawChartOutlines(trackInfo, model, theme);
  }
  drawGrid(trackInfo, model, theme);
}
function drawPostEmbellishment(HGC, trackInfo, tile, model, theme) {
  if (!HGC || !trackInfo || !tile) {
    return;
  }
  if (model.spec().mark === "brush") {
    return;
  }
  ["x", "x1", "x1e", "xe"].forEach((d) => {
    model.setChannelScale(d, trackInfo._xScale);
  });
  const isCircular = model.spec().layout === "circular";
  if (isCircular) {
    drawCircularYAxis(HGC, trackInfo, tile, model, theme);
    drawCircularTitle(HGC, trackInfo, tile, model, theme);
  } else {
    drawLinearYAxis(HGC, trackInfo, tile, model, theme);
    drawRowLegend(HGC, trackInfo, tile, model, theme);
  }
  drawColorLegend(HGC, trackInfo, tile, model, theme);
}
function resolveSuperposedTracks(track) {
  if (IsDataTrack(track) || IsDummyTrack(track)) {
    return [];
  }
  if (!IsOverlaidTrack(track)) {
    return [track];
  }
  if (track._overlay.length === 0) {
    return [{ ...track, superpose: void 0 }];
  }
  const { _overlay, ...base } = track;
  const resolved = [];
  track._overlay.forEach((subSpec, i) => {
    const spec = Object.assign({}, base, subSpec);
    if (spec.title && i !== 0) {
      delete spec.title;
    }
    resolved.push(spec);
  });
  let xAxisPosition = void 0;
  resolved.forEach((d) => {
    if (IsChannelDeep(d.x) && d.x.axis && !xAxisPosition) {
      xAxisPosition = d.x.axis;
    }
  });
  const corrected = resolved.map((d) => {
    return {
      ...d,
      x: { ...d.x, axis: xAxisPosition }
    };
  });
  return corrected;
}
function spreadTracksByData(tracks) {
  return [].concat(
    ...tracks.map((t) => {
      if (IsDataTrack(t) || !IsOverlaidTrack(t) || t._overlay.length <= 1) {
        return [t];
      }
      if (t._overlay.filter((s) => s.data).length === 0) {
        return [t];
      }
      if (isIdenticalDataSpec([t.data, ...t._overlay.map((s) => s.data)])) {
        return [t];
      }
      const base = { ...t, id: void 0, _overlay: void 0 };
      const spread = [];
      const original = JSON.parse(JSON.stringify(base));
      original._overlay = [];
      t._overlay.forEach((subSpec) => {
        if (!original.data) {
          original.data = subSpec.data;
        }
        if (!original.id) {
          original.id = subSpec.id;
        }
        if (!subSpec.data || isIdenticalDataSpec([original.data, subSpec.data])) {
          original._overlay.push(subSpec);
          return;
        }
        const spec = Object.assign(JSON.parse(JSON.stringify(base)), subSpec);
        spread.push(spec);
      });
      const output = original._overlay.length > 0 ? [original, ...spread] : spread;
      return output.map((track, i, arr) => {
        const overlayOnPreviousTrack = i !== 0;
        const y = IsSingleTrack(track) && IsChannelDeep(track.y) && !track.y.axis && overlayOnPreviousTrack ? { ...track.y, axis: i === 1 ? "right" : "none" } : IsSingleTrack(track) ? track.y : void 0;
        if (track.title && i !== arr.length - 1 && arr.length !== 1) {
          delete track.title;
        }
        return { ...track, overlayOnPreviousTrack, y };
      });
    })
  );
}
function isIdenticalDataSpec(specs) {
  if (specs.length === 0) {
    return false;
  }
  const definedSpecs = specs.filter((d) => d);
  if (definedSpecs.length !== specs.length) {
    return false;
  }
  const keys = Object.keys(definedSpecs[0]).sort();
  let isIdentical = true;
  keys.forEach((k) => {
    const uniqueProperties = Array.from(new Set(definedSpecs.map((d) => JSON.stringify(d[k]))));
    if (uniqueProperties.length !== 1) {
      isIdentical = false;
      return;
    }
  });
  return isIdentical;
}
const PREDEFINED_COLOR_STR_MAP = {
  viridis: interpolateViridis,
  grey: interpolateGreys,
  warm: interpolateWarm,
  spectral: interpolateSpectral,
  cividis: interpolateCividis,
  bupu: interpolateBuPu,
  rdbu: interpolateRdBu,
  hot: interpolateYlOrBr,
  pink: interpolateRdPu
};
function isObject(x) {
  return typeof x === "object" && x !== null;
}
function isTabularDataFetcher(dataFetcher) {
  return isObject(dataFetcher) && "getTabularData" in dataFetcher;
}
function hasDataTransform(spec, type2) {
  var _a;
  return ((_a = spec.dataTransform) != null ? _a : []).some((d) => d.type === type2);
}
function getHiGlassColorRange(colorStr = "viridis", step = 100) {
  var _a;
  const interpolate = (_a = PREDEFINED_COLOR_STR_MAP[colorStr]) != null ? _a : PREDEFINED_COLOR_STR_MAP["viridis"];
  return [...Array(step)].map((_, i) => interpolate(1 / step * i));
}
function IsFlatTracks(_) {
  return !("alignment" in _) && !_.tracks.find((d) => d.alignment === "overlay" || "tracks" in d);
}
function IsOverlaidTracks(_) {
  return "alignment" in _ && _.alignment === "overlay";
}
function IsStackedTracks(_) {
  return !IsFlatTracks(_) && !IsOverlaidTracks(_);
}
function IsDataTrack(_) {
  return !IsOverlaidTrack(_) && "data" in _ && !("mark" in _);
}
function IsDummyTrack(_) {
  return "type" in _ && _.type == "dummy-track";
}
function IsDataTemplate(_) {
  return !!("data" in _ && "overrideTemplate" in _ && _.overrideTemplate);
}
function IsDataDeep(data2) {
  return typeof data2 === "object";
}
function IsDomainChr(domain) {
  return "chromosome" in domain && !("interval" in domain);
}
function IsDomainInterval(domain) {
  return !("chromosome" in domain) && "interval" in domain;
}
function IsDomainChrInterval(domain) {
  return "chromosome" in domain && "interval" in domain;
}
function IsSingleTrack(track) {
  return !("_overlay" in track);
}
function IsOverlaidTrack(track) {
  return "_overlay" in track;
}
function IsTemplateTrack(track) {
  return "template" in track;
}
function IsVerticalRule(track) {
  return IsSingleTrack(track) && !IsChannelDeep(track.x) && IsChannelDeep(track.y) && track.y.type === "genomic";
}
function Is2DTrack(track) {
  const t = IsSingleTrack(track) ? track : resolveSuperposedTracks(track)[0];
  return IsChannelDeep(t.x) && t.x.type === "genomic" && IsChannelDeep(t.y) && t.y.type === "genomic";
}
function IsHiGlassMatrix(track) {
  return Is2DTrack(track) && track.data.type === "matrix" && (track.mark === "bar" || track.mark === "rect") && track.xe && track.ye;
}
function IsChannelValue(channel) {
  return channel !== null && typeof channel === "object" && "value" in channel;
}
function IsDataDeepTileset(_) {
  return _ !== void 0 && (_.type === "vector" || _.type === "beddb" || _.type === "multivec" || _.type === "bigwig" || _.type === "matrix" || _.type === "bam" || _.type === "vcf" || _.type === "gff" || _.type === "bed");
}
function IsChannelDeep(channel) {
  return isObject(channel) && !("value" in channel);
}
function IsOneOfFilter(_) {
  return "oneOf" in _;
}
function IsRangeFilter(_) {
  return "inRange" in _;
}
function IsIncludeFilter(_) {
  return "include" in _;
}
function IsDomainArray(domain) {
  return Array.isArray(domain);
}
function IsRangeArray(range) {
  return Array.isArray(range);
}
function IsStackedMark(track) {
  return (track.mark === "bar" || track.mark === "area" || track.mark === "text") && IsChannelDeep(track.color) && track.color.type === "nominal" && (!track.row || IsChannelValue(track.row)) && // TODO: determine whether to use stacked bar for nominal fields or not
  IsChannelDeep(track.y) && track.y.type === "quantitative" && !IsChannelDeep(track.ye);
}
function IsStackedChannel(track, channelKey) {
  const channel = track[channelKey];
  return IsStackedMark(track) && // only x or y channel can be stacked
  (channelKey === "x" || channelKey === "y") && // only quantitative channel can be stacked
  IsChannelDeep(channel) && channel.type === "quantitative";
}
function getValueUsingChannel(datum, channel) {
  if (IsChannelDeep(channel) && channel.field) {
    return datum[channel == null ? void 0 : channel.field];
  }
  return void 0;
}
function getChannelKeysByAggregateFnc(spec) {
  const keys = [];
  SUPPORTED_CHANNELS.forEach((k) => {
    const c = spec[k];
    if (IsChannelDeep(c) && "aggregate" in c) {
      keys.push(k);
    }
  });
  return keys;
}
function getChannelKeysByType(spec, t) {
  const keys = [];
  SUPPORTED_CHANNELS.forEach((k) => {
    const c = spec[k];
    if (IsChannelDeep(c) && c.type === t) {
      keys.push(k);
    }
  });
  return keys;
}
function IsXAxis(_) {
  if ((IsSingleTrack(_) || IsOverlaidTrack(_)) && IsChannelDeep(_.x) && _.x.axis && _.x.axis !== "none") {
    return true;
  } else if (IsOverlaidTrack(_)) {
    let isFound = false;
    _._overlay.forEach((t) => {
      if (isFound)
        return;
      if (IsChannelDeep(t.x) && t.x.axis && t.x.axis !== "none") {
        isFound = true;
      }
    });
    return isFound;
  }
  return false;
}
function IsYAxis(_) {
  if ((IsSingleTrack(_) || IsOverlaidTrack(_)) && IsChannelDeep(_.y) && _.y.axis && _.y.axis !== "none") {
    return true;
  } else if (IsOverlaidTrack(_)) {
    let isFound = false;
    _._overlay.forEach((t) => {
      if (isFound)
        return;
      if (IsChannelDeep(t.y) && t.y.axis && t.y.axis !== "none") {
        isFound = true;
      }
    });
    return isFound;
  }
  return false;
}
function IsMouseEventsDeep(_) {
  return typeof _ === "object";
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var uri_all = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(module, exports) {
  (function(global2, factory2) {
    factory2(exports);
  })(commonjsGlobal, function(exports2) {
    function merge() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return "(?:" + str + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray2(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign2(target, source) {
      var obj = target;
      if (source) {
        for (var key in source) {
          obj[key] = source[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI) {
      var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
      subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
      var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
      subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
      var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
      subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
      return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err2) {
          _d = true;
          _e = err2;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$1(type2) {
      throw new RangeError(errors[type2]);
    }
    function map(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (
        ;
        /* no initialization */
        delta > baseMinusTMin * tMax >> 1;
        k += base
      ) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$1("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i;
        for (
          var w = 1, k = base;
          ;
          /* no condition */
          k += base
        ) {
          if (index >= inputLength) {
            error$1("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error$1("overflow");
          }
          i += digit * w;
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          var baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error$1("overflow");
          }
          w *= baseMinusT;
        }
        var out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$1("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output);
    };
    var encode = function encode2(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err2) {
        _didIteratorError = true;
        _iteratorError = err2;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m2 = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m2) {
              m2 = currentValue;
            }
          }
        } catch (err2) {
          _didIteratorError2 = true;
          _iteratorError2 = err2;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$1("overflow");
        }
        delta += (m2 - n) * handledCPCountPlusOne;
        n = m2;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$1("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (
                var k = base;
                ;
                /* no condition */
                k += base
              ) {
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                var qMinusT = q - t;
                var baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err2) {
          _didIteratorError3 = true;
          _iteratorError3 = err2;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = "";
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host))
          ;
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse(serialize(base2, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve2(baseURI, relativeURI, options) {
      var schemelessOptions = assign2({ scheme: "null" }, options);
      return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri2, options) {
      if (typeof uri2 === "string") {
        uri2 = serialize(parse(uri2, options), options);
      } else if (typeOf(uri2) === "object") {
        uri2 = parse(serialize(uri2, options), options);
      }
      return uri2;
    }
    function equal3(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse2(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse2(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      },
      serialize: function serialize2(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path && path !== "/" ? path : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray2(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name2 in headers) {
          if (headers[name2] !== O[name2]) {
            fields.push(name2.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name2].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID2 = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse2(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID2))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports2.SCHEMES = SCHEMES;
    exports2.pctEncChar = pctEncChar;
    exports2.pctDecChars = pctDecChars;
    exports2.parse = parse;
    exports2.removeDotSegments = removeDotSegments;
    exports2.serialize = serialize;
    exports2.resolveComponents = resolveComponents;
    exports2.resolve = resolve2;
    exports2.normalize = normalize;
    exports2.equal = equal3;
    exports2.escapeComponent = escapeComponent;
    exports2.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(uri_all, uri_all.exports);
var uri_allExports = uri_all.exports;
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var ucs2length$1 = function ucs2length(str) {
  var length = 0, len = str.length, pos = 0, value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) == 56320)
        pos++;
    }
  }
  return length;
};
var util$5 = {
  copy,
  checkDataType,
  checkDataTypes,
  coerceToTypes,
  toHash: toHash$1,
  getProperty,
  escapeQuotes,
  equal: fastDeepEqual,
  ucs2length: ucs2length$1,
  varOccurences,
  varReplace,
  schemaHasRules,
  schemaHasRulesExcept,
  schemaUnknownRules,
  toQuotedString,
  getPathExpr,
  getPath,
  getData,
  unescapeFragment,
  unescapeJsonPointer,
  escapeFragment,
  escapeJsonPointer
};
function copy(o, to) {
  to = to || {};
  for (var key in o)
    to[key] = o[key];
  return to;
}
function checkDataType(dataType, data2, strictNumbers, negate) {
  var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
  switch (dataType) {
    case "null":
      return data2 + EQUAL + "null";
    case "array":
      return OK + "Array.isArray(" + data2 + ")";
    case "object":
      return "(" + OK + data2 + AND + "typeof " + data2 + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data2 + "))";
    case "integer":
      return "(typeof " + data2 + EQUAL + '"number"' + AND + NOT + "(" + data2 + " % 1)" + AND + data2 + EQUAL + data2 + (strictNumbers ? AND + OK + "isFinite(" + data2 + ")" : "") + ")";
    case "number":
      return "(typeof " + data2 + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data2 + ")" : "") + ")";
    default:
      return "typeof " + data2 + EQUAL + '"' + dataType + '"';
  }
}
function checkDataTypes(dataTypes, data2, strictNumbers) {
  switch (dataTypes.length) {
    case 1:
      return checkDataType(dataTypes[0], data2, strictNumbers, true);
    default:
      var code = "";
      var types = toHash$1(dataTypes);
      if (types.array && types.object) {
        code = types.null ? "(" : "(!" + data2 + " || ";
        code += "typeof " + data2 + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number)
        delete types.integer;
      for (var t in types)
        code += (code ? " && " : "") + checkDataType(t, data2, strictNumbers, true);
      return code;
  }
}
var COERCE_TO_TYPES = toHash$1(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i = 0; i < dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t])
        types[types.length] = t;
      else if (optionCoerceTypes === "array" && t === "array")
        types[types.length] = t;
    }
    if (types.length)
      return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === "array" && dataTypes === "array") {
    return ["array"];
  }
}
function toHash$1(arr) {
  var hash = {};
  for (var i = 0; i < arr.length; i++)
    hash[arr[i]] = true;
  return hash;
}
var IDENTIFIER$1 = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == "number" ? "[" + key + "]" : IDENTIFIER$1.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
}
function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
}
function varOccurences(str, dataVar) {
  dataVar += "[^0-9]";
  var matches = str.match(new RegExp(dataVar, "g"));
  return matches ? matches.length : 0;
}
function varReplace(str, dataVar, expr) {
  dataVar += "([^0-9])";
  expr = expr.replace(/\$/g, "$$$$");
  return str.replace(new RegExp(dataVar, "g"), expr + "$1");
}
function schemaHasRules(schema, rules3) {
  if (typeof schema == "boolean")
    return !schema;
  for (var key in schema)
    if (rules3[key])
      return true;
}
function schemaHasRulesExcept(schema, rules3, exceptKeyword) {
  if (typeof schema == "boolean")
    return !schema && exceptKeyword != "not";
  for (var key in schema)
    if (key != exceptKeyword && rules3[key])
      return true;
}
function schemaUnknownRules(schema, rules3) {
  if (typeof schema == "boolean")
    return;
  for (var key in schema)
    if (!rules3[key])
      return key;
}
function toQuotedString(str) {
  return "'" + escapeQuotes(str) + "'";
}
function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
  return joinPaths(currentPath, path);
}
function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}
var JSON_POINTER$1 = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER$1 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data2, matches;
  if ($data === "")
    return "rootData";
  if ($data[0] == "/") {
    if (!JSON_POINTER$1.test($data))
      throw new Error("Invalid JSON-pointer: " + $data);
    jsonPointer = $data;
    data2 = "rootData";
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER$1);
    if (!matches)
      throw new Error("Invalid JSON-pointer: " + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == "#") {
      if (up >= lvl)
        throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
      return paths[lvl - up];
    }
    if (up > lvl)
      throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
    data2 = "data" + (lvl - up || "");
    if (!jsonPointer)
      return data2;
  }
  var expr = data2;
  var segments = jsonPointer.split("/");
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data2 += getProperty(unescapeJsonPointer(segment));
      expr += " && " + data2;
    }
  }
  return expr;
}
function joinPaths(a, b) {
  if (a == '""')
    return b;
  return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
}
function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}
function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}
function escapeJsonPointer(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapeJsonPointer(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
var util$4 = util$5;
var schema_obj = SchemaObject$2;
function SchemaObject$2(obj) {
  util$4.copy(obj, this);
}
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts, pre, post, schema, "", schema);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == "object" && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
var URI$1 = uri_allExports, equal$1 = fastDeepEqual, util$3 = util$5, SchemaObject$1 = schema_obj, traverse = jsonSchemaTraverseExports;
var resolve_1 = resolve$3;
resolve$3.normalizeId = normalizeId;
resolve$3.fullPath = getFullPath;
resolve$3.url = resolveUrl;
resolve$3.ids = resolveIds;
resolve$3.inlineRef = inlineRef;
resolve$3.schema = resolveSchema;
function resolve$3(compile2, root, ref2) {
  var refVal = this._refs[ref2];
  if (typeof refVal == "string") {
    if (this._refs[refVal])
      refVal = this._refs[refVal];
    else
      return resolve$3.call(this, compile2, root, refVal);
  }
  refVal = refVal || this._schemas[ref2];
  if (refVal instanceof SchemaObject$1) {
    return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
  }
  var res = resolveSchema.call(this, root, ref2);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }
  if (schema instanceof SchemaObject$1) {
    v = schema.validate || compile2.call(this, schema.schema, root, void 0, baseId);
  } else if (schema !== void 0) {
    v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile2.call(this, schema, root, void 0, baseId);
  }
  return v;
}
function resolveSchema(root, ref2) {
  var p = URI$1.parse(ref2), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == "string") {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject$1) {
      if (!refVal.validate)
        this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject$1) {
        if (!refVal.validate)
          this._compile(refVal);
        if (id == normalizeId(ref2))
          return { schema: refVal, root, baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema)
      return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}
function resolveRecursive(root, ref2, parsedRef) {
  var res = resolveSchema.call(this, root, ref2);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id)
      baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}
var PREVENT_SCOPE_CHANGE = util$3.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
function getJsonPointer(parsedRef, baseId, schema, root) {
  parsedRef.fragment = parsedRef.fragment || "";
  if (parsedRef.fragment.slice(0, 1) != "/")
    return;
  var parts = parsedRef.fragment.split("/");
  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util$3.unescapeFragment(part);
      schema = schema[part];
      if (schema === void 0)
        break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id)
          baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref2 = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref2);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== void 0 && schema !== root.schema)
    return { schema, root, baseId };
}
var SIMPLE_INLINED = util$3.toHash([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum"
]);
function inlineRef(schema, limit) {
  if (limit === false)
    return false;
  if (limit === void 0 || limit === true)
    return checkNoRef(schema);
  else if (limit)
    return countKeys(schema) <= limit;
}
function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) {
      item = schema[i];
      if (typeof item == "object" && !checkNoRef(item))
        return false;
    }
  } else {
    for (var key in schema) {
      if (key == "$ref")
        return false;
      item = schema[key];
      if (typeof item == "object" && !checkNoRef(item))
        return false;
    }
  }
  return true;
}
function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) {
      item = schema[i];
      if (typeof item == "object")
        count += countKeys(item);
      if (count == Infinity)
        return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == "$ref")
        return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == "object")
          count += countKeys(item) + 1;
        if (count == Infinity)
          return Infinity;
      }
    }
  }
  return count;
}
function getFullPath(id, normalize) {
  if (normalize !== false)
    id = normalizeId(id);
  var p = URI$1.parse(id);
  return _getFullPath(p);
}
function _getFullPath(p) {
  return URI$1.serialize(p).split("#")[0] + "#";
}
var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI$1.resolve(baseId, id);
}
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = { "": schemaId };
  var fullPaths = { "": getFullPath(schemaId, false) };
  var localRefs = {};
  var self2 = this;
  traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === "")
      return;
    var id = self2._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
    if (keyIndex !== void 0)
      fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util$3.escapeFragment(keyIndex));
    if (typeof id == "string") {
      id = baseId = normalizeId(baseId ? URI$1.resolve(baseId, id) : id);
      var refVal = self2._refs[id];
      if (typeof refVal == "string")
        refVal = self2._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal$1(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == "#") {
          if (localRefs[id] && !equal$1(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self2._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });
  return localRefs;
}
var resolve$2 = resolve_1;
var error_classes = {
  Validation: errorSubclass(ValidationError$1),
  MissingRef: errorSubclass(MissingRefError$1)
};
function ValidationError$1(errors) {
  this.message = "validation failed";
  this.errors = errors;
  this.ajv = this.validation = true;
}
MissingRefError$1.message = function(baseId, ref2) {
  return "can't resolve reference " + ref2 + " from id " + baseId;
};
function MissingRefError$1(baseId, ref2, message) {
  this.message = message || MissingRefError$1.message(baseId, ref2);
  this.missingRef = resolve$2.url(baseId, ref2);
  this.missingSchema = resolve$2.normalizeId(resolve$2.fullPath(this.missingRef));
}
function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}
var fastJsonStableStringify = function(data2, opts) {
  if (!opts)
    opts = {};
  if (typeof opts === "function")
    opts = { cmp: opts };
  var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
  var cmp = opts.cmp && function(f) {
    return function(node) {
      return function(a, b) {
        var aobj = { key: a, value: node[a] };
        var bobj = { key: b, value: node[b] };
        return f(aobj, bobj);
      };
    };
  }(opts.cmp);
  var seen = [];
  return function stringify(node) {
    if (node && node.toJSON && typeof node.toJSON === "function") {
      node = node.toJSON();
    }
    if (node === void 0)
      return;
    if (typeof node == "number")
      return isFinite(node) ? "" + node : "null";
    if (typeof node !== "object")
      return JSON.stringify(node);
    var i, out;
    if (Array.isArray(node)) {
      out = "[";
      for (i = 0; i < node.length; i++) {
        if (i)
          out += ",";
        out += stringify(node[i]) || "null";
      }
      return out + "]";
    }
    if (node === null)
      return "null";
    if (seen.indexOf(node) !== -1) {
      if (cycles)
        return JSON.stringify("__cycle__");
      throw new TypeError("Converting circular structure to JSON");
    }
    var seenIndex = seen.push(node) - 1;
    var keys = Object.keys(node).sort(cmp && cmp(node));
    out = "";
    for (i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = stringify(node[key]);
      if (!value)
        continue;
      if (out)
        out += ",";
      out += JSON.stringify(key) + ":" + value;
    }
    seen.splice(seenIndex, 1);
    return "{" + out + "}";
  }(data2);
};
var validate$1 = function generate_validate(it, $keyword, $ruleType) {
  var out = "";
  var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id2 = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = "unknown keyword: " + $unknownKwd;
      if (it.opts.strictKeywords === "log")
        it.logger.warn($keywordsMsg);
      else
        throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += " var validate = ";
    if ($async) {
      it.async = true;
      out += "async ";
    }
    out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
    if ($id2 && (it.opts.sourceCode || it.opts.processCode)) {
      out += " " + ("/*# sourceURL=" + $id2 + " */") + " ";
    }
  }
  if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
    var $keyword = "false schema";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += " var " + $valid + " = false; ";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'boolean schema is false' ";
        }
        if (it.opts.verbose) {
          out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += " return data; ";
        } else {
          out += " validate.errors = null; return true; ";
        }
      } else {
        out += " var " + $valid + " = true; ";
      }
    }
    if (it.isTop) {
      out += " }; return validate; ";
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [""];
    if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = "default is ignored in the schema root";
      if (it.opts.strictDefaults === "log")
        it.logger.warn($defaultMsg);
      else
        throw new Error($defaultMsg);
    }
    out += " var vErrors = null; ";
    out += " var errors = 0;     ";
    out += " if (rootData === undefined) rootData = data; ";
  } else {
    var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
    if ($id2)
      it.baseId = it.resolve.url(it.baseId, $id2);
    if ($async && !it.async)
      throw new Error("async schema in sync schema");
    out += " var errs_" + $lvl + " = errors;";
  }
  var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
  var $errorKeyword;
  var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf("null") == -1)
        $typeSchema = $typeSchema.concat("null");
    } else if ($typeSchema != "null") {
      $typeSchema = [$typeSchema, "null"];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == "fail") {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += " " + it.RULES.all.$comment.code(it, "$comment");
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
      var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
      var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
      out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
      if ($coerceToTypes) {
        var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
        out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
        if (it.opts.coerceTypes == "array") {
          out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
        }
        out += " if (" + $coerced + " !== undefined) ; ";
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($type == "string") {
              out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
            } else if ($type == "number" || $type == "integer") {
              out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
              if ($type == "integer") {
                out += " && !(" + $data + " % 1)";
              }
              out += ")) " + $coerced + " = +" + $data + "; ";
            } else if ($type == "boolean") {
              out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
            } else if ($type == "null") {
              out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
            } else if (it.opts.coerceTypes == "array" && $type == "array") {
              out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
            }
          }
        }
        out += " else {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
          if ($typeIsArray) {
            out += "" + $typeSchema.join(",");
          } else {
            out += "" + $typeSchema;
          }
          out += "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be ";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } if (" + $coerced + " !== undefined) {  ";
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " " + $data + " = " + $coerced + "; ";
        if (!$dataLvl) {
          out += "if (" + $parentData + " !== undefined)";
        }
        out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
          if ($typeIsArray) {
            out += "" + $typeSchema.join(",");
          } else {
            out += "" + $typeSchema;
          }
          out += "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be ";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      }
      out += " } ";
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
    if ($breakOnError) {
      out += " } if (errors === ";
      if ($top) {
        out += "0";
      } else {
        out += "errs_" + $lvl;
      }
      out += ") { ";
      $closingBraces2 += "}";
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == "object" && it.schema.properties) {
              var $schema2 = it.schema.properties, $schemaKeys = Object.keys($schema2);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema2[$propertyKey];
                  if ($sch.default !== void 0) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = "default is ignored for: " + $passData;
                        if (it.opts.strictDefaults === "log")
                          it.logger.warn($defaultMsg);
                        else
                          throw new Error($defaultMsg);
                      }
                    } else {
                      out += " if (" + $passData + " === undefined ";
                      if (it.opts.useDefaults == "empty") {
                        out += " || " + $passData + " === null || " + $passData + " === '' ";
                      }
                      out += " ) " + $passData + " = ";
                      if (it.opts.useDefaults == "shared") {
                        out += " " + it.useDefault($sch.default) + " ";
                      } else {
                        out += " " + JSON.stringify($sch.default) + " ";
                      }
                      out += "; ";
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1, l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== void 0) {
                    var $passData = $data + "[" + $i + "]";
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = "default is ignored for: " + $passData;
                        if (it.opts.strictDefaults === "log")
                          it.logger.warn($defaultMsg);
                        else
                          throw new Error($defaultMsg);
                      }
                    } else {
                      out += " if (" + $passData + " === undefined ";
                      if (it.opts.useDefaults == "empty") {
                        out += " || " + $passData + " === null || " + $passData + " === '' ";
                      }
                      out += " ) " + $passData + " = ";
                      if (it.opts.useDefaults == "shared") {
                        out += " " + it.useDefault($sch.default) + " ";
                      } else {
                        out += " " + JSON.stringify($sch.default) + " ";
                      }
                      out += "; ";
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1, l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += " " + $code + " ";
                  if ($breakOnError) {
                    $closingBraces1 += "}";
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += " " + $closingBraces1 + " ";
            $closingBraces1 = "";
          }
          if ($rulesGroup.type) {
            out += " } ";
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += " else { ";
              var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should be ";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } ";
            }
          }
          if ($breakOnError) {
            out += " if (errors === ";
            if ($top) {
              out += "0";
            } else {
              out += "errs_" + $lvl;
            }
            out += ") { ";
            $closingBraces2 += "}";
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += " " + $closingBraces2 + " ";
  }
  if ($top) {
    if ($async) {
      out += " if (errors === 0) return data;           ";
      out += " else throw new ValidationError(vErrors); ";
    } else {
      out += " validate.errors = vErrors; ";
      out += " return errors === 0;       ";
    }
    out += " }; return validate;";
  } else {
    out += " var " + $valid + " = errors === errs_" + $lvl + ";";
  }
  function $shouldUseGroup($rulesGroup2) {
    var rules3 = $rulesGroup2.rules;
    for (var i = 0; i < rules3.length; i++)
      if ($shouldUseRule(rules3[i]))
        return true;
  }
  function $shouldUseRule($rule2) {
    return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
  }
  function $ruleImplementsSomeKeyword($rule2) {
    var impl = $rule2.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== void 0)
        return true;
  }
  return out;
};
var resolve$1 = resolve_1, util$2 = util$5, errorClasses$1 = error_classes, stableStringify$1 = fastJsonStableStringify;
var validateGenerator = validate$1;
var ucs2length2 = util$2.ucs2length;
var equal2 = fastDeepEqual;
var ValidationError = errorClasses$1.Validation;
var compile_1 = compile$2;
function compile$2(schema, root, localRefs, baseId) {
  var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
  root = root || { schema, refVal, refs };
  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling)
    return compilation.callValidate = callValidate;
  var formats2 = this._formats;
  var RULES = this.RULES;
  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode)
        cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }
  function callValidate() {
    var validate2 = compilation.validate;
    var result = validate2.apply(this, arguments);
    callValidate.errors = validate2.errors;
    return result;
  }
  function localCompile(_schema, _root, localRefs2, baseId2) {
    var isRoot = !_root || _root && _root.schema == _schema;
    if (_root.schema != root.schema)
      return compile$2.call(self2, _schema, _root, localRefs2, baseId2);
    var $async = _schema.$async === true;
    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot,
      baseId: baseId2,
      root: _root,
      schemaPath: "",
      errSchemaPath: "#",
      errorPath: '""',
      MissingRefError: errorClasses$1.MissingRef,
      RULES,
      validate: validateGenerator,
      util: util$2,
      resolve: resolve$1,
      resolveRef,
      usePattern,
      useDefault,
      useCustomRule,
      opts,
      formats: formats2,
      logger: self2.logger,
      self: self2
    });
    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode$1) + sourceCode;
    if (opts.processCode)
      sourceCode = opts.processCode(sourceCode, _schema);
    var validate2;
    try {
      var makeValidate = new Function(
        "self",
        "RULES",
        "formats",
        "root",
        "refVal",
        "defaults",
        "customRules",
        "equal",
        "ucs2length",
        "ValidationError",
        sourceCode
      );
      validate2 = makeValidate(
        self2,
        RULES,
        formats2,
        root,
        refVal,
        defaults,
        customRules,
        equal2,
        ucs2length2,
        ValidationError
      );
      refVal[0] = validate2;
    } catch (e) {
      self2.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    }
    validate2.schema = _schema;
    validate2.errors = null;
    validate2.refs = refs;
    validate2.refVal = refVal;
    validate2.root = isRoot ? validate2 : _root;
    if ($async)
      validate2.$async = true;
    if (opts.sourceCode === true) {
      validate2.source = {
        code: sourceCode,
        patterns,
        defaults
      };
    }
    return validate2;
  }
  function resolveRef(baseId2, ref2, isRoot) {
    ref2 = resolve$1.url(baseId2, ref2);
    var refIndex = refs[ref2];
    var _refVal, refCode;
    if (refIndex !== void 0) {
      _refVal = refVal[refIndex];
      refCode = "refVal[" + refIndex + "]";
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref2];
      if (rootRefId !== void 0) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref2, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }
    refCode = addLocalRef(ref2);
    var v2 = resolve$1.call(self2, localCompile, root, ref2);
    if (v2 === void 0) {
      var localSchema = localRefs && localRefs[ref2];
      if (localSchema) {
        v2 = resolve$1.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile$2.call(self2, localSchema, root, localRefs, baseId2);
      }
    }
    if (v2 === void 0) {
      removeLocalRef(ref2);
    } else {
      replaceLocalRef(ref2, v2);
      return resolvedRef(v2, refCode);
    }
  }
  function addLocalRef(ref2, v2) {
    var refId = refVal.length;
    refVal[refId] = v2;
    refs[ref2] = refId;
    return "refVal" + refId;
  }
  function removeLocalRef(ref2) {
    delete refs[ref2];
  }
  function replaceLocalRef(ref2, v2) {
    var refId = refs[ref2];
    refVal[refId] = v2;
  }
  function resolvedRef(refVal2, code) {
    return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
  }
  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === void 0) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return "pattern" + index;
  }
  function useDefault(value) {
    switch (typeof value) {
      case "boolean":
      case "number":
        return "" + value;
      case "string":
        return util$2.toQuotedString(value);
      case "object":
        if (value === null)
          return "null";
        var valueStr = stableStringify$1(value);
        var index = defaultsHash[valueStr];
        if (index === void 0) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return "default" + index;
    }
  }
  function useCustomRule(rule, schema2, parentSchema, it) {
    if (self2._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword2) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword2);
      }))
        throw new Error("parent schema must have all required keywords: " + deps.join(","));
      var validateSchema2 = rule.definition.validateSchema;
      if (validateSchema2) {
        var valid = validateSchema2(schema2);
        if (!valid) {
          var message = "keyword schema is invalid: " + self2.errorsText(validateSchema2.errors);
          if (self2._opts.validateSchema == "log")
            self2.logger.error(message);
          else
            throw new Error(message);
        }
      }
    }
    var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
    var validate2;
    if (compile2) {
      validate2 = compile2.call(self2, schema2, parentSchema, it);
    } else if (macro) {
      validate2 = macro.call(self2, schema2, parentSchema, it);
      if (opts.validateSchema !== false)
        self2.validateSchema(validate2, true);
    } else if (inline) {
      validate2 = inline.call(self2, it, rule.keyword, schema2, parentSchema);
    } else {
      validate2 = rule.definition.validate;
      if (!validate2)
        return;
    }
    if (validate2 === void 0)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
    var index = customRules.length;
    customRules[index] = validate2;
    return {
      code: "customRule" + index,
      validate: validate2
    };
  }
}
function checkCompiling(schema, root, baseId) {
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0)
    return { index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema,
    root,
    baseId
  };
  return { index, compiling: false };
}
function endCompiling(schema, root, baseId) {
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0)
    this._compilations.splice(i, 1);
}
function compIndex(schema, root, baseId) {
  for (var i = 0; i < this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId)
      return i;
  }
  return -1;
}
function patternCode(i, patterns) {
  return "var pattern" + i + " = new RegExp(" + util$2.toQuotedString(patterns[i]) + ");";
}
function defaultCode(i) {
  return "var default" + i + " = defaults[" + i + "];";
}
function refValCode(i, refVal) {
  return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
}
function customRuleCode$1(i) {
  return "var customRule" + i + " = customRules[" + i + "];";
}
function vars(arr, statement) {
  if (!arr.length)
    return "";
  var code = "";
  for (var i = 0; i < arr.length; i++)
    code += statement(i, arr);
  return code;
}
var cache = { exports: {} };
var Cache$1 = cache.exports = function Cache() {
  this._cache = {};
};
Cache$1.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};
Cache$1.prototype.get = function Cache_get(key) {
  return this._cache[key];
};
Cache$1.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};
Cache$1.prototype.clear = function Cache_clear() {
  this._cache = {};
};
var cacheExports = cache.exports;
var util$1 = util$5;
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME$1 = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var URL$1 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var formats_1 = formats$1;
function formats$1(mode) {
  mode = mode == "full" ? "full" : "fast";
  return util$1.copy(formats$1[mode]);
}
formats$1.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
  "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  "uri-template": URITEMPLATE,
  url: URL$1,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  "json-pointer": JSON_POINTER,
  "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  "relative-json-pointer": RELATIVE_JSON_POINTER
};
formats$1.full = {
  date,
  time,
  "date-time": date_time,
  uri,
  "uri-reference": URIREF,
  "uri-template": URITEMPLATE,
  url: URL$1,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex,
  uuid: UUID,
  "json-pointer": JSON_POINTER,
  "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
  "relative-json-pointer": RELATIVE_JSON_POINTER
};
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date(str) {
  var matches = str.match(DATE);
  if (!matches)
    return false;
  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function time(str, full) {
  var matches = str.match(TIME$1);
  if (!matches)
    return false;
  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}
var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    new RegExp(str);
    return true;
  } catch (e) {
    return false;
  }
}
var ref = function generate_ref(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $async, $refCode;
  if ($schema2 == "#" || $schema2 == "#/") {
    if (it.isRoot) {
      $async = it.async;
      $refCode = "validate";
    } else {
      $async = it.root.schema.$async === true;
      $refCode = "root.refVal[0]";
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema2, it.isRoot);
    if ($refVal === void 0) {
      var $message = it.MissingRefError.message(it.baseId, $schema2);
      if (it.opts.missingRefs == "fail") {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema2) + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema2) + "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: " + it.util.toQuotedString($schema2) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        if ($breakOnError) {
          out += " if (false) { ";
        }
      } else if (it.opts.missingRefs == "ignore") {
        it.logger.warn($message);
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema2, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = "";
      $it.errSchemaPath = $schema2;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += " " + $code + " ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
      }
    } else {
      $async = $refVal.$async === true || it.async && $refVal.$async !== false;
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.opts.passContext) {
      out += " " + $refCode + ".call(this, ";
    } else {
      out += " " + $refCode + "( ";
    }
    out += " " + $data + ", (dataPath || '')";
    if (it.errorPath != '""') {
      out += " + " + it.errorPath;
    }
    var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
    out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async)
        throw new Error("async schema referenced by sync schema");
      if ($breakOnError) {
        out += " var " + $valid + "; ";
      }
      out += " try { await " + __callValidate + "; ";
      if ($breakOnError) {
        out += " " + $valid + " = true; ";
      }
      out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
      if ($breakOnError) {
        out += " " + $valid + " = false; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " if (" + $valid + ") { ";
      }
    } else {
      out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
      if ($breakOnError) {
        out += " else { ";
      }
    }
  }
  return out;
};
var allOf = function generate_allOf(it, $keyword, $ruleType) {
  var out = " ";
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
  var arr1 = $schema2;
  if (arr1) {
    var $sch, $i = -1, l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + "[" + $i + "]";
        $it.errSchemaPath = $errSchemaPath + "/" + $i;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += " if (true) { ";
    } else {
      out += " " + $closingBraces.slice(0, -1) + " ";
    }
  }
  return out;
};
var anyOf = function generate_anyOf(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $noEmptySchema = $schema2.every(function($sch2) {
    return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + "[" + $i + "]";
        $it.errSchemaPath = $errSchemaPath + "/" + $i;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
        $closingBraces += "}";
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should match some schema in anyOf' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    if (it.opts.allErrors) {
      out += " } ";
    }
  } else {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  }
  return out;
};
var comment = function generate_comment(it, $keyword, $ruleType) {
  var out = " ";
  var $schema2 = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema2);
  if (it.opts.$comment === true) {
    out += " console.log(" + $comment + ");";
  } else if (typeof it.opts.$comment == "function") {
    out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
  }
  return out;
};
var _const = function generate_const(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
  }
  if (!$isData) {
    out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
  }
  out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be equal to constant' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " }";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var contains = function generate_contains(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all);
  out += "var " + $errs + " = errors;var " + $valid + ";";
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + "[" + $idx + "]";
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
    } else {
      out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
    }
    out += " if (" + $nextValid + ") break; }  ";
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " " + $closingBraces + " if (!" + $nextValid + ") {";
  } else {
    out += " if (" + $data + ".length == 0) {";
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
    if (it.opts.messages !== false) {
      out += " , message: 'should contain a valid item' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " } else { ";
  if ($nonEmptySchema) {
    out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
  }
  if (it.opts.allErrors) {
    out += " } ";
  }
  return out;
};
var dependencies = function generate_dependencies(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
  for ($property in $schema2) {
    if ($property == "__proto__")
      continue;
    var $sch = $schema2[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += "var " + $errs + " = errors;";
  var $currentErrorPath = it.errorPath;
  out += "var missing" + $lvl + ";";
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
      if ($ownProperties) {
        out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
      }
      if ($breakOnError) {
        out += " && ( ";
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += " || ";
            }
            var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
            out += " ( ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
          }
        }
        out += ")) {  ";
        var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should have ";
            if ($deps.length == 1) {
              out += "property " + it.util.escapeQuotes($deps[0]);
            } else {
              out += "properties " + it.util.escapeQuotes($deps.join(", "));
            }
            out += " when property " + it.util.escapeQuotes($property) + " is present' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      } else {
        out += " ) { ";
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += " if ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
          }
        }
      }
      out += " }   ";
      if ($breakOnError) {
        $closingBraces += "}";
        out += " else { ";
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
      out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
      if ($ownProperties) {
        out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
      }
      out += ") { ";
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      out += " }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
  }
  if ($breakOnError) {
    out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var _enum = function generate_enum(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
  }
  var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
  if (!$isData) {
    out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
  }
  out += "var " + $valid + ";";
  if ($isData) {
    out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
  }
  out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
  if ($isData) {
    out += "  }  ";
  }
  out += " if (!" + $valid + ") {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be equal to one of the allowed values' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " }";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var format = function generate_format(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += " if (true) { ";
    }
    return out;
  }
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
    out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
    if (it.async) {
      out += " var async" + $lvl + " = " + $format + ".async; ";
    }
    out += " " + $format + " = " + $format + ".validate; } if (  ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
    }
    out += " (";
    if ($unknownFormats != "ignore") {
      out += " (" + $schemaValue + " && !" + $format + " ";
      if ($allowUnknown) {
        out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
      }
      out += ") || ";
    }
    out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
    if (it.async) {
      out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
    } else {
      out += " " + $format + "(" + $data + ") ";
    }
    out += " : " + $format + ".test(" + $data + "))))) {";
  } else {
    var $format = it.formats[$schema2];
    if (!$format) {
      if ($unknownFormats == "ignore") {
        it.logger.warn('unknown format "' + $schema2 + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema2) >= 0) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema2 + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || "string";
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
      return out;
    }
    if ($async) {
      if (!it.async)
        throw new Error("async format in sync schema");
      var $formatRef = "formats" + it.util.getProperty($schema2) + ".validate";
      out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
    } else {
      out += " if (! ";
      var $formatRef = "formats" + it.util.getProperty($schema2);
      if ($isObject)
        $formatRef += ".validate";
      if (typeof $format == "function") {
        out += " " + $formatRef + "(" + $data + ") ";
      } else {
        out += " " + $formatRef + ".test(" + $data + ") ";
      }
      out += ") { ";
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
    if ($isData) {
      out += "" + $schemaValue;
    } else {
      out += "" + it.util.toQuotedString($schema2);
    }
    out += "  } ";
    if (it.opts.messages !== false) {
      out += ` , message: 'should match format "`;
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + it.util.escapeQuotes($schema2);
      }
      out += `"' `;
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + it.util.toQuotedString($schema2);
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " } ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _if = function generate_if(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += "  " + it.validate($it) + " ";
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += " if (" + $nextValid + ") {  ";
      $it.schema = it.schema["then"];
      $it.schemaPath = it.schemaPath + ".then";
      $it.errSchemaPath = it.errSchemaPath + "/then";
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      out += " " + $valid + " = " + $nextValid + "; ";
      if ($thenPresent && $elsePresent) {
        $ifClause = "ifClause" + $lvl;
        out += " var " + $ifClause + " = 'then'; ";
      } else {
        $ifClause = "'then'";
      }
      out += " } ";
      if ($elsePresent) {
        out += " else { ";
      }
    } else {
      out += " if (!" + $nextValid + ") { ";
    }
    if ($elsePresent) {
      $it.schema = it.schema["else"];
      $it.schemaPath = it.schemaPath + ".else";
      $it.errSchemaPath = it.errSchemaPath + "/else";
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      out += " " + $valid + " = " + $nextValid + "; ";
      if ($thenPresent && $elsePresent) {
        $ifClause = "ifClause" + $lvl;
        out += " var " + $ifClause + " = 'else'; ";
      } else {
        $ifClause = "'else'";
      }
      out += " } ";
    }
    out += " if (!" + $valid + ") {   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += " }   ";
    if ($breakOnError) {
      out += " else { ";
    }
  } else {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  }
  return out;
};
var items = function generate_items(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
  out += "var " + $errs + " = errors;var " + $valid + ";";
  if (Array.isArray($schema2)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += " " + $valid + " = " + $data + ".length <= " + $schema2.length + "; ";
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + "/additionalItems";
      out += "  if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema2.length + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have more than " + $schema2.length + " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += "}";
        out += " else { ";
      }
    }
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
          var $passData = $data + "[" + $i + "]";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + ".additionalItems";
      $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
      out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema2.length + ") {  for (var " + $idx + " = " + $schema2.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      if ($breakOnError) {
        out += " if (!" + $nextValid + ") break; ";
      }
      out += " } }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
  } else if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + "[" + $idx + "]";
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
    } else {
      out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
    }
    if ($breakOnError) {
      out += " if (!" + $nextValid + ") break; ";
    }
    out += " }";
  }
  if ($breakOnError) {
    out += " " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var _limit = function generate__limit(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
  if (!($isData || typeof $schema2 == "number" || $schema2 === void 0)) {
    throw new Error($keyword + " must be number");
  }
  if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
    throw new Error($exclusiveKeyword + " must be number or boolean");
  }
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
    out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
    $schemaValueExcl = "schemaExcl" + $lvl;
    out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
    if ($schema2 === void 0) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = "'" + $opStr + "'";
      out += " if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
    } else {
      if ($exclIsNumber && $schema2 === void 0) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += "=";
      } else {
        if ($exclIsNumber)
          $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema2);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $notOp += "=";
        } else {
          $exclusive = false;
          $opStr += "=";
        }
      }
      var $opExpr = "'" + $opStr + "'";
      out += " if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be " + $opStr + " ";
      if ($isData) {
        out += "' + " + $schemaValue;
      } else {
        out += "" + $schemaValue + "'";
      }
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " } ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _limitItems = function generate__limitItems(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  var $op = $keyword == "maxItems" ? ">" : "<";
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
  }
  out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT have ";
      if ($keyword == "maxItems") {
        out += "more";
      } else {
        out += "fewer";
      }
      out += " than ";
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + $schema2;
      }
      out += " items' ";
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _limitLength = function generate__limitLength(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  var $op = $keyword == "maxLength" ? ">" : "<";
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
  }
  if (it.opts.unicode === false) {
    out += " " + $data + ".length ";
  } else {
    out += " ucs2length(" + $data + ") ";
  }
  out += " " + $op + " " + $schemaValue + ") { ";
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT be ";
      if ($keyword == "maxLength") {
        out += "longer";
      } else {
        out += "shorter";
      }
      out += " than ";
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + $schema2;
      }
      out += " characters' ";
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _limitProperties = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  var $op = $keyword == "maxProperties" ? ">" : "<";
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
  }
  out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT have ";
      if ($keyword == "maxProperties") {
        out += "more";
      } else {
        out += "fewer";
      }
      out += " than ";
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + $schema2;
      }
      out += " properties' ";
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var multipleOf = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  out += "var division" + $lvl + ";if (";
  if ($isData) {
    out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
  }
  out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
  if (it.opts.multipleOfPrecision) {
    out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
  } else {
    out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
  }
  out += " ) ";
  if ($isData) {
    out += "  )  ";
  }
  out += " ) {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be multiple of ";
      if ($isData) {
        out += "' + " + $schemaValue;
      } else {
        out += "" + $schemaValue + "'";
      }
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var not = function generate_not(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = "valid" + $it.level;
  if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += " var " + $errs + " = errors;  ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += " " + it.validate($it) + " ";
    $it.createErrors = true;
    if ($allErrorsOption)
      $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " if (" + $nextValid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT be valid' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    if (it.opts.allErrors) {
      out += " } ";
    }
  } else {
    out += "  var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT be valid' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if ($breakOnError) {
      out += " if (false) { ";
    }
  }
  return out;
};
var oneOf = function generate_oneOf(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
  out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema2;
  if (arr1) {
    var $sch, $i = -1, l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + "[" + $i + "]";
        $it.errSchemaPath = $errSchemaPath + "/" + $i;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
      } else {
        out += " var " + $nextValid + " = true; ";
      }
      if ($i) {
        out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
        $closingBraces += "}";
      }
      out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
  if (it.createErrors !== false) {
    out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should match exactly one schema in oneOf' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError(vErrors); ";
    } else {
      out += " validate.errors = vErrors; return false; ";
    }
  }
  out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
  if (it.opts.allErrors) {
    out += " } ";
  }
  return out;
};
var pattern = function generate_pattern(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema2);
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
  }
  out += " !" + $regexp + ".test(" + $data + ") ) {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
    if ($isData) {
      out += "" + $schemaValue;
    } else {
      out += "" + it.util.toQuotedString($schema2);
    }
    out += "  } ";
    if (it.opts.messages !== false) {
      out += ` , message: 'should match pattern "`;
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + it.util.escapeQuotes($schema2);
      }
      out += `"' `;
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + it.util.toQuotedString($schema2);
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var properties$2 = function generate_properties(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
  var $schemaKeys = Object.keys($schema2 || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
    var $requiredHash = it.util.toHash($required);
  }
  function notProto(p) {
    return p !== "__proto__";
  }
  out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
  if ($ownProperties) {
    out += " var " + $dataProperties + " = undefined;";
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
    } else {
      out += " for (var " + $key + " in " + $data + ") { ";
    }
    if ($someProperties) {
      out += " var isAdditional" + $lvl + " = !(false ";
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1, l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
          }
        }
      }
      out += " ); if (isAdditional" + $lvl + ") { ";
    }
    if ($removeAdditional == "all") {
      out += " delete " + $data + "[" + $key + "]; ";
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = "' + " + $key + " + '";
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          out += " " + $nextValid + " = false; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalProperties";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is an invalid additional property";
              } else {
                out += "should NOT have additional properties";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += " break; ";
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == "failing") {
          out += " var " + $errs + " = errors;  ";
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + ".additionalProperties";
          $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + "[" + $key + "]";
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + ".additionalProperties";
          $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + "[" + $key + "]";
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += " } ";
    }
    out += " }  ";
    if ($breakOnError) {
      out += " if (" + $nextValid + ") { ";
      $closingBraces += "}";
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1, l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema2[$propertyKey];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += " var " + $nextData + " = " + $passData + "; ";
          }
          if ($hasDefault) {
            out += " " + $code + " ";
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") { " + $nextValid + " = false; ";
              var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + "/required";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += " } else { ";
            } else {
              if ($breakOnError) {
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") { " + $nextValid + " = true; } else { ";
              } else {
                out += " if (" + $useData + " !== undefined ";
                if ($ownProperties) {
                  out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += " ) { ";
              }
            }
            out += " " + $code + " } ";
          }
        }
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1, l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
          } else {
            out += " for (var " + $key + " in " + $data + ") { ";
          }
          out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + "[" + $key + "]";
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " else " + $nextValid + " = true; ";
          }
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += " " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var propertyNames = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  out += "var " + $errs + " = errors;";
  if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += " var " + $dataProperties + " = undefined; ";
    }
    if ($ownProperties) {
      out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
    } else {
      out += " for (var " + $key + " in " + $data + ") { ";
    }
    out += " var startErrs" + $lvl + " = errors; ";
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
    } else {
      out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
      if (it.opts.messages !== false) {
        out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    if ($breakOnError) {
      out += " break; ";
    }
    out += " } }";
  }
  if ($breakOnError) {
    out += " " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var required$1 = function generate_required(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
  }
  var $vSchema = "schema" + $lvl;
  if (!$isData) {
    if ($schema2.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema2;
      if (arr1) {
        var $property, i1 = -1, l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema2;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += " var missing" + $lvl + "; ";
      if ($loopRequired) {
        if (!$isData) {
          out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
        }
        var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += " var " + $valid + " = true; ";
        if ($isData) {
          out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
        }
        out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
        if ($ownProperties) {
          out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
        }
        out += "; if (!" + $valid + ") break; } ";
        if ($isData) {
          out += "  }  ";
        }
        out += "  if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            if (it.opts._errorDataPathProperty) {
              out += "is a required property";
            } else {
              out += "should have required property \\'" + $missingProperty + "\\'";
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else { ";
      } else {
        out += " if ( ";
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1, l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += " || ";
            }
            var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
            out += " ( ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
          }
        }
        out += ") {  ";
        var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            if (it.opts._errorDataPathProperty) {
              out += "is a required property";
            } else {
              out += "should have required property \\'" + $missingProperty + "\\'";
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else { ";
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
        }
        var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
        }
        out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
        if ($ownProperties) {
          out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
        }
        out += ") {  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            if (it.opts._errorDataPathProperty) {
              out += "is a required property";
            } else {
              out += "should have required property \\'" + $missingProperty + "\\'";
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
        if ($isData) {
          out += "  }  ";
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += " if ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += " if (true) {";
  }
  return out;
};
var uniqueItems = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (($schema2 || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
    }
    out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
    var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
      out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
    } else {
      out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
      var $method = "checkDataType" + ($typeIsArray ? "s" : "");
      out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
      if ($typeIsArray) {
        out += ` if (typeof item == 'string') item = '"' + item; `;
      }
      out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
    }
    out += " } ";
    if ($isData) {
      out += "  }  ";
    }
    out += " if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
  } else {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  }
  return out;
};
var dotjs = {
  "$ref": ref,
  allOf,
  anyOf,
  "$comment": comment,
  const: _const,
  contains,
  dependencies,
  "enum": _enum,
  format,
  "if": _if,
  items,
  maximum: _limit,
  minimum: _limit,
  maxItems: _limitItems,
  minItems: _limitItems,
  maxLength: _limitLength,
  minLength: _limitLength,
  maxProperties: _limitProperties,
  minProperties: _limitProperties,
  multipleOf,
  not,
  oneOf,
  pattern,
  properties: properties$2,
  propertyNames,
  required: required$1,
  uniqueItems,
  validate: validate$1
};
var ruleModules = dotjs, toHash = util$5.toHash;
var rules$1 = function rules() {
  var RULES = [
    {
      type: "number",
      rules: [
        { "maximum": ["exclusiveMaximum"] },
        { "minimum": ["exclusiveMinimum"] },
        "multipleOf",
        "format"
      ]
    },
    {
      type: "string",
      rules: ["maxLength", "minLength", "pattern", "format"]
    },
    {
      type: "array",
      rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
    },
    {
      type: "object",
      rules: [
        "maxProperties",
        "minProperties",
        "required",
        "dependencies",
        "propertyNames",
        { "properties": ["additionalProperties", "patternProperties"] }
      ]
    },
    { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
  ];
  var ALL = ["type", "$comment"];
  var KEYWORDS2 = [
    "$schema",
    "$id",
    "id",
    "$data",
    "$async",
    "title",
    "description",
    "default",
    "definitions",
    "examples",
    "readOnly",
    "writeOnly",
    "contentMediaType",
    "contentEncoding",
    "additionalItems",
    "then",
    "else"
  ];
  var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);
  RULES.forEach(function(group2) {
    group2.rules = group2.rules.map(function(keyword2) {
      var implKeywords;
      if (typeof keyword2 == "object") {
        var key = Object.keys(keyword2)[0];
        implKeywords = keyword2[key];
        keyword2 = key;
        implKeywords.forEach(function(k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword2);
      var rule = RULES.all[keyword2] = {
        keyword: keyword2,
        code: ruleModules[keyword2],
        implements: implKeywords
      };
      return rule;
    });
    RULES.all.$comment = {
      keyword: "$comment",
      code: ruleModules.$comment
    };
    if (group2.type)
      RULES.types[group2.type] = group2;
  });
  RULES.keywords = toHash(ALL.concat(KEYWORDS2));
  RULES.custom = {};
  return RULES;
};
var KEYWORDS = [
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum",
  "maxLength",
  "minLength",
  "pattern",
  "additionalItems",
  "maxItems",
  "minItems",
  "uniqueItems",
  "maxProperties",
  "minProperties",
  "required",
  "additionalProperties",
  "enum",
  "format",
  "const"
];
var data = function(metaSchema2, keywordsJsonPointers) {
  for (var i = 0; i < keywordsJsonPointers.length; i++) {
    metaSchema2 = JSON.parse(JSON.stringify(metaSchema2));
    var segments = keywordsJsonPointers[i].split("/");
    var keywords = metaSchema2;
    var j;
    for (j = 1; j < segments.length; j++)
      keywords = keywords[segments[j]];
    for (j = 0; j < KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
          ]
        };
      }
    }
  }
  return metaSchema2;
};
var MissingRefError = error_classes.MissingRef;
var async = compileAsync;
function compileAsync(schema, meta, callback) {
  var self2 = this;
  if (typeof this._opts.loadSchema != "function")
    throw new Error("options.loadSchema should be a function");
  if (typeof meta == "function") {
    callback = meta;
    meta = void 0;
  }
  var p = loadMetaSchemaOf(schema).then(function() {
    var schemaObj = self2._addSchema(schema, void 0, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });
  if (callback) {
    p.then(
      function(v) {
        callback(null, v);
      },
      callback
    );
  }
  return p;
  function loadMetaSchemaOf(sch) {
    var $schema2 = sch.$schema;
    return $schema2 && !self2.getSchema($schema2) ? compileAsync.call(self2, { $ref: $schema2 }, true) : Promise.resolve();
  }
  function _compileAsync(schemaObj) {
    try {
      return self2._compile(schemaObj);
    } catch (e) {
      if (e instanceof MissingRefError)
        return loadMissingSchema(e);
      throw e;
    }
    function loadMissingSchema(e) {
      var ref2 = e.missingSchema;
      if (added(ref2))
        throw new Error("Schema " + ref2 + " is loaded but " + e.missingRef + " cannot be resolved");
      var schemaPromise = self2._loadingSchemas[ref2];
      if (!schemaPromise) {
        schemaPromise = self2._loadingSchemas[ref2] = self2._opts.loadSchema(ref2);
        schemaPromise.then(removePromise, removePromise);
      }
      return schemaPromise.then(function(sch) {
        if (!added(ref2)) {
          return loadMetaSchemaOf(sch).then(function() {
            if (!added(ref2))
              self2.addSchema(sch, ref2, void 0, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });
      function removePromise() {
        delete self2._loadingSchemas[ref2];
      }
      function added(ref3) {
        return self2._refs[ref3] || self2._schemas[ref3];
      }
    }
  }
}
var custom = function generate_custom(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = "keywordValidate" + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema2, it.schema, it);
    if (!$ruleValidate)
      return;
    $schemaValue = "validate.schema" + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async)
    throw new Error("async keyword in sync schema");
  if (!($inline || $macro)) {
    out += "" + $ruleErrs + " = null;";
  }
  out += "var " + $errs + " = errors;var " + $valid + ";";
  if ($isData && $rDef.$data) {
    $closingBraces += "}";
    out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
    if ($validateSchema) {
      $closingBraces += "}";
      out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += " " + $ruleValidate.validate + " ";
    } else {
      out += " " + $valid + " = " + $ruleValidate.validate + "; ";
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = "";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " " + $code;
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    out += "  " + $validateCode + ".call( ";
    if (it.opts.passContext) {
      out += "this";
    } else {
      out += "self";
    }
    if ($compile || $rDef.schema === false) {
      out += " , " + $data + " ";
    } else {
      out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
    }
    out += " , (dataPath || '')";
    if (it.errorPath != '""') {
      out += " + " + it.errorPath;
    }
    var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
    out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += " " + $valid + " = ";
      if ($asyncKeyword) {
        out += "await ";
      }
      out += "" + def_callRuleValidate + "; ";
    } else {
      if ($asyncKeyword) {
        $ruleErrs = "customErrors" + $lvl;
        out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
      } else {
        out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
      }
    }
  }
  if ($rDef.modifying) {
    out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
  }
  out += "" + $closingBraces;
  if ($rDef.valid) {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  } else {
    out += " if ( ";
    if ($rDef.valid === void 0) {
      out += " !";
      if ($macro) {
        out += "" + $nextValid;
      } else {
        out += "" + $valid;
      }
    } else {
      out += " " + !$rDef.valid + " ";
    }
    out += ") { ";
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != "full") {
          out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
          if (it.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } ";
        }
      } else {
        if ($rDef.errors === false) {
          out += " " + def_customError + " ";
        } else {
          out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
          if (it.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } } ";
        }
      }
    } else if ($macro) {
      out += "   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += " " + def_customError + " ";
      } else {
        out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
        if (it.opts.verbose) {
          out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
        }
        out += " } } else { " + def_customError + " } ";
      }
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
  }
  return out;
};
const $schema$4 = "http://json-schema.org/draft-07/schema#";
const $id$1 = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions$3 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type$1 = [
  "object",
  "boolean"
];
const properties$1 = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$13 = {
  $schema: $schema$4,
  $id: $id$1,
  title,
  definitions: definitions$3,
  type: type$1,
  properties: properties$1,
  "default": true
};
var metaSchema = require$$13;
var definition_schema = {
  $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: "object",
  dependencies: {
    schema: ["validate"],
    $data: ["validate"],
    statements: ["inline"],
    valid: { not: { required: ["macro"] } }
  },
  properties: {
    type: metaSchema.properties.type,
    schema: { type: "boolean" },
    statements: { type: "boolean" },
    dependencies: {
      type: "array",
      items: { type: "string" }
    },
    metaSchema: { type: "object" },
    modifying: { type: "boolean" },
    valid: { type: "boolean" },
    $data: { type: "boolean" },
    async: { type: "boolean" },
    errors: {
      anyOf: [
        { type: "boolean" },
        { const: "full" }
      ]
    }
  }
};
var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = custom;
var definitionSchema = definition_schema;
var keyword = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};
function addKeyword(keyword2, definition) {
  var RULES = this.RULES;
  if (RULES.keywords[keyword2])
    throw new Error("Keyword " + keyword2 + " is already defined");
  if (!IDENTIFIER.test(keyword2))
    throw new Error("Keyword " + keyword2 + " is not a valid identifier");
  if (definition) {
    this.validateKeyword(definition, true);
    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i = 0; i < dataType.length; i++)
        _addRule(keyword2, dataType[i], definition);
    } else {
      _addRule(keyword2, dataType, definition);
    }
    var metaSchema2 = definition.metaSchema;
    if (metaSchema2) {
      if (definition.$data && this._opts.$data) {
        metaSchema2 = {
          anyOf: [
            metaSchema2,
            { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema2, true);
    }
  }
  RULES.keywords[keyword2] = RULES.all[keyword2] = true;
  function _addRule(keyword3, dataType2, definition2) {
    var ruleGroup;
    for (var i2 = 0; i2 < RULES.length; i2++) {
      var rg = RULES[i2];
      if (rg.type == dataType2) {
        ruleGroup = rg;
        break;
      }
    }
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.push(ruleGroup);
    }
    var rule = {
      keyword: keyword3,
      definition: definition2,
      custom: true,
      code: customRuleCode,
      implements: definition2.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword3] = rule;
  }
  return this;
}
function getKeyword(keyword2) {
  var rule = this.RULES.custom[keyword2];
  return rule ? rule.definition : this.RULES.keywords[keyword2] || false;
}
function removeKeyword(keyword2) {
  var RULES = this.RULES;
  delete RULES.keywords[keyword2];
  delete RULES.all[keyword2];
  delete RULES.custom[keyword2];
  for (var i = 0; i < RULES.length; i++) {
    var rules3 = RULES[i].rules;
    for (var j = 0; j < rules3.length; j++) {
      if (rules3[j].keyword == keyword2) {
        rules3.splice(j, 1);
        break;
      }
    }
  }
  return this;
}
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
  if (v(definition))
    return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
  else
    return false;
}
const $schema$3 = "http://json-schema.org/draft-07/schema#";
const $id = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON Schema extension proposal)";
const type = "object";
const required = [
  "$data"
];
const properties = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties = false;
const require$$12 = {
  $schema: $schema$3,
  $id,
  description,
  type,
  required,
  properties,
  additionalProperties
};
var compileSchema = compile_1, resolve = resolve_1, Cache2 = cacheExports, SchemaObject = schema_obj, stableStringify = fastJsonStableStringify, formats = formats_1, rules2 = rules$1, $dataMetaSchema = data, util = util$5;
var ajv = Ajv;
Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile$1;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;
Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;
Ajv.prototype.compileAsync = async;
var customKeyword = keyword;
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;
var errorClasses = error_classes;
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;
var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
var META_SUPPORT_DATA = ["/properties"];
function Ajv(opts) {
  if (!(this instanceof Ajv))
    return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);
  this._cache = opts.cache || new Cache2();
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules2();
  this._getId = chooseGetId(opts);
  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == "property")
    opts._errorDataPathProperty = true;
  if (opts.serialize === void 0)
    opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);
  if (opts.formats)
    addInitialFormats(this);
  if (opts.keywords)
    addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == "object")
    this.addMetaSchema(opts.meta);
  if (opts.nullable)
    this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
  addInitialSchemas(this);
}
function validate(schemaKeyRef, data2) {
  var v;
  if (typeof schemaKeyRef == "string") {
    v = this.getSchema(schemaKeyRef);
    if (!v)
      throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }
  var valid = v(data2);
  if (v.$async !== true)
    this.errors = v.errors;
  return valid;
}
function compile$1(schema, _meta) {
  var schemaObj = this._addSchema(schema, void 0, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++)
      this.addSchema(schema[i], void 0, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== void 0 && typeof id != "string")
    throw new Error("schema id must be string");
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}
function validateSchema(schema, throwOrLogError) {
  var $schema2 = schema.$schema;
  if ($schema2 !== void 0 && typeof $schema2 != "string")
    throw new Error("$schema must be a string");
  $schema2 = $schema2 || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema2) {
    this.logger.warn("meta-schema not available");
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema2, schema);
  if (!valid && throwOrLogError) {
    var message = "schema is invalid: " + this.errorsText();
    if (this._opts.validateSchema == "log")
      this.logger.error(message);
    else
      throw new Error(message);
  }
  return valid;
}
function defaultMeta(self2) {
  var meta = self2._opts.meta;
  self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
  return self2._opts.defaultMeta;
}
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case "object":
      return schemaObj.validate || this._compile(schemaObj);
    case "string":
      return this.getSchema(schemaObj);
    case "undefined":
      return _getSchemaFragment(this, keyRef);
  }
}
function _getSchemaFragment(self2, ref2) {
  var res = resolve.schema.call(self2, { schema: {} }, ref2);
  if (res) {
    var schema = res.schema, root = res.root, baseId = res.baseId;
    var v = compileSchema.call(self2, schema, root, void 0, baseId);
    self2._fragments[ref2] = new SchemaObject({
      ref: ref2,
      fragment: true,
      schema,
      root,
      baseId,
      validate: v
    });
    return v;
  }
}
function _getSchemaObj(self2, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
}
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case "undefined":
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case "string":
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj)
        this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case "object":
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}
function _removeAllSchemas(self2, schemas, regex2) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex2 || regex2.test(keyRef))) {
      self2._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != "object" && typeof schema != "boolean")
    throw new Error("schema should be object or boolean");
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached)
    return cached;
  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema)
    checkUnique(this, id);
  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);
  var localRefs = resolve.ids.call(this, schema);
  var schemaObj = new SchemaObject({
    id,
    schema,
    localRefs,
    cacheKey,
    meta
  });
  if (id[0] != "#" && shouldAddSchema)
    this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);
  if (willValidate && recursiveMeta)
    this.validateSchema(schema, true);
  return schemaObj;
}
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;
  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }
  var v;
  try {
    v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
  } catch (e) {
    delete schemaObj.validate;
    throw e;
  } finally {
    schemaObj.compiling = false;
    if (schemaObj.meta)
      this._opts = currentOpts;
  }
  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;
  function callValidate() {
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}
function chooseGetId(opts) {
  switch (opts.schemaId) {
    case "auto":
      return _get$IdOrId;
    case "id":
      return _getId;
    default:
      return _get$Id;
  }
}
function _getId(schema) {
  if (schema.$id)
    this.logger.warn("schema $id ignored", schema.$id);
  return schema.id;
}
function _get$Id(schema) {
  if (schema.id)
    this.logger.warn("schema id ignored", schema.id);
  return schema.$id;
}
function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error("schema $id is different from id");
  return schema.$id || schema.id;
}
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors)
    return "No errors";
  options = options || {};
  var separator = options.separator === void 0 ? ", " : options.separator;
  var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
  var text = "";
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    if (e)
      text += dataVar + e.dataPath + " " + e.message + separator;
  }
  return text.slice(0, -separator.length);
}
function addFormat(name2, format2) {
  if (typeof format2 == "string")
    format2 = new RegExp(format2);
  this._formats[name2] = format2;
  return this;
}
function addDefaultMetaSchema(self2) {
  var $dataSchema;
  if (self2._opts.$data) {
    $dataSchema = require$$12;
    self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self2._opts.meta === false)
    return;
  var metaSchema2 = require$$13;
  if (self2._opts.$data)
    metaSchema2 = $dataMetaSchema(metaSchema2, META_SUPPORT_DATA);
  self2.addMetaSchema(metaSchema2, META_SCHEMA_ID, true);
  self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
}
function addInitialSchemas(self2) {
  var optsSchemas = self2._opts.schemas;
  if (!optsSchemas)
    return;
  if (Array.isArray(optsSchemas))
    self2.addSchema(optsSchemas);
  else
    for (var key in optsSchemas)
      self2.addSchema(optsSchemas[key], key);
}
function addInitialFormats(self2) {
  for (var name2 in self2._opts.formats) {
    var format2 = self2._opts.formats[name2];
    self2.addFormat(name2, format2);
  }
}
function addInitialKeywords(self2) {
  for (var name2 in self2._opts.keywords) {
    var keyword2 = self2._opts.keywords[name2];
    self2.addKeyword(name2, keyword2);
  }
}
function checkUnique(self2, id) {
  if (self2._schemas[id] || self2._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}
function getMetaSchemaOptions(self2) {
  var metaOpts = util.copy(self2._opts);
  for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}
function setLogger(self2) {
  var logger = self2._opts.logger;
  if (logger === false) {
    self2.logger = { log: noop$1, warn: noop$1, error: noop$1 };
  } else {
    if (logger === void 0)
      logger = console;
    if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
      throw new Error("logger must implement log, warn and error methods");
    self2.logger = logger;
  }
}
function noop$1() {
}
const Ajv$1 = /* @__PURE__ */ getDefaultExportFromCjs(ajv);
const $ref$2 = "#/definitions/GoslingSpec";
const $schema$2 = "http://json-schema.org/draft-07/schema#";
const definitions$2 = {
  Aggregate: {
    "enum": [
      "max",
      "min",
      "mean",
      "bin",
      "count"
    ],
    type: "string"
  },
  Assembly: {
    anyOf: [
      {
        "const": "hg38",
        type: "string"
      },
      {
        "const": "hg19",
        type: "string"
      },
      {
        "const": "hg18",
        type: "string"
      },
      {
        "const": "hg17",
        type: "string"
      },
      {
        "const": "hg16",
        type: "string"
      },
      {
        "const": "mm10",
        type: "string"
      },
      {
        "const": "mm9",
        type: "string"
      },
      {
        "const": "unknown",
        type: "string"
      },
      {
        $ref: "#/definitions/ChromSizes"
      }
    ]
  },
  AxisPosition: {
    "enum": [
      "none",
      "top",
      "bottom",
      "left",
      "right"
    ],
    type: "string"
  },
  BamData: {
    additionalProperties: false,
    description: "Binary Alignment Map (BAM) is the comprehensive raw data of genome sequencing; it consists of the lossless, compressed binary representation of the Sequence Alignment Map-files.",
    properties: {
      extractJunction: {
        description: "Determine whether to extract exon-to-exon junctions. __Default__: `false`",
        type: "boolean"
      },
      indexUrl: {
        description: "URL link to the index file of the BAM file",
        type: "string"
      },
      junctionMinCoverage: {
        description: "Determine the threshold of coverage when extracting exon-to-exon junctions. __Default__: `1`",
        type: "number"
      },
      loadMates: {
        description: "Load mates that are located in the same chromosome. __Default__: `false`",
        type: "boolean"
      },
      maxInsertSize: {
        description: "Determines the threshold of insert sizes for determining the structural variants. __Default__: `5000`",
        type: "number"
      },
      type: {
        "const": "bam",
        type: "string"
      },
      url: {
        description: "URL link to the BAM data file",
        type: "string"
      }
    },
    required: [
      "type",
      "url",
      "indexUrl"
    ],
    type: "object"
  },
  BedData: {
    additionalProperties: false,
    description: "BED file format",
    properties: {
      customFields: {
        description: "An array of strings, where each string is the name of a non-standard field in the BED file. If there are `n` custom fields, we assume that the last `n` columns of the BED file correspond to the custom fields.",
        items: {
          type: "string"
        },
        type: "array"
      },
      indexUrl: {
        description: "Specify the URL address of the data file index.",
        type: "string"
      },
      sampleLength: {
        description: "Specify the number of rows loaded from the URL.\n\n__Default:__ `1000`",
        type: "number"
      },
      type: {
        "const": "bed",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      }
    },
    required: [
      "type",
      "url",
      "indexUrl"
    ],
    type: "object"
  },
  BeddbData: {
    additionalProperties: false,
    description: "Regular BED or similar files can be pre-aggregated for the scalable data exploration. Find our more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#bed-files).",
    properties: {
      exonIntervalFields: {
        description: "experimental",
        items: [
          {
            additionalProperties: false,
            properties: {
              index: {
                type: "number"
              },
              name: {
                type: "string"
              }
            },
            required: [
              "index",
              "name"
            ],
            type: "object"
          },
          {
            additionalProperties: false,
            properties: {
              index: {
                type: "number"
              },
              name: {
                type: "string"
              }
            },
            required: [
              "index",
              "name"
            ],
            type: "object"
          }
        ],
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      genomicFields: {
        description: "Specify the name of genomic data fields.",
        items: {
          additionalProperties: false,
          properties: {
            index: {
              type: "number"
            },
            name: {
              type: "string"
            }
          },
          required: [
            "index",
            "name"
          ],
          type: "object"
        },
        type: "array"
      },
      type: {
        "const": "beddb",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      valueFields: {
        description: "Specify the column indexes, field names, and field types.",
        items: {
          additionalProperties: false,
          properties: {
            index: {
              type: "number"
            },
            name: {
              type: "string"
            },
            type: {
              "enum": [
                "nominal",
                "quantitative"
              ],
              type: "string"
            }
          },
          required: [
            "index",
            "name",
            "type"
          ],
          type: "object"
        },
        type: "array"
      }
    },
    required: [
      "type",
      "url",
      "genomicFields"
    ],
    type: "object"
  },
  BigWigData: {
    additionalProperties: false,
    properties: {
      aggregation: {
        $ref: "#/definitions/BinAggregate",
        description: 'Determine aggregation function to apply within bins. __Default__: `"mean"`'
      },
      binSize: {
        description: "Binning the genomic interval in tiles (unit size: 256).",
        type: "number"
      },
      column: {
        description: 'Assign a field name of the middle position of genomic intervals. __Default__: `"position"`',
        type: "string"
      },
      end: {
        description: 'Assign a field name of the end position of genomic intervals. __Default__: `"end"`',
        type: "string"
      },
      start: {
        description: 'Assign a field name of the start position of genomic intervals. __Default__: `"start"`',
        type: "string"
      },
      type: {
        "const": "bigwig",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      value: {
        description: 'Assign a field name of quantitative values. __Default__: `"value"`',
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  BinAggregate: {
    "enum": [
      "mean",
      "sum"
    ],
    type: "string"
  },
  Channel: {
    anyOf: [
      {
        $ref: "#/definitions/ChannelDeep"
      },
      {
        $ref: "#/definitions/ChannelValue"
      }
    ]
  },
  ChannelDeep: {
    anyOf: [
      {
        $ref: "#/definitions/X"
      },
      {
        $ref: "#/definitions/Y"
      },
      {
        $ref: "#/definitions/Row"
      },
      {
        $ref: "#/definitions/Color"
      },
      {
        $ref: "#/definitions/Size"
      },
      {
        $ref: "#/definitions/Stroke"
      },
      {
        $ref: "#/definitions/StrokeWidth"
      },
      {
        $ref: "#/definitions/Opacity"
      },
      {
        $ref: "#/definitions/Text"
      }
    ]
  },
  ChannelValue: {
    additionalProperties: false,
    properties: {
      value: {
        description: "Assign a constant value for a visual channel.",
        type: [
          "number",
          "string"
        ]
      }
    },
    required: [
      "value"
    ],
    type: "object"
  },
  ChromSizes: {
    description: 'Custom chromosome sizes, e.g., [["foo", 1000], ["bar", 300], ["baz", 240]]',
    items: {
      items: [
        {
          type: "string"
        },
        {
          type: "number"
        }
      ],
      maxItems: 2,
      minItems: 2,
      type: "array"
    },
    type: "array"
  },
  Color: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      range: {
        $ref: "#/definitions/Range",
        description: "Determine the colors that should be bound to data value. Default properties are determined considering the field type."
      },
      scale: {
        "enum": [
          "linear",
          "log"
        ],
        type: "string"
      },
      scaleOffset: {
        description: "Whether to use offset of the domain proportionally. This is bound to brushes on the color legend. __Default__: `[0, 1]`",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      title: {
        description: "Title of the legend. __Default__: `undefined`",
        type: "string"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  CoverageTransform: {
    additionalProperties: false,
    description: "Aggregate rows and calculate coverage",
    properties: {
      endField: {
        type: "string"
      },
      groupField: {
        description: "The name of a nominal field to group rows by in prior to piling-up",
        type: "string"
      },
      newField: {
        type: "string"
      },
      startField: {
        type: "string"
      },
      type: {
        "const": "coverage",
        type: "string"
      }
    },
    required: [
      "type",
      "startField",
      "endField"
    ],
    type: "object"
  },
  CsvData: {
    additionalProperties: false,
    description: 'Any small enough tabular data files, such as tsv, csv, BED, BEDPE, and GFF, can be loaded using "csv" data specification.',
    properties: {
      chromosomeField: {
        description: "Specify the name of chromosome data fields.",
        type: "string"
      },
      chromosomePrefix: {
        description: 'Specify the chromosome prefix if chromosomes are denoted using a prefix besides "chr" or a number',
        type: "string"
      },
      genomicFields: {
        description: "Specify the name of genomic data fields.",
        items: {
          type: "string"
        },
        type: "array"
      },
      genomicFieldsToConvert: {
        description: "experimental",
        items: {
          additionalProperties: false,
          properties: {
            chromosomeField: {
              type: "string"
            },
            genomicFields: {
              items: {
                type: "string"
              },
              type: "array"
            }
          },
          required: [
            "chromosomeField",
            "genomicFields"
          ],
          type: "object"
        },
        type: "array"
      },
      headerNames: {
        description: "Specify the names of data fields if a CSV file does not contain a header.",
        items: {
          type: "string"
        },
        type: "array"
      },
      longToWideId: {
        description: "experimental",
        type: "string"
      },
      sampleLength: {
        description: "Specify the number of rows loaded from the URL.\n\n__Default:__ `1000`",
        type: "number"
      },
      separator: {
        description: "Specify file separator, __Default:__ ','",
        type: "string"
      },
      type: {
        "const": "csv",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  DataDeep: {
    anyOf: [
      {
        $ref: "#/definitions/JsonData"
      },
      {
        $ref: "#/definitions/CsvData"
      },
      {
        $ref: "#/definitions/BedData"
      },
      {
        $ref: "#/definitions/BigWigData"
      },
      {
        $ref: "#/definitions/MultivecData"
      },
      {
        $ref: "#/definitions/BeddbData"
      },
      {
        $ref: "#/definitions/VectorData"
      },
      {
        $ref: "#/definitions/MatrixData"
      },
      {
        $ref: "#/definitions/BamData"
      },
      {
        $ref: "#/definitions/VcfData"
      },
      {
        $ref: "#/definitions/GffData"
      }
    ]
  },
  DataTrack: {
    additionalProperties: false,
    description: "Partial specification of `BasicSingleTrack` to use default visual encoding predefined by data type.",
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "data"
    ],
    type: "object"
  },
  DataTransform: {
    anyOf: [
      {
        $ref: "#/definitions/FilterTransform"
      },
      {
        $ref: "#/definitions/StrConcatTransform"
      },
      {
        $ref: "#/definitions/StrReplaceTransform"
      },
      {
        $ref: "#/definitions/LogTransform"
      },
      {
        $ref: "#/definitions/DisplaceTransform"
      },
      {
        $ref: "#/definitions/ExonSplitTransform"
      },
      {
        $ref: "#/definitions/GenomicLengthTransform"
      },
      {
        $ref: "#/definitions/SvTypeTransform"
      },
      {
        $ref: "#/definitions/CoverageTransform"
      },
      {
        $ref: "#/definitions/JsonParseTransform"
      }
    ]
  },
  Datum: {
    additionalProperties: {
      type: [
        "number",
        "string"
      ]
    },
    description: "Values in the form of JSON.",
    type: "object"
  },
  DisplaceTransform: {
    additionalProperties: false,
    properties: {
      boundingBox: {
        additionalProperties: false,
        properties: {
          endField: {
            description: "The name of a quantitative field that represents the end position.",
            type: "string"
          },
          groupField: {
            description: "The name of a nominal field to group rows by in prior to piling-up.",
            type: "string"
          },
          isPaddingBP: {
            description: "Whether to consider `padding` as the bp length.",
            type: "boolean"
          },
          padding: {
            description: "The padding around visual lements. Either px or bp",
            type: "number"
          },
          startField: {
            description: "The name of a quantitative field that represents the start position.",
            type: "string"
          }
        },
        required: [
          "startField",
          "endField"
        ],
        type: "object"
      },
      maxRows: {
        description: "Specify maximum rows to be generated (default has no limit).",
        type: "number"
      },
      method: {
        $ref: "#/definitions/DisplacementType",
        description: "A string that specifies the type of displacement."
      },
      newField: {
        type: "string"
      },
      type: {
        "const": "displace",
        type: "string"
      }
    },
    required: [
      "type",
      "boundingBox",
      "method",
      "newField"
    ],
    type: "object"
  },
  Displacement: {
    additionalProperties: false,
    properties: {
      padding: {
        type: "number"
      },
      type: {
        $ref: "#/definitions/DisplacementType"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  DisplacementType: {
    "enum": [
      "pile",
      "spread"
    ],
    type: "string"
  },
  DomainChr: {
    additionalProperties: false,
    properties: {
      chromosome: {
        type: "string"
      }
    },
    required: [
      "chromosome"
    ],
    type: "object"
  },
  DomainChrInterval: {
    additionalProperties: false,
    properties: {
      chromosome: {
        description: "If specified, only showing a certain interval in a chromosome.",
        type: "string"
      },
      interval: {
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      }
    },
    required: [
      "chromosome",
      "interval"
    ],
    type: "object"
  },
  DomainInterval: {
    additionalProperties: false,
    properties: {
      interval: {
        description: "Show a certain interval within entire chromosome",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      }
    },
    required: [
      "interval"
    ],
    type: "object"
  },
  DummyTrack: {
    additionalProperties: false,
    description: "A placeholder track. In contrast to other tracks, this track does not display any data. Instead it provides empty space for third party tools to display their data on top of.",
    properties: {
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      assembly: {
        "const": "unknown",
        description: "No assemblies can be associated with a dummy track",
        type: "string"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      layout: {
        "const": "linear",
        description: "Only linear layout are supported at this time",
        type: "string"
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      "static": {
        "const": true,
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      style: {
        $ref: "#/definitions/DummyTrackStyle",
        description: "Defines how the track is styled"
      },
      title: {
        description: "Text that gets shown on the DummyTrack",
        type: "string"
      },
      type: {
        "const": "dummy-track",
        description: "Used to specify the dummy track",
        type: "string"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      zoomLimits: {
        description: "Unused property for DummyTrack",
        items: {
          type: "null"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  DummyTrackStyle: {
    additionalProperties: false,
    properties: {
      background: {
        description: "Background color of the track",
        type: "string"
      },
      outline: {
        description: "Color of the outline of the track",
        type: "string"
      },
      textFontSize: {
        description: "Specify the font size of the title",
        type: "number"
      },
      textFontWeight: {
        description: "Specify the font weight of the title.",
        "enum": [
          "bold",
          "normal"
        ],
        type: "string"
      },
      textStroke: {
        description: "Specify the stroke color of title.",
        type: "string"
      },
      textStrokeWidth: {
        description: "Specify the stroke width of the title.",
        type: "number"
      }
    },
    type: "object"
  },
  EventStyle: {
    additionalProperties: false,
    description: "The styles defined here will be applied to the target marks of mouse events, such as a point mark after the user clicks on it.",
    properties: {
      arrange: {
        description: "Show event effects behind or in front of marks.",
        "enum": [
          "behind",
          "front"
        ],
        type: "string"
      },
      color: {
        description: "color of the marks when mouse events are triggered",
        type: "string"
      },
      opacity: {
        description: "opacity of the marks when mouse events are triggered",
        type: "number"
      },
      stroke: {
        description: "stroke color of the marks when mouse events are triggered",
        type: "string"
      },
      strokeOpacity: {
        type: "number"
      },
      strokeWidth: {
        description: "stroke width of the marks when mouse events are triggered",
        type: "number"
      }
    },
    type: "object"
  },
  ExonSplitTransform: {
    additionalProperties: false,
    properties: {
      fields: {
        items: {
          additionalProperties: false,
          properties: {
            chrField: {
              type: "string"
            },
            field: {
              type: "string"
            },
            newField: {
              type: "string"
            },
            type: {
              $ref: "#/definitions/FieldType"
            }
          },
          required: [
            "field",
            "type",
            "newField",
            "chrField"
          ],
          type: "object"
        },
        type: "array"
      },
      flag: {
        additionalProperties: false,
        properties: {
          field: {
            type: "string"
          },
          value: {
            type: [
              "number",
              "string"
            ]
          }
        },
        required: [
          "field",
          "value"
        ],
        type: "object"
      },
      separator: {
        type: "string"
      },
      type: {
        "const": "exonSplit",
        type: "string"
      }
    },
    required: [
      "type",
      "separator",
      "flag",
      "fields"
    ],
    type: "object"
  },
  FieldType: {
    "enum": [
      "genomic",
      "nominal",
      "quantitative"
    ],
    type: "string"
  },
  FilterTransform: {
    anyOf: [
      {
        $ref: "#/definitions/OneOfFilter"
      },
      {
        $ref: "#/definitions/RangeFilter"
      },
      {
        $ref: "#/definitions/IncludeFilter"
      }
    ]
  },
  GenomicDomain: {
    anyOf: [
      {
        $ref: "#/definitions/DomainInterval"
      },
      {
        $ref: "#/definitions/DomainChrInterval"
      },
      {
        $ref: "#/definitions/DomainChr"
      }
    ]
  },
  GenomicLengthTransform: {
    additionalProperties: false,
    description: "Calculate genomic length using two genomic fields",
    properties: {
      endField: {
        type: "string"
      },
      newField: {
        type: "string"
      },
      startField: {
        type: "string"
      },
      type: {
        "const": "genomicLength",
        type: "string"
      }
    },
    required: [
      "type",
      "startField",
      "endField",
      "newField"
    ],
    type: "object"
  },
  GffData: {
    additionalProperties: false,
    description: "Generic Feature Format Version 3 (GFF3) format data. It parses files that follow the [GFF3 specification](https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md).",
    properties: {
      attributesToFields: {
        description: 'Specifies which attributes to include as a fields. GFF files have an "attributes" column which contains a list of attributes which are each tag-value pairs (`tag=value`). This option allows for specific attributes to be accessible as a field. For example, if you have an attribute called "gene_name" and you want label features on your track using those values, you can use this option so that you can use `"field": "gene_name"` in the schema.\n\nIf there is a single `value` corresponding to the `tag`, Gosling will parse that value as a string. If there are multiple `value`s corresponding to a `tag`, Gosling will parse it as a comma-separated list string. If a feature does not have a particular attribute, then the attribute value will be set to the `defaultValue`.',
        items: {
          additionalProperties: false,
          properties: {
            attribute: {
              type: "string"
            },
            defaultValue: {
              type: "string"
            }
          },
          required: [
            "attribute",
            "defaultValue"
          ],
          type: "object"
        },
        type: "array"
      },
      indexUrl: {
        description: "URL link to the tabix index file",
        type: "string"
      },
      sampleLength: {
        description: "The maximum number of samples to be shown on the track. Samples are uniformly randomly selected so that this threshold is not exceeded. __Default:__ `1000`",
        type: "number"
      },
      type: {
        "const": "gff",
        type: "string"
      },
      url: {
        description: "URL link to the GFF file",
        type: "string"
      }
    },
    required: [
      "type",
      "url",
      "indexUrl"
    ],
    type: "object"
  },
  GoslingSpec: {
    anyOf: [
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "overlay",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          description: {
            type: "string"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              $ref: "#/definitions/PartialTrack"
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "alignment",
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "stack",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          description: {
            type: "string"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              anyOf: [
                {
                  $ref: "#/definitions/PartialTrack"
                },
                {
                  $ref: "#/definitions/OverlaidTracks"
                }
              ]
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          description: {
            type: "string"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          title: {
            type: "string"
          },
          tracks: {
            items: {
              $ref: "#/definitions/Track"
            },
            type: "array"
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          arrangement: {
            description: "Specify how multiple views are arranged.",
            "enum": [
              "parallel",
              "serial",
              "horizontal",
              "vertical"
            ],
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          description: {
            type: "string"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    arrangement: {
                      description: "Specify how multiple views are arranged.",
                      "enum": [
                        "parallel",
                        "serial",
                        "horizontal",
                        "vertical"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    views: {
                      description: "An array of view specifications",
                      items: {
                        anyOf: [
                          {
                            $ref: "#/definitions/SingleView"
                          },
                          {
                            $ref: "#/definitions/MultipleViews"
                          }
                        ]
                      },
                      type: "array"
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          title: {
            type: "string"
          },
          views: {
            description: "An array of view specifications",
            items: {
              anyOf: [
                {
                  $ref: "#/definitions/SingleView"
                },
                {
                  $ref: "#/definitions/MultipleViews"
                }
              ]
            },
            type: "array"
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "views"
        ],
        type: "object"
      }
    ]
  },
  IncludeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      include: {
        description: "Check whether the value includes a substring.",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "include",
      "type"
    ],
    type: "object"
  },
  JsonData: {
    additionalProperties: false,
    description: "The JSON data format allows users to include data directly in the Gosling's JSON specification.",
    properties: {
      chromosomeField: {
        description: "Specify the name of chromosome data fields.",
        type: "string"
      },
      genomicFields: {
        description: "Specify the name of genomic data fields.",
        items: {
          type: "string"
        },
        type: "array"
      },
      genomicFieldsToConvert: {
        description: "experimental",
        items: {
          additionalProperties: false,
          properties: {
            chromosomeField: {
              type: "string"
            },
            genomicFields: {
              items: {
                type: "string"
              },
              type: "array"
            }
          },
          required: [
            "chromosomeField",
            "genomicFields"
          ],
          type: "object"
        },
        type: "array"
      },
      sampleLength: {
        description: "Specify the number of rows loaded from the URL.\n\n__Default:__ `1000`",
        type: "number"
      },
      sampleType: {
        description: "Specify the way of sampling from the data if the number of rows to show exceeds `sampleLength`.\n\n__Default:__ `random`",
        "enum": [
          "first",
          "random"
        ],
        type: "string"
      },
      type: {
        "const": "json",
        description: "Define data type.",
        type: "string"
      },
      values: {
        description: "Values in the form of JSON.",
        items: {
          $ref: "#/definitions/Datum"
        },
        type: "array"
      }
    },
    required: [
      "type",
      "values"
    ],
    type: "object"
  },
  JsonParseTransform: {
    additionalProperties: false,
    description: "Parse JSON Object Array and append vertically",
    properties: {
      baseGenomicField: {
        description: "Base genomic position when parsing relative position.",
        type: "string"
      },
      field: {
        description: "The field that contains the JSON object array.",
        type: "string"
      },
      genomicField: {
        description: "Relative genomic position to parse.",
        type: "string"
      },
      genomicLengthField: {
        description: "Length of genomic interval.",
        type: "string"
      },
      type: {
        "const": "subjson",
        type: "string"
      }
    },
    required: [
      "type",
      "field",
      "baseGenomicField",
      "genomicField",
      "genomicLengthField"
    ],
    type: "object"
  },
  Layout: {
    "enum": [
      "linear",
      "circular"
    ],
    type: "string"
  },
  LogBase: {
    anyOf: [
      {
        type: "number"
      },
      {
        "const": "e",
        type: "string"
      }
    ]
  },
  LogTransform: {
    additionalProperties: false,
    properties: {
      base: {
        $ref: "#/definitions/LogBase",
        description: "If not specified, 10 is used."
      },
      field: {
        type: "string"
      },
      newField: {
        description: "If specified, store transformed values in a new field.",
        type: "string"
      },
      type: {
        "const": "log",
        type: "string"
      }
    },
    required: [
      "type",
      "field"
    ],
    type: "object"
  },
  LogicalOperation: {
    "enum": [
      "less-than",
      "lt",
      "LT",
      "greater-than",
      "gt",
      "GT",
      "less-than-or-equal-to",
      "ltet",
      "LTET",
      "greater-than-or-equal-to",
      "gtet",
      "GTET"
    ],
    type: "string"
  },
  Mark: {
    "enum": [
      "point",
      "line",
      "area",
      "bar",
      "rect",
      "text",
      "withinLink",
      "betweenLink",
      "rule",
      "triangleLeft",
      "triangleRight",
      "triangleBottom",
      "brush",
      "header"
    ],
    type: "string"
  },
  MatrixData: {
    additionalProperties: false,
    properties: {
      binSize: {
        description: "Determine the number of nearby cells to aggregate. __Default__: `1`",
        type: "number"
      },
      column: {
        description: "The name of the first genomic field. __Default__: `x`",
        type: "string"
      },
      row: {
        description: "The name of the first genomic field. __Default__: `y`",
        type: "string"
      },
      type: {
        "const": "matrix",
        type: "string"
      },
      url: {
        description: "URL link to the matrix data file",
        type: "string"
      },
      value: {
        description: "The name of the value field. __Default__: `value`",
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  MouseEventsDeep: {
    additionalProperties: false,
    description: "Options for determining mouse events in detail, e.g., turning on specific events only",
    properties: {
      click: {
        description: "Whether to enable click events.",
        type: "boolean"
      },
      enableMouseOverOnMultipleMarks: {
        description: "Determine whether all marks underneath the mouse point should be affected by mouse over. __Default__: `false`",
        type: "boolean"
      },
      groupMarksByField: {
        description: "Group marks using keys in a data field. This affects how a set of marks are highlighted/selected by interaction. __Default__: `undefined`",
        type: "string"
      },
      mouseOver: {
        description: "Whether to enable mouseover events.",
        type: "boolean"
      },
      rangeSelect: {
        description: "Whether to send range selection events.",
        type: "boolean"
      }
    },
    type: "object"
  },
  MultipleViews: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      arrangement: {
        description: "Specify how multiple views are arranged.",
        "enum": [
          "parallel",
          "serial",
          "horizontal",
          "vertical"
        ],
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      id: {
        description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
        type: "string"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      views: {
        description: "An array of view specifications",
        items: {
          anyOf: [
            {
              $ref: "#/definitions/SingleView"
            },
            {
              $ref: "#/definitions/MultipleViews"
            }
          ]
        },
        type: "array"
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "views"
    ],
    type: "object"
  },
  MultivecData: {
    additionalProperties: false,
    description: 'Two-dimensional quantitative values, one axis for genomic coordinate and the other for different samples, can be converted into HiGlass\' `"multivec"` data. For example, multiple BigWig files can be converted into a single multivec file. You can also convert sequence data (FASTA) into this format where rows will be different nucleotide bases (e.g., A, T, G, C) and quantitative values represent the frequency. Find out more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#multivec-files).',
    properties: {
      aggregation: {
        $ref: "#/definitions/BinAggregate",
        description: 'Determine aggregation function to apply within bins. __Default__: `"mean"`'
      },
      binSize: {
        description: "Binning the genomic interval in tiles (unit size: 256).",
        type: "number"
      },
      categories: {
        description: "assign names of individual samples.",
        items: {
          type: "string"
        },
        type: "array"
      },
      column: {
        description: 'Assign a field name of the middle position of genomic intervals. __Default__: `"position"`',
        type: "string"
      },
      end: {
        description: 'Assign a field name of the end position of genomic intervals. __Default__: `"end"`',
        type: "string"
      },
      row: {
        description: 'Assign a field name of samples. __Default__: `"category"`',
        type: "string"
      },
      start: {
        description: 'Assign a field name of the start position of genomic intervals. __Default__: `"start"`',
        type: "string"
      },
      type: {
        "const": "multivec",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      value: {
        description: 'Assign a field name of quantitative values. __Default__: `"value"`',
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  OneOfFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      oneOf: {
        description: "Check whether the value is an element in the provided list.",
        items: {
          type: [
            "string",
            "number",
            "null"
          ]
        },
        type: "array"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "oneOf",
      "type"
    ],
    type: "object"
  },
  Opacity: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Ranges of visual channel values"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Orientation: {
    "enum": [
      "horizontal",
      "vertical"
    ],
    type: "string"
  },
  OverlaidTrack: {
    additionalProperties: false,
    description: "Superposing multiple tracks.",
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _overlay: {
        items: {
          additionalProperties: false,
          properties: {
            _assignedHeight: {
              type: "number"
            },
            _assignedWidth: {
              description: "Internal: Used for responsive spec",
              type: "number"
            },
            _invalidTrack: {
              description: "internal",
              type: "boolean"
            },
            _renderingId: {
              description: "internal",
              type: "string"
            },
            assembly: {
              $ref: "#/definitions/Assembly",
              description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
            },
            baselineY: {
              type: "number"
            },
            centerRadius: {
              description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
              type: "number"
            },
            color: {
              anyOf: [
                {
                  $ref: "#/definitions/Color"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            data: {
              $ref: "#/definitions/DataDeep"
            },
            dataTransform: {
              items: {
                $ref: "#/definitions/DataTransform"
              },
              type: "array"
            },
            displacement: {
              $ref: "#/definitions/Displacement"
            },
            endAngle: {
              description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            experimental: {
              additionalProperties: false,
              properties: {
                mouseEvents: {
                  anyOf: [
                    {
                      type: "boolean"
                    },
                    {
                      $ref: "#/definitions/MouseEventsDeep"
                    }
                  ]
                },
                performanceMode: {
                  "default": false,
                  description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                  type: "boolean"
                }
              },
              type: "object"
            },
            flipY: {
              type: "boolean"
            },
            id: {
              description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
              type: "string"
            },
            innerRadius: {
              description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
              type: "number"
            },
            linkingId: {
              description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
              type: "string"
            },
            mark: {
              $ref: "#/definitions/Mark"
            },
            opacity: {
              anyOf: [
                {
                  $ref: "#/definitions/Opacity"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            orientation: {
              $ref: "#/definitions/Orientation",
              description: "Specify the orientation."
            },
            outerRadius: {
              description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
              type: "number"
            },
            overlayOnPreviousTrack: {
              type: "boolean"
            },
            overrideTemplate: {
              type: "boolean"
            },
            prerelease: {
              additionalProperties: false,
              description: "internal",
              type: "object"
            },
            row: {
              anyOf: [
                {
                  $ref: "#/definitions/Row"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            size: {
              anyOf: [
                {
                  $ref: "#/definitions/Size"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            spacing: {
              description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
              type: "number"
            },
            startAngle: {
              description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            "static": {
              description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
              type: "boolean"
            },
            stretch: {
              type: "boolean"
            },
            stroke: {
              anyOf: [
                {
                  $ref: "#/definitions/Stroke"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            strokeWidth: {
              anyOf: [
                {
                  $ref: "#/definitions/StrokeWidth"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            style: {
              $ref: "#/definitions/Style",
              description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
            },
            text: {
              anyOf: [
                {
                  $ref: "#/definitions/Text"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            tooltip: {
              items: {
                $ref: "#/definitions/Tooltip"
              },
              type: "array"
            },
            visibility: {
              items: {
                $ref: "#/definitions/VisibilityCondition"
              },
              type: "array"
            },
            x: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1e: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            xAxis: {
              $ref: "#/definitions/AxisPosition",
              description: "not supported"
            },
            xDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic x-axis"
            },
            xOffset: {
              description: "Specify the x offset of views in the unit of pixels",
              type: "number"
            },
            xe: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1e: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            yDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic y-axis"
            },
            yOffset: {
              description: "Specify the y offset of views in the unit of pixels",
              type: "number"
            },
            ye: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            zoomLimits: {
              $ref: "#/definitions/ZoomLimits"
            }
          },
          type: "object"
        },
        type: "array"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "_overlay"
    ],
    type: "object"
  },
  OverlaidTracks: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      alignment: {
        "const": "overlay",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      tracks: {
        items: {
          $ref: "#/definitions/PartialTrack"
        },
        type: "array"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "alignment",
      "tracks"
    ],
    type: "object"
  },
  PartialTrack: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _overlay: {
        items: {
          additionalProperties: false,
          properties: {
            _assignedHeight: {
              type: "number"
            },
            _assignedWidth: {
              description: "Internal: Used for responsive spec",
              type: "number"
            },
            _invalidTrack: {
              description: "internal",
              type: "boolean"
            },
            _renderingId: {
              description: "internal",
              type: "string"
            },
            assembly: {
              $ref: "#/definitions/Assembly",
              description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
            },
            baselineY: {
              type: "number"
            },
            centerRadius: {
              description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
              type: "number"
            },
            color: {
              anyOf: [
                {
                  $ref: "#/definitions/Color"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            data: {
              $ref: "#/definitions/DataDeep"
            },
            dataTransform: {
              items: {
                $ref: "#/definitions/DataTransform"
              },
              type: "array"
            },
            displacement: {
              $ref: "#/definitions/Displacement"
            },
            endAngle: {
              description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            experimental: {
              additionalProperties: false,
              properties: {
                mouseEvents: {
                  anyOf: [
                    {
                      type: "boolean"
                    },
                    {
                      $ref: "#/definitions/MouseEventsDeep"
                    }
                  ]
                },
                performanceMode: {
                  "default": false,
                  description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                  type: "boolean"
                }
              },
              type: "object"
            },
            flipY: {
              type: "boolean"
            },
            id: {
              description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
              type: "string"
            },
            innerRadius: {
              description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
              type: "number"
            },
            linkingId: {
              description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
              type: "string"
            },
            mark: {
              $ref: "#/definitions/Mark"
            },
            opacity: {
              anyOf: [
                {
                  $ref: "#/definitions/Opacity"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            orientation: {
              $ref: "#/definitions/Orientation",
              description: "Specify the orientation."
            },
            outerRadius: {
              description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
              type: "number"
            },
            overlayOnPreviousTrack: {
              type: "boolean"
            },
            overrideTemplate: {
              type: "boolean"
            },
            prerelease: {
              additionalProperties: false,
              description: "internal",
              type: "object"
            },
            row: {
              anyOf: [
                {
                  $ref: "#/definitions/Row"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            size: {
              anyOf: [
                {
                  $ref: "#/definitions/Size"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            spacing: {
              description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
              type: "number"
            },
            startAngle: {
              description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            "static": {
              description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
              type: "boolean"
            },
            stretch: {
              type: "boolean"
            },
            stroke: {
              anyOf: [
                {
                  $ref: "#/definitions/Stroke"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            strokeWidth: {
              anyOf: [
                {
                  $ref: "#/definitions/StrokeWidth"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            style: {
              $ref: "#/definitions/Style",
              description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
            },
            text: {
              anyOf: [
                {
                  $ref: "#/definitions/Text"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            tooltip: {
              items: {
                $ref: "#/definitions/Tooltip"
              },
              type: "array"
            },
            visibility: {
              items: {
                $ref: "#/definitions/VisibilityCondition"
              },
              type: "array"
            },
            x: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1e: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            xAxis: {
              $ref: "#/definitions/AxisPosition",
              description: "not supported"
            },
            xDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic x-axis"
            },
            xOffset: {
              description: "Specify the x offset of views in the unit of pixels",
              type: "number"
            },
            xe: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1e: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            yDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic y-axis"
            },
            yOffset: {
              description: "Specify the y offset of views in the unit of pixels",
              type: "number"
            },
            ye: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            zoomLimits: {
              $ref: "#/definitions/ZoomLimits"
            }
          },
          type: "object"
        },
        type: "array"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        anyOf: [
          {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          {
            "const": "unknown",
            description: "No assemblies can be associated with a dummy track",
            type: "string"
          }
        ],
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      encoding: {
        additionalProperties: {
          $ref: "#/definitions/Channel"
        },
        type: "object"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        anyOf: [
          {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          {
            "const": "linear",
            description: "Only linear layout are supported at this time",
            type: "string"
          }
        ],
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        anyOf: [
          {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          {
            "const": true,
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          }
        ],
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`."
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        anyOf: [
          {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          {
            $ref: "#/definitions/DummyTrackStyle",
            description: "Defines how the track is styled"
          }
        ],
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      template: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      type: {
        "const": "dummy-track",
        description: "Used to specify the dummy track",
        type: "string"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        anyOf: [
          {
            $ref: "#/definitions/ZoomLimits"
          },
          {
            description: "Unused property for DummyTrack",
            items: {
              type: "null"
            },
            maxItems: 2,
            minItems: 2,
            type: "array"
          }
        ]
      }
    },
    type: "object"
  },
  PredefinedColors: {
    "enum": [
      "viridis",
      "grey",
      "spectral",
      "warm",
      "cividis",
      "bupu",
      "rdbu",
      "hot",
      "pink"
    ],
    type: "string"
  },
  Range: {
    anyOf: [
      {
        $ref: "#/definitions/ValueExtent"
      },
      {
        $ref: "#/definitions/PredefinedColors"
      }
    ]
  },
  RangeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      inRange: {
        description: "Check whether the value is in a number range.",
        items: {
          type: "number"
        },
        type: "array"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "inRange",
      "type"
    ],
    type: "object"
  },
  ResponsiveSize: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        additionalProperties: false,
        properties: {
          height: {
            type: "boolean"
          },
          width: {
            type: "boolean"
          }
        },
        type: "object"
      }
    ]
  },
  Row: {
    additionalProperties: false,
    properties: {
      clip: {
        description: "Clip row when the actual y value exceeds the max value of the y scale. Used only for bar marks at the moment. __Default__: `true`",
        type: "boolean"
      },
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      grid: {
        description: "Whether to display grid. __Default__: `false`",
        type: "boolean"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      padding: {
        description: "Determines the size of inner white spaces on the top and bottom of individiual rows. __Default__: `0`",
        type: "number"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Determine the start and end position of rendering area of this track along vertical axis. __Default__: `[0, height]`"
      },
      type: {
        "const": "nominal",
        description: "Specify the data type",
        type: "string"
      }
    },
    type: "object"
  },
  SelectivityCondition: {
    additionalProperties: false,
    properties: {
      measure: {
        "enum": [
          "width",
          "height",
          "aspectRatio"
        ],
        type: "string"
      },
      operation: {
        $ref: "#/definitions/LogicalOperation"
      },
      target: {
        description: "Does the condition applied to the visualization itself or its container? __Default__: `'self'`",
        "enum": [
          "self",
          "container"
        ],
        type: "string"
      },
      threshold: {
        description: "Threshold in the unit of pixels.",
        type: "number"
      }
    },
    required: [
      "operation",
      "measure",
      "threshold"
    ],
    type: "object"
  },
  SingleTrack: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "data",
      "mark"
    ],
    type: "object"
  },
  SingleView: {
    anyOf: [
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "overlay",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              $ref: "#/definitions/PartialTrack"
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "alignment",
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "stack",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              anyOf: [
                {
                  $ref: "#/definitions/PartialTrack"
                },
                {
                  $ref: "#/definitions/OverlaidTracks"
                }
              ]
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          id: {
            description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
            type: "string"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      description: "The ID of a view that is maintained for the use of JS API functions, e.g., positions of a view",
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          tracks: {
            items: {
              $ref: "#/definitions/Track"
            },
            type: "array"
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      }
    ]
  },
  Size: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      legend: {
        description: "not supported: Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Ranges of visual channel values"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  SizeVisibilityCondition: {
    additionalProperties: false,
    properties: {
      conditionPadding: {
        description: "Specify the buffer size (in pixel) of width or height when calculating the visibility.\n\n__Default__: `0`",
        type: "number"
      },
      measure: {
        description: "Specify which aspect of the `target` will be compared to the `threshold`.",
        "enum": [
          "width",
          "height"
        ],
        type: "string"
      },
      operation: {
        $ref: "#/definitions/LogicalOperation",
        description: 'A string that specifies the logical operation to conduct between `threshold` and the `measure` of `target`. Support\n\n- greater than : "greater-than", "gt", "GT"\n\n- less than : "less-than", "lt", "LT"\n\n- greater than or equal to : "greater-than-or-equal-to", "gtet", "GTET"\n\n- less than or equal to : "less-than-or-equal-to", "ltet", "LTET"'
      },
      target: {
        description: "Target specifies the object that you want to compare with the threshold.",
        "enum": [
          "track",
          "mark"
        ],
        type: "string"
      },
      threshold: {
        anyOf: [
          {
            type: "number"
          },
          {
            "const": "|xe-x|",
            type: "string"
          }
        ],
        description: 'Specify the threshold as one of:\n\n- A number representing a fixed threshold in the unit of pixels;\n\n- `"|xe-x|"`, using the distance between `xe` and `x` as threshold'
      },
      transitionPadding: {
        description: "Specify the buffer size (in pixel) of width or height for smooth transition.\n\n__Default__: `0`",
        type: "number"
      }
    },
    required: [
      "measure",
      "operation",
      "target",
      "threshold"
    ],
    type: "object"
  },
  StrConcatTransform: {
    additionalProperties: false,
    properties: {
      fields: {
        items: {
          type: "string"
        },
        type: "array"
      },
      newField: {
        type: "string"
      },
      separator: {
        type: "string"
      },
      type: {
        "const": "concat",
        type: "string"
      }
    },
    required: [
      "type",
      "fields",
      "newField",
      "separator"
    ],
    type: "object"
  },
  StrReplaceTransform: {
    additionalProperties: false,
    properties: {
      field: {
        type: "string"
      },
      newField: {
        type: "string"
      },
      replace: {
        items: {
          additionalProperties: false,
          properties: {
            from: {
              type: "string"
            },
            to: {
              type: "string"
            }
          },
          required: [
            "from",
            "to"
          ],
          type: "object"
        },
        type: "array"
      },
      type: {
        "const": "replace",
        type: "string"
      }
    },
    required: [
      "type",
      "field",
      "newField",
      "replace"
    ],
    type: "object"
  },
  Stroke: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      range: {
        $ref: "#/definitions/Range",
        description: "Ranges of visual channel values"
      },
      scaleOffset: {
        description: "Whether to use offset of the domain proportionally. This is bound to brushes on the color legend. __Default__: `[0, 1]`",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      title: {
        description: "Title of the legend. __Default__: `undefined`",
        type: "string"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  StrokeWidth: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Ranges of visual channel values"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Style: {
    additionalProperties: false,
    properties: {
      align: {
        description: "Specify the alignment of marks. This property is currently only supported for `triangle` marks.",
        "enum": [
          "left",
          "right"
        ],
        type: "string"
      },
      background: {
        type: "string"
      },
      backgroundOpacity: {
        type: "number"
      },
      brush: {
        additionalProperties: false,
        description: "Customize the style of the brush mark in the `rangeSelect` mouse event.",
        properties: {
          color: {
            description: "color of the marks when mouse events are triggered",
            type: "string"
          },
          opacity: {
            description: "opacity of the marks when mouse events are triggered",
            type: "number"
          },
          stroke: {
            description: "stroke color of the marks when mouse events are triggered",
            type: "string"
          },
          strokeOpacity: {
            type: "number"
          },
          strokeWidth: {
            description: "stroke width of the marks when mouse events are triggered",
            type: "number"
          }
        },
        type: "object"
      },
      curve: {
        description: "Specify the curve of `rule` marks.",
        "enum": [
          "top",
          "bottom",
          "left",
          "right"
        ],
        type: "string"
      },
      dashed: {
        description: "Specify the pattern of dashes and gaps for `rule` marks.",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      dx: {
        description: "Offset the position of marks in x direction. This property is currently only supported for `text` marks",
        type: "number"
      },
      dy: {
        description: "Offset the position of marks in y direction. This property is currently only supported for `text` marks.",
        type: "number"
      },
      enableSmoothPath: {
        description: "Whether to enable smooth paths when drawing curves.\n\n__Default__: `false`",
        type: "boolean"
      },
      inlineLegend: {
        description: "Specify whether to show legend in a single horizontal line?",
        type: "boolean"
      },
      legendTitle: {
        description: "If defined, show legend title on the top or left",
        type: "string"
      },
      linePattern: {
        additionalProperties: false,
        description: "Specify the pattern of dashes and gaps for `rule` marks.",
        properties: {
          size: {
            type: "number"
          },
          type: {
            "enum": [
              "triangleLeft",
              "triangleRight"
            ],
            type: "string"
          }
        },
        required: [
          "type",
          "size"
        ],
        type: "object"
      },
      linkConnectionType: {
        description: 'Specify the connetion type of `betweenLink` marks.\n\n__Default__: `"corner"`',
        "enum": [
          "straight",
          "curve",
          "corner"
        ],
        type: "string"
      },
      linkMinHeight: {
        description: "The minimum height of `withinLink` and `betweenLink` marks. Unit is a percentagle. __Default__: `0.5`",
        type: "number"
      },
      linkStyle: {
        description: "The style of `withinLink` and `betweenLink` marks. __Default__: `'circular'` `'elliptical'` will be used as a default option.",
        "enum": [
          "elliptical",
          "circular",
          "straight"
        ],
        type: "string"
      },
      matrixExtent: {
        description: 'Determine to show only one side of the diagonal in a HiGlass matrix. __Default__: `"full"`',
        "enum": [
          "full",
          "upper-right",
          "lower-left"
        ],
        type: "string"
      },
      mouseOver: {
        $ref: "#/definitions/EventStyle",
        description: "Customize visual effects of `mouseOver` events on marks."
      },
      outline: {
        type: "string"
      },
      outlineWidth: {
        type: "number"
      },
      select: {
        $ref: "#/definitions/EventStyle",
        description: "Customize visual effects of `rangeSelect` events on marks ."
      },
      textAnchor: {
        description: "Specify the alignment of `text` marks to a given point.",
        "enum": [
          "start",
          "middle",
          "end"
        ],
        type: "string"
      },
      textFontSize: {
        description: "Specify the font size of `text` marks. Can also be specified using the `size` channel option of `text` marks.",
        type: "number"
      },
      textFontWeight: {
        description: "Specify the font weight of `text` marks.",
        "enum": [
          "bold",
          "normal"
        ],
        type: "string"
      },
      textStroke: {
        description: "Specify the stroke of `text` marks. Can also be specified using the `stroke` channel option of `text` marks.",
        type: "string"
      },
      textStrokeWidth: {
        description: "Specify the stroke width of `text` marks. Can also be specified using the `strokeWidth` channel option of `text` marks.",
        type: "number"
      },
      withinLinkVerticalLines: {
        description: "Whether to show vertical lines that connect to the baseline (axis) when `y` and `ye` are both used. __Default__: `false`",
        type: "boolean"
      }
    },
    type: "object"
  },
  SvTypeTransform: {
    additionalProperties: false,
    properties: {
      firstBp: {
        additionalProperties: false,
        description: "Based on the BEDPE, infer SV types. SV types are specified as one of the following strings: DUP, TRA, DEL, t2tINV, h2hINV.",
        properties: {
          chrField: {
            type: "string"
          },
          posField: {
            type: "string"
          },
          strandField: {
            type: "string"
          }
        },
        required: [
          "chrField",
          "posField",
          "strandField"
        ],
        type: "object"
      },
      newField: {
        type: "string"
      },
      secondBp: {
        additionalProperties: false,
        description: "Based on the BEDPE, infer SV types. SV types are specified as one of the following strings: DUP, TRA, DEL, t2tINV, h2hINV.",
        properties: {
          chrField: {
            type: "string"
          },
          posField: {
            type: "string"
          },
          strandField: {
            type: "string"
          }
        },
        required: [
          "chrField",
          "posField",
          "strandField"
        ],
        type: "object"
      },
      type: {
        "const": "svType",
        type: "string"
      }
    },
    required: [
      "type",
      "firstBp",
      "secondBp",
      "newField"
    ],
    type: "object"
  },
  TemplateTrack: {
    additionalProperties: false,
    description: "Template specification that will be internally converted into `SingleTrack` for rendering.",
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      encoding: {
        additionalProperties: {
          $ref: "#/definitions/Channel"
        },
        type: "object"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        description: "Assigned to `uid` in a HiGlass view config, used for API and caching.",
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      template: {
        type: "string"
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "template",
      "data"
    ],
    type: "object"
  },
  Text: {
    additionalProperties: false,
    properties: {
      domain: {
        description: "Values of the data",
        items: {
          type: "string"
        },
        type: "array"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      range: {
        description: "Ranges of visual channel values",
        items: {
          type: "string"
        },
        type: "array"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Tooltip: {
    additionalProperties: false,
    properties: {
      alt: {
        description: "Name of the data field for showing in the tooltip. Will use the field name if not specified.",
        type: "string"
      },
      field: {
        description: "Specifiy a data field whose value will show in the tooltip.",
        type: "string"
      },
      format: {
        description: "format of the data value.",
        type: "string"
      },
      type: {
        $ref: "#/definitions/FieldType",
        description: "Type of the data field."
      }
    },
    required: [
      "field",
      "type"
    ],
    type: "object"
  },
  Track: {
    anyOf: [
      {
        $ref: "#/definitions/SingleTrack"
      },
      {
        $ref: "#/definitions/OverlaidTrack"
      },
      {
        $ref: "#/definitions/DataTrack"
      },
      {
        $ref: "#/definitions/TemplateTrack"
      },
      {
        $ref: "#/definitions/DummyTrack"
      }
    ]
  },
  ValueExtent: {
    anyOf: [
      {
        items: {
          type: "string"
        },
        type: "array"
      },
      {
        items: {
          type: "number"
        },
        type: "array"
      }
    ]
  },
  VcfData: {
    additionalProperties: false,
    description: "The Variant Call Format (VCF).",
    properties: {
      indexUrl: {
        description: "URL link to the tabix index file",
        type: "string"
      },
      sampleLength: {
        description: "The maximum number of rows to be loaded from the URL. __Default:__ `1000`",
        type: "number"
      },
      type: {
        "const": "vcf",
        type: "string"
      },
      url: {
        description: "URL link to the VCF file",
        type: "string"
      }
    },
    required: [
      "type",
      "url",
      "indexUrl"
    ],
    type: "object"
  },
  VectorData: {
    additionalProperties: false,
    description: 'One-dimensional quantitative values along genomic position (e.g., bigwig) can be converted into HiGlass\' `"vector"` format data. Find out more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#bigwig-files).',
    properties: {
      aggregation: {
        $ref: "#/definitions/BinAggregate",
        description: 'Determine aggregation function to apply within bins. __Default__: `"mean"`'
      },
      binSize: {
        description: "Binning the genomic interval in tiles (unit size: 256).",
        type: "number"
      },
      column: {
        description: 'Assign a field name of the middle position of genomic intervals. __Default__: `"position"`',
        type: "string"
      },
      end: {
        description: 'Assign a field name of the end position of genomic intervals. __Default__: `"end"`',
        type: "string"
      },
      start: {
        description: 'Assign a field name of the start position of genomic intervals. __Default__: `"start"`',
        type: "string"
      },
      type: {
        "const": "vector",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      value: {
        description: 'Assign a field name of quantitative values. __Default__: `"value"`',
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  VisibilityCondition: {
    anyOf: [
      {
        $ref: "#/definitions/SizeVisibilityCondition"
      },
      {
        $ref: "#/definitions/ZoomLevelVisibilityCondition"
      }
    ]
  },
  X: {
    additionalProperties: false,
    properties: {
      aggregate: {
        $ref: "#/definitions/Aggregate",
        description: "Specify how to aggregate data. __Default__: `undefined`"
      },
      axis: {
        $ref: "#/definitions/AxisPosition",
        description: "Specify where should the axis be put"
      },
      domain: {
        $ref: "#/definitions/GenomicDomain",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field.",
        type: "string"
      },
      grid: {
        description: "Whether to display grid. __Default__: `false`",
        type: "boolean"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      linkingId: {
        description: "Users need to assign a unique linkingId for [linking views](/docs/user-interaction#linking-views) and [Brushing and Linking](/docs/user-interaction#brushing-and-linking)",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the visual channel."
      },
      type: {
        "const": "genomic",
        description: "Specify the data type.",
        type: "string"
      }
    },
    type: "object"
  },
  Y: {
    additionalProperties: false,
    properties: {
      aggregate: {
        $ref: "#/definitions/Aggregate",
        description: "Specify how to aggregate data. __Default__: `undefined`"
      },
      axis: {
        $ref: "#/definitions/AxisPosition",
        description: "Specify where should the axis be put"
      },
      baseline: {
        description: "Custom baseline of the y-axis. __Default__: `0`",
        type: [
          "string",
          "number"
        ]
      },
      domain: {
        anyOf: [
          {
            $ref: "#/definitions/ValueExtent"
          },
          {
            $ref: "#/definitions/GenomicDomain"
          }
        ],
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field.",
        type: "string"
      },
      flip: {
        description: "Whether to flip the y-axis. This is done by inverting the `range` property. __Default__: `false`",
        type: "boolean"
      },
      grid: {
        description: "Whether to display grid. __Default__: `false`",
        type: "boolean"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      linkingId: {
        description: "Users need to assign a unique linkingId for [linking views](/docs/user-interaction#linking-views) and [Brushing and Linking](/docs/user-interaction#brushing-and-linking)",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the visual channel."
      },
      type: {
        description: "Specify the data type.",
        "enum": [
          "quantitative",
          "nominal",
          "genomic"
        ],
        type: "string"
      },
      zeroBaseline: {
        description: "Specify whether to use zero baseline. __Default__: `true`",
        type: "boolean"
      }
    },
    type: "object"
  },
  ZoomLevelVisibilityCondition: {
    additionalProperties: false,
    properties: {
      conditionPadding: {
        description: "Specify the buffer size (in pixel) of width or height when calculating the visibility.\n\n__Default__: `0`",
        type: "number"
      },
      measure: {
        "const": "zoomLevel",
        description: "Specify which aspect of the `target` will be compared to the `threshold`.",
        type: "string"
      },
      operation: {
        $ref: "#/definitions/LogicalOperation",
        description: 'A string that specifies the logical operation to conduct between `threshold` and the `measure` of `target`. Support\n\n- greater than : "greater-than", "gt", "GT"\n\n- less than : "less-than", "lt", "LT"\n\n- greater than or equal to : "greater-than-or-equal-to", "gtet", "GTET"\n\n- less than or equal to : "less-than-or-equal-to", "ltet", "LTET"'
      },
      target: {
        description: "Target specifies the object that you want to compare with the threshold.",
        "enum": [
          "track",
          "mark"
        ],
        type: "string"
      },
      threshold: {
        description: "Set a threshold in the unit of base pairs (bp)",
        type: "number"
      },
      transitionPadding: {
        description: "Specify the buffer size (in pixel) of width or height for smooth transition.\n\n__Default__: `0`",
        type: "number"
      }
    },
    required: [
      "measure",
      "operation",
      "target",
      "threshold"
    ],
    type: "object"
  },
  ZoomLimits: {
    items: {
      type: [
        "number",
        "null"
      ]
    },
    maxItems: 2,
    minItems: 2,
    type: "array"
  }
};
const GoslingSchema = {
  $ref: $ref$2,
  $schema: $schema$2,
  definitions: definitions$2
};
function validateGoslingSpec(spec) {
  return validateSpec(GoslingSchema, spec);
}
function validateSpec(schema, spec, silence = false) {
  const validate2 = new Ajv$1({ extendRefs: true }).compile(schema);
  const valid = validate2(spec);
  let message = "";
  let details = "";
  if (validate2.errors) {
    details = JSON.stringify(validate2.errors, null, 2);
    if (!silence) {
      console.warn(details);
    }
    message = " Some properties are incorrectly used.";
  }
  return { state: valid ? "success" : "warn", message, details };
}
function validateTrack(track) {
  let valid = true;
  const errorMessages = [];
  const resolvedTrack = resolveSuperposedTracks(track);
  resolvedTrack.forEach((spec) => {
    if (!getGenomicChannelFromTrack(spec) && spec.mark !== "brush" && spec.mark !== "rule") {
      errorMessages.push("genomic type is not encoded to either a x- or y- axis");
      valid = false;
    }
    const color2 = spec.color;
    if (spec.mark === "line" && IsChannelDeep(color2) && color2.type === "quantitative") {
      errorMessages.push("`line` mark cannot be used with `quantitative` value");
      valid = false;
    }
  });
  return { valid, errorMessages };
}
function getGenomicChannelFromTrack(track) {
  let genomicChannel = void 0;
  ["x", "y", "xe", "ye", "x1", "y1", "x1e", "y1e"].reverse().forEach((channelType) => {
    const channel = track[channelType];
    if (IsChannelDeep(channel) && channel.type === "genomic") {
      genomicChannel = channel;
    }
  });
  return genomicChannel;
}
function getGenomicChannelKeyFromTrack(track) {
  let genomicChannelKey = void 0;
  ["x", "xe", "y", "ye", "x1", "y1", "x1e", "y1e"].reverse().forEach((channelKey) => {
    const channel = track[channelKey];
    if (IsChannelDeep(channel) && channel.type === "genomic") {
      genomicChannelKey = channelKey;
    }
  });
  return genomicChannelKey;
}
const $ref$1 = "#/definitions/Theme";
const $schema$1 = "http://json-schema.org/draft-07/schema#";
const definitions$1 = {
  AxisStyle: {
    additionalProperties: false,
    properties: {
      baselineColor: {
        type: "string"
      },
      gridColor: {
        type: "string"
      },
      gridStrokeDash: {
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      gridStrokeType: {
        "enum": [
          "solid",
          "dashed"
        ],
        type: "string"
      },
      gridStrokeWidth: {
        type: "number"
      },
      labelColor: {
        type: "string"
      },
      labelExcludeChrPrefix: {
        description: "If `true`, labels of genomics axes excludes the chromosome prefix (e.g., `chr1` -> `1`).",
        type: "boolean"
      },
      labelFontFamily: {
        type: "string"
      },
      labelFontSize: {
        type: "number"
      },
      labelFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      },
      labelMargin: {
        description: "The margin around labels for calculating visual overlaps between labels. This is mainly used for determining the visibility of axis labels. `0` if no margin to use. Negative values (`-1`) for showing all labels even if they overlap.",
        type: "number"
      },
      tickColor: {
        type: "string"
      }
    },
    type: "object"
  },
  LegendStyle: {
    additionalProperties: false,
    properties: {
      background: {
        type: "string"
      },
      backgroundOpacity: {
        type: "number"
      },
      backgroundStroke: {
        type: "string"
      },
      labelColor: {
        type: "string"
      },
      labelFontFamily: {
        type: "string"
      },
      labelFontSize: {
        type: "number"
      },
      labelFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      },
      position: {
        "enum": [
          "top",
          "right"
        ],
        type: "string"
      },
      tickColor: {
        type: "string"
      }
    },
    type: "object"
  },
  MarkStyle: {
    additionalProperties: false,
    properties: {
      color: {
        type: "string"
      },
      nominalColorRange: {
        items: {
          type: "string"
        },
        type: "array"
      },
      opacity: {
        type: "number"
      },
      quantitativeSizeRange: {
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      size: {
        type: "number"
      },
      stroke: {
        type: "string"
      },
      strokeWidth: {
        type: "number"
      }
    },
    type: "object"
  },
  RootStyle: {
    additionalProperties: false,
    properties: {
      background: {
        type: "string"
      },
      mousePositionColor: {
        type: "string"
      },
      showMousePosition: {
        type: "boolean"
      },
      subtitleAlign: {
        "enum": [
          "left",
          "middle",
          "right"
        ],
        type: "string"
      },
      subtitleBackgroundColor: {
        type: "string"
      },
      subtitleColor: {
        type: "string"
      },
      subtitleFontFamily: {
        type: "string"
      },
      subtitleFontSize: {
        type: "number"
      },
      subtitleFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      },
      titleAlign: {
        "enum": [
          "left",
          "middle",
          "right"
        ],
        type: "string"
      },
      titleBackgroundColor: {
        type: "string"
      },
      titleColor: {
        type: "string"
      },
      titleFontFamily: {
        type: "string"
      },
      titleFontSize: {
        type: "number"
      },
      titleFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Theme: {
    anyOf: [
      {
        $ref: "#/definitions/ThemeType"
      },
      {
        $ref: "#/definitions/ThemeDeep"
      }
    ]
  },
  ThemeDeep: {
    additionalProperties: false,
    properties: {
      area: {
        $ref: "#/definitions/MarkStyle"
      },
      axis: {
        $ref: "#/definitions/AxisStyle"
      },
      bar: {
        $ref: "#/definitions/MarkStyle"
      },
      base: {
        $ref: "#/definitions/ThemeType"
      },
      brush: {
        $ref: "#/definitions/MarkStyle"
      },
      legend: {
        $ref: "#/definitions/LegendStyle"
      },
      line: {
        $ref: "#/definitions/MarkStyle"
      },
      link: {
        $ref: "#/definitions/MarkStyle"
      },
      markCommon: {
        $ref: "#/definitions/MarkStyle"
      },
      point: {
        $ref: "#/definitions/MarkStyle"
      },
      rect: {
        $ref: "#/definitions/MarkStyle"
      },
      root: {
        $ref: "#/definitions/RootStyle"
      },
      rule: {
        $ref: "#/definitions/MarkStyle"
      },
      text: {
        additionalProperties: false,
        properties: {
          color: {
            type: "string"
          },
          nominalColorRange: {
            items: {
              type: "string"
            },
            type: "array"
          },
          opacity: {
            type: "number"
          },
          quantitativeSizeRange: {
            items: {
              type: "number"
            },
            maxItems: 2,
            minItems: 2,
            type: "array"
          },
          size: {
            type: "number"
          },
          stroke: {
            type: "string"
          },
          strokeWidth: {
            type: "number"
          },
          textAnchor: {
            "enum": [
              "start",
              "middle",
              "end"
            ],
            type: "string"
          },
          textFontWeight: {
            "enum": [
              "bold",
              "normal"
            ],
            type: "string"
          }
        },
        type: "object"
      },
      track: {
        $ref: "#/definitions/TrackStyle"
      },
      triangle: {
        $ref: "#/definitions/MarkStyle"
      }
    },
    required: [
      "base"
    ],
    type: "object"
  },
  ThemeType: {
    "enum": [
      "light",
      "dark",
      "warm",
      "ggplot",
      "igv",
      "ensembl",
      "jbrowse",
      "ucsc",
      "washu",
      "excel",
      "google"
    ],
    type: "string"
  },
  TrackStyle: {
    additionalProperties: false,
    properties: {
      alternatingBackground: {
        type: "string"
      },
      background: {
        type: "string"
      },
      outline: {
        type: "string"
      },
      outlineWidth: {
        type: "number"
      },
      titleAlign: {
        "enum": [
          "left",
          "middle",
          "right"
        ],
        type: "string"
      },
      titleBackground: {
        type: "string"
      },
      titleColor: {
        type: "string"
      },
      titleFontSize: {
        type: "number"
      }
    },
    type: "object"
  }
};
const theme_schema = {
  $ref: $ref$1,
  $schema: $schema$1,
  definitions: definitions$1
};
function getStyleOverridden(parent, child) {
  const base = parent ? JSON.parse(JSON.stringify(parent)) : {};
  return child ? Object.assign(base, child) : base;
}
function fallback() {
  return Math.random().toString(36).substring(2, 10);
}
function uuid() {
  var _a, _b, _c;
  return (_c = (_b = (_a = globalThis.crypto).randomUUID) == null ? void 0 : _b.call(_a)) != null ? _c : fallback();
}
function traverseTracks(spec, callback) {
  if ("tracks" in spec) {
    spec.tracks.forEach((t, i, ts) => {
      callback(t, i, ts);
      traverseTracks(t, callback);
    });
  } else if ("views" in spec) {
    spec.views.forEach((view) => traverseTracks(view, callback));
  }
}
function traverseTracksAndViews(spec, callback) {
  if ("tracks" in spec) {
    spec.tracks.forEach((t) => {
      callback(t);
      traverseTracksAndViews(t, callback);
    });
  } else if ("views" in spec) {
    spec.views.forEach((v) => {
      callback(v);
      traverseTracksAndViews(v, callback);
    });
  }
}
function traverseViewArrangements(spec, callback) {
  if ("tracks" in spec)
    ;
  else {
    callback(spec);
    spec.views.forEach((v) => {
      traverseViewArrangements(v, callback);
    });
  }
}
function convertToFlatTracks(spec) {
  if (IsFlatTracks(spec)) {
    const base = { ...spec, tracks: void 0, id: void 0 };
    return spec.tracks.filter((track) => !track._invalidTrack).map((track) => Object.assign(JSON.parse(JSON.stringify(base)), track));
  }
  const newTracks = [];
  if (IsStackedTracks(spec)) {
    spec.tracks.filter((track) => !track._invalidTrack).map((track) => {
      if ("alignment" in track) {
        newTracks.push({
          ...track,
          _overlay: [...track.tracks],
          tracks: void 0,
          alignment: void 0
        });
      } else {
        const base = { ...spec, tracks: void 0, id: void 0 };
        const newSpec = Object.assign(JSON.parse(JSON.stringify(base)), track);
        newTracks.push(newSpec);
      }
    });
  } else {
    newTracks.push({
      ...spec,
      _overlay: [...spec.tracks.filter((track) => !track._invalidTrack)],
      tracks: void 0,
      alignment: void 0
    });
  }
  return JSON.parse(JSON.stringify(newTracks));
}
function traverseToFixSpecDownstream(spec, parentDef) {
  if (parentDef) {
    if (spec.assembly === void 0)
      spec.assembly = parentDef.assembly;
    if (spec.layout === void 0)
      spec.layout = parentDef.layout;
    if (spec.orientation === void 0)
      spec.orientation = parentDef.orientation;
    if (spec.static === void 0)
      spec.static = parentDef.static !== void 0 ? parentDef.static : false;
    if (spec.zoomLimits === void 0)
      spec.zoomLimits = parentDef.zoomLimits;
    if (spec.xDomain === void 0)
      spec.xDomain = parentDef.xDomain;
    if (spec.yDomain === void 0)
      spec.yDomain = parentDef.yDomain;
    if (spec.linkingId === void 0)
      spec.linkingId = parentDef.linkingId;
    if (spec.centerRadius === void 0)
      spec.centerRadius = parentDef.centerRadius;
    if (spec.spacing === void 0 && !("tracks" in spec))
      spec.spacing = parentDef.spacing;
    if (spec.xOffset === void 0)
      spec.xOffset = parentDef.xOffset;
    if (spec.yOffset === void 0)
      spec.yOffset = parentDef.yOffset;
    if ("views" in spec && "arrangement" in parentDef && spec.arrangement === void 0)
      spec.arrangement = parentDef.arrangement;
    spec.style = getStyleOverridden(parentDef.style, spec.style);
  } else {
    if (spec.assembly === void 0)
      spec.assembly = "hg38";
    if (spec.layout === void 0)
      spec.layout = "linear";
    if (spec.orientation === void 0)
      spec.orientation = "horizontal";
    if (spec.static === void 0)
      spec.static = false;
    if (spec.zoomLimits === void 0)
      spec.zoomLimits = [1, null];
    if (spec.centerRadius === void 0)
      spec.centerRadius = DEFAULT_INNER_RADIUS_PROP;
    if (spec.spacing === void 0)
      spec.spacing = DEFAULT_VIEW_SPACING;
    if ("views" in spec && spec.arrangement === void 0)
      spec.arrangement = "vertical";
    if (spec.xOffset === void 0)
      spec.xOffset = 0;
    if (spec.yOffset === void 0)
      spec.yOffset = 0;
  }
  if (!spec.id) {
    spec.id = uuid();
  }
  if ("tracks" in spec) {
    let tracks = convertToFlatTracks(spec);
    tracks = spreadTracksByData(tracks);
    const linkID = uuid();
    tracks.forEach((track, i, array) => {
      var _a, _b, _c;
      if (!track.id) {
        track.id = uuid();
      }
      if (!track.width) {
        track.width = Is2DTrack(track) ? DEFAULT_TRACK_SIZE_2D : DEFAULT_TRACK_WIDTH_LINEAR;
      }
      if (!track.height) {
        track.height = Is2DTrack(track) ? DEFAULT_TRACK_SIZE_2D : DEFAULT_TRACK_HEIGHT_LINEAR;
      }
      if ("displacement" in track) {
        if (((_a = track.displacement) == null ? void 0 : _a.type) === "pile" && track.row === void 0 && IsChannelDeep(track.x) && track.x.field && IsChannelDeep(track.xe) && track.xe.field) {
          const newField = uuid();
          const startField = track.x.field;
          const endField = track.xe.field;
          const padding = track.displacement.padding;
          const displaceTransform = {
            type: "displace",
            newField,
            boundingBox: { startField, endField, padding },
            method: "pile"
          };
          if (!track.dataTransform) {
            track.dataTransform = [];
          }
          track.dataTransform = [...track.dataTransform, displaceTransform];
          track.row = { field: newField, type: "nominal" };
        } else if (((_b = track.displacement) == null ? void 0 : _b.type) === "spread")
          ;
      }
      if (track.layout)
        track.layout = void 0;
      if (track.zoomLimits)
        track.zoomLimits = void 0;
      if (!track.assembly)
        track.assembly = spec.assembly;
      if (!track.layout)
        track.layout = spec.layout;
      if (!track.orientation)
        track.orientation = spec.orientation;
      if (track.static === void 0)
        track.static = spec.static !== void 0 ? spec.static : false;
      if (!track.zoomLimits)
        track.zoomLimits = spec.zoomLimits;
      if (track.layout == "circular" && IsDummyTrack(track)) {
        track._invalidTrack = true;
        return;
      }
      track.style = getStyleOverridden(spec.style, track.style);
      if (IsOverlaidTrack(track)) {
        track._overlay = track._overlay.filter((overlayTrack) => {
          return !("type" in overlayTrack && overlayTrack.type == "dummy-track");
        });
        track._overlay.forEach((o) => {
          o.style = getStyleOverridden(track.style, o.style);
        });
      }
      if ((track.layout === "circular" || Is2DTrack(track)) && track.orientation === "vertical") {
        track.orientation = "horizontal";
      }
      if (Is2DTrack(track)) {
        track.layout = "linear";
        if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.y) && !track.y.domain) {
          track.y.domain = spec.yDomain;
        } else if (IsOverlaidTrack(track)) {
          track._overlay.forEach((o) => {
            if (IsChannelDeep(o.y) && !o.y.domain) {
              o.y.domain = spec.yDomain;
            }
          });
        }
      }
      if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && !track.x.domain) {
        track.x.domain = spec.xDomain;
      } else if (IsOverlaidTrack(track)) {
        track._overlay.forEach((o) => {
          if (IsChannelDeep(o.x) && !o.x.domain) {
            o.x.domain = spec.xDomain;
          }
        });
      }
      if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && !track.x.linkingId) {
        track.x.linkingId = (_c = spec.linkingId) != null ? _c : linkID;
      } else if (IsOverlaidTrack(track)) {
        let isAdded = false;
        track._overlay.forEach((o) => {
          var _a2;
          if (isAdded)
            return;
          if (IsChannelDeep(o.x) && !o.x.linkingId) {
            o.x.linkingId = (_a2 = spec.linkingId) != null ? _a2 : linkID;
            isAdded = true;
          }
        });
      }
      if (i === 0) {
        track.overlayOnPreviousTrack = false;
      }
      if (i === 0 || i !== 0 && tracks.slice(0, i).filter((d) => !d.overlayOnPreviousTrack).length === 1 && track.overlayOnPreviousTrack === true) {
        if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && !track.x.axis) {
          if (track.orientation === "vertical") {
            track.x.axis = "left";
          } else {
            track.x.axis = "top";
          }
        } else if (IsOverlaidTrack(track)) {
          track._overlay.forEach((o) => {
            if (IsChannelDeep(o.x) && !o.x.axis) {
              if (track.orientation === "vertical") {
                o.x.axis = "left";
              } else {
                o.x.axis = "top";
              }
            }
          });
        }
      }
      if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && track.x.axis && track.x.axis !== "none") {
        if (track.orientation === "vertical") {
          if (track.x.axis === "top") {
            track.x.axis = "left";
          } else if (track.x.axis === "bottom") {
            track.x.axis = "right";
          }
        } else {
          if (track.x.axis === "left") {
            track.x.axis = "top";
          } else if (track.x.axis === "right") {
            track.x.axis = "bottom";
          }
        }
      } else if (IsOverlaidTrack(track)) {
        track._overlay.forEach((o) => {
          if (IsChannelDeep(o.x) && o.x.axis && o.x.axis !== "none") {
            if (track.orientation === "vertical") {
              if (o.x.axis === "top") {
                o.x.axis = "left";
              } else if (o.x.axis === "bottom") {
                o.x.axis = "right";
              }
            } else {
              if (o.x.axis === "left") {
                o.x.axis = "top";
              } else if (o.x.axis === "right") {
                o.x.axis = "bottom";
              }
            }
          }
        });
      }
      if (
        // first track can never flipped by default
        i !== 0 && // [0, ..., i] tracks should not overlaid as a single track
        (i === array.length - 1 && array.slice(0, i + 1).filter((d) => d.overlayOnPreviousTrack).length < i || // Are the rest of the tracks overlaid as a single track?
        i !== array.length - 1 && array.slice(i + 1).filter((d) => d.overlayOnPreviousTrack).length === array.length - i - 1 && array.slice(0, i + 1).filter((d) => d.overlayOnPreviousTrack).length < i)
      ) {
        if (IsSingleTrack(track) && track.mark === "withinLink" && track.flipY === void 0) {
          track.flipY = true;
        } else if (IsOverlaidTrack(track)) {
          if (track.mark === "withinLink" && track.flipY === void 0) {
            track.flipY = true;
          }
          track._overlay.forEach((o) => {
            if (o.mark === "withinLink" && o.flipY === void 0) {
              o.flipY = true;
            }
          });
        }
      }
      if (track.overlayOnPreviousTrack && array[i - 1]) {
        track.width = array[i - 1].width;
        track.height = array[i - 1].height;
        track.layout = array[i - 1].layout;
        track.assembly = array[i - 1].assembly;
      }
    });
    tracks = tracks.filter((track) => !track._invalidTrack);
    spec.tracks = tracks;
  } else {
    spec.views.forEach((v) => {
      traverseToFixSpecDownstream(v, spec);
    });
  }
}
function getVectorTemplate(column, value) {
  return {
    data: {
      type: "vector",
      url: "",
      column,
      value
    },
    mark: "bar",
    x: { field: column, type: "genomic", axis: "top" },
    y: { field: value, type: "quantitative" },
    width: 400,
    height: 100
  };
}
function getMultivecTemplate(row, column, value, categories) {
  return categories && categories.length < 10 ? {
    data: {
      type: "multivec",
      url: "",
      row,
      column,
      value,
      categories
    },
    mark: "bar",
    x: { field: column, type: "genomic", axis: "top" },
    y: { field: value, type: "quantitative" },
    row: { field: row, type: "nominal", legend: true },
    color: { field: row, type: "nominal" },
    width: 400,
    height: 100
  } : {
    data: {
      type: "multivec",
      url: "",
      row,
      column,
      value,
      categories
    },
    mark: "rect",
    x: { field: column, type: "genomic", axis: "top" },
    row: { field: row, type: "nominal", legend: true },
    color: { field: value, type: "quantitative" },
    width: 400,
    height: 100
  };
}
function overrideDataTemplates(spec) {
  traverseTracks(spec, (t, i, ts) => {
    var _a, _b, _c, _d, _e;
    if (!("data" in t) || !t.data || !IsDataDeepTileset(t.data)) {
      return;
    }
    if ("alignment" in t) {
      return;
    }
    if (!IsDataTemplate(t)) {
      return;
    }
    switch (t.data.type) {
      case "vector":
      case "bigwig":
        ts[i] = Object.assign(getVectorTemplate((_a = t.data.column) != null ? _a : "position", (_b = t.data.value) != null ? _b : "value"), t);
        break;
      case "multivec":
        ts[i] = Object.assign(
          getMultivecTemplate(
            (_c = t.data.row) != null ? _c : "category",
            (_d = t.data.column) != null ? _d : "position",
            (_e = t.data.value) != null ? _e : "value",
            t.data.categories
          ),
          t
        );
        break;
    }
  });
}
const GoslingTemplates = [
  {
    name: "gene",
    channels: [
      { name: "startPosition", type: "genomic", required: true },
      { name: "endPosition", type: "genomic", required: true },
      { name: "strandColor", type: "nominal", required: true },
      { name: "strandRow", type: "nominal", required: true },
      { name: "opacity", type: "value", required: false },
      { name: "geneHeight", type: "value", required: false },
      { name: "geneLabel", type: "nominal", required: true },
      { name: "geneLabelColor", type: "nominal", required: true },
      { name: "geneLabelFontSize", type: "value", required: false },
      { name: "geneLabelStroke", type: "value", required: false },
      { name: "geneLabelStrokeThickness", type: "value", required: false },
      { name: "geneLabelOpacity", type: "value", required: false },
      { name: "type", type: "nominal", required: true }
      // either 'gene' or 'exon'
    ],
    mapping: [
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["-"] }
        ],
        mark: "triangleLeft",
        x: { base: "startPosition", type: "genomic" },
        size: { base: "geneHeight", value: 12 },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        style: { align: "right" }
      },
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["+"] }
        ],
        mark: "triangleRight",
        x: { base: "endPosition", type: "genomic" },
        size: { base: "geneHeight", value: 12 },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        style: { align: "left" }
      },
      {
        dataTransform: [{ type: "filter", base: "type", oneOf: ["exon"] }],
        mark: "rect",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        size: { base: "geneHeight", value: 12 },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 }
      },
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["+"] }
        ],
        mark: "rect",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        size: { value: 3 }
        // style: {
        //     linePattern: { type: 'triangleRight', size: 5 }
        // }
      },
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["-"] }
        ],
        mark: "rect",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        size: { value: 3 }
        // style: {
        //     linePattern: { type: 'triangleLeft', size: 5 }
        // }
      },
      {
        dataTransform: [{ type: "filter", base: "type", oneOf: ["gene"] }],
        mark: "text",
        text: { base: "geneLabel", type: "nominal" },
        // TODO: add dy here
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "geneLabelColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 1 },
        size: { base: "geneLabelFontSize", value: 18 },
        stroke: { base: "geneLabelStroke", value: "white" },
        strokeWidth: { base: "geneLabelStrokeThickness", value: 2 },
        // TODO: how to redefine style from the users' side? (e.g., dy: -30)
        visibility: [
          {
            operation: "less-than",
            measure: "width",
            threshold: "|xe-x|",
            transitionPadding: 10,
            target: "mark"
          }
        ]
      }
    ]
  },
  {
    name: "ideogram",
    channels: [
      { name: "startPosition", type: "genomic", required: true },
      { name: "endPosition", type: "genomic", required: true },
      { name: "chrHeight", type: "value", required: false },
      // https://eweitz.github.io/ideogram/
      { name: "name", type: "nominal", required: true },
      { name: "stainBackgroundColor", type: "nominal", required: true },
      { name: "stainLabelColor", type: "nominal", required: true },
      { name: "stainStroke", type: "value", required: false },
      { name: "stainStrokeWidth", type: "value", required: false }
    ],
    mapping: [
      {
        mark: "rect",
        dataTransform: [{ type: "filter", base: "stainBackgroundColor", oneOf: ["acen"], not: true }],
        color: {
          base: "stainBackgroundColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar", "acen"],
          range: ["white", "lightgray", "gray", "gray", "black", "#7B9CC8", "#DC4542"]
        },
        size: { base: "chrHeight", value: 18 },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        stroke: { base: "stainStroke", value: "gray" },
        strokeWidth: { base: "stainStrokeWidth", value: 0.3 }
      },
      {
        mark: "triangleRight",
        dataTransform: [
          { type: "filter", base: "stainBackgroundColor", oneOf: ["acen"] },
          { type: "filter", base: "name", include: "q" }
        ],
        color: {
          base: "stainBackgroundColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar", "acen"],
          range: ["white", "lightgray", "gray", "gray", "black", "#7B9CC8", "#DC4542"]
        },
        size: { base: "chrHeight", value: 18 },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        stroke: { base: "stainStroke", value: "gray" },
        strokeWidth: { base: "stainStrokeWidth", value: 0.3 }
      },
      {
        mark: "triangleLeft",
        dataTransform: [
          { type: "filter", base: "stainBackgroundColor", oneOf: ["acen"] },
          { type: "filter", base: "name", include: "p" }
        ],
        color: {
          base: "stainBackgroundColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar", "acen"],
          range: ["white", "lightgray", "gray", "gray", "black", "#7B9CC8", "#DC4542"]
        },
        size: { base: "chrHeight", value: 18 },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        stroke: { base: "stainStroke", value: "gray" },
        strokeWidth: { base: "stainStrokeWidth", value: 0.3 }
      },
      {
        mark: "text",
        dataTransform: [{ type: "filter", base: "stainLabelColor", oneOf: ["acen"], not: true }],
        color: {
          base: "stainLabelColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar"],
          range: ["black", "black", "black", "black", "white", "black"]
        },
        text: { base: "name", type: "nominal" },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        visibility: [
          {
            operation: "less-than",
            measure: "width",
            threshold: "|xe-x|",
            transitionPadding: 10,
            target: "mark"
          }
        ]
      }
    ]
  },
  {
    name: "sequence",
    channels: [
      { name: "startPosition", type: "genomic", required: true },
      { name: "endPosition", type: "genomic", required: true },
      { name: "barLength", type: "quantitative", required: true },
      { name: "baseBackground", type: "nominal", required: true },
      { name: "baseLabelColor", type: "nominal", required: true },
      { name: "baseLabelFontSize", type: "value", required: false }
    ],
    mapping: [
      {
        mark: "bar",
        // x: { base: 'position', type: 'genomic' },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        y: { base: "barLength", type: "quantitative", axis: "none" },
        color: { base: "baseBackground", type: "nominal", domain: ["A", "T", "G", "C"] }
      },
      {
        dataTransform: [{ type: "filter", base: "barLength", oneOf: [0], not: true }],
        mark: "text",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        color: { base: "baseLabelColor", type: "nominal", domain: ["A", "T", "G", "C"], range: ["white"] },
        text: { base: "baseBackground", type: "nominal" },
        size: { base: "baseLabelFontSize", value: 18 },
        visibility: [
          {
            operation: "less-than",
            measure: "width",
            threshold: "|xe-x|",
            transitionPadding: 30,
            target: "mark"
          },
          {
            operation: "LT",
            measure: "zoomLevel",
            threshold: 10,
            target: "track"
          }
        ]
      }
    ]
  }
];
function replaceTrackTemplates(spec, templates) {
  traverseTracks(spec, (t, i, ts) => {
    var _a, _b;
    if (!IsTemplateTrack(t)) {
      return;
    }
    const { template: name2 } = t;
    const templateDef = templates.find((d) => d.name === name2);
    if (!templateDef) {
      t._invalidTrack = true;
      console.warn(`There is no track template named '${name2}'`);
      return;
    }
    let isValid = true;
    templateDef.channels.forEach((d) => {
      if (d.required && (!t.encoding || !(d.name in t.encoding))) {
        isValid = false;
        console.warn(`A template spec ('${name2}') does not contain a required channel, ${d.name}`);
      }
    });
    if (!isValid) {
      t._invalidTrack = true;
      return;
    }
    const viewBase = JSON.parse(JSON.stringify(t));
    if ("encoding" in viewBase) {
      delete viewBase.encoding;
    }
    const convertedView = {
      ...viewBase,
      alignment: "overlay",
      tracks: [],
      width: (_a = t.width) != null ? _a : 100,
      height: (_b = t.height) != null ? _b : 100
    };
    templateDef.mapping.forEach((singleTrackMappingDef) => {
      const convertedTrack = {
        data: t.data,
        mark: singleTrackMappingDef.mark
      };
      const { dataTransform } = singleTrackMappingDef;
      if (dataTransform) {
        dataTransform.map((dataTramsformMap) => {
          const baseChannelName = dataTramsformMap.base;
          if (baseChannelName && t.encoding && baseChannelName in t.encoding && "field" in t.encoding[baseChannelName]) {
            delete dataTramsformMap.base;
            dataTramsformMap.field = t.encoding[baseChannelName].field;
          }
        });
      }
      const encodingSpec = t.encoding;
      if (!encodingSpec) {
        Object.keys(singleTrackMappingDef).filter((k) => k !== "mark").forEach((channelKey) => {
          const channelMap = JSON.parse(JSON.stringify(singleTrackMappingDef[channelKey]));
          if ("base" in channelMap) {
            delete channelMap.base;
          }
          convertedTrack[channelKey] = channelMap;
        });
      } else {
        Object.keys(singleTrackMappingDef).filter((k) => k !== "mark").forEach((channelKey) => {
          const channelMap = JSON.parse(JSON.stringify(singleTrackMappingDef[channelKey]));
          if ("base" in channelMap) {
            const baseChannelName = channelMap.base;
            if (baseChannelName in encodingSpec) {
              const base = JSON.parse(JSON.stringify(encodingSpec[baseChannelName]));
              delete channelMap.base;
              const newChannelSpec = Object.assign(channelMap, JSON.parse(JSON.stringify(base)));
              convertedTrack[channelKey] = newChannelSpec;
            } else {
              delete channelMap.base;
              convertedTrack[channelKey] = channelMap;
            }
          } else {
            convertedTrack[channelKey] = channelMap;
          }
        });
      }
      convertedView.tracks.push(convertedTrack);
    });
    ts[i] = convertedView;
  });
}
const NOMINAL_COLOR$a = [
  "#E79F00",
  "#029F73",
  "#0072B2",
  "#CB7AA7",
  "#D45E00",
  "#57B4E9",
  "#EFE441"
  /*'#000000'*/
];
const LightThemeMarkCommonStyle$1 = {
  color: NOMINAL_COLOR$a[0],
  size: 1,
  stroke: "black",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: NOMINAL_COLOR$a,
  quantitativeSizeRange: [2, 6]
};
const light = {
  base: "light",
  root: {
    background: "white",
    titleColor: "black",
    titleBackgroundColor: "transparent",
    titleFontSize: 18,
    titleFontFamily: "Arial",
    titleAlign: "left",
    titleFontWeight: "bold",
    subtitleColor: "gray",
    subtitleBackgroundColor: "transparent",
    subtitleFontSize: 16,
    subtitleFontFamily: "Arial",
    subtitleFontWeight: "normal",
    subtitleAlign: "left",
    showMousePosition: true,
    mousePositionColor: "#000000"
  },
  track: {
    background: "transparent",
    alternatingBackground: "transparent",
    titleColor: "black",
    titleBackground: "white",
    titleFontSize: 24,
    titleAlign: "left",
    outline: "black",
    outlineWidth: 1
  },
  legend: {
    position: "top",
    background: "white",
    backgroundOpacity: 0.7,
    labelColor: "black",
    labelFontSize: 12,
    labelFontWeight: "normal",
    labelFontFamily: "Arial",
    backgroundStroke: "#DBDBDB",
    tickColor: "black"
  },
  axis: {
    tickColor: "black",
    labelColor: "black",
    labelMargin: 5,
    labelExcludeChrPrefix: false,
    labelFontSize: 12,
    labelFontWeight: "normal",
    labelFontFamily: "Arial",
    baselineColor: "black",
    gridColor: "#E3E3E3",
    gridStrokeWidth: 1,
    gridStrokeType: "solid",
    gridStrokeDash: [4, 4]
  },
  markCommon: {
    ...LightThemeMarkCommonStyle$1
  },
  point: {
    ...LightThemeMarkCommonStyle$1,
    size: 3
  },
  rect: {
    ...LightThemeMarkCommonStyle$1
  },
  triangle: {
    ...LightThemeMarkCommonStyle$1
  },
  area: {
    ...LightThemeMarkCommonStyle$1
  },
  line: {
    ...LightThemeMarkCommonStyle$1
  },
  bar: {
    ...LightThemeMarkCommonStyle$1
  },
  rule: {
    ...LightThemeMarkCommonStyle$1,
    strokeWidth: 1
  },
  link: {
    ...LightThemeMarkCommonStyle$1,
    strokeWidth: 1
  },
  text: {
    ...LightThemeMarkCommonStyle$1,
    textAnchor: "middle",
    textFontWeight: "normal"
  },
  brush: {
    ...LightThemeMarkCommonStyle$1,
    color: "gray",
    opacity: 0.3,
    stroke: "black",
    strokeWidth: 1
  }
};
const NOMINAL_COLOR$9 = [
  "#E79F00",
  "#029F73",
  "#0072B2",
  "#CB7AA7",
  "#D45E00",
  "#57B4E9",
  "#EFE441"
  /*'#000000'*/
];
const LightThemeMarkCommonStyle = {
  color: NOMINAL_COLOR$9[0],
  size: 1,
  stroke: "black",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: NOMINAL_COLOR$9,
  quantitativeSizeRange: [2, 6]
};
const DarkThemeMarkCommonStyle = { ...LightThemeMarkCommonStyle, stroke: "white" };
const dark = {
  base: "dark",
  root: {
    background: "black",
    titleColor: "white",
    titleBackgroundColor: "transparent",
    titleFontSize: 18,
    titleFontFamily: "Arial",
    titleAlign: "middle",
    titleFontWeight: "bold",
    subtitleColor: "lightgray",
    subtitleBackgroundColor: "transparent",
    subtitleFontSize: 16,
    subtitleFontFamily: "Arial",
    subtitleAlign: "middle",
    subtitleFontWeight: "normal",
    showMousePosition: true,
    mousePositionColor: "#FFFFFF"
  },
  track: {
    background: "transparent",
    alternatingBackground: "transparent",
    titleColor: "white",
    titleBackground: "black",
    titleFontSize: 18,
    titleAlign: "left",
    outline: "white",
    outlineWidth: 1
  },
  legend: {
    position: "right",
    background: "black",
    backgroundOpacity: 0.7,
    labelColor: "white",
    labelFontSize: 12,
    labelFontWeight: "normal",
    labelFontFamily: "Arial",
    backgroundStroke: "#DBDBDB",
    tickColor: "white"
  },
  axis: {
    tickColor: "white",
    labelMargin: 5,
    labelExcludeChrPrefix: false,
    labelColor: "white",
    labelFontSize: 10,
    labelFontWeight: "normal",
    labelFontFamily: "Arial",
    baselineColor: "white",
    gridColor: "gray",
    gridStrokeWidth: 1,
    gridStrokeType: "solid",
    gridStrokeDash: [4, 4]
  },
  markCommon: {
    ...DarkThemeMarkCommonStyle
  },
  point: {
    ...DarkThemeMarkCommonStyle,
    size: 3
  },
  rect: {
    ...DarkThemeMarkCommonStyle
  },
  triangle: {
    ...DarkThemeMarkCommonStyle
  },
  area: {
    ...DarkThemeMarkCommonStyle
  },
  line: {
    ...DarkThemeMarkCommonStyle
  },
  bar: {
    ...DarkThemeMarkCommonStyle
  },
  rule: {
    ...DarkThemeMarkCommonStyle,
    strokeWidth: 1
  },
  link: {
    ...DarkThemeMarkCommonStyle,
    strokeWidth: 1
  },
  text: {
    ...DarkThemeMarkCommonStyle,
    textAnchor: "middle",
    textFontWeight: "normal"
  },
  brush: {
    ...DarkThemeMarkCommonStyle,
    color: "lightgray",
    opacity: 0.3,
    stroke: "white",
    strokeWidth: 1
  }
};
const NOMINAL_COLOR$8 = ["#D19000", "#008F67", "#005F96", "#B86E97", "#B55100", "#4793BF", "#C9C03"];
const WarmThemeMarkCommonStyle = {
  color: NOMINAL_COLOR$8[0],
  size: 1,
  stroke: "#3C3C3C",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: NOMINAL_COLOR$8,
  quantitativeSizeRange: [2, 6]
};
const warm = {
  base: "warm",
  root: {
    background: "#FFF8E8",
    titleColor: "#3C3C3C",
    subtitleColor: "gray",
    showMousePosition: true,
    mousePositionColor: "#3C3C3C"
  },
  track: {
    titleColor: "#3C3C3C",
    titleBackground: "#FFF8E8",
    outline: "#3C3C3C",
    outlineWidth: 1
  },
  legend: {
    background: "#FFF8E8",
    backgroundOpacity: 0.7,
    labelColor: "#3C3C3C",
    backgroundStroke: "#3C3C3C",
    tickColor: "3C3C3C"
  },
  axis: {
    tickColor: "#3C3C3C",
    labelColor: "#3C3C3C",
    baselineColor: "#3C3C3C",
    gridColor: "#E3E3E3",
    gridStrokeWidth: 1
  },
  markCommon: {
    ...WarmThemeMarkCommonStyle
  },
  point: {
    ...WarmThemeMarkCommonStyle,
    size: 3
  },
  rect: {
    ...WarmThemeMarkCommonStyle
  },
  triangle: {
    ...WarmThemeMarkCommonStyle
  },
  area: {
    ...WarmThemeMarkCommonStyle
  },
  line: {
    ...WarmThemeMarkCommonStyle
  },
  bar: {
    ...WarmThemeMarkCommonStyle
  },
  rule: {
    ...WarmThemeMarkCommonStyle,
    strokeWidth: 1
  },
  link: {
    ...WarmThemeMarkCommonStyle,
    strokeWidth: 1
  },
  text: {
    ...WarmThemeMarkCommonStyle,
    textAnchor: "middle",
    textFontWeight: "normal"
  },
  brush: {
    ...WarmThemeMarkCommonStyle,
    color: "lightgray",
    opacity: 0.3,
    stroke: "#3C3C3C",
    strokeWidth: 1
  }
};
const NOMINAL_COLOR$7 = ["#F66A62", "#05B230", "#5692FF", "#D764D6", "#86E9D4", "#6E6AD7", "#FFFB00"];
const GgplotThemeMarkCommonStyle = {
  color: NOMINAL_COLOR$7[0],
  size: 1,
  stroke: "black",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: NOMINAL_COLOR$7,
  quantitativeSizeRange: [2, 6]
};
const ggplot = {
  base: "ggplot",
  root: {
    background: "white",
    titleColor: "black",
    titleFontSize: 18,
    titleFontFamily: "Helvetica",
    titleAlign: "middle",
    titleFontWeight: "bold",
    titleBackgroundColor: "white",
    subtitleColor: "gray",
    subtitleFontSize: 14,
    subtitleFontFamily: "Helvetica",
    subtitleAlign: "middle",
    subtitleFontWeight: "light",
    subtitleBackgroundColor: "white",
    showMousePosition: true,
    mousePositionColor: "black"
  },
  track: {
    background: "#e8e8e8",
    alternatingBackground: "#d1d1d1",
    titleColor: "black",
    titleBackground: "white",
    //titleFontSize:'',
    //titleAlign:'',
    outline: "black",
    outlineWidth: 2
  },
  legend: {
    position: "right",
    background: "#e8e8e8",
    backgroundOpacity: 1,
    labelColor: "black",
    backgroundStroke: "#e8e8e8",
    tickColor: "white"
    //,labelFontSize: '',
    //labelFontWeight: '',
    //labelFontFamily: ''
  },
  axis: {
    tickColor: "white",
    labelColor: "black",
    //labelFontSize: '',
    //labelFontWeight: '',
    //labelFontFamily: '',
    baselineColor: "#e8e8e8",
    gridColor: "white",
    gridStrokeWidth: 2
    //,gridStrokeType: '',
    //gridStrokeDash:
  },
  markCommon: {
    ...GgplotThemeMarkCommonStyle
  },
  point: {
    ...GgplotThemeMarkCommonStyle,
    size: 3
  },
  rect: {
    ...GgplotThemeMarkCommonStyle
  },
  triangle: {
    ...GgplotThemeMarkCommonStyle
  },
  area: {
    ...GgplotThemeMarkCommonStyle
  },
  line: {
    ...GgplotThemeMarkCommonStyle
  },
  bar: {
    ...GgplotThemeMarkCommonStyle
  },
  rule: {
    ...GgplotThemeMarkCommonStyle,
    strokeWidth: 1
  },
  link: {
    ...GgplotThemeMarkCommonStyle,
    strokeWidth: 1
  },
  text: {
    ...GgplotThemeMarkCommonStyle,
    textAnchor: "middle",
    textFontWeight: "bold"
  },
  brush: {
    ...GgplotThemeMarkCommonStyle,
    color: "black",
    opacity: 0.3,
    stroke: "black",
    strokeWidth: 1
  }
};
const NOMINAL_COLOR$6 = ["#37E649", "#ED2D44", "#AEAFEA", "#EBAEAE", "#CE7B3D", "#8743E0", "#5233F0"];
const IGVThemeMarkCommonStyle = {
  color: NOMINAL_COLOR$6[0],
  size: 1,
  stroke: "black",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: NOMINAL_COLOR$6,
  quantitativeSizeRange: [2, 6]
};
const igv = {
  base: "igv",
  root: {
    background: "white",
    titleColor: "white",
    //titleFontSize:'',
    //titleFontFamily:'',
    titleAlign: "left",
    titleFontWeight: "bold",
    titleBackgroundColor: "#5f5f5f",
    subtitleColor: "#3b3b3b",
    //subtitleFontSize:'',
    //subtitleFontFamily:'',
    subtitleAlign: "left",
    subtitleFontWeight: "bold",
    subtitleBackgroundColor: "#c4c4c4",
    showMousePosition: true,
    mousePositionColor: "black"
  },
  track: {
    background: "white",
    alternatingBackground: "#e8e8e8",
    titleColor: "white",
    titleBackground: "#5F5F5F",
    //titleFontSize:'',
    //titleAlign:'',
    outline: "#5F5F5F",
    outlineWidth: 1
  },
  legend: {
    position: "top",
    background: "white",
    backgroundOpacity: 1,
    labelColor: "black",
    //labelFontSize: '',
    //labelFontWeight: '',
    //labelFontFamily: '',
    backgroundStroke: "black",
    tickColor: "black"
  },
  axis: {
    tickColor: "black",
    labelColor: "black",
    //labelFontSize: '',
    //labelFontWeight: '',
    //labelFontFamily: '',
    //baselineColor: '#E6E6E6',
    baselineColor: "white",
    gridColor: "transparent",
    gridStrokeWidth: 0
    //gridStrokeType: '',
    //gridStrokeDash:
  },
  markCommon: {
    ...IGVThemeMarkCommonStyle
  },
  point: {
    ...IGVThemeMarkCommonStyle,
    size: 3
  },
  rect: {
    ...IGVThemeMarkCommonStyle
  },
  triangle: {
    ...IGVThemeMarkCommonStyle
  },
  area: {
    ...IGVThemeMarkCommonStyle
  },
  line: {
    ...IGVThemeMarkCommonStyle
  },
  bar: {
    ...IGVThemeMarkCommonStyle
  },
  rule: {
    ...IGVThemeMarkCommonStyle,
    strokeWidth: 1
  },
  link: {
    ...IGVThemeMarkCommonStyle,
    strokeWidth: 1
  },
  text: {
    ...IGVThemeMarkCommonStyle,
    textAnchor: "middle",
    textFontWeight: "bold"
  },
  brush: {
    ...IGVThemeMarkCommonStyle,
    color: "white",
    opacity: 0.3,
    stroke: "black",
    strokeWidth: 1
  }
};
const NOMINAL_COLOR$5 = [
  "#CD9B1D",
  "#8A668B",
  "#40E0D0",
  "#FF6969",
  "#666666",
  "#FAC902",
  "#FE0000",
  "#CC96CD",
  "#D9D9D9"
  /*'#000000'*/
];
const EnsemblThemeMarkCommonStyle = {
  color: NOMINAL_COLOR$5[0],
  size: 1,
  stroke: "black",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: NOMINAL_COLOR$5,
  quantitativeSizeRange: [2, 6]
};
const ensembl = {
  base: "ensembl",
  root: {
    background: "white",
    titleColor: "#494949",
    titleFontSize: 24,
    titleFontFamily: "GGX88",
    titleAlign: "left",
    titleFontWeight: "bold",
    titleBackgroundColor: "white",
    subtitleColor: "white",
    subtitleFontSize: 19,
    subtitleFontFamily: "GGX88",
    subtitleAlign: "left",
    subtitleFontWeight: "normal",
    subtitleBackgroundColor: "#7B8BAF",
    mousePositionColor: "#FE0000",
    showMousePosition: true
  },
  track: {
    background: "white",
    alternatingBackground: "#fffdf7",
    titleColor: "black",
    titleBackground: "white",
    titleAlign: "left",
    outline: "#7B8BAF",
    outlineWidth: 2
  },
  legend: {
    tickColor: "black",
    labelColor: "black",
    //labelFontSize: ,
    labelFontWeight: "normal",
    labelFontFamily: "GGX88",
    background: "white",
    backgroundOpacity: 2,
    backgroundStroke: "lightgray"
  },
  axis: {
    tickColor: "black",
    labelColor: "black",
    //labelFontSize: ,
    //labelFontWeight: '',
    labelFontFamily: "GGX88",
    baselineColor: "black",
    gridColor: "#7B8BAF",
    gridStrokeWidth: 2
    //gridStrokeType: '',
    //gridStrokeDash:
  },
  markCommon: {
    ...EnsemblThemeMarkCommonStyle
  },
  point: {
    ...EnsemblThemeMarkCommonStyle,
    /*color: NOMINAL_COLOR[0],
    stroke: 'black',
    strokeWidth: 0,
    opacity: 1,
    nominalColorRange: NOMINAL_COLOR,
    quantitativeSizeRange: [2, 6]*/
    size: 3
  },
  rect: {
    ...EnsemblThemeMarkCommonStyle
    /*color: NOMINAL_COLOR[0],
    size: 1,
    stroke: 'black',
    strokeWidth: 0,
    opacity: 1,
    nominalColorRange: NOMINAL_COLOR,
    quantitativeSizeRange: [2, 6]*/
  },
  triangle: {
    ...EnsemblThemeMarkCommonStyle
    /*color: NOMINAL_COLOR[0],
    size: 1,
    stroke: 'black',
    strokeWidth: 0,
    opacity: 1,
    nominalColorRange: NOMINAL_COLOR,
    quantitativeSizeRange: [2, 6]*/
  },
  area: {
    ...EnsemblThemeMarkCommonStyle
    /*color: NOMINAL_COLOR[0],
    size: 1,
    stroke: 'black',
    strokeWidth: 0,
    opacity: 1,
    nominalColorRange: NOMINAL_COLOR,
    quantitativeSizeRange: [2, 6]*/
  },
  line: {
    ...EnsemblThemeMarkCommonStyle
    /*color: NOMINAL_COLOR[0],
    size: 1,
    stroke: 'black',
    strokeWidth: 0,
    opacity: 1,
    nominalColorRange: NOMINAL_COLOR,
    quantitativeSizeRange: [2, 6]*/
  },
  bar: {
    ...EnsemblThemeMarkCommonStyle
    /*color: NOMINAL_COLOR[0],
    size: 1,
    stroke: 'black',
    strokeWidth: 0,
    opacity: 1,
    nominalColorRange: NOMINAL_COLOR,
    quantitativeSizeRange: [2, 6]*/
  },
  rule: {
    ...EnsemblThemeMarkCommonStyle,
    /*color: NOMINAL_COLOR[0],
    size: 1,
    stroke: 'black',
    opacity: 1,
    nominalColorRange: NOMINAL_COLOR,
    quantitativeSizeRange: [2, 6]*/
    strokeWidth: 1
  },
  link: {
    ...EnsemblThemeMarkCommonStyle,
    /*color: NOMINAL_COLOR[0],
    size: 1,
    stroke: 'black',
    opacity: 1,
    nominalColorRange: NOMINAL_COLOR,
    quantitativeSizeRange: [2, 6]*/
    strokeWidth: 1
  },
  text: {
    ...EnsemblThemeMarkCommonStyle,
    /*color: NOMINAL_COLOR[0],
    size: 1,
    stroke: 'black',
    strokeWidth: 0,
    opacity: 1,
    nominalColorRange: NOMINAL_COLOR,
    quantitativeSizeRange: [2, 6]*/
    textAnchor: "middle",
    textFontWeight: "normal"
  },
  brush: {
    ...EnsemblThemeMarkCommonStyle,
    /*size: 1,
    nominalColorRange: NOMINAL_COLOR,
    quantitativeSizeRange: [2, 6]*/
    color: "gray",
    opacity: 0.3,
    stroke: "black",
    strokeWidth: 1
  }
};
const NOMINAL_COLOR$4 = [
  "#3A62FE",
  "#F85353",
  "#3A62FE",
  "#F85353",
  "#DCA326",
  "#03BF06",
  "#BABABA"
  /*'#000000'*/
];
const JBrowseThemeMarkCommonStyle = {
  color: NOMINAL_COLOR$4[0],
  size: 1,
  stroke: "black",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: NOMINAL_COLOR$4,
  quantitativeSizeRange: [2, 6]
};
const jbrowse = {
  base: "jbrowse",
  root: {
    background: "white",
    titleColor: "white",
    titleFontSize: 20,
    titleFontFamily: "Roboto",
    titleAlign: "middle",
    titleFontWeight: "normal",
    titleBackgroundColor: "#0b243f",
    subtitleColor: "white",
    subtitleFontSize: 18,
    subtitleFontFamily: "Roboto",
    subtitleAlign: "middle",
    subtitleFontWeight: "normal",
    subtitleBackgroundColor: "#732162",
    showMousePosition: true,
    mousePositionColor: "#000000"
  },
  track: {
    background: "white",
    alternatingBackground: "white",
    //titleFontSize:'',
    titleAlign: "middle",
    titleColor: "white",
    titleBackground: "#0B243F",
    outline: "black",
    outlineWidth: 1
  },
  legend: {
    position: "top",
    background: "white",
    backgroundOpacity: 0.7,
    labelColor: "#DCA326",
    //labelFontSize: '',
    labelFontWeight: "bold",
    labelFontFamily: "Roboto",
    backgroundStroke: "#black",
    tickColor: "black"
  },
  axis: {
    tickColor: "black",
    labelColor: "#DCA326",
    //labelFontSize: '',
    labelFontWeight: "bold",
    labelFontFamily: "Roboto",
    baselineColor: "black",
    gridColor: "#c5d5d9",
    gridStrokeWidth: 1
    //,
    //gridStrokeType: '',
    //gridStrokeDash:
  },
  markCommon: {
    ...JBrowseThemeMarkCommonStyle
  },
  point: {
    ...JBrowseThemeMarkCommonStyle,
    size: 3
  },
  rect: {
    ...JBrowseThemeMarkCommonStyle
  },
  triangle: {
    ...JBrowseThemeMarkCommonStyle
  },
  area: {
    ...JBrowseThemeMarkCommonStyle
  },
  line: {
    ...JBrowseThemeMarkCommonStyle
  },
  bar: {
    ...JBrowseThemeMarkCommonStyle
  },
  rule: {
    ...JBrowseThemeMarkCommonStyle,
    strokeWidth: 1
  },
  link: {
    ...JBrowseThemeMarkCommonStyle,
    strokeWidth: 1
  },
  text: {
    ...JBrowseThemeMarkCommonStyle,
    textAnchor: "middle",
    textFontWeight: "normal"
  },
  brush: {
    ...JBrowseThemeMarkCommonStyle,
    color: "#c5d5d9",
    opacity: 0.3,
    stroke: "black",
    strokeWidth: 1
  }
};
const NOMINAL_COLOR$3 = [
  "#3A5FCD",
  "#FFA54E",
  "#8FBC8F",
  "#B6709B",
  "#EE6A50",
  "#CCB79E",
  "#DADA8F",
  "#00CDCC",
  "#EED5D2",
  "#CD8EDD",
  "#9ACD31",
  "#D1BEA8",
  "#FFB6C0"
  /*'#000000'*/
];
const UCSCThemeMarkCommonStyle = {
  color: NOMINAL_COLOR$3[0],
  size: 1,
  stroke: "black",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: NOMINAL_COLOR$3,
  quantitativeSizeRange: [2, 6]
};
const ucsc = {
  base: "ucsc",
  root: {
    background: "white",
    titleColor: "white",
    titleFontSize: 22,
    //titleFontFamily:'',
    titleAlign: "middle",
    titleFontWeight: "bold",
    titleBackgroundColor: "#00457c",
    subtitleColor: "black",
    //subtitleFontSize:'',
    //subtitleFontFamily:'',
    subtitleAlign: "middle",
    subtitleFontWeight: "bold",
    subtitleBackgroundColor: "white",
    showMousePosition: true,
    mousePositionColor: "#FE0000"
  },
  track: {
    background: "white",
    alternatingBackground: "#e3f7fc",
    titleColor: "#3A5FCD",
    titleBackground: "white",
    //titleFontSize:'',
    //titleAlign:'',
    outline: "black",
    outlineWidth: 1
  },
  legend: {
    position: "top",
    background: "white",
    backgroundOpacity: 0.7,
    labelColor: "black",
    //labelFontSize: '',
    labelFontWeight: "bold",
    //labelFontFamily: '',
    backgroundStroke: "#DBDBDB",
    tickColor: "black"
  },
  axis: {
    tickColor: "black",
    labelColor: "#3A5FCD",
    //labelFontSize: '',
    labelFontWeight: "bold",
    //labelFontFamily: '',
    baselineColor: "black",
    gridColor: "#E3E3E3",
    gridStrokeWidth: 1
    //,
    //gridStrokeType: '',
    //gridStrokeDash:
  },
  markCommon: {
    ...UCSCThemeMarkCommonStyle
  },
  point: {
    ...UCSCThemeMarkCommonStyle,
    size: 3
  },
  rect: {
    ...UCSCThemeMarkCommonStyle
  },
  triangle: {
    ...UCSCThemeMarkCommonStyle
  },
  area: {
    ...UCSCThemeMarkCommonStyle
  },
  line: {
    ...UCSCThemeMarkCommonStyle
  },
  bar: {
    ...UCSCThemeMarkCommonStyle
  },
  rule: {
    ...UCSCThemeMarkCommonStyle,
    strokeWidth: 1
  },
  link: {
    ...UCSCThemeMarkCommonStyle,
    strokeWidth: 1
  },
  text: {
    ...UCSCThemeMarkCommonStyle,
    textAnchor: "middle",
    textFontWeight: "normal"
  },
  brush: {
    ...UCSCThemeMarkCommonStyle,
    color: "gray",
    opacity: 0.3,
    stroke: "black",
    strokeWidth: 1
  }
};
const NOMINAL_COLOR$2 = [
  "#6E12AC",
  "#15C250",
  "#E70FB1",
  "#FF8E55",
  "#A3B8F3",
  "#DE5E59",
  "#77AAAA",
  "#F5CCCA"
  /*'#000000'*/
];
const WashUThemeMarkCommonStyle = {
  color: NOMINAL_COLOR$2[0],
  size: 1,
  stroke: "black",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: NOMINAL_COLOR$2,
  quantitativeSizeRange: [2, 6]
};
const washu = {
  base: "washu",
  root: {
    background: "white",
    titleColor: "gray",
    //titleFontSize:16,
    //titleFontFamily:'',
    titleAlign: "left",
    titleFontWeight: "normal",
    titleBackgroundColor: "white",
    subtitleColor: "lightgray",
    //subtitleFontSize:12,
    //subtitleFontFamily:'',
    subtitleAlign: "left",
    subtitleFontWeight: "light",
    subtitleBackgroundColor: "white",
    showMousePosition: true,
    mousePositionColor: "#000000"
  },
  track: {
    background: "white",
    //alternatingBackground:'',
    titleColor: "gray",
    titleBackground: "white",
    //titleFontSize:'',
    titleAlign: "left",
    outline: "gray",
    outlineWidth: 1
  },
  legend: {
    background: "white",
    backgroundOpacity: 0.5,
    labelColor: "gray",
    //labelFontSize: '',
    labelFontWeight: "light",
    //labelFontFamily: '',
    backgroundStroke: "#DBDBDB",
    tickColor: "gray"
  },
  axis: {
    tickColor: "lightgray",
    labelColor: "gray",
    //labelFontSize: '',
    labelFontWeight: "light",
    //labelFontFamily: '',
    baselineColor: "gray",
    gridColor: "transparent",
    gridStrokeWidth: 0
    //,
    //gridStrokeType: '',
    //gridStrokeDash:
  },
  markCommon: {
    ...WashUThemeMarkCommonStyle
  },
  point: {
    ...WashUThemeMarkCommonStyle,
    size: 3
  },
  rect: {
    ...WashUThemeMarkCommonStyle
  },
  triangle: {
    ...WashUThemeMarkCommonStyle
  },
  area: {
    ...WashUThemeMarkCommonStyle
  },
  line: {
    ...WashUThemeMarkCommonStyle
  },
  bar: {
    ...WashUThemeMarkCommonStyle
  },
  rule: {
    ...WashUThemeMarkCommonStyle,
    strokeWidth: 1
  },
  link: {
    ...WashUThemeMarkCommonStyle,
    strokeWidth: 1
  },
  text: {
    ...WashUThemeMarkCommonStyle,
    textAnchor: "middle",
    textFontWeight: "normal"
  },
  brush: {
    ...WashUThemeMarkCommonStyle,
    color: "gray",
    opacity: 0.3,
    stroke: "gray",
    strokeWidth: 1
  }
};
const NOMINAL_COLOR$1 = [
  "#ED7D31",
  "#4472C4",
  "#FFC207",
  "#76AE4F",
  "#9E480E",
  "#A5A5A5",
  "#4472C4",
  "#264378",
  "#76AE4F",
  "#5B9CD5"
  /*'#000000'*/
];
const ExcelThemeMarkCommonStyle = {
  color: NOMINAL_COLOR$1[0],
  size: 1,
  stroke: "#5A5A5A",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: NOMINAL_COLOR$1,
  quantitativeSizeRange: [2, 6]
};
const excel = {
  base: "excel",
  root: {
    background: "white",
    titleColor: "#5A5A5A",
    titleFontSize: 30,
    titleFontFamily: "Calibri",
    titleAlign: "middle",
    titleFontWeight: "bold",
    titleBackgroundColor: "white",
    subtitleColor: "#5A5A5A",
    subtitleFontSize: 22,
    subtitleFontFamily: "Calibri",
    subtitleAlign: "middle",
    subtitleFontWeight: "bold",
    subtitleBackgroundColor: "white",
    showMousePosition: true,
    mousePositionColor: "#000000"
  },
  track: {
    background: "white",
    alternatingBackground: "#f5f5f5",
    titleColor: "#5A5A5A",
    titleBackground: "white",
    //titleFontSize:'',
    //titleAlign:'',
    outline: "#5A5A5A",
    outlineWidth: 1
  },
  legend: {
    position: "right",
    tickColor: "#5A5A5A",
    labelColor: "#5A5A5A",
    labelFontSize: 12,
    labelFontWeight: "bold",
    labelFontFamily: "Calibri",
    background: "white",
    backgroundOpacity: 0.7,
    backgroundStroke: "#5A5A5A"
  },
  axis: {
    tickColor: "#5A5A5A",
    labelColor: "#5A5A5A",
    //labelFontSize: '',
    //labelFontWeight: '',
    labelFontFamily: "Calibri",
    baselineColor: "#5A5A5A",
    gridColor: "#5A5A5A",
    gridStrokeWidth: 1
    //gridStrokeType: '',
    //gridStrokeDash:
  },
  markCommon: {
    ...ExcelThemeMarkCommonStyle
  },
  point: {
    ...ExcelThemeMarkCommonStyle,
    size: 3
  },
  rect: {
    ...ExcelThemeMarkCommonStyle
  },
  triangle: {
    ...ExcelThemeMarkCommonStyle
  },
  area: {
    ...ExcelThemeMarkCommonStyle
  },
  line: {
    ...ExcelThemeMarkCommonStyle
  },
  bar: {
    ...ExcelThemeMarkCommonStyle
  },
  rule: {
    ...ExcelThemeMarkCommonStyle,
    strokeWidth: 1
  },
  link: {
    ...ExcelThemeMarkCommonStyle,
    strokeWidth: 1
  },
  text: {
    ...ExcelThemeMarkCommonStyle,
    textAnchor: "middle",
    textFontWeight: "normal"
  },
  brush: {
    ...ExcelThemeMarkCommonStyle,
    color: "#5A5A5A",
    opacity: 0.3,
    stroke: "#5A5A5A",
    strokeWidth: 1
  }
};
const NOMINAL_COLOR = [
  "#4185f4",
  "#DB4437",
  "#F4B400",
  "#0D9D58",
  "#AA30C3",
  "#FF6E02",
  "#CBC74C"
  /*'#000000'*/
];
const GoogleThemeMarkCommonStyle = {
  color: NOMINAL_COLOR[0],
  size: 2,
  stroke: "black",
  strokeWidth: 0.3,
  opacity: 1,
  nominalColorRange: NOMINAL_COLOR,
  quantitativeSizeRange: [2, 6]
};
const google = {
  base: "google",
  root: {
    background: "white",
    titleColor: "#454545",
    titleFontSize: 20,
    titleFontFamily: "Arial",
    titleAlign: "left",
    titleFontWeight: "normal",
    titleBackgroundColor: "white",
    subtitleColor: "#7d7d7d",
    subtitleFontSize: 16,
    subtitleFontFamily: "Arial",
    subtitleAlign: "left",
    subtitleFontWeight: "light",
    subtitleBackgroundColor: "white",
    showMousePosition: true,
    mousePositionColor: "#000000"
  },
  track: {
    background: "white",
    alternatingBackground: "#f5f5f5",
    titleColor: "#e8e8e8",
    titleBackground: "white",
    titleFontSize: 12,
    titleAlign: "left",
    outline: "black",
    outlineWidth: 1
  },
  legend: {
    position: "right",
    background: "white",
    backgroundOpacity: 1,
    labelColor: "black",
    labelFontSize: 12,
    labelFontWeight: "normal",
    labelFontFamily: "Arial",
    backgroundStroke: "black",
    tickColor: "black"
  },
  axis: {
    labelFontSize: 12,
    labelFontWeight: "normal",
    labelFontFamily: "Arial",
    tickColor: "black",
    labelColor: "black",
    baselineColor: "black",
    gridColor: "black",
    gridStrokeWidth: 1
    //,
    //gridStrokeType: '',
    //gridStrokeDash:
  },
  markCommon: {
    ...GoogleThemeMarkCommonStyle
  },
  point: {
    ...GoogleThemeMarkCommonStyle,
    size: 3
  },
  rect: {
    ...GoogleThemeMarkCommonStyle
  },
  triangle: {
    ...GoogleThemeMarkCommonStyle
  },
  area: {
    ...GoogleThemeMarkCommonStyle
  },
  line: {
    ...GoogleThemeMarkCommonStyle
  },
  bar: {
    ...GoogleThemeMarkCommonStyle
  },
  rule: {
    ...GoogleThemeMarkCommonStyle,
    strokeWidth: 1
  },
  link: {
    ...GoogleThemeMarkCommonStyle,
    strokeWidth: 1
  },
  text: {
    ...GoogleThemeMarkCommonStyle,
    textAnchor: "middle",
    textFontWeight: "normal"
  },
  brush: {
    ...GoogleThemeMarkCommonStyle,
    color: "#999999",
    opacity: 0.3,
    stroke: "black",
    strokeWidth: 0.7
  }
};
const Themes = {
  light,
  dark,
  warm,
  ggplot,
  igv,
  ensembl,
  jbrowse,
  ucsc,
  washu,
  excel,
  google
};
function isThereTheme(key) {
  return Object.keys(Themes).indexOf(key) !== -1;
}
function getTheme$1(key) {
  return isThereTheme(key) ? Themes[key] : Themes["light"];
}
function createPluginTrack(config2, factory2) {
  var _a;
  function Track(...args) {
    if (!new.target) {
      throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
    }
    return factory2(...args);
  }
  Track.config = {
    ...config2,
    availableOptions: Object.keys((_a = config2.defaultOptions) != null ? _a : {})
  };
  return Track;
}
const TICK_WIDTH = 200;
const TICK_HEIGHT = 6;
const TICK_TEXT_SEPARATION = 2;
const TICK_COLOR = 7829367;
const icon$1 = '<svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 5640 5420" preserveAspectRatio="xMidYMid meet"> <g id="layer101" fill="#000000" stroke="none"> <path d="M0 2710 l0 -2710 2820 0 2820 0 0 2710 0 2710 -2820 0 -2820 0 0 -2710z"/> </g> <g id="layer102" fill="#750075" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> <path d="M4340 2710 l0 -2510 560 0 560 0 0 2510 0 2510 -560 0 -560 0 0 -2510z"/> <path d="M200 1870 l0 -1670 630 0 630 0 0 1670 0 1670 -630 0 -630 0 0 -1670z"/> <path d="M1660 1810 l0 -1610 570 0 570 0 0 1610 0 1610 -570 0 -570 0 0 -1610z"/> <path d="M3000 840 l0 -640 570 0 570 0 0 640 0 640 -570 0 -570 0 0 -640z"/> </g> <g id="layer103" fill="#ffff04" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> </g> </svg>';
const config$3 = {
  type: "axis-track",
  datatype: ["multivec", "epilogos"],
  local: false,
  orientation: "1d-horizontal",
  thumbnail: new DOMParser().parseFromString(icon$1, "text/xml").documentElement,
  defaultOptions: {
    innerRadius: 340,
    outerRadius: 310,
    startAngle: 0,
    endAngle: 360,
    width: 700,
    height: 700,
    layout: "linear",
    labelMargin: 5,
    excludeChrPrefix: false,
    labelPosition: "none",
    labelColor: "black",
    labelTextOpacity: 0.4,
    trackBorderWidth: 0,
    trackBorderColor: "black",
    tickPositions: "even",
    fontSize: 12,
    fontFamily: "sans-serif",
    // 'Arial',
    fontWeight: "normal",
    color: "#808080",
    stroke: "#ffffff",
    backgroundColor: "transparent",
    showMousePosition: false,
    tickColor: TICK_COLOR
  }
};
const factory$2 = (HGC, context, options) => {
  const { absToChr, colorToHex: colorToHex2, pixiTextToSvg, svgLine, showMousePosition } = HGC.utils;
  function createTickText(text, style) {
    return Object.assign(new HGC.libraries.PIXI.Text(text, style), { hashValue: Math.random() });
  }
  class AxisTrackClass extends HGC.tracks.PixiTrack {
    constructor() {
      super(context, options);
      __publicField(this, "allTexts");
      __publicField(this, "searchField");
      __publicField(this, "chromInfo");
      __publicField(this, "dataConfig");
      __publicField(this, "pTicksCircular");
      __publicField(this, "pTicks");
      __publicField(this, "gTicks");
      __publicField(this, "tickTexts");
      __publicField(this, "isShowGlobalMousePosition");
      __publicField(this, "pixiTextConfig");
      __publicField(this, "stroke");
      __publicField(this, "tickWidth");
      __publicField(this, "tickHeight");
      __publicField(this, "tickTextSeparation");
      __publicField(this, "tickColor");
      __publicField(this, "animate");
      __publicField(this, "hideMousePosition");
      __publicField(this, "gBoundTicks");
      __publicField(this, "leftBoundTick");
      __publicField(this, "rightBoundTick");
      __publicField(this, "is2d");
      __publicField(this, "texts");
      const { dataConfig, animate, chromInfoPath, isShowGlobalMousePosition } = context;
      this.searchField = null;
      this.dataConfig = dataConfig;
      this.allTexts = [];
      this.pTicksCircular = new HGC.libraries.PIXI.Graphics();
      this.pTicks = new HGC.libraries.PIXI.Graphics();
      this.pMain.addChild(this.pTicks);
      this.pMain.addChild(this.pTicksCircular);
      this.gTicks = {};
      this.tickTexts = {};
      this.options = options;
      this.isShowGlobalMousePosition = isShowGlobalMousePosition;
      this.pixiTextConfig = getTextStyle({
        size: +this.options.fontSize,
        fontFamily: this.options.fontFamily,
        fontWeight: this.options.fontWeight,
        color: this.options.color,
        stroke: this.options.stroke,
        strokeThickness: 2
      });
      this.stroke = colorToHex2(this.pixiTextConfig.stroke);
      this.tickWidth = TICK_WIDTH;
      this.tickHeight = TICK_HEIGHT;
      this.tickTextSeparation = TICK_TEXT_SEPARATION;
      this.tickColor = colorToHex2(this.options.tickColor);
      this.animate = animate;
      this.pubSubs = [];
      if (this.options.showMousePosition && !this.hideMousePosition) {
        this.hideMousePosition = showMousePosition(this, this.is2d, this.isShowGlobalMousePosition());
      }
      let chromSizesPath = chromInfoPath;
      if (!chromSizesPath) {
        chromSizesPath = `${dataConfig.server}/chrom-sizes/?id=${dataConfig.tilesetUid}`;
      }
      const assembly = this.options.assembly;
      const chrPositions = {};
      const chromLengths = { ...computeChromSizes(assembly).size };
      const cumPositions = [];
      Object.keys(computeChromSizes(assembly).size).forEach((k) => {
        chrPositions[k] = { chr: k, pos: computeChromSizes(assembly).size[k] };
      });
      Object.keys(computeChromSizes(assembly).interval).forEach((k) => {
        cumPositions.push({ chr: k, pos: computeChromSizes(assembly).interval[k][0] });
      });
      this.chromInfo = { chrPositions, chromLengths, cumPositions };
      this.rerender(this.options, true);
      this.draw();
      this.animate();
    }
    initBoundsTicks() {
      if (this.pTicks) {
        this.pMain.removeChild(this.pTicks);
        this.pTicks = null;
      }
      if (!this.gBoundTicks) {
        this.gBoundTicks = new HGC.libraries.PIXI.Graphics();
        this.leftBoundTick = createTickText("", this.pixiTextConfig);
        this.rightBoundTick = createTickText("", this.pixiTextConfig);
        this.gBoundTicks.addChild(this.leftBoundTick);
        this.gBoundTicks.addChild(this.rightBoundTick);
        this.pMain.addChild(this.gBoundTicks);
      }
      this.texts = [];
    }
    initChromLabels() {
      if (!this.chromInfo)
        return;
      if (this.gBoundTicks) {
        this.pMain.removeChild(this.gBoundTicks);
        this.gBoundTicks = void 0;
      }
      if (!this.pTicks) {
        this.pTicks = new HGC.libraries.PIXI.Graphics();
        this.pMain.addChild(this.pTicks);
      }
      this.texts = [];
      this.pTicks.removeChildren();
      this.chromInfo.cumPositions.forEach((info) => {
        var _a, _b, _c;
        const chromName = info.chr;
        this.gTicks[chromName] = new HGC.libraries.PIXI.Graphics();
        if (!this.tickTexts[chromName])
          this.tickTexts[chromName] = [];
        const chromNameText = this.options.excludeChrPrefix ? chromName.replace("chr", "") : chromName;
        const text = createTickText(chromNameText, this.pixiTextConfig);
        (_a = this.pTicks) == null ? void 0 : _a.addChild(text);
        (_b = this.pTicks) == null ? void 0 : _b.addChild(this.gTicks[chromName]);
        (_c = this.texts) == null ? void 0 : _c.push(text);
      });
    }
    rerender(options2, force) {
      const strOptions = JSON.stringify(options2);
      if (!force && strOptions === this.prevOptions)
        return;
      this.prevOptions = strOptions;
      this.options = options2;
      this.pixiTextConfig.fontSize = +this.options.fontSize ? `${+this.options.fontSize}px` : this.pixiTextConfig.fontSize;
      this.pixiTextConfig.fill = this.options.color || this.pixiTextConfig.fill;
      this.pixiTextConfig.stroke = this.options.stroke || this.pixiTextConfig.stroke;
      this.stroke = colorToHex2(this.pixiTextConfig.stroke);
      this.tickColor = this.options.tickColor ? colorToHex2(this.options.tickColor) : TICK_COLOR;
      if (this.options.tickPositions === "ends" && this.options.layout !== "circular") {
        this.initBoundsTicks();
      } else {
        this.initChromLabels();
      }
      super.rerender(options2, force);
      if (this.options.showMousePosition && !this.hideMousePosition) {
        this.hideMousePosition = showMousePosition(this, this.is2d, this.isShowGlobalMousePosition());
      }
      if (!this.options.showMousePosition && this.hideMousePosition) {
        this.hideMousePosition();
        this.hideMousePosition = void 0;
      }
    }
    formatTick(pos) {
      if (isNaN(pos)) {
        return "null";
      }
      const domain = this._xScale.domain();
      const viewWidth = domain[1] - domain[0];
      const p = precisionPrefix(pos, viewWidth);
      const fPlain = format$1(",");
      const fPrecision = formatPrefix(`,.${p}`, viewWidth);
      let f = fPlain;
      if (this.options.tickFormat === "si") {
        f = fPrecision;
      } else if (this.options.tickFormat === "plain") {
        f = fPlain;
      } else if (this.options.tickPositions === "ends") {
        f = fPrecision;
      }
      return f(pos);
    }
    /** Show two labels at the end of both left and right sides */
    drawBoundsTicks(x1, x2) {
      if (!this.gBoundTicks || !this.leftBoundTick || !this.rightBoundTick)
        return;
      const graphics = this.gBoundTicks;
      graphics.clear();
      graphics.lineStyle(1, 0);
      const lineYStart = this.options.reverseOrientation ? 0 : this.dimensions[1];
      const lineYEnd = this.options.reverseOrientation ? this.tickHeight : this.dimensions[1] - this.tickHeight;
      graphics.moveTo(1, lineYStart);
      graphics.lineTo(1, lineYEnd);
      graphics.moveTo(this.dimensions[0] - 1, lineYStart);
      graphics.lineTo(this.dimensions[0] - 1, lineYEnd);
      this.leftBoundTick.x = 0;
      this.leftBoundTick.y = this.options.reverseOrientation ? lineYEnd + this.tickTextSeparation : lineYEnd - this.tickTextSeparation;
      this.leftBoundTick.text = this.options.assembly === "unknown" ? `${this.formatTick(x1[1])}` : `${x1[0]}: ${this.formatTick(x1[1])}`;
      this.leftBoundTick.anchor.y = this.options.reverseOrientation ? 0 : 1;
      this.rightBoundTick.x = this.dimensions[0];
      this.rightBoundTick.text = this.options.assembly === "unknown" ? `${this.formatTick(x2[1])}` : `${x2[0]}: ${this.formatTick(x2[1])}`;
      this.rightBoundTick.y = this.options.reverseOrientation ? lineYEnd + this.tickTextSeparation : lineYEnd - this.tickTextSeparation;
      this.rightBoundTick.anchor.y = this.options.reverseOrientation ? 0 : 1;
      this.rightBoundTick.anchor.x = 1;
      if (this.flipText) {
        this.leftBoundTick.scale.x = -1;
        this.leftBoundTick.anchor.x = 1;
        this.rightBoundTick.scale.x = -1;
        this.rightBoundTick.anchor.x = 0;
      }
      this.leftBoundTick.tickLine = [1, this.dimensions[1], 1, this.dimensions[1] - this.tickHeight];
      this.rightBoundTick.tickLine = [
        this.dimensions[0] - 1,
        this.dimensions[1],
        this.dimensions[0] - 1,
        this.dimensions[1] - this.tickHeight
      ];
      this.tickTexts = {};
      this.tickTexts.all = [this.leftBoundTick, this.rightBoundTick];
    }
    drawTicks(cumPos) {
      const graphics = this.gTicks[cumPos.chr];
      graphics.visible = true;
      graphics.clear();
      const chromLen = +this.chromInfo.chromLengths[cumPos.chr];
      const vpLeft = Math.max(this._xScale(cumPos.pos), 0);
      const vpRight = Math.min(this._xScale(cumPos.pos + chromLen), this.dimensions[0]);
      const numTicks = (vpRight - vpLeft) / this.tickWidth;
      const xScale = scaleLinear().domain([
        Math.max(1, this._xScale.invert(0) - cumPos.pos),
        Math.min(chromLen, this._xScale.invert(this.dimensions[0]) - cumPos.pos)
      ]).range([vpLeft, vpRight]);
      const ticks = xScale.ticks(numTicks).filter((tick) => Number.isInteger(tick));
      const tickTexts = this.tickTexts[cumPos.chr];
      const tickHeight = this.tickHeight;
      const xPadding = 0;
      let yPadding = tickHeight + this.tickTextSeparation;
      if (this.options.reverseOrientation) {
        yPadding = this.dimensions[1] - yPadding;
      }
      while (tickTexts.length < ticks.length) {
        const newText = createTickText("", this.pixiTextConfig);
        tickTexts.push(newText);
        this.gTicks[cumPos.chr].addChild(newText);
      }
      while (tickTexts.length > ticks.length) {
        const text = tickTexts.pop();
        this.gTicks[cumPos.chr].removeChild(text);
      }
      let i = 0;
      while (i < ticks.length) {
        tickTexts[i].visible = true;
        tickTexts[i].anchor.x = 0.5;
        tickTexts[i].anchor.y = this.options.layout === "circular" ? 0 : this.options.reverseOrientation ? 0 : 1;
        if (this.flipText)
          tickTexts[i].scale.x = -1;
        const chrText = this.options.assembly === "unknown" ? "" : `${cumPos.chr}: `;
        tickTexts[i].text = ticks[i] === 0 ? `${chrText}1` : `${chrText}${this.formatTick(ticks[i])}`;
        const x = this._xScale(cumPos.pos + ticks[i]);
        if (this.options.layout === "circular") {
          const rope = this.addCurvedText(tickTexts[i], x + xPadding);
          rope && this.pTicksCircular.addChild(rope);
        } else {
          tickTexts[i].x = x + xPadding;
          tickTexts[i].y = this.dimensions[1] - yPadding;
          tickTexts[i].tickLine = [x - 1, this.dimensions[1], x - 1, this.dimensions[1] - tickHeight - 1];
          const lineYStart = this.options.reverseOrientation ? 0 : this.dimensions[1];
          const lineYEnd = this.options.reverseOrientation ? tickHeight : this.dimensions[1] - tickHeight;
          graphics.lineStyle(1, this.tickColor);
          graphics.moveTo(x, lineYStart);
          graphics.lineTo(x, lineYEnd);
        }
        i += 1;
      }
      if (this.options.layout === "circular")
        i = 0;
      while (i < tickTexts.length) {
        tickTexts[i].visible = false;
        i += 1;
      }
      return ticks.length;
    }
    addCurvedText(textObj, cx) {
      const [width, height] = this.dimensions;
      const { startAngle, endAngle } = this.options;
      const factor = Math.min(width, height) / Math.min(this.options.width, this.options.height);
      const innerRadius = this.options.innerRadius * factor;
      const outerRadius = this.options.outerRadius * factor;
      const r = (outerRadius + innerRadius) / 2;
      const centerPos = cartesianToPolar(cx, width, r, width / 2, height / 2, startAngle, endAngle);
      textObj.x = centerPos.x;
      textObj.y = centerPos.y;
      textObj.resolution = 4;
      const txtStyle = new HGC.libraries.PIXI.TextStyle(this.pixiTextConfig);
      const metric = HGC.libraries.PIXI.TextMetrics.measureText(textObj.text, txtStyle);
      const tw = metric.width / (2 * r * Math.PI) * width * 360 / (endAngle - startAngle);
      let [minX, maxX] = [cx - tw / 2, cx + tw / 2];
      if (minX < 0) {
        const gap = -minX;
        minX = 0;
        maxX += gap;
      } else if (maxX > width) {
        const gap = maxX - width;
        maxX = width;
        minX -= gap;
      }
      const ropePoints = [];
      const baseR = innerRadius + metric.height / 2 + 3;
      for (let i = maxX; i >= minX; i -= tw / 10) {
        const p = cartesianToPolar(i, width, baseR, width / 2, height / 2, startAngle, endAngle);
        ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
      }
      if (ropePoints.length === 0) {
        return void 0;
      }
      textObj.updateText();
      const rope = new HGC.libraries.PIXI.SimpleRope(textObj.texture, ropePoints);
      return rope;
    }
    draw() {
      this.allTexts = [];
      if (!this.texts)
        return;
      const x1 = absToChr(this._xScale.domain()[0], this.chromInfo);
      const x2 = absToChr(this._xScale.domain()[1], this.chromInfo);
      if (!x1 || !x2) {
        console.warn("Empty chromInfo:", this.dataConfig, this.chromInfo);
        return;
      }
      if (this.options.tickPositions === "ends" && this.options.layout !== "circular") {
        if (!this.gBoundTicks)
          return;
        this.gBoundTicks.visible = true;
        this.drawBoundsTicks(x1, x2);
        return;
      }
      if (!this.pTicks) {
        return;
      }
      const circular = this.options.layout === "circular";
      for (let i = 0; i < this.texts.length; i++) {
        this.texts[i].visible = false;
        this.gTicks[this.chromInfo.cumPositions[i].chr].visible = false;
      }
      let yPadding = this.tickHeight + this.tickTextSeparation;
      if (this.options.reverseOrientation) {
        yPadding = this.dimensions[1] - yPadding;
      }
      Object.keys(this.chromInfo.chrPositions).forEach((chrom) => {
        if (this.tickTexts[chrom]) {
          this.tickTexts[chrom].forEach((tick) => {
            tick.visible = false;
          });
        }
      });
      this.pTicksCircular.removeChildren();
      for (let i = x1[3]; i <= x2[3]; i++) {
        const xCumPos = this.chromInfo.cumPositions[i];
        const midX = xCumPos.pos + this.chromInfo.chromLengths[xCumPos.chr] / 2;
        const viewportMidX = this._xScale(midX);
        const chrText = this.texts[i];
        chrText.anchor.x = 0.5;
        chrText.anchor.y = circular ? 0.5 : this.options.reverseOrientation ? 0 : 1;
        let rope;
        if (circular) {
          rope = this.addCurvedText(chrText, viewportMidX);
          if (rope) {
            this.pTicksCircular.addChild(rope);
          }
        } else {
          chrText.x = viewportMidX;
          chrText.y = this.dimensions[1] - yPadding;
        }
        chrText.updateTransform();
        if (this.flipText)
          chrText.scale.x = -1;
        const numTicksDrawn = this.drawTicks(xCumPos);
        if (!circular) {
          chrText.visible = numTicksDrawn <= 0;
        } else {
          if (numTicksDrawn > 0) {
            rope && this.pTicksCircular.removeChild(rope);
          }
        }
        this.allTexts.push({
          importance: chrText.hashValue,
          text: chrText,
          rope
        });
      }
      this.hideOverlaps(this.allTexts);
    }
    hideOverlaps(allTexts) {
      const tree = new RBush();
      allTexts.sort((a, b) => b.importance - a.importance).forEach(({ text, rope }) => {
        text.updateTransform();
        const b = text.getBounds();
        const m2 = this.options.labelMargin;
        const boxWithMargin = {
          minX: b.x - m2,
          minY: b.y - m2,
          maxX: b.x + b.width + m2 * 2,
          maxY: b.y + b.height + m2 * 2
        };
        if (m2 < 0 || !tree.collides(boxWithMargin)) {
          tree.insert(boxWithMargin);
        } else {
          text.visible = false;
          if (this.options.layout === "circular" && rope) {
            this.pTicksCircular.removeChild(rope);
          }
        }
      });
    }
    setPosition(newPosition) {
      super.setPosition(newPosition);
      [this.pMain.position.x, this.pMain.position.y] = this.position;
    }
    zoomed(newXScale, newYScale) {
      const domainValues = [...newXScale.domain(), ...newYScale.domain()];
      if (domainValues.filter((d) => isNaN(d)).length !== 0) {
        return;
      }
      this.xScale(newXScale);
      this.yScale(newYScale);
      this.draw();
    }
    exportSVG() {
      let track = null;
      let base = null;
      if (super.exportSVG) {
        [base, track] = super.exportSVG();
      } else {
        base = document.createElement("g");
        track = base;
      }
      base.setAttribute("class", "chromosome-labels");
      const output = document.createElement("g");
      track.appendChild(output);
      output.setAttribute("transform", `translate(${this.position[0]},${this.position[1]})`);
      this.allTexts.filter((text) => text.text.visible).forEach((text) => {
        const g = pixiTextToSvg(text.text);
        output.appendChild(g);
      });
      Object.values(this.tickTexts).forEach((texts) => {
        texts.filter((x) => x.visible).forEach((text) => {
          if (!text.tickLine)
            return;
          let g = pixiTextToSvg(text);
          output.appendChild(g);
          g = svgLine(
            text.x,
            this.options.reverseOrientation ? 0 : this.dimensions[1],
            text.x,
            this.options.reverseOrientation ? this.tickHeight : this.dimensions[1] - this.tickHeight,
            1,
            this.tickColor
          );
          const line = document.createElement("line");
          line.setAttribute("x1", String(text.tickLine[0]));
          line.setAttribute("y1", String(text.tickLine[1]));
          line.setAttribute("x2", String(text.tickLine[2]));
          line.setAttribute("y2", String(text.tickLine[3]));
          line.setAttribute("style", "stroke: grey");
          output.appendChild(g);
          output.appendChild(line);
        });
      });
      return [base, track];
    }
  }
  return new AxisTrackClass();
};
const AxisTrack = createPluginTrack(config$3, factory$2);
function BrushTrack(HGC, ...args) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  class BrushTrackClass extends HGC.tracks.SVGTrack {
    constructor(params) {
      var _a, _b;
      super(...params);
      __publicField(this, "circularBrushData");
      __publicField(this, "prevExtent");
      const [context, options] = params;
      const { registerViewportChanged, removeViewportChanged, setDomainsCallback } = context;
      this.uid = uuid();
      this.options = options;
      this.hasFromView = !context.projectionXDomain;
      this.removeViewportChanged = removeViewportChanged;
      this.setDomainsCallback = setDomainsCallback;
      this.viewportXDomain = this.hasFromView ? null : context.projectionXDomain;
      this.viewportYDomain = this.hasFromView ? null : [0, 0];
      this.prevExtent = [0, 0];
      this.RR = 0.02;
      const extent = [0, Math.PI * 1.7];
      this.circularBrushData = this.getBrushData(extent);
      this.brush = arc().innerRadius((_a = this.options.innerRadius) != null ? _a : 100).outerRadius((_b = this.options.outerRadius) != null ? _b : 200);
      this.gBrush = this.gMain.append("g").attr("id", `brush-${this.uid}`).selectAll(".brush").data(this.circularBrushData).enter().append("path").attr("class", "brush").attr("d", this.brush).attr("fill", this.options.projectionFillColor).attr("stroke", this.options.projectionStrokeColor).attr(
        "fill-opacity",
        (d) => d.type === "brush" ? this.options.projectionFillOpacity : 0
      ).attr(
        "stroke-opacity",
        (d) => d.type === "brush" ? this.options.projectionStrokeOpacity : 0
      ).attr("stroke-width", this.options.strokeWidth).style("pointer-events", "all").style("cursor", (d) => d.cursor).call(this.dragged());
      registerViewportChanged(this.uid, this.viewportChanged.bind(this));
      this.draw();
    }
    /**
     * Get information for circular brush for given extent of angle.
     */
    getBrushData(extent) {
      return [
        {
          type: "brush",
          startAngle: extent[0],
          endAngle: extent[1],
          cursor: "grab"
        },
        {
          type: "start",
          startAngle: extent[0],
          endAngle: extent[0] + this.RR,
          cursor: "move"
        },
        {
          type: "end",
          startAngle: extent[1] - this.RR,
          endAngle: extent[1],
          cursor: "move"
        }
      ];
    }
    cropExtent(extent) {
      let [s, e] = extent;
      let round = 0;
      while (s > Math.PI * 2 || e > Math.PI * 2 || s < 0 || e < 0) {
        if (round++ > 10) {
          break;
        }
        if (s > Math.PI * 2 || e > Math.PI * 2) {
          s -= Math.PI * 2;
          e -= Math.PI * 2;
        } else if (s < 0 || e < 0) {
          s += Math.PI * 2;
          e += Math.PI * 2;
        }
      }
      return [s, e].sort((a, b) => a - b);
    }
    /**
     * Update the position and size of brush.
     */
    updateBrush(extent) {
      let [s, e] = extent;
      if (s <= RADIAN_GAP && e <= RADIAN_GAP || s >= Math.PI * 2 - RADIAN_GAP && e >= Math.PI * 2 - RADIAN_GAP) {
        this.gBrush.attr("visibility", "hidden");
        return;
      }
      if (s < RADIAN_GAP) {
        s = RADIAN_GAP;
      }
      if (s > Math.PI * 2 - RADIAN_GAP) {
        s = Math.PI * 2 - RADIAN_GAP;
      }
      if (e < RADIAN_GAP) {
        e = RADIAN_GAP;
      }
      if (e > Math.PI * 2 - RADIAN_GAP) {
        e = Math.PI * 2 - RADIAN_GAP;
      }
      this.circularBrushData = this.getBrushData(extent);
      this.gBrush.data(this.circularBrushData).attr("d", this.brush).attr("visibility", "visible");
    }
    /**
     * Function to call upon hearing click event on the brush
     */
    dragged() {
      const start = (event) => {
        this.startEvent = event.sourceEvent;
        this.prevExtent = [this.circularBrushData[0].startAngle, this.circularBrushData[0].endAngle];
      };
      const drag = (event, d) => {
        const [x, y] = this.position;
        const [w, h] = this.dimensions;
        const endEvent = event.sourceEvent;
        const startX = this.startEvent.layerX - x;
        const startY = this.startEvent.layerY - y;
        const endX = endEvent.layerX - x;
        const endY = endEvent.layerY - y;
        const radDiff = (
          // radian of the start position
          Math.atan2(startX - w / 2, startY - h / 2) - // radian of the current position
          Math.atan2(endX - w / 2, endY - h / 2)
        );
        let [s, e] = this.prevExtent;
        if (d.type === "brush") {
          s = s + radDiff;
          e = e + radDiff;
          if (s < RADIAN_GAP || Math.PI * 2 - RADIAN_GAP < e) {
            const sto = RADIAN_GAP - s;
            const eto = e - (Math.PI * 2 - RADIAN_GAP);
            if (sto > eto) {
              e += sto;
              s += sto;
            } else {
              s -= eto;
              e -= eto;
            }
          }
        } else if (d.type === "start") {
          s = s + radDiff;
        } else if (d.type === "end") {
          e = e + radDiff;
        }
        [s, e] = this.cropExtent([s, e]);
        if (!this._xScale || !this._yScale) {
          return;
        }
        const scale = (this.options.endAngle - this.options.startAngle) / 360;
        const offsetedS = s - this.options.startAngle / 360 * Math.PI * 2;
        const offsetedE = e - this.options.startAngle / 360 * Math.PI * 2;
        const xDomain = [
          this._xScale.invert(w - w * offsetedE / (Math.PI * 2 * scale)),
          this._xScale.invert(w - w * offsetedS / (Math.PI * 2 * scale))
        ];
        const yDomain = this.viewportYDomain;
        if (!this.hasFromView) {
          this.viewportXDomain = xDomain;
        }
        this.setDomainsCallback(xDomain, yDomain);
        this.updateBrush([s, e]);
      };
      return HGC.libraries.d3Drag.drag().on("start", start).on("drag", drag);
    }
    draw() {
      if (!this._xScale || !this.yScale) {
        return;
      }
      if (!this.viewportXDomain || !this.viewportYDomain) {
        return;
      }
      const x0 = this._xScale(this.viewportXDomain[0]);
      const x1 = this._xScale(this.viewportXDomain[1]);
      const [w] = this.dimensions;
      let e = valueToRadian(x0, w, this.options.startAngle, this.options.endAngle) + Math.PI / 2;
      let s = valueToRadian(x1, w, this.options.startAngle, this.options.endAngle) + Math.PI / 2;
      [s, e] = this.cropExtent([s, e]);
      this.updateBrush([s, e]);
    }
    viewportChanged(viewportXScale, viewportYScale) {
      const viewportXDomain = viewportXScale.domain();
      const viewportYDomain = viewportYScale.domain();
      this.viewportXDomain = viewportXDomain;
      this.viewportYDomain = viewportYDomain;
      this.draw();
    }
    remove() {
      this.removeViewportChanged(this.uid);
      super.remove();
    }
    rerender() {
    }
    zoomed(newXScale, newYScale) {
      this.xScale(newXScale);
      this.yScale(newYScale);
      this.draw();
    }
    setPosition(newPosition) {
      super.setPosition(newPosition);
      this.draw();
    }
    setDimensions(newDimensions) {
      super.setDimensions(newDimensions);
      this.gBrush.attr("transform", `translate(${newDimensions[0] / 2},${newDimensions[1] / 2})`);
      this.draw();
    }
  }
  return new BrushTrackClass(args);
}
const icon = '<svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 5640 5420" preserveAspectRatio="xMidYMid meet"> <g id="layer101" fill="#000000" stroke="none"> <path d="M0 2710 l0 -2710 2820 0 2820 0 0 2710 0 2710 -2820 0 -2820 0 0 -2710z"/> </g> <g id="layer102" fill="#750075" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> <path d="M4340 2710 l0 -2510 560 0 560 0 0 2510 0 2510 -560 0 -560 0 0 -2510z"/> <path d="M200 1870 l0 -1670 630 0 630 0 0 1670 0 1670 -630 0 -630 0 0 -1670z"/> <path d="M1660 1810 l0 -1610 570 0 570 0 0 1610 0 1610 -570 0 -570 0 0 -1610z"/> <path d="M3000 840 l0 -640 570 0 570 0 0 640 0 640 -570 0 -570 0 0 -640z"/> </g> <g id="layer103" fill="#ffff04" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> </g> </svg>';
BrushTrack.config = {
  type: "brush-track",
  datatype: ["projection"],
  local: false,
  // TODO:
  projection: true,
  orientation: "2d",
  thumbnail: new DOMParser().parseFromString(icon, "text/xml").documentElement,
  availableOptions: [
    "innerRadius",
    "outerRadius",
    "startAngle",
    "endAngle",
    "axisPositionHorizontal",
    "projectionFillColor",
    "projectionStrokeColor",
    "projectionFillOpacity",
    "projectionStrokeOpacity",
    "strokeWidth"
  ],
  defaultOptions: {
    innerRadius: 100,
    outerRadius: 200,
    startAngle: 0,
    endAngle: 360,
    axisPositionHorizontal: "left",
    projectionFillColor: "#777",
    projectionStrokeColor: "#777",
    projectionFillOpacity: 0.3,
    projectionStrokeOpacity: 0.7,
    strokeWidth: 1
  }
};
const HIDDEN_BRUSH_EDGE_SIZE = 3;
const BRUSH_STYLE_DEFAULT = {
  color: "#777",
  stroke: "#777",
  strokeWidth: 1,
  strokeOpacity: 0.7,
  opacity: 0.3
};
class LinearBrushModel {
  constructor(selection, hgLibraries, style = {}) {
    /* graphical elements */
    __publicField(this, "brushSelection");
    __publicField(this, "style");
    /* data */
    __publicField(this, "range");
    __publicField(this, "data");
    /* drag */
    __publicField(this, "startEvent");
    __publicField(this, "prevExtent");
    /* visual parameters */
    __publicField(this, "offset");
    __publicField(this, "size");
    // fixed size of one-dimension of a brush (e.g., height)
    /* External libraries that we re-use from HiGlass */
    __publicField(this, "externals");
    __publicField(this, "emitter");
    this.emitter = createNanoEvents();
    this.range = null;
    this.prevExtent = [0, 0];
    this.data = this.rangeToData(0, 0);
    this.offset = [0, 0];
    this.size = 0;
    this.externals = {
      d3Selection: hgLibraries.d3Selection,
      d3Drag: hgLibraries.d3Drag
    };
    this.style = Object.assign({}, BRUSH_STYLE_DEFAULT, style);
    this.brushSelection = selection.selectAll(".genomic-range-brush").data(this.data).enter().append("rect").attr("class", "genomic-range-brush").call(this.onDrag());
  }
  getRange() {
    return this.range;
  }
  setSize(size) {
    this.size = size;
    return this;
  }
  /**
   * Update the left and top offsets for drawing the brush.
   */
  setOffset(offsetX, offsetY) {
    this.offset = [offsetX, offsetY];
    return this;
  }
  /**
   * Update brush data based on the positions of two edges.
   */
  updateRange(range) {
    if (range) {
      this.range = [Math.min(...range), Math.max(...range)];
      this.data = this.rangeToData(...this.range);
    } else {
      this.range = null;
    }
    return this;
  }
  /**
   * Update the brush using the internal range value. By default,
   * This function calls a render function from gosling-track.
   */
  drawBrush(skipApiTrigger = false) {
    const [x, y] = this.offset;
    const height = this.size;
    const getWidth = (d) => Math.abs(d.end - d.start);
    this.brushSelection.data(this.data).attr("transform", (d) => `translate(${x + d.start}, ${y + 1})`).attr("width", (d) => `${getWidth(d)}px`).attr("height", `${height - 2}px`).attr("fill", this.style.color).attr("stroke", this.style.stroke).attr("stroke-width", `${this.style.strokeWidth}px`).attr("fill-opacity", (d) => d.type === "body" ? this.style.opacity : 0).attr("stroke-opacity", (d) => d.type === "body" ? this.style.strokeOpacity : 0).attr("cursor", (d) => d.cursor);
    this.emitter.emit("brush", this.getRange(), skipApiTrigger);
    return this;
  }
  enable() {
    this.brushSelection.attr("pointer-events", "all");
    return this;
  }
  disable() {
    this.brushSelection.attr("pointer-events", "none");
    return this;
  }
  visible() {
    this.brushSelection.attr("visibility", "visible");
    return this;
  }
  hidden() {
    this.brushSelection.attr("visibility", "hidden");
    return this;
  }
  clear() {
    this.updateRange(null).drawBrush().hidden().disable();
    return this;
  }
  remove() {
    this.brushSelection.remove();
    return this;
  }
  /**
   * Based on the extent values, generate a JSON object for the brush.
   */
  rangeToData(start, end) {
    return [
      {
        type: "body",
        cursor: "grab",
        start,
        end
      },
      {
        type: "start",
        cursor: "ew-resize",
        start: start - HIDDEN_BRUSH_EDGE_SIZE,
        end: start
      },
      {
        type: "end",
        cursor: "ew-resize",
        start: end,
        end: end + HIDDEN_BRUSH_EDGE_SIZE
      }
    ];
  }
  onDrag() {
    const started = (event) => {
      this.startEvent = event.sourceEvent;
      this.prevExtent = this.range;
    };
    const dragged = (event, d) => {
      var _a;
      const delta = event.sourceEvent.layerX - this.startEvent.layerX;
      let [s, e] = (_a = this.prevExtent) != null ? _a : [0, 0];
      if (d.type === "body") {
        s += delta;
        e += delta;
      } else if (d.type === "start") {
        s += delta;
      } else if (d.type === "end") {
        e += delta;
      }
      this.updateRange([s, e]).drawBrush();
    };
    return this.externals.d3Drag.drag().on("start", started).on("drag", dragged);
  }
  on(event, callback) {
    this.emitter.on(event, callback);
  }
}
const isPointInsideDonutSlice = ([x, y], [cx, cy], [innerRadius, outerRadius], [startAngle, endAngle]) => {
  const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
  if (dist < innerRadius || outerRadius < dist) {
    return false;
  }
  const degree = pointsToDegree(x, y, cx, cy);
  if (degree < startAngle || endAngle < degree) {
    return false;
  }
  return true;
};
const isPointNearPoint = ([x1, y1], [x2, y2], radius = 5) => {
  return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) < radius;
};
const isPointInsideRange = ([x1, x2], x) => {
  return x1 <= x && x <= x2;
};
const isCircleWithinRange = (range, x, radius = 5) => {
  return isPointInsideRange(range, x - radius) && isPointInsideRange(range, x + radius);
};
const isAllPointsWithinRange = (range, path) => {
  return path.filter((_, i) => i % 2 === 0).every((x) => isPointInsideRange(range, x));
};
const isPointNearLine = ([x, y], path, dist = 5) => {
  let x1;
  let y1;
  let x2;
  let y2;
  let isWithin = false;
  for (let i = 0; i < path.length - 2; i += 2) {
    x1 = path[i];
    y1 = path[i + 1];
    x2 = path[i + 2];
    y2 = path[i + 3];
    const AB = [x2 - x1, y2 - y1];
    const BE = [x - x2, y - y2];
    const AE = [x - x1, y - y1];
    const AB_BE = AB[0] * BE[0] + AB[1] * BE[1];
    const AB_AE = AB[0] * AE[0] + AB[1] * AE[1];
    let actDist = 0;
    if (AB_BE > 0) {
      actDist = Math.sqrt((y - y2) ** 2 + (x - x2) ** 2);
    } else if (AB_AE < 0) {
      actDist = Math.sqrt((y - y1) ** 2 + (x - x1) ** 2);
    } else {
      actDist = Math.abs(AB[0] * AE[1] - AB[1] * AE[0]) / Math.sqrt(AB[0] ** 2 + AB[1] ** 2);
    }
    if (actDist < dist) {
      isWithin = true;
    }
  }
  return isWithin;
};
const isPointInPolygon = ([x, y], polygon) => {
  let x1;
  let y1;
  let x2;
  let y2;
  let isWithin = false;
  for (let i = 0, j = polygon.length - 2; i < polygon.length; i += 2) {
    x1 = polygon[i];
    y1 = polygon[i + 1];
    x2 = polygon[j];
    y2 = polygon[j + 1];
    if (y1 > y !== y2 > y && x < (x2 - x1) * (y - y1) / (y2 - y1) + x1) {
      isWithin = !isWithin;
    }
    j = i;
  }
  return isWithin;
};
class MouseEventModel {
  constructor() {
    // main data that this model manage
    __publicField(this, "data");
    this.data = [];
  }
  /**
   * Access the number of mouse events stored.
   */
  size() {
    return this.data.length;
  }
  /**
   * Add a new mouse event that is polygon-based.
   */
  addPolygonBasedEvent(value, polygon) {
    this.data.push({ uid: uuid(), type: "polygon", value, polygon });
  }
  /**
   * Add a new mouse event that is point-based.
   */
  addPointBasedEvent(value, pointAndRadius) {
    this.data.push({ uid: uuid(), type: "point", value, polygon: pointAndRadius });
  }
  /**
   * Add a new mouse event that is line-based.
   */
  addLineBasedEvent(value, path) {
    this.data.push({ uid: uuid(), type: "line", value, polygon: path });
  }
  /**
   * Make the data array empty.
   */
  clear() {
    this.data = [];
  }
  /**
   * Find the first event data that is within the mouse position.
   */
  find(x, y, reverse = false) {
    const _ = Array.from(this.data);
    if (reverse)
      _.reverse();
    return _.find((d) => this.isMouseWithin(d, x, y));
  }
  /**
   * Find all event data that is within the mouse position.
   */
  findAll(x, y, reverse = false) {
    const _ = Array.from(this.data);
    if (reverse)
      _.reverse();
    return _.filter((d) => this.isMouseWithin(d, x, y));
  }
  /**
   * Find all event data that matches the id values in the source and return them.
   */
  getSiblings(source, idField) {
    const siblings = [];
    const sourceUids = Array.from(new Set(source.map((d) => d.uid)));
    source.forEach((s) => {
      const id = s.value[idField];
      if (id) {
        siblings.push(...this.data.filter((_) => _.value[idField] === id && sourceUids.indexOf(_.uid) === -1));
      }
    });
    return siblings;
  }
  /**
   * Test if a mouse position is within a given object.
   */
  isMouseWithin(data2, x, y) {
    switch (data2.type) {
      case "point":
        return isPointNearPoint([x, y], data2.polygon);
      case "line":
        return isPointNearLine([x, y], data2.polygon);
      case "polygon":
      default:
        return isPointInPolygon([x, y], data2.polygon);
    }
  }
  /**
   * Find all event data that is within the range along the x-axis.
   */
  findAllWithinRange(x1, x2, reverse = false) {
    const _ = Array.from(this.data);
    if (reverse)
      _.reverse();
    return _.filter((d) => this.isWithinRange(d, x1, x2));
  }
  /**
   * Test if a given object is within an 1D range.
   */
  isWithinRange(data2, x1, x2) {
    switch (data2.type) {
      case "point":
        return isCircleWithinRange([x1, x2], data2.polygon[0], data2.polygon[2]);
      case "line":
      case "polygon":
      default:
        return isAllPointsWithinRange([x1, x2], data2.polygon);
    }
  }
}
const encodedJs$3 = "KCgpID0+IHsKICB2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlOwogIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgdmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwogIHZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzOwogIHZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CiAgdmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogIHZhciBfX2VzbSA9IChmbiwgcmVzKSA9PiBmdW5jdGlvbiBfX2luaXQoKSB7CiAgICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltPYmplY3Qua2V5cyhmbilbMF1dKShmbiA9IDApKSwgcmVzOwogIH07CiAgdmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkgewogICAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbT2JqZWN0LmtleXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7CiAgfTsKICB2YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZSwgZGVzYykgPT4gewogICAgaWYgKG1vZHVsZSAmJiB0eXBlb2YgbW9kdWxlID09PSAib2JqZWN0IiB8fCB0eXBlb2YgbW9kdWxlID09PSAiZnVuY3Rpb24iKSB7CiAgICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUpKQogICAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gImRlZmF1bHQiKQogICAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7CiAgICB9CiAgICByZXR1cm4gdGFyZ2V0OwogIH07CiAgdmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlKSA9PiB7CiAgICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlKSkgOiB7fSwgImRlZmF1bHQiLCBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgJiYgImRlZmF1bHQiIGluIG1vZHVsZSA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlKTsKICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vYmFzZTY0LWpzQDEuNS4xL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMKICB2YXIgcmVxdWlyZV9iYXNlNjRfanMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYmFzZTY0LWpzQDEuNS4xL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7CiAgICAgIGV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheTsKICAgICAgZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheTsKICAgICAgdmFyIGxvb2t1cCA9IFtdOwogICAgICB2YXIgcmV2TG9va3VwID0gW107CiAgICAgIHZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gInVuZGVmaW5lZCIgPyBVaW50OEFycmF5IDogQXJyYXk7CiAgICAgIHZhciBjb2RlID0gIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iOwogICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgbG9va3VwW2ldID0gY29kZVtpXTsKICAgICAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7CiAgICAgIH0KICAgICAgdmFyIGk7CiAgICAgIHZhciBsZW47CiAgICAgIHJldkxvb2t1cFsiLSIuY2hhckNvZGVBdCgwKV0gPSA2MjsKICAgICAgcmV2TG9va3VwWyJfIi5jaGFyQ29kZUF0KDApXSA9IDYzOwogICAgICBmdW5jdGlvbiBnZXRMZW5zKGI2NCkgewogICAgICAgIHZhciBsZW4yID0gYjY0Lmxlbmd0aDsKICAgICAgICBpZiAobGVuMiAlIDQgPiAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQiKTsKICAgICAgICB9CiAgICAgICAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoIj0iKTsKICAgICAgICBpZiAodmFsaWRMZW4gPT09IC0xKQogICAgICAgICAgdmFsaWRMZW4gPSBsZW4yOwogICAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuMiA/IDAgOiA0IC0gdmFsaWRMZW4gJSA0OwogICAgICAgIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChiNjQpIHsKICAgICAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTsKICAgICAgICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdOwogICAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdOwogICAgICAgIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7CiAgICAgICAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiB0b0J5dGVBcnJheShiNjQpIHsKICAgICAgICB2YXIgdG1wOwogICAgICAgIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpOwogICAgICAgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07CiAgICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07CiAgICAgICAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSk7CiAgICAgICAgdmFyIGN1ckJ5dGUgPSAwOwogICAgICAgIHZhciBsZW4yID0gcGxhY2VIb2xkZXJzTGVuID4gMCA/IHZhbGlkTGVuIC0gNCA6IHZhbGlkTGVuOwogICAgICAgIHZhciBpMjsKICAgICAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW4yOyBpMiArPSA0KSB7CiAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAxOCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA8PCAxMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA8PCA2IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMyldOwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gMTYgJiAyNTU7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7CiAgICAgICAgfQogICAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHsKICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPj4gNDsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1OwogICAgICAgIH0KICAgICAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7CiAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAxMCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA8PCA0IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMildID4+IDI7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bSkgewogICAgICAgIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgNjNdICsgbG9va3VwW251bSA+PiAxMiAmIDYzXSArIGxvb2t1cFtudW0gPj4gNiAmIDYzXSArIGxvb2t1cFtudW0gJiA2M107CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW5jb2RlQ2h1bmsodWludDgsIHN0YXJ0LCBlbmQpIHsKICAgICAgICB2YXIgdG1wOwogICAgICAgIHZhciBvdXRwdXQgPSBbXTsKICAgICAgICBmb3IgKHZhciBpMiA9IHN0YXJ0OyBpMiA8IGVuZDsgaTIgKz0gMykgewogICAgICAgICAgdG1wID0gKHVpbnQ4W2kyXSA8PCAxNiAmIDE2NzExNjgwKSArICh1aW50OFtpMiArIDFdIDw8IDggJiA2NTI4MCkgKyAodWludDhbaTIgKyAyXSAmIDI1NSk7CiAgICAgICAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvdXRwdXQuam9pbigiIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSh1aW50OCkgewogICAgICAgIHZhciB0bXA7CiAgICAgICAgdmFyIGxlbjIgPSB1aW50OC5sZW5ndGg7CiAgICAgICAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4yICUgMzsKICAgICAgICB2YXIgcGFydHMgPSBbXTsKICAgICAgICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsKICAgICAgICBmb3IgKHZhciBpMiA9IDAsIGxlbjIyID0gbGVuMiAtIGV4dHJhQnl0ZXM7IGkyIDwgbGVuMjI7IGkyICs9IG1heENodW5rTGVuZ3RoKSB7CiAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpMiwgaTIgKyBtYXhDaHVua0xlbmd0aCA+IGxlbjIyID8gbGVuMjIgOiBpMiArIG1heENodW5rTGVuZ3RoKSk7CiAgICAgICAgfQogICAgICAgIGlmIChleHRyYUJ5dGVzID09PSAxKSB7CiAgICAgICAgICB0bXAgPSB1aW50OFtsZW4yIC0gMV07CiAgICAgICAgICBwYXJ0cy5wdXNoKGxvb2t1cFt0bXAgPj4gMl0gKyBsb29rdXBbdG1wIDw8IDQgJiA2M10gKyAiPT0iKTsKICAgICAgICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHsKICAgICAgICAgIHRtcCA9ICh1aW50OFtsZW4yIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4yIC0gMV07CiAgICAgICAgICBwYXJ0cy5wdXNoKGxvb2t1cFt0bXAgPj4gMTBdICsgbG9va3VwW3RtcCA+PiA0ICYgNjNdICsgbG9va3VwW3RtcCA8PCAyICYgNjNdICsgIj0iKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oIiIpOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9pZWVlNzU0QDEuMi4xL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfaWVlZTc1NCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9pZWVlNzU0QDEuMi4xL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogICAgICAgIHZhciBlLCBtOwogICAgICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxOwogICAgICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwogICAgICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTsKICAgICAgICB2YXIgbkJpdHMgPSAtNzsKICAgICAgICB2YXIgaSA9IGlzTEUgPyBuQnl0ZXMgLSAxIDogMDsKICAgICAgICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7CiAgICAgICAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07CiAgICAgICAgaSArPSBkOwogICAgICAgIGUgPSBzICYgKDEgPDwgLW5CaXRzKSAtIDE7CiAgICAgICAgcyA+Pj0gLW5CaXRzOwogICAgICAgIG5CaXRzICs9IGVMZW47CiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkgewogICAgICAgIH0KICAgICAgICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxOwogICAgICAgIGUgPj49IC1uQml0czsKICAgICAgICBuQml0cyArPSBtTGVuOwogICAgICAgIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgaWYgKGUgPT09IDApIHsKICAgICAgICAgIGUgPSAxIC0gZUJpYXM7CiAgICAgICAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7CiAgICAgICAgICByZXR1cm4gbSA/IE5hTiA6IChzID8gLTEgOiAxKSAqIEluZmluaXR5OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pOwogICAgICAgICAgZSA9IGUgLSBlQmlhczsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7CiAgICAgIH07CiAgICAgIGV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogICAgICAgIHZhciBlLCBtLCBjOwogICAgICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxOwogICAgICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwogICAgICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTsKICAgICAgICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMDsKICAgICAgICB2YXIgaSA9IGlzTEUgPyAwIDogbkJ5dGVzIC0gMTsKICAgICAgICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7CiAgICAgICAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwOwogICAgICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpOwogICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7CiAgICAgICAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7CiAgICAgICAgICBlID0gZU1heDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpOwogICAgICAgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkgewogICAgICAgICAgICBlLS07CiAgICAgICAgICAgIGMgKj0gMjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICAgICAgICB2YWx1ZSArPSBydCAvIGM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodmFsdWUgKiBjID49IDIpIHsKICAgICAgICAgICAgZSsrOwogICAgICAgICAgICBjIC89IDI7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHsKICAgICAgICAgICAgbSA9IDA7CiAgICAgICAgICAgIGUgPSBlTWF4OwogICAgICAgICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICAgICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgICAgIGUgPSBlICsgZUJpYXM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgICAgIGUgPSAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMjU1LCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgZSA9IGUgPDwgbUxlbiB8IG07CiAgICAgICAgZUxlbiArPSBtTGVuOwogICAgICAgIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDI1NSwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2J1ZmZlckA2LjAuMy9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfYnVmZmVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2J1ZmZlckA2LjAuMy9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgYmFzZTY0ID0gcmVxdWlyZV9iYXNlNjRfanMoKTsKICAgICAgdmFyIGllZWU3NTQgPSByZXF1aXJlX2llZWU3NTQoKTsKICAgICAgdmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIHR5cGVvZiBTeW1ib2xbImZvciJdID09PSAiZnVuY3Rpb24iID8gU3ltYm9sWyJmb3IiXSgibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20iKSA6IG51bGw7CiAgICAgIGV4cG9ydHMuQnVmZmVyID0gQnVmZmVyODsKICAgICAgZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjsKICAgICAgZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwOwogICAgICB2YXIgS19NQVhfTEVOR1RIID0gMjE0NzQ4MzY0NzsKICAgICAgZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIOwogICAgICBCdWZmZXI4LlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpOwogICAgICBpZiAoIUJ1ZmZlcjguVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4iKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpIHsKICAgICAgICB0cnkgewogICAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSk7CiAgICAgICAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIDQyOwogICAgICAgICAgfSB9OwogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSk7CiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90byk7CiAgICAgICAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MjsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXI4LnByb3RvdHlwZSwgInBhcmVudCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgICBpZiAoIUJ1ZmZlcjguaXNCdWZmZXIodGhpcykpCiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlcjgucHJvdG90eXBlLCAib2Zmc2V0IiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmICghQnVmZmVyOC5pc0J1ZmZlcih0aGlzKSkKICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXQ7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGxlbmd0aCkgewogICAgICAgIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgIicgKyBsZW5ndGggKyAnIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gInNpemUiJyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7CiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyOC5wcm90b3R5cGUpOwogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gQnVmZmVyOChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAibnVtYmVyIikgewogICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInN0cmluZyIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyOC5wb29sU2l6ZSA9IDgxOTI7CiAgICAgIGZ1bmN0aW9uIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7CiAgICAgICAgfQogICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAiICsgdHlwZW9mIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fCB2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAidW5kZWZpbmVkIiAmJiAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8IHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAibnVtYmVyIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJ2YWx1ZSIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKTsKICAgICAgICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyOC5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKTsKICAgICAgICBpZiAoYikKICAgICAgICAgIHJldHVybiBiOwogICAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAidW5kZWZpbmVkIiAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcmV0dXJuIEJ1ZmZlcjguZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCJzdHJpbmciKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgIiArIHR5cGVvZiB2YWx1ZSk7CiAgICAgIH0KICAgICAgQnVmZmVyOC5mcm9tID0gZnVuY3Rpb24odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICB9OwogICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyOC5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKTsKICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlcjgsIFVpbnQ4QXJyYXkpOwogICAgICBmdW5jdGlvbiBhc3NlcnRTaXplKHNpemUpIHsKICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcic2l6ZSIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpOwogICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgIicgKyBzaXplICsgJyIgaXMgaW52YWxpZCBmb3Igb3B0aW9uICJzaXplIicpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykgewogICAgICAgIGFzc2VydFNpemUoc2l6ZSk7CiAgICAgICAgaWYgKHNpemUgPD0gMCkgewogICAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKTsKICAgICAgICB9CiAgICAgICAgaWYgKGZpbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gInN0cmluZyIgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZykgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKTsKICAgICAgfQogICAgICBCdWZmZXI4LmFsbG9jID0gZnVuY3Rpb24oc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7CiAgICAgICAgYXNzZXJ0U2l6ZShzaXplKTsKICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKTsKICAgICAgfQogICAgICBCdWZmZXI4LmFsbG9jVW5zYWZlID0gZnVuY3Rpb24oc2l6ZSkgewogICAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKTsKICAgICAgfTsKICAgICAgQnVmZmVyOC5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbihzaXplKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIiB8fCBlbmNvZGluZyA9PT0gIiIpIHsKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIH0KICAgICAgICBpZiAoIUJ1ZmZlcjguaXNFbmNvZGluZyhlbmNvZGluZykpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIgKyBlbmNvZGluZyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwOwogICAgICAgIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKTsKICAgICAgICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7CiAgICAgICAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7CiAgICAgICAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGFycmF5KSB7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwOwogICAgICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21BcnJheVZpZXcoYXJyYXlWaWV3KSB7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkgewogICAgICAgICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5Vmlldyk7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcib2Zmc2V0IiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTsKICAgICAgICB9CiAgICAgICAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJsZW5ndGgiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpOwogICAgICAgIH0KICAgICAgICBsZXQgYnVmOwogICAgICAgIGlmIChieXRlT2Zmc2V0ID09PSB2b2lkIDAgJiYgbGVuZ3RoID09PSB2b2lkIDApIHsKICAgICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KTsKICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXI4LnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iaikgewogICAgICAgIGlmIChCdWZmZXI4LmlzQnVmZmVyKG9iaikpIHsKICAgICAgICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwOwogICAgICAgICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbik7CiAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgICAgfQogICAgICAgICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pOwogICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai5sZW5ndGggIT09IHZvaWQgMCkgewogICAgICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAibnVtYmVyIiB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkgewogICAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai50eXBlID09PSAiQnVmZmVyIiAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja2VkKGxlbmd0aCkgewogICAgICAgIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweCIgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgIiBieXRlcyIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbGVuZ3RoIHwgMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBTbG93QnVmZmVyKGxlbmd0aCkgewogICAgICAgIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjguYWxsb2MoK2xlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyOC5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKGIpIHsKICAgICAgICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmIGIgIT09IEJ1ZmZlcjgucHJvdG90eXBlOwogICAgICB9OwogICAgICBCdWZmZXI4LmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHsKICAgICAgICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkKICAgICAgICAgIGEgPSBCdWZmZXI4LmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aCk7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpCiAgICAgICAgICBiID0gQnVmZmVyOC5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpOwogICAgICAgIGlmICghQnVmZmVyOC5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyOC5pc0J1ZmZlcihiKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJidWYxIiwgImJ1ZjIiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyk7CiAgICAgICAgfQogICAgICAgIGlmIChhID09PSBiKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbGV0IHggPSBhLmxlbmd0aDsKICAgICAgICBsZXQgeSA9IGIubGVuZ3RoOwogICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkgewogICAgICAgICAgICB4ID0gYVtpXTsKICAgICAgICAgICAgeSA9IGJbaV07CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoeCA8IHkpCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKHkgPCB4KQogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjguaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcoZW5jb2RpbmcpIHsKICAgICAgICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkgewogICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgIGNhc2UgImJpbmFyeSI6CiAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgY2FzZSAidWNzMiI6CiAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgIGNhc2UgInV0Zi0xNmxlIjoKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9OwogICAgICBCdWZmZXI4LmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChsaXN0LCBsZW5ndGgpIHsKICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTsKICAgICAgICB9CiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyOC5hbGxvYygwKTsKICAgICAgICB9CiAgICAgICAgbGV0IGk7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBsZW5ndGggPSAwOwogICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXI4LmFsbG9jVW5zYWZlKGxlbmd0aCk7CiAgICAgICAgbGV0IHBvcyA9IDA7CiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGxldCBidWYgPSBsaXN0W2ldOwogICAgICAgICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkgewogICAgICAgICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgICAgICBpZiAoIUJ1ZmZlcjguaXNCdWZmZXIoYnVmKSkKICAgICAgICAgICAgICAgIGJ1ZiA9IEJ1ZmZlcjguZnJvbShidWYpOwogICAgICAgICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChidWZmZXIsIGJ1ZiwgcG9zKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmICghQnVmZmVyOC5pc0J1ZmZlcihidWYpKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTsKICAgICAgICAgIH0KICAgICAgICAgIHBvcyArPSBidWYubGVuZ3RoOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmZmVyOwogICAgICB9OwogICAgICBmdW5jdGlvbiBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHsKICAgICAgICBpZiAoQnVmZmVyOC5pc0J1ZmZlcihzdHJpbmcpKSB7CiAgICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHsKICAgICAgICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInN0cmluZyIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmcpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoOwogICAgICAgIGNvbnN0IG11c3RNYXRjaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZTsKICAgICAgICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgICAgIHJldHVybiBsZW47CiAgICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoOwogICAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICAgIHJldHVybiBsZW4gKiAyOwogICAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgICAgIHJldHVybiBsZW4gPj4+IDE7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAoIiIgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIEJ1ZmZlcjguYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7CiAgICAgIGZ1bmN0aW9uIHNsb3dUb1N0cmluZyhlbmNvZGluZywgc3RhcnQsIGVuZCkgewogICAgICAgIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlOwogICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwIHx8IHN0YXJ0IDwgMCkgewogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkgewogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kID09PSB2b2lkIDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kIDw9IDApIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgZW5kID4+Pj0gMDsKICAgICAgICBzdGFydCA+Pj49IDA7CiAgICAgICAgaWYgKGVuZCA8PSBzdGFydCkgewogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIH0KICAgICAgICBpZiAoIWVuY29kaW5nKQogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgIiIpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBCdWZmZXI4LnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlOwogICAgICBmdW5jdGlvbiBzd2FwKGIsIG4sIG0pIHsKICAgICAgICBjb25zdCBpID0gYltuXTsKICAgICAgICBiW25dID0gYlttXTsKICAgICAgICBiW21dID0gaTsKICAgICAgfQogICAgICBCdWZmZXI4LnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDIgIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMigpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuICUgNCAhPT0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzIik7CiAgICAgICAgfQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHsKICAgICAgICAgIHN3YXAodGhpcywgaSwgaSArIDMpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0KCkgewogICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmIChsZW4gJSA4ICE9PSAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMiKTsKICAgICAgICB9CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkgewogICAgICAgICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7CiAgICAgICAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNik7CiAgICAgICAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSk7CiAgICAgICAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmIChsZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlcjgucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICBCdWZmZXI4LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMoYikgewogICAgICAgIGlmICghQnVmZmVyOC5pc0J1ZmZlcihiKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIiKTsKICAgICAgICBpZiAodGhpcyA9PT0gYikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHJldHVybiBCdWZmZXI4LmNvbXBhcmUodGhpcywgYikgPT09IDA7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkgewogICAgICAgIGxldCBzdHIgPSAiIjsKICAgICAgICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTOwogICAgICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoImhleCIsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICIkMSAiKS50cmltKCk7CiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KQogICAgICAgICAgc3RyICs9ICIgLi4uICI7CiAgICAgICAgcmV0dXJuICI8QnVmZmVyICIgKyBzdHIgKyAiPiI7CiAgICAgIH07CiAgICAgIGlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7CiAgICAgICAgQnVmZmVyOC5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXI4LnByb3RvdHlwZS5pbnNwZWN0OwogICAgICB9CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkgewogICAgICAgICAgdGFyZ2V0ID0gQnVmZmVyOC5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpOwogICAgICAgIH0KICAgICAgICBpZiAoIUJ1ZmZlcjguaXNCdWZmZXIodGFyZ2V0KSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJ0YXJnZXQiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiB0YXJnZXQpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgewogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsKICAgICAgICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc1N0YXJ0ID09PSB2b2lkIDApIHsKICAgICAgICAgIHRoaXNTdGFydCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzRW5kID09PSB2b2lkIDApIHsKICAgICAgICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigib3V0IG9mIHJhbmdlIGluZGV4Iik7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ID49IGVuZCkgewogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgfQogICAgICAgIHN0YXJ0ID4+Pj0gMDsKICAgICAgICBlbmQgPj4+PSAwOwogICAgICAgIHRoaXNTdGFydCA+Pj49IDA7CiAgICAgICAgdGhpc0VuZCA+Pj49IDA7CiAgICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDsKICAgICAgICBsZXQgeSA9IGVuZCAtIHN0YXJ0OwogICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpOwogICAgICAgIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpOwogICAgICAgIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkgewogICAgICAgICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7CiAgICAgICAgICAgIHggPSB0aGlzQ29weVtpXTsKICAgICAgICAgICAgeSA9IHRhcmdldENvcHlbaV07CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoeCA8IHkpCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKHkgPCB4KQogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7CiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0OwogICAgICAgICAgYnl0ZU9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMjE0NzQ4MzY0NykgewogICAgICAgICAgYnl0ZU9mZnNldCA9IDIxNDc0ODM2NDc7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTIxNDc0ODM2NDgpIHsKICAgICAgICAgIGJ5dGVPZmZzZXQgPSAtMjE0NzQ4MzY0ODsKICAgICAgICB9CiAgICAgICAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0OwogICAgICAgIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkgewogICAgICAgICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiBidWZmZXIubGVuZ3RoIC0gMTsKICAgICAgICB9CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwKQogICAgICAgICAgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0OwogICAgICAgIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgIGlmIChkaXIpCiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxOwogICAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHsKICAgICAgICAgIGlmIChkaXIpCiAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSAwOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikgewogICAgICAgICAgdmFsID0gQnVmZmVyOC5mcm9tKHZhbCwgZW5jb2RpbmcpOwogICAgICAgIH0KICAgICAgICBpZiAoQnVmZmVyOC5pc0J1ZmZlcih2YWwpKSB7CiAgICAgICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICB2YWwgPSB2YWwgJiAyNTU7CiAgICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgaWYgKGRpcikgewogICAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXJyYXlJbmRleE9mKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7CiAgICAgICAgbGV0IGluZGV4U2l6ZSA9IDE7CiAgICAgICAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGg7CiAgICAgICAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7CiAgICAgICAgaWYgKGVuY29kaW5nICE9PSB2b2lkIDApIHsKICAgICAgICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgaWYgKGVuY29kaW5nID09PSAidWNzMiIgfHwgZW5jb2RpbmcgPT09ICJ1Y3MtMiIgfHwgZW5jb2RpbmcgPT09ICJ1dGYxNmxlIiB8fCBlbmNvZGluZyA9PT0gInV0Zi0xNmxlIikgewogICAgICAgICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHsKICAgICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaW5kZXhTaXplID0gMjsKICAgICAgICAgICAgYXJyTGVuZ3RoIC89IDI7CiAgICAgICAgICAgIHZhbExlbmd0aCAvPSAyOwogICAgICAgICAgICBieXRlT2Zmc2V0IC89IDI7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHJlYWQoYnVmLCBpMikgewogICAgICAgICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkgewogICAgICAgICAgICByZXR1cm4gYnVmW2kyXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkyICogaW5kZXhTaXplKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgbGV0IGk7CiAgICAgICAgaWYgKGRpcikgewogICAgICAgICAgbGV0IGZvdW5kSW5kZXggPSAtMTsKICAgICAgICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykgewogICAgICAgICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7CiAgICAgICAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKQogICAgICAgICAgICAgICAgZm91bmRJbmRleCA9IGk7CiAgICAgICAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKQogICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemU7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKQogICAgICAgICAgICAgICAgaSAtPSBpIC0gZm91bmRJbmRleDsKICAgICAgICAgICAgICBmb3VuZEluZGV4ID0gLTE7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpCiAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGg7CiAgICAgICAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkgewogICAgICAgICAgICBsZXQgZm91bmQgPSB0cnVlOwogICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7CiAgICAgICAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkgewogICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZm91bmQpCiAgICAgICAgICAgICAgcmV0dXJuIGk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAtMTsKICAgICAgfQogICAgICBCdWZmZXI4LnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMTsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogICAgICAgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKTsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgICAgICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gaGV4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMDsKICAgICAgICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0OwogICAgICAgIGlmICghbGVuZ3RoKSB7CiAgICAgICAgICBsZW5ndGggPSByZW1haW5pbmc7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpOwogICAgICAgICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykgewogICAgICAgICAgICBsZW5ndGggPSByZW1haW5pbmc7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHsKICAgICAgICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7CiAgICAgICAgfQogICAgICAgIGxldCBpOwogICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTsKICAgICAgICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKQogICAgICAgICAgICByZXR1cm4gaTsKICAgICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmOFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJhc2U2NFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdWNzMldyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHsKICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICBvZmZzZXQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB2b2lkIDAgJiYgdHlwZW9mIG9mZnNldCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIGVuY29kaW5nID0gb2Zmc2V0OwogICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICBvZmZzZXQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkgewogICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHsKICAgICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwOwogICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkKICAgICAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGVuY29kaW5nID0gbGVuZ3RoOwogICAgICAgICAgICBsZW5ndGggPSB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQiKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwIHx8IGxlbmd0aCA+IHJlbWFpbmluZykKICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcyIpOwogICAgICAgIH0KICAgICAgICBpZiAoIWVuY29kaW5nKQogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2U7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgICAgICAgIGVuY29kaW5nID0gKCIiICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICB0eXBlOiAiQnVmZmVyIiwKICAgICAgICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKQogICAgICAgIH07CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJhc2U2NFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHsKICAgICAgICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmOFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7CiAgICAgICAgY29uc3QgcmVzID0gW107CiAgICAgICAgbGV0IGkgPSBzdGFydDsKICAgICAgICB3aGlsZSAoaSA8IGVuZCkgewogICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldOwogICAgICAgICAgbGV0IGNvZGVQb2ludCA9IG51bGw7CiAgICAgICAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IGZpcnN0Qnl0ZSA+IDIzOSA/IDQgOiBmaXJzdEJ5dGUgPiAyMjMgPyAzIDogZmlyc3RCeXRlID4gMTkxID8gMiA6IDE7CiAgICAgICAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7CiAgICAgICAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkgewogICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAxMjgpIHsKICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07CiAgICAgICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAzMSkgPDwgNiB8IHNlY29uZEJ5dGUgJiA2MzsKICAgICAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAxMjcpIHsKICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07CiAgICAgICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKHRoaXJkQnl0ZSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDE1KSA8PCAxMiB8IChzZWNvbmRCeXRlICYgNjMpIDw8IDYgfCB0aGlyZEJ5dGUgJiA2MzsKICAgICAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAyMDQ3ICYmICh0ZW1wQ29kZVBvaW50IDwgNTUyOTYgfHwgdGVtcENvZGVQb2ludCA+IDU3MzQzKSkgewogICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwogICAgICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTsKICAgICAgICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdOwogICAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmICh0aGlyZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKGZvdXJ0aEJ5dGUgJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTggfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCAxMiB8ICh0aGlyZEJ5dGUgJiA2MykgPDwgNiB8IGZvdXJ0aEJ5dGUgJiA2MzsKICAgICAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiA2NTUzNSAmJiB0ZW1wQ29kZVBvaW50IDwgMTExNDExMikgewogICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkgewogICAgICAgICAgICBjb2RlUG9pbnQgPSA2NTUzMzsKICAgICAgICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDY1NTM1KSB7CiAgICAgICAgICAgIGNvZGVQb2ludCAtPSA2NTUzNjsKICAgICAgICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDEwMjMgfCA1NTI5Nik7CiAgICAgICAgICAgIGNvZGVQb2ludCA9IDU2MzIwIHwgY29kZVBvaW50ICYgMTAyMzsKICAgICAgICAgIH0KICAgICAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7CiAgICAgICAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKTsKICAgICAgfQogICAgICB2YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSA0MDk2OwogICAgICBmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoY29kZVBvaW50cykgewogICAgICAgIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoOwogICAgICAgIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHsKICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cyk7CiAgICAgICAgfQogICAgICAgIGxldCByZXMgPSAiIjsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHsKICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBsZXQgcmV0ID0gIiI7CiAgICAgICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTsKICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMTI3KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBsYXRpbjFTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBsZXQgcmV0ID0gIiI7CiAgICAgICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTsKICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBoZXhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBjb25zdCBsZW4gPSBidWYubGVuZ3RoOwogICAgICAgIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKQogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKQogICAgICAgICAgZW5kID0gbGVuOwogICAgICAgIGxldCBvdXQgPSAiIjsKICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG91dDsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGYxNmxlU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCk7CiAgICAgICAgbGV0IHJlcyA9ICIiOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7CiAgICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH0KICAgICAgQnVmZmVyOC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgc3RhcnQgPSB+fnN0YXJ0OwogICAgICAgIGVuZCA9IGVuZCA9PT0gdm9pZCAwID8gbGVuIDogfn5lbmQ7CiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgewogICAgICAgICAgc3RhcnQgKz0gbGVuOwogICAgICAgICAgaWYgKHN0YXJ0IDwgMCkKICAgICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHsKICAgICAgICAgIHN0YXJ0ID0gbGVuOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kIDwgMCkgewogICAgICAgICAgZW5kICs9IGxlbjsKICAgICAgICAgIGlmIChlbmQgPCAwKQogICAgICAgICAgICBlbmQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7CiAgICAgICAgICBlbmQgPSBsZW47CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPCBzdGFydCkKICAgICAgICAgIGVuZCA9IHN0YXJ0OwogICAgICAgIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7CiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyOC5wcm90b3R5cGUpOwogICAgICAgIHJldHVybiBuZXdCdWY7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGNoZWNrT2Zmc2V0KG9mZnNldCwgZXh0LCBsZW5ndGgpIHsKICAgICAgICBpZiAob2Zmc2V0ICUgMSAhPT0gMCB8fCBvZmZzZXQgPCAwKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm9mZnNldCBpcyBub3QgdWludCIpOwogICAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCIpOwogICAgICB9CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnJlYWRVaW50TEUgPSBCdWZmZXI4LnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7CiAgICAgICAgfQogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnJlYWRVaW50QkUgPSBCdWZmZXI4LnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoMl07CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgd2hpbGUgKGJ5dGVMZW5ndGgyID4gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aDJdICogbXVsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS5yZWFkVWludDggPSBCdWZmZXI4LnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDgob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XTsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUucmVhZFVpbnQxNkxFID0gQnVmZmVyOC5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9IEJ1ZmZlcjgucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIDw8IDggfCB0aGlzW29mZnNldCArIDFdOwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS5yZWFkVWludDMyTEUgPSBCdWZmZXI4LnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuICh0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2KSArIHRoaXNbb2Zmc2V0ICsgM10gKiAxNjc3NzIxNjsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUucmVhZFVpbnQzMkJFID0gQnVmZmVyOC5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gKiAxNjc3NzIxNiArICh0aGlzW29mZnNldCArIDFdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAzXSk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsbyA9IGZpcnN0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQ7CiAgICAgICAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgbGFzdCAqIDIgKiogMjQ7CiAgICAgICAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF07CiAgICAgICAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIGxhc3Q7CiAgICAgICAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7CiAgICAgICAgfQogICAgICAgIG11bCAqPSAxMjg7CiAgICAgICAgaWYgKHZhbCA+PSBtdWwpCiAgICAgICAgICB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKTsKICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGxldCBpID0gYnl0ZUxlbmd0aDI7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXTsKICAgICAgICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsOwogICAgICAgIH0KICAgICAgICBtdWwgKj0gMTI4OwogICAgICAgIGlmICh2YWwgPj0gbXVsKQogICAgICAgICAgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMik7CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTsKICAgICAgICBpZiAoISh0aGlzW29mZnNldF0gJiAxMjgpKQogICAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XTsKICAgICAgICByZXR1cm4gKDI1NSAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4OwogICAgICAgIHJldHVybiB2YWwgJiAzMjc2OCA/IHZhbCB8IDQyOTQ5MDE3NjAgOiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8IHRoaXNbb2Zmc2V0XSA8PCA4OwogICAgICAgIHJldHVybiB2YWwgJiAzMjc2OCA/IHZhbCB8IDQyOTQ5MDE3NjAgOiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYgfCB0aGlzW29mZnNldCArIDNdIDw8IDI0OwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gPDwgMjQgfCB0aGlzW29mZnNldCArIDFdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAzXTsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICsgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICsgKGxhc3QgPDwgMjQpOwogICAgICAgIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQoZmlyc3QgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCk7CiAgICAgIH0pOwogICAgICBCdWZmZXI4LnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdOwogICAgICAgIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyBsYXN0KTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KTsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KTsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gY2hlY2tJbnQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7CiAgICAgICAgaWYgKCFCdWZmZXI4LmlzQnVmZmVyKGJ1ZikpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCciYnVmZmVyIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7CiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJ2YWx1ZSIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpOwogICAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICB9CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLndyaXRlVWludExFID0gQnVmZmVyOC5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMikgLSAxOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG1heEJ5dGVzLCAwKTsKICAgICAgICB9CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAvIG11bCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyOwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS53cml0ZVVpbnRCRSA9IEJ1ZmZlcjgucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpIC0gMTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBtYXhCeXRlcywgMCk7CiAgICAgICAgfQogICAgICAgIGxldCBpID0gYnl0ZUxlbmd0aDIgLSAxOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgLyBtdWwgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUud3JpdGVVaW50OCA9IEJ1ZmZlcjgucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAyNTUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAxOwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID0gQnVmZmVyOC5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDY1NTM1LCAwKTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLndyaXRlVWludDE2QkUgPSBCdWZmZXI4LnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgNjU1MzUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9IEJ1ZmZlcjgucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCA0Mjk0OTY3Mjk1LCAwKTsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID0gQnVmZmVyOC5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDQyOTQ5NjcyOTUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiAyNDsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDE2OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHsKICAgICAgICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpOwogICAgICAgIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgcmV0dXJuIG9mZnNldDsKICAgICAgfQogICAgICBmdW5jdGlvbiB3cnRCaWdVSW50NjRCRShidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7CiAgICAgICAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KTsKICAgICAgICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQgKyA3XSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgNl0gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDVdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyA0XSA9IGxvOwogICAgICAgIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0ICsgM10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDJdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyAxXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0XSA9IGhpOwogICAgICAgIHJldHVybiBvZmZzZXQgKyA4OwogICAgICB9CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgiMHhmZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCIweGZmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXI4LnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIgLSAxKTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBsaW1pdCAtIDEsIC1saW1pdCk7CiAgICAgICAgfQogICAgICAgIGxldCBpID0gMDsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgc3ViID0gMDsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkgewogICAgICAgICAgICBzdWIgPSAxOwogICAgICAgICAgfQogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCA+PiAwKSAtIHN1YiAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyOwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIgLSAxKTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBsaW1pdCAtIDEsIC1saW1pdCk7CiAgICAgICAgfQogICAgICAgIGxldCBpID0gYnl0ZUxlbmd0aDIgLSAxOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBzdWIgPSAwOwogICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkgewogICAgICAgICAgICBzdWIgPSAxOwogICAgICAgICAgfQogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCA+PiAwKSAtIHN1YiAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyOwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDEyNywgLTEyOCk7CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHZhbHVlID0gMjU1ICsgdmFsdWUgKyAxOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAxOwogICAgICB9OwogICAgICBCdWZmZXI4LnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDMyNzY3LCAtMzI3NjgpOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAzMjc2NywgLTMyNzY4KTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMjE0NzQ4MzY0NywgLTIxNDc0ODM2NDgpOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDE2OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMjE0NzQ4MzY0NywgLTIxNDc0ODM2NDgpOwogICAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgICB2YWx1ZSA9IDQyOTQ5NjcyOTUgKyB2YWx1ZSArIDE7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCIweDgwMDAwMDAwMDAwMDAwMDAiKSwgQmlnSW50KCIweDdmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXI4LnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoIjB4ODAwMDAwMDAwMDAwMDAwMCIpLCBCaWdJbnQoIjB4N2ZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICAgICAgICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgICBpZiAob2Zmc2V0IDwgMCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzNDAyODIzNDY2Mzg1Mjg4NmUyMiwgLTM0MDI4MjM0NjYzODUyODg2ZTIyKTsKICAgICAgICB9CiAgICAgICAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpOwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgQnVmZmVyOC5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwgLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mik7CiAgICAgICAgfQogICAgICAgIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgODsKICAgICAgfQogICAgICBCdWZmZXI4LnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBpZiAoIUJ1ZmZlcjguaXNCdWZmZXIodGFyZ2V0KSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlciIpOwogICAgICAgIGlmICghc3RhcnQpCiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKQogICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpCiAgICAgICAgICB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7CiAgICAgICAgaWYgKCF0YXJnZXRTdGFydCkKICAgICAgICAgIHRhcmdldFN0YXJ0ID0gMDsKICAgICAgICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkKICAgICAgICAgIGVuZCA9IHN0YXJ0OwogICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcyIpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICAgIGlmIChlbmQgPCAwKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzIik7CiAgICAgICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKQogICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7CiAgICAgICAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDsKICAgICAgICB9CiAgICAgICAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnQ7CiAgICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwodGFyZ2V0LCB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLCB0YXJnZXRTdGFydCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBsZW47CiAgICAgIH07CiAgICAgIEJ1ZmZlcjgucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGVuY29kaW5nID0gc3RhcnQ7CiAgICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGVuY29kaW5nID0gZW5kOwogICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChlbmNvZGluZyAhPT0gdm9pZCAwICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZyIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gInN0cmluZyIgJiYgIUJ1ZmZlcjguaXNFbmNvZGluZyhlbmNvZGluZykpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTsKICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSAidXRmOCIgJiYgY29kZSA8IDEyOCB8fCBlbmNvZGluZyA9PT0gImxhdGluMSIpIHsKICAgICAgICAgICAgICB2YWwgPSBjb2RlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikgewogICAgICAgICAgdmFsID0gdmFsICYgMjU1OwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gImJvb2xlYW4iKSB7CiAgICAgICAgICB2YWwgPSBOdW1iZXIodmFsKTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiT3V0IG9mIHJhbmdlIGluZGV4Iik7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPD0gc3RhcnQpIHsKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICBzdGFydCA9IHN0YXJ0ID4+PiAwOwogICAgICAgIGVuZCA9IGVuZCA9PT0gdm9pZCAwID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7CiAgICAgICAgaWYgKCF2YWwpCiAgICAgICAgICB2YWwgPSAwOwogICAgICAgIGxldCBpOwogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikgewogICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgICB0aGlzW2ldID0gdmFsOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zdCBieXRlcyA9IEJ1ZmZlcjguaXNCdWZmZXIodmFsKSA/IHZhbCA6IEJ1ZmZlcjguZnJvbSh2YWwsIGVuY29kaW5nKTsKICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDsKICAgICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlICInICsgdmFsICsgJyIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgInZhbHVlIicpOwogICAgICAgICAgfQogICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHsKICAgICAgICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICB2YXIgZXJyb3JzID0ge307CiAgICAgIGZ1bmN0aW9uIEUoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7CiAgICAgICAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHsKICAgICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgICBzdXBlcigpOwogICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgIm1lc3NhZ2UiLCB7CiAgICAgICAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSwKICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gOwogICAgICAgICAgICB0aGlzLnN0YWNrOwogICAgICAgICAgICBkZWxldGUgdGhpcy5uYW1lOwogICAgICAgICAgfQogICAgICAgICAgZ2V0IGNvZGUoKSB7CiAgICAgICAgICAgIHJldHVybiBzeW07CiAgICAgICAgICB9CiAgICAgICAgICBzZXQgY29kZSh2YWx1ZSkgewogICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgImNvZGUiLCB7CiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgICAgICAgdmFsdWUsCiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgICB0b1N0cmluZygpIHsKICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWA7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgfQogICAgICBFKCJFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMiLCBmdW5jdGlvbihuYW1lKSB7CiAgICAgICAgaWYgKG5hbWUpIHsKICAgICAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgOwogICAgICAgIH0KICAgICAgICByZXR1cm4gIkF0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMiOwogICAgICB9LCBSYW5nZUVycm9yKTsKICAgICAgRSgiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCBmdW5jdGlvbihuYW1lLCBhY3R1YWwpIHsKICAgICAgICByZXR1cm4gYFRoZSAiJHtuYW1lfSIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YDsKICAgICAgfSwgVHlwZUVycm9yKTsKICAgICAgRSgiRVJSX09VVF9PRl9SQU5HRSIsIGZ1bmN0aW9uKHN0ciwgcmFuZ2UsIGlucHV0KSB7CiAgICAgICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgIiR7c3RyfSIgaXMgb3V0IG9mIHJhbmdlLmA7CiAgICAgICAgbGV0IHJlY2VpdmVkID0gaW5wdXQ7CiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHsKICAgICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAiYmlnaW50IikgewogICAgICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpOwogICAgICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkgewogICAgICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZCk7CiAgICAgICAgICB9CiAgICAgICAgICByZWNlaXZlZCArPSAibiI7CiAgICAgICAgfQogICAgICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YDsKICAgICAgICByZXR1cm4gbXNnOwogICAgICB9LCBSYW5nZUVycm9yKTsKICAgICAgZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHZhbCkgewogICAgICAgIGxldCByZXMgPSAiIjsKICAgICAgICBsZXQgaSA9IHZhbC5sZW5ndGg7CiAgICAgICAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICItIiA/IDEgOiAwOwogICAgICAgIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7CiAgICAgICAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgyKSB7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgaWYgKGJ1ZltvZmZzZXRdID09PSB2b2lkIDAgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGgyXSA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aDIgKyAxKSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aDIpIHsKICAgICAgICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHsKICAgICAgICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAiYmlnaW50IiA/ICJuIiA6ICIiOwogICAgICAgICAgbGV0IHJhbmdlOwogICAgICAgICAgaWYgKGJ5dGVMZW5ndGgyID4gMykgewogICAgICAgICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7CiAgICAgICAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aDIgKyAxKSAqIDh9JHtufWA7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoMiArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiAkeyhieXRlTGVuZ3RoMiArIDEpICogOCAtIDF9JHtufWA7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gOwogICAgICAgICAgfQogICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCJ2YWx1ZSIsIHJhbmdlLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIodmFsdWUsIG5hbWUpIHsKICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAibnVtYmVyIikgewogICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAibnVtYmVyIiwgdmFsdWUpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBib3VuZHNFcnJvcih2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7CiAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkgewogICAgICAgICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpOwogICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgIm9mZnNldCIsICJhbiBpbnRlZ2VyIiwgdmFsdWUpOwogICAgICAgIH0KICAgICAgICBpZiAobGVuZ3RoIDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgIm9mZnNldCIsIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsIHZhbHVlKTsKICAgICAgfQogICAgICB2YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nOwogICAgICBmdW5jdGlvbiBiYXNlNjRjbGVhbihzdHIpIHsKICAgICAgICBzdHIgPSBzdHIuc3BsaXQoIj0iKVswXTsKICAgICAgICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICIiKTsKICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDIpCiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7CiAgICAgICAgICBzdHIgPSBzdHIgKyAiPSI7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzdHI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyaW5nLCB1bml0cykgewogICAgICAgIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7CiAgICAgICAgbGV0IGNvZGVQb2ludDsKICAgICAgICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOwogICAgICAgIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbDsKICAgICAgICBjb25zdCBieXRlcyA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpOwogICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDU1Mjk1ICYmIGNvZGVQb2ludCA8IDU3MzQ0KSB7CiAgICAgICAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkgewogICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiA1NjMxOSkgewogICAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpOwogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgNTYzMjApIHsKICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpOwogICAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSA1NTI5NiA8PCAxMCB8IGNvZGVQb2ludCAtIDU2MzIwKSArIDY1NTM2OwogICAgICAgICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpOwogICAgICAgICAgfQogICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7CiAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMTI4KSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDIwNDgpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDYgfCAxOTIsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgNjU1MzYpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDEyIHwgMjI0LCBjb2RlUG9pbnQgPj4gNiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDExMTQxMTIpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDE4IHwgMjQwLCBjb2RlUG9pbnQgPj4gMTIgJiA2MyB8IDEyOCwgY29kZVBvaW50ID4+IDYgJiA2MyB8IDEyOCwgY29kZVBvaW50ICYgNjMgfCAxMjgpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGNvZGUgcG9pbnQiKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ5dGVzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhzdHIpIHsKICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBbXTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkgewogICAgICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAyNTUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZUFycmF5OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKHN0ciwgdW5pdHMpIHsKICAgICAgICBsZXQgYywgaGksIGxvOwogICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgICBoaSA9IGMgPj4gODsKICAgICAgICAgIGxvID0gYyAlIDI1NjsKICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGxvKTsKICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGhpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheTsKICAgICAgfQogICAgICBmdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikgewogICAgICAgIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBsZXQgaTsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGlmIChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGggfHwgaSA+PSBzcmMubGVuZ3RoKQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaXNJbnN0YW5jZShvYmosIHR5cGUpIHsKICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fCBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbnVtYmVySXNOYU4ob2JqKSB7CiAgICAgICAgcmV0dXJuIG9iaiAhPT0gb2JqOwogICAgICB9CiAgICAgIHZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gZnVuY3Rpb24oKSB7CiAgICAgICAgY29uc3QgYWxwaGFiZXQgPSAiMDEyMzQ1Njc4OWFiY2RlZiI7CiAgICAgICAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHsKICAgICAgICAgIGNvbnN0IGkxNiA9IGkgKiAxNjsKICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikgewogICAgICAgICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiB0YWJsZTsKICAgICAgfSgpOwogICAgICBmdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QoZm4pIHsKICAgICAgICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gInVuZGVmaW5lZCIgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCgpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkJpZ0ludCBub3Qgc3VwcG9ydGVkIik7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gc3JjL2FsaWFzL2J1ZmZlci1zaGltLmpzCiAgdmFyIGltcG9ydF9idWZmZXI7CiAgdmFyIGluaXRfYnVmZmVyX3NoaW0gPSBfX2VzbSh7CiAgICAic3JjL2FsaWFzL2J1ZmZlci1zaGltLmpzIigpIHsKICAgICAgaW1wb3J0X2J1ZmZlciA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9pcy1vYnNlcnZhYmxlQDIuMS4wL25vZGVfbW9kdWxlcy9pcy1vYnNlcnZhYmxlL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfaXNfb2JzZXJ2YWJsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9pcy1vYnNlcnZhYmxlQDIuMS4wL25vZGVfbW9kdWxlcy9pcy1vYnNlcnZhYmxlL2luZGV4LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gKHZhbHVlKSA9PiB7CiAgICAgICAgaWYgKCF2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIFN5bWJvbC5vYnNlcnZhYmxlID09PSAic3ltYm9sIiAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLm9ic2VydmFibGVdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlW1N5bWJvbC5vYnNlcnZhYmxlXSgpOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHZhbHVlWyJAQG9ic2VydmFibGUiXSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVsiQEBvYnNlcnZhYmxlIl0oKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3NlcmlhbGl6ZXJzLmpzCiAgdmFyIHJlcXVpcmVfc2VyaWFsaXplcnMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3NlcmlhbGl6ZXJzLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzLkRlZmF1bHRTZXJpYWxpemVyID0gZXhwb3J0cy5leHRlbmRTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICBmdW5jdGlvbiBleHRlbmRTZXJpYWxpemVyKGV4dGVuZCwgaW1wbGVtZW50YXRpb24pIHsKICAgICAgICBjb25zdCBmYWxsYmFja0Rlc2VyaWFsaXplciA9IGV4dGVuZC5kZXNlcmlhbGl6ZS5iaW5kKGV4dGVuZCk7CiAgICAgICAgY29uc3QgZmFsbGJhY2tTZXJpYWxpemVyID0gZXh0ZW5kLnNlcmlhbGl6ZS5iaW5kKGV4dGVuZCk7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uLmRlc2VyaWFsaXplKG1lc3NhZ2UsIGZhbGxiYWNrRGVzZXJpYWxpemVyKTsKICAgICAgICAgIH0sCiAgICAgICAgICBzZXJpYWxpemUoaW5wdXQpIHsKICAgICAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uLnNlcmlhbGl6ZShpbnB1dCwgZmFsbGJhY2tTZXJpYWxpemVyKTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICAgIGV4cG9ydHMuZXh0ZW5kU2VyaWFsaXplciA9IGV4dGVuZFNlcmlhbGl6ZXI7CiAgICAgIHZhciBEZWZhdWx0RXJyb3JTZXJpYWxpemVyID0gewogICAgICAgIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKEVycm9yKG1lc3NhZ2UubWVzc2FnZSksIHsKICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lLAogICAgICAgICAgICBzdGFjazogbWVzc2FnZS5zdGFjawogICAgICAgICAgfSk7CiAgICAgICAgfSwKICAgICAgICBzZXJpYWxpemUoZXJyb3IpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIF9fZXJyb3JfbWFya2VyOiAiJCRlcnJvciIsCiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsCiAgICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsCiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjawogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIHZhciBpc1NlcmlhbGl6ZWRFcnJvciA9ICh0aGluZykgPT4gdGhpbmcgJiYgdHlwZW9mIHRoaW5nID09PSAib2JqZWN0IiAmJiAiX19lcnJvcl9tYXJrZXIiIGluIHRoaW5nICYmIHRoaW5nLl9fZXJyb3JfbWFya2VyID09PSAiJCRlcnJvciI7CiAgICAgIGV4cG9ydHMuRGVmYXVsdFNlcmlhbGl6ZXIgPSB7CiAgICAgICAgZGVzZXJpYWxpemUobWVzc2FnZSkgewogICAgICAgICAgaWYgKGlzU2VyaWFsaXplZEVycm9yKG1lc3NhZ2UpKSB7CiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0RXJyb3JTZXJpYWxpemVyLmRlc2VyaWFsaXplKG1lc3NhZ2UpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBzZXJpYWxpemUoaW5wdXQpIHsKICAgICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEVycm9yKSB7CiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0RXJyb3JTZXJpYWxpemVyLnNlcmlhbGl6ZShpbnB1dCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gaW5wdXQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L2NvbW1vbi5qcwogIHZhciByZXF1aXJlX2NvbW1vbiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvY29tbW9uLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzLnNlcmlhbGl6ZSA9IGV4cG9ydHMuZGVzZXJpYWxpemUgPSBleHBvcnRzLnJlZ2lzdGVyU2VyaWFsaXplciA9IHZvaWQgMDsKICAgICAgdmFyIHNlcmlhbGl6ZXJzXzEgPSByZXF1aXJlX3NlcmlhbGl6ZXJzKCk7CiAgICAgIHZhciByZWdpc3RlcmVkU2VyaWFsaXplciA9IHNlcmlhbGl6ZXJzXzEuRGVmYXVsdFNlcmlhbGl6ZXI7CiAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyU2VyaWFsaXplcjIoc2VyaWFsaXplcikgewogICAgICAgIHJlZ2lzdGVyZWRTZXJpYWxpemVyID0gc2VyaWFsaXplcnNfMS5leHRlbmRTZXJpYWxpemVyKHJlZ2lzdGVyZWRTZXJpYWxpemVyLCBzZXJpYWxpemVyKTsKICAgICAgfQogICAgICBleHBvcnRzLnJlZ2lzdGVyU2VyaWFsaXplciA9IHJlZ2lzdGVyU2VyaWFsaXplcjI7CiAgICAgIGZ1bmN0aW9uIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUobWVzc2FnZSk7CiAgICAgIH0KICAgICAgZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplOwogICAgICBmdW5jdGlvbiBzZXJpYWxpemUoaW5wdXQpIHsKICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNlcmlhbGl6ZXIuc2VyaWFsaXplKGlucHV0KTsKICAgICAgfQogICAgICBleHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zeW1ib2xzLmpzCiAgdmFyIHJlcXVpcmVfc3ltYm9scyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc3ltYm9scy5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0cy4kd29ya2VyID0gZXhwb3J0cy4kdHJhbnNmZXJhYmxlID0gZXhwb3J0cy4kdGVybWluYXRlID0gZXhwb3J0cy4kZXZlbnRzID0gZXhwb3J0cy4kZXJyb3JzID0gdm9pZCAwOwogICAgICBleHBvcnRzLiRlcnJvcnMgPSBTeW1ib2woInRocmVhZC5lcnJvcnMiKTsKICAgICAgZXhwb3J0cy4kZXZlbnRzID0gU3ltYm9sKCJ0aHJlYWQuZXZlbnRzIik7CiAgICAgIGV4cG9ydHMuJHRlcm1pbmF0ZSA9IFN5bWJvbCgidGhyZWFkLnRlcm1pbmF0ZSIpOwogICAgICBleHBvcnRzLiR0cmFuc2ZlcmFibGUgPSBTeW1ib2woInRocmVhZC50cmFuc2ZlcmFibGUiKTsKICAgICAgZXhwb3J0cy4kd29ya2VyID0gU3ltYm9sKCJ0aHJlYWQud29ya2VyIik7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHJhbnNmZXJhYmxlLmpzCiAgdmFyIHJlcXVpcmVfdHJhbnNmZXJhYmxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90cmFuc2ZlcmFibGUuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMuVHJhbnNmZXIgPSBleHBvcnRzLmlzVHJhbnNmZXJEZXNjcmlwdG9yID0gdm9pZCAwOwogICAgICB2YXIgc3ltYm9sc18xID0gcmVxdWlyZV9zeW1ib2xzKCk7CiAgICAgIGZ1bmN0aW9uIGlzVHJhbnNmZXJhYmxlKHRoaW5nKSB7CiAgICAgICAgaWYgKCF0aGluZyB8fCB0eXBlb2YgdGhpbmcgIT09ICJvYmplY3QiKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGlzVHJhbnNmZXJEZXNjcmlwdG9yKHRoaW5nKSB7CiAgICAgICAgcmV0dXJuIHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgdGhpbmdbc3ltYm9sc18xLiR0cmFuc2ZlcmFibGVdOwogICAgICB9CiAgICAgIGV4cG9ydHMuaXNUcmFuc2ZlckRlc2NyaXB0b3IgPSBpc1RyYW5zZmVyRGVzY3JpcHRvcjsKICAgICAgZnVuY3Rpb24gVHJhbnNmZXIyKHBheWxvYWQsIHRyYW5zZmVyYWJsZXMpIHsKICAgICAgICBpZiAoIXRyYW5zZmVyYWJsZXMpIHsKICAgICAgICAgIGlmICghaXNUcmFuc2ZlcmFibGUocGF5bG9hZCkpCiAgICAgICAgICAgIHRocm93IEVycm9yKCk7CiAgICAgICAgICB0cmFuc2ZlcmFibGVzID0gW3BheWxvYWRdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gewogICAgICAgICAgW3N5bWJvbHNfMS4kdHJhbnNmZXJhYmxlXTogdHJ1ZSwKICAgICAgICAgIHNlbmQ6IHBheWxvYWQsCiAgICAgICAgICB0cmFuc2ZlcmFibGVzCiAgICAgICAgfTsKICAgICAgfQogICAgICBleHBvcnRzLlRyYW5zZmVyID0gVHJhbnNmZXIyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3R5cGVzL21lc3NhZ2VzLmpzCiAgdmFyIHJlcXVpcmVfbWVzc2FnZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3R5cGVzL21lc3NhZ2VzLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzLldvcmtlck1lc3NhZ2VUeXBlID0gZXhwb3J0cy5NYXN0ZXJNZXNzYWdlVHlwZSA9IHZvaWQgMDsKICAgICAgdmFyIE1hc3Rlck1lc3NhZ2VUeXBlOwogICAgICAoZnVuY3Rpb24oTWFzdGVyTWVzc2FnZVR5cGUyKSB7CiAgICAgICAgTWFzdGVyTWVzc2FnZVR5cGUyWyJjYW5jZWwiXSA9ICJjYW5jZWwiOwogICAgICAgIE1hc3Rlck1lc3NhZ2VUeXBlMlsicnVuIl0gPSAicnVuIjsKICAgICAgfSkoTWFzdGVyTWVzc2FnZVR5cGUgPSBleHBvcnRzLk1hc3Rlck1lc3NhZ2VUeXBlIHx8IChleHBvcnRzLk1hc3Rlck1lc3NhZ2VUeXBlID0ge30pKTsKICAgICAgdmFyIFdvcmtlck1lc3NhZ2VUeXBlOwogICAgICAoZnVuY3Rpb24oV29ya2VyTWVzc2FnZVR5cGUyKSB7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJlcnJvciJdID0gImVycm9yIjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbImluaXQiXSA9ICJpbml0IjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbInJlc3VsdCJdID0gInJlc3VsdCI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJydW5uaW5nIl0gPSAicnVubmluZyI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJ1bmNhdWdodEVycm9yIl0gPSAidW5jYXVnaHRFcnJvciI7CiAgICAgIH0pKFdvcmtlck1lc3NhZ2VUeXBlID0gZXhwb3J0cy5Xb3JrZXJNZXNzYWdlVHlwZSB8fCAoZXhwb3J0cy5Xb3JrZXJNZXNzYWdlVHlwZSA9IHt9KSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2ltcGxlbWVudGF0aW9uLmJyb3dzZXIuanMKICB2YXIgcmVxdWlyZV9pbXBsZW1lbnRhdGlvbl9icm93c2VyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW1wbGVtZW50YXRpb24uYnJvd3Nlci5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIGlzV29ya2VyUnVudGltZSA9IGZ1bmN0aW9uIGlzV29ya2VyUnVudGltZTIoKSB7CiAgICAgICAgY29uc3QgaXNXaW5kb3dDb250ZXh0ID0gdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBXaW5kb3cgIT09ICJ1bmRlZmluZWQiICYmIHNlbGYgaW5zdGFuY2VvZiBXaW5kb3c7CiAgICAgICAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiAmJiBzZWxmLnBvc3RNZXNzYWdlICYmICFpc1dpbmRvd0NvbnRleHQgPyB0cnVlIDogZmFsc2U7CiAgICAgIH07CiAgICAgIHZhciBwb3N0TWVzc2FnZVRvTWFzdGVyID0gZnVuY3Rpb24gcG9zdE1lc3NhZ2VUb01hc3RlcjIoZGF0YSwgdHJhbnNmZXJMaXN0KSB7CiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2Zlckxpc3QpOwogICAgICB9OwogICAgICB2YXIgc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcyA9IGZ1bmN0aW9uIHN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMyKG9uTWVzc2FnZSkgewogICAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gKG1lc3NhZ2VFdmVudCkgPT4gewogICAgICAgICAgb25NZXNzYWdlKG1lc3NhZ2VFdmVudC5kYXRhKTsKICAgICAgICB9OwogICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4gewogICAgICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgbWVzc2FnZUhhbmRsZXIpOwogICAgICAgIH07CiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgbWVzc2FnZUhhbmRsZXIpOwogICAgICAgIHJldHVybiB1bnN1YnNjcmliZTsKICAgICAgfTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gewogICAgICAgIGlzV29ya2VyUnVudGltZSwKICAgICAgICBwb3N0TWVzc2FnZVRvTWFzdGVyLAogICAgICAgIHN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW5kZXguanMKICB2YXIgcmVxdWlyZV93b3JrZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbmRleC5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9fYXdhaXRlciA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7CiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsKICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpIHsKICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIHJlamVjdChlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvclsidGhyb3ciXSh2YWx1ZSkpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgcmVqZWN0KGUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgewogICAgICAgICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsKICAgICAgICAgIH0KICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTsKICAgICAgICB9KTsKICAgICAgfTsKICAgICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgImRlZmF1bHQiOiBtb2QgfTsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0cy5leHBvc2UgPSBleHBvcnRzLmlzV29ya2VyUnVudGltZSA9IGV4cG9ydHMuVHJhbnNmZXIgPSBleHBvcnRzLnJlZ2lzdGVyU2VyaWFsaXplciA9IHZvaWQgMDsKICAgICAgdmFyIGlzX29ic2VydmFibGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX2lzX29ic2VydmFibGUoKSk7CiAgICAgIHZhciBjb21tb25fMSA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciB0cmFuc2ZlcmFibGVfMSA9IHJlcXVpcmVfdHJhbnNmZXJhYmxlKCk7CiAgICAgIHZhciBtZXNzYWdlc18xID0gcmVxdWlyZV9tZXNzYWdlcygpOwogICAgICB2YXIgaW1wbGVtZW50YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX2ltcGxlbWVudGF0aW9uX2Jyb3dzZXIoKSk7CiAgICAgIHZhciBjb21tb25fMiA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAicmVnaXN0ZXJTZXJpYWxpemVyIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiBjb21tb25fMi5yZWdpc3RlclNlcmlhbGl6ZXI7CiAgICAgIH0gfSk7CiAgICAgIHZhciB0cmFuc2ZlcmFibGVfMiA9IHJlcXVpcmVfdHJhbnNmZXJhYmxlKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiVHJhbnNmZXIiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRyYW5zZmVyYWJsZV8yLlRyYW5zZmVyOwogICAgICB9IH0pOwogICAgICBleHBvcnRzLmlzV29ya2VyUnVudGltZSA9IGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWU7CiAgICAgIHZhciBleHBvc2VDYWxsZWQgPSBmYWxzZTsKICAgICAgdmFyIGFjdGl2ZVN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7CiAgICAgIHZhciBpc01hc3RlckpvYkNhbmNlbE1lc3NhZ2UgPSAodGhpbmcpID0+IHRoaW5nICYmIHRoaW5nLnR5cGUgPT09IG1lc3NhZ2VzXzEuTWFzdGVyTWVzc2FnZVR5cGUuY2FuY2VsOwogICAgICB2YXIgaXNNYXN0ZXJKb2JSdW5NZXNzYWdlID0gKHRoaW5nKSA9PiB0aGluZyAmJiB0aGluZy50eXBlID09PSBtZXNzYWdlc18xLk1hc3Rlck1lc3NhZ2VUeXBlLnJ1bjsKICAgICAgdmFyIGlzT2JzZXJ2YWJsZSA9ICh0aGluZykgPT4gaXNfb2JzZXJ2YWJsZV8xLmRlZmF1bHQodGhpbmcpIHx8IGlzWmVuT2JzZXJ2YWJsZSh0aGluZyk7CiAgICAgIGZ1bmN0aW9uIGlzWmVuT2JzZXJ2YWJsZSh0aGluZykgewogICAgICAgIHJldHVybiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICJvYmplY3QiICYmIHR5cGVvZiB0aGluZy5zdWJzY3JpYmUgPT09ICJmdW5jdGlvbiI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVjb25zdHJ1Y3RUcmFuc2Zlcih0aGluZykgewogICAgICAgIHJldHVybiB0cmFuc2ZlcmFibGVfMS5pc1RyYW5zZmVyRGVzY3JpcHRvcih0aGluZykgPyB7IHBheWxvYWQ6IHRoaW5nLnNlbmQsIHRyYW5zZmVyYWJsZXM6IHRoaW5nLnRyYW5zZmVyYWJsZXMgfSA6IHsgcGF5bG9hZDogdGhpbmcsIHRyYW5zZmVyYWJsZXM6IHZvaWQgMCB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RGdW5jdGlvbkluaXRNZXNzYWdlKCkgewogICAgICAgIGNvbnN0IGluaXRNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5pbml0LAogICAgICAgICAgZXhwb3NlZDogewogICAgICAgICAgICB0eXBlOiAiZnVuY3Rpb24iCiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3Rlcihpbml0TWVzc2FnZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdE1vZHVsZUluaXRNZXNzYWdlKG1ldGhvZE5hbWVzKSB7CiAgICAgICAgY29uc3QgaW5pdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLmluaXQsCiAgICAgICAgICBleHBvc2VkOiB7CiAgICAgICAgICAgIHR5cGU6ICJtb2R1bGUiLAogICAgICAgICAgICBtZXRob2RzOiBtZXRob2ROYW1lcwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoaW5pdE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RKb2JFcnJvck1lc3NhZ2UodWlkLCByYXdFcnJvcikgewogICAgICAgIGNvbnN0IHsgcGF5bG9hZDogZXJyb3IsIHRyYW5zZmVyYWJsZXMgfSA9IGRlY29uc3RydWN0VHJhbnNmZXIocmF3RXJyb3IpOwogICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUuZXJyb3IsCiAgICAgICAgICB1aWQsCiAgICAgICAgICBlcnJvcjogY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoZXJyb3JNZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0Sm9iUmVzdWx0TWVzc2FnZSh1aWQsIGNvbXBsZXRlZCwgcmVzdWx0VmFsdWUpIHsKICAgICAgICBjb25zdCB7IHBheWxvYWQsIHRyYW5zZmVyYWJsZXMgfSA9IGRlY29uc3RydWN0VHJhbnNmZXIocmVzdWx0VmFsdWUpOwogICAgICAgIGNvbnN0IHJlc3VsdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnJlc3VsdCwKICAgICAgICAgIHVpZCwKICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZWQgPyB0cnVlIDogdm9pZCAwLAogICAgICAgICAgcGF5bG9hZAogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIocmVzdWx0TWVzc2FnZSwgdHJhbnNmZXJhYmxlcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEpvYlN0YXJ0TWVzc2FnZSh1aWQsIHJlc3VsdFR5cGUpIHsKICAgICAgICBjb25zdCBzdGFydE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnJ1bm5pbmcsCiAgICAgICAgICB1aWQsCiAgICAgICAgICByZXN1bHRUeXBlCiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihzdGFydE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvcikgewogICAgICAgIHRyeSB7CiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSB7CiAgICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUudW5jYXVnaHRFcnJvciwKICAgICAgICAgICAgZXJyb3I6IGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikKICAgICAgICAgIH07CiAgICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihlcnJvck1lc3NhZ2UpOwogICAgICAgIH0gY2F0Y2ggKHN1YkVycm9yKSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKCJOb3QgcmVwb3J0aW5nIHVuY2F1Z2h0IGVycm9yIGJhY2sgdG8gbWFzdGVyIHRocmVhZCBhcyBpdCBvY2N1cmVkIHdoaWxlIHJlcG9ydGluZyBhbiB1bmNhdWdodCBlcnJvciBhbHJlYWR5LlxuTGF0ZXN0IGVycm9yOiIsIHN1YkVycm9yLCAiXG5PcmlnaW5hbCBlcnJvcjoiLCBlcnJvcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJ1bkZ1bmN0aW9uKGpvYlVJRCwgZm4sIGFyZ3MpIHsKICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgewogICAgICAgICAgbGV0IHN5bmNSZXN1bHQ7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBzeW5jUmVzdWx0ID0gZm4oLi4uYXJncyk7CiAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICByZXR1cm4gcG9zdEpvYkVycm9yTWVzc2FnZShqb2JVSUQsIGVycm9yKTsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHJlc3VsdFR5cGUgPSBpc09ic2VydmFibGUoc3luY1Jlc3VsdCkgPyAib2JzZXJ2YWJsZSIgOiAicHJvbWlzZSI7CiAgICAgICAgICBwb3N0Sm9iU3RhcnRNZXNzYWdlKGpvYlVJRCwgcmVzdWx0VHlwZSk7CiAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHN5bmNSZXN1bHQpKSB7CiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN5bmNSZXN1bHQuc3Vic2NyaWJlKCh2YWx1ZSkgPT4gcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCBmYWxzZSwgY29tbW9uXzEuc2VyaWFsaXplKHZhbHVlKSksIChlcnJvcikgPT4gewogICAgICAgICAgICAgIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9LCAoKSA9PiB7CiAgICAgICAgICAgICAgcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCB0cnVlKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5zZXQoam9iVUlELCBzdWJzY3JpcHRpb24pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzeW5jUmVzdWx0OwogICAgICAgICAgICAgIHBvc3RKb2JSZXN1bHRNZXNzYWdlKGpvYlVJRCwgdHJ1ZSwgY29tbW9uXzEuc2VyaWFsaXplKHJlc3VsdCkpOwogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGV4cG9zZTIoZXhwb3NlZCkgewogICAgICAgIGlmICghaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZSgpKSB7CiAgICAgICAgICB0aHJvdyBFcnJvcigiZXhwb3NlKCkgY2FsbGVkIGluIHRoZSBtYXN0ZXIgdGhyZWFkLiIpOwogICAgICAgIH0KICAgICAgICBpZiAoZXhwb3NlQ2FsbGVkKSB7CiAgICAgICAgICB0aHJvdyBFcnJvcigiZXhwb3NlKCkgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLiBUaGlzIGlzIG5vdCBwb3NzaWJsZS4gUGFzcyBhbiBvYmplY3QgdG8gZXhwb3NlKCkgaWYgeW91IHdhbnQgdG8gZXhwb3NlIG11bHRpcGxlIGZ1bmN0aW9ucy4iKTsKICAgICAgICB9CiAgICAgICAgZXhwb3NlQ2FsbGVkID0gdHJ1ZTsKICAgICAgICBpZiAodHlwZW9mIGV4cG9zZWQgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgICBpZiAoaXNNYXN0ZXJKb2JSdW5NZXNzYWdlKG1lc3NhZ2VEYXRhKSAmJiAhbWVzc2FnZURhdGEubWV0aG9kKSB7CiAgICAgICAgICAgICAgcnVuRnVuY3Rpb24obWVzc2FnZURhdGEudWlkLCBleHBvc2VkLCBtZXNzYWdlRGF0YS5hcmdzLm1hcChjb21tb25fMS5kZXNlcmlhbGl6ZSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHBvc3RGdW5jdGlvbkluaXRNZXNzYWdlKCk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3NlZCA9PT0gIm9iamVjdCIgJiYgZXhwb3NlZCkgewogICAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMoKG1lc3NhZ2VEYXRhKSA9PiB7CiAgICAgICAgICAgIGlmIChpc01hc3RlckpvYlJ1bk1lc3NhZ2UobWVzc2FnZURhdGEpICYmIG1lc3NhZ2VEYXRhLm1ldGhvZCkgewogICAgICAgICAgICAgIHJ1bkZ1bmN0aW9uKG1lc3NhZ2VEYXRhLnVpZCwgZXhwb3NlZFttZXNzYWdlRGF0YS5tZXRob2RdLCBtZXNzYWdlRGF0YS5hcmdzLm1hcChjb21tb25fMS5kZXNlcmlhbGl6ZSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGNvbnN0IG1ldGhvZE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3NlZCkuZmlsdGVyKChrZXkpID0+IHR5cGVvZiBleHBvc2VkW2tleV0gPT09ICJmdW5jdGlvbiIpOwogICAgICAgICAgcG9zdE1vZHVsZUluaXRNZXNzYWdlKG1ldGhvZE5hbWVzKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGV4cG9zZSgpLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCwgZ290OiAke2V4cG9zZWR9YCk7CiAgICAgICAgfQogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgaWYgKGlzTWFzdGVySm9iQ2FuY2VsTWVzc2FnZShtZXNzYWdlRGF0YSkpIHsKICAgICAgICAgICAgY29uc3Qgam9iVUlEID0gbWVzc2FnZURhdGEudWlkOwogICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhY3RpdmVTdWJzY3JpcHRpb25zLmdldChqb2JVSUQpOwogICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7CiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7CiAgICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5kZWxldGUoam9iVUlEKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGV4cG9ydHMuZXhwb3NlID0gZXhwb3NlMjsKICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2Ygc2VsZi5hZGRFdmVudExpc3RlbmVyID09PSAiZnVuY3Rpb24iICYmIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWUoKSkgewogICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigiZXJyb3IiLCAoZXZlbnQpID0+IHsKICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGV2ZW50LmVycm9yIHx8IGV2ZW50KSwgMjUwKTsKICAgICAgICB9KTsKICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoInVuaGFuZGxlZHJlamVjdGlvbiIsIChldmVudCkgPT4gewogICAgICAgICAgY29uc3QgZXJyb3IgPSBldmVudC5yZWFzb247CiAgICAgICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGVycm9yKSwgMjUwKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBwcm9jZXNzLm9uID09PSAiZnVuY3Rpb24iICYmIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWUoKSkgewogICAgICAgIHByb2Nlc3Mub24oInVuY2F1Z2h0RXhjZXB0aW9uIiwgKGVycm9yKSA9PiB7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgfSk7CiAgICAgICAgcHJvY2Vzcy5vbigidW5oYW5kbGVkUmVqZWN0aW9uIiwgKGVycm9yKSA9PiB7CiAgICAgICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGVycm9yKSwgMjUwKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9uZ0A0LjAuMC9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcwogIHZhciByZXF1aXJlX2xvbmcgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vbG9uZ0A0LjAuMC9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBMb25nNDsKICAgICAgdmFyIHdhc20gPSBudWxsOwogICAgICB0cnkgewogICAgICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbCiAgICAgICAgICAwLAogICAgICAgICAgOTcsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxLAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDEzLAogICAgICAgICAgMiwKICAgICAgICAgIDk2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjcsCiAgICAgICAgICA5NiwKICAgICAgICAgIDQsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMywKICAgICAgICAgIDcsCiAgICAgICAgICA2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgNiwKICAgICAgICAgIDYsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMSwKICAgICAgICAgIDY1LAogICAgICAgICAgMCwKICAgICAgICAgIDExLAogICAgICAgICAgNywKICAgICAgICAgIDUwLAogICAgICAgICAgNiwKICAgICAgICAgIDMsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxMTcsCiAgICAgICAgICAxMDgsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDUsCiAgICAgICAgICAxMDAsCiAgICAgICAgICAxMDUsCiAgICAgICAgICAxMTgsCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNSwKICAgICAgICAgIDAsCiAgICAgICAgICAyLAogICAgICAgICAgNSwKICAgICAgICAgIDEwMCwKICAgICAgICAgIDEwNSwKICAgICAgICAgIDExOCwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE3LAogICAgICAgICAgMCwKICAgICAgICAgIDMsCiAgICAgICAgICA1LAogICAgICAgICAgMTE0LAogICAgICAgICAgMTAxLAogICAgICAgICAgMTA5LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAwLAogICAgICAgICAgNCwKICAgICAgICAgIDUsCiAgICAgICAgICAxMTQsCiAgICAgICAgICAxMDEsCiAgICAgICAgICAxMDksCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNywKICAgICAgICAgIDAsCiAgICAgICAgICA1LAogICAgICAgICAgOCwKICAgICAgICAgIDEwMywKICAgICAgICAgIDEwMSwKICAgICAgICAgIDExNiwKICAgICAgICAgIDk1LAogICAgICAgICAgMTA0LAogICAgICAgICAgMTA1LAogICAgICAgICAgMTAzLAogICAgICAgICAgMTA0LAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAxMCwKICAgICAgICAgIDE5MSwKICAgICAgICAgIDEsCiAgICAgICAgICA2LAogICAgICAgICAgNCwKICAgICAgICAgIDAsCiAgICAgICAgICAzNSwKICAgICAgICAgIDAsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNywKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOSwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEzMCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMQogICAgICAgIF0pKSwge30pLmV4cG9ydHM7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgfQogICAgICBmdW5jdGlvbiBMb25nNChsb3csIGhpZ2gsIHVuc2lnbmVkKSB7CiAgICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwOwogICAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwOwogICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgICB9CiAgICAgIExvbmc0LnByb3RvdHlwZS5fX2lzTG9uZ19fOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZzQucHJvdG90eXBlLCAiX19pc0xvbmdfXyIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGZ1bmN0aW9uIGlzTG9uZyhvYmopIHsKICAgICAgICByZXR1cm4gKG9iaiAmJiBvYmpbIl9faXNMb25nX18iXSkgPT09IHRydWU7CiAgICAgIH0KICAgICAgTG9uZzQuaXNMb25nID0gaXNMb25nOwogICAgICB2YXIgSU5UX0NBQ0hFID0ge307CiAgICAgIHZhciBVSU5UX0NBQ0hFID0ge307CiAgICAgIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7CiAgICAgICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTsKICAgICAgICBpZiAodW5zaWduZWQpIHsKICAgICAgICAgIHZhbHVlID4+Pj0gMDsKICAgICAgICAgIGlmIChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpIHsKICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpOwogICAgICAgICAgaWYgKGNhY2hlKQogICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajsKICAgICAgICAgIHJldHVybiBvYmo7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhbHVlIHw9IDA7CiAgICAgICAgICBpZiAoY2FjaGUgPSAtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSB7CiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTsKICAgICAgICAgIGlmIChjYWNoZSkKICAgICAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajsKICAgICAgICAgIHJldHVybiBvYmo7CiAgICAgICAgfQogICAgICB9CiAgICAgIExvbmc0LmZyb21JbnQgPSBmcm9tSW50OwogICAgICBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkgewogICAgICAgIGlmIChpc05hTih2YWx1ZSkpCiAgICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICAgICAgaWYgKHVuc2lnbmVkKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgICByZXR1cm4gVVpFUk87CiAgICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpCiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpCiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKQogICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFOwogICAgICAgIH0KICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCB2YWx1ZSAvIFRXT19QV1JfMzJfREJMIHwgMCwgdW5zaWduZWQpOwogICAgICB9CiAgICAgIExvbmc0LmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyOwogICAgICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmc0KGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbUJpdHMgPSBmcm9tQml0czsKICAgICAgdmFyIHBvd19kYmwgPSBNYXRoLnBvdzsKICAgICAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkgewogICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKQogICAgICAgICAgdGhyb3cgRXJyb3IoImVtcHR5IHN0cmluZyIpOwogICAgICAgIGlmIChzdHIgPT09ICJOYU4iIHx8IHN0ciA9PT0gIkluZmluaXR5IiB8fCBzdHIgPT09ICIrSW5maW5pdHkiIHx8IHN0ciA9PT0gIi1JbmZpbml0eSIpCiAgICAgICAgICByZXR1cm4gWkVSTzsKICAgICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAibnVtYmVyIikgewogICAgICAgICAgcmFkaXggPSB1bnNpZ25lZCwgdW5zaWduZWQgPSBmYWxzZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgICAgIH0KICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwOwogICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkKICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoInJhZGl4Iik7CiAgICAgICAgdmFyIHA7CiAgICAgICAgaWYgKChwID0gc3RyLmluZGV4T2YoIi0iKSkgPiAwKQogICAgICAgICAgdGhyb3cgRXJyb3IoImludGVyaW9yIGh5cGhlbiIpOwogICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHsKICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7CiAgICAgICAgfQogICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTsKICAgICAgICB2YXIgcmVzdWx0ID0gWkVSTzsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkgewogICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTsKICAgICAgICAgIGlmIChzaXplIDwgOCkgewogICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkOwogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7CiAgICAgIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKQogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICJib29sZWFuIiA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nNC5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7CiAgICAgIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7CiAgICAgIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7CiAgICAgIHZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7CiAgICAgIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7CiAgICAgIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjsKICAgICAgdmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTsKICAgICAgdmFyIFpFUk8gPSBmcm9tSW50KDApOwogICAgICBMb25nNC5aRVJPID0gWkVSTzsKICAgICAgdmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTsKICAgICAgTG9uZzQuVVpFUk8gPSBVWkVSTzsKICAgICAgdmFyIE9ORSA9IGZyb21JbnQoMSk7CiAgICAgIExvbmc0Lk9ORSA9IE9ORTsKICAgICAgdmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpOwogICAgICBMb25nNC5VT05FID0gVU9ORTsKICAgICAgdmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTsKICAgICAgTG9uZzQuTkVHX09ORSA9IE5FR19PTkU7CiAgICAgIHZhciBNQVhfVkFMVUUgPSBmcm9tQml0cyg0Mjk0OTY3Mjk1IHwgMCwgMjE0NzQ4MzY0NyB8IDAsIGZhbHNlKTsKICAgICAgTG9uZzQuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFOwogICAgICB2YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoNDI5NDk2NzI5NSB8IDAsIDQyOTQ5NjcyOTUgfCAwLCB0cnVlKTsKICAgICAgTG9uZzQuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFOwogICAgICB2YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMjE0NzQ4MzY0OCB8IDAsIGZhbHNlKTsKICAgICAgTG9uZzQuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFOwogICAgICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmc0LnByb3RvdHlwZTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkgewogICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkgewogICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKQogICAgICAgICAgcmV0dXJuICh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkgewogICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7CiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KQogICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiAiMCI7CiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7CiAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSwgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSwgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7CiAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTsKICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICByZXR1cm4gIi0iICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7CiAgICAgICAgfQogICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSwgcmVtID0gdGhpczsKICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLCBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpOwogICAgICAgICAgcmVtID0gcmVtRGl2OwogICAgICAgICAgaWYgKHJlbS5pc1plcm8oKSkKICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpCiAgICAgICAgICAgICAgZGlnaXRzID0gIjAiICsgZGlnaXRzOwogICAgICAgICAgICByZXN1bHQgPSAiIiArIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkgewogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHsKICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7CiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7CiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7CiAgICAgICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKQogICAgICAgICAgaWYgKCh2YWwgJiAxIDw8IGJpdCkgIT0gMCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvOwogICAgICBMb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkgewogICAgICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkgewogICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7CiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHsKICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzOwogICAgICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikgewogICAgICAgIHJldHVybiAhdGhpcy5lcShvdGhlcik7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUubmUgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFsczsKICAgICAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPCAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjsKICAgICAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHsKICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA8PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID4gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47CiAgICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPj0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpOwogICAgICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZykKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpCiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTsKICAgICAgICByZXR1cm4gb3RoZXIuaGlnaCA+Pj4gMCA+IHRoaXMuaGlnaCA+Pj4gMCB8fCBvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDAgPyAtMSA6IDE7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTsKICAgICAgTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSkKICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7CiAgICAgIExvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkgewogICAgICAgIGlmICghaXNMb25nKGFkZGVuZCkpCiAgICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTsKICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2OwogICAgICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjsKICAgICAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDY1NTM1OwogICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgICAgIGMwMCArPSBhMDAgKyBiMDA7CiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7CiAgICAgICAgYzAwICY9IDY1NTM1OwogICAgICAgIGMxNiArPSBhMTYgKyBiMTY7CiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICAgICAgYzE2ICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMzIgKyBiMzI7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGM0OCArPSBhNDggKyBiNDg7CiAgICAgICAgYzQ4ICY9IDY1NTM1OwogICAgICAgIHJldHVybiBmcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7CiAgICAgICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpCiAgICAgICAgICBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpOwogICAgICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0OwogICAgICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikgewogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIFpFUk87CiAgICAgICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpCiAgICAgICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpOwogICAgICAgIGlmICh3YXNtKSB7CiAgICAgICAgICB2YXIgbG93ID0gd2FzbS5tdWwodGhpcy5sb3csIHRoaXMuaGlnaCwgbXVsdGlwbGllci5sb3csIG11bHRpcGxpZXIuaGlnaCk7CiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiBaRVJPOwogICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpCiAgICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTzsKICAgICAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87CiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpOwogICAgICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7CiAgICAgICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSkKICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7CiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDsKICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjsKICAgICAgICBjMDAgJj0gNjU1MzU7CiAgICAgICAgYzE2ICs9IGExNiAqIGIwMDsKICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjsKICAgICAgICBjMTYgJj0gNjU1MzU7CiAgICAgICAgYzE2ICs9IGEwMCAqIGIxNjsKICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjsKICAgICAgICBjMTYgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGExNiAqIGIxNjsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGEwMCAqIGIzMjsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODsKICAgICAgICBjNDggJj0gNjU1MzU7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5OwogICAgICBMb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7CiAgICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpCiAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpOwogICAgICAgIGlmIChkaXZpc29yLmlzWmVybygpKQogICAgICAgICAgdGhyb3cgRXJyb3IoImRpdmlzaW9uIGJ5IHplcm8iKTsKICAgICAgICBpZiAod2FzbSkgewogICAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA9PT0gLTIxNDc0ODM2NDggJiYgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLmRpdl91IDogd2FzbS5kaXZfcykodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7CiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgICAgIHZhciBhcHByb3gsIHJlbSwgcmVzOwogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkgewogICAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkgewogICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpCiAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsKICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgICAgIHJldHVybiBPTkU7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpOwogICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7CiAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7CiAgICAgICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpOwogICAgICAgICAgICAgICAgcmV0dXJuIHJlczsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTzsKICAgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpOwogICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7CiAgICAgICAgICByZXMgPSBaRVJPOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpCiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTsKICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKQogICAgICAgICAgICByZXR1cm4gVVpFUk87CiAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKQogICAgICAgICAgICByZXR1cm4gVU9ORTsKICAgICAgICAgIHJlcyA9IFVaRVJPOwogICAgICAgIH0KICAgICAgICByZW0gPSB0aGlzOwogICAgICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7CiAgICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7CiAgICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLCBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLCBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7CiAgICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkgewogICAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7CiAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpCiAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTsKICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTsKICAgICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTsKICAgICAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikgewogICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKQogICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTsKICAgICAgICBpZiAod2FzbSkgewogICAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5yZW1fdSA6IHdhc20ucmVtX3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87CiAgICAgIExvbmdQcm90b3R5cGUucmVtID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87CiAgICAgIExvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkgewogICAgICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikgewogICAgICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykgewogICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgdGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gMzIgLSBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICBlbHNlCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgbnVtQml0cyAtIDMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSkKICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMikKICAgICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICBlbHNlCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IG51bUJpdHMgLSAzMiwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykgewogICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIG51bUJpdHMgJj0gNjM7CiAgICAgICAgaWYgKG51bUJpdHMgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIHsKICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoOwogICAgICAgICAgaWYgKG51bUJpdHMgPCAzMikgewogICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7CiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhsb3cgPj4+IG51bUJpdHMgfCBoaWdoIDw8IDMyIC0gbnVtQml0cywgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKQogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiBudW1CaXRzIC0gMzIsIDAsIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7CiAgICAgIExvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICAgICAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkgewogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7CiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMobGUpIHsKICAgICAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7CiAgICAgICAgdmFyIGhpID0gdGhpcy5oaWdoLCBsbyA9IHRoaXMubG93OwogICAgICAgIHJldHVybiBbCiAgICAgICAgICBsbyAmIDI1NSwKICAgICAgICAgIGxvID4+PiA4ICYgMjU1LAogICAgICAgICAgbG8gPj4+IDE2ICYgMjU1LAogICAgICAgICAgbG8gPj4+IDI0LAogICAgICAgICAgaGkgJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGhpID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGhpID4+PiAyNAogICAgICAgIF07CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkgewogICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgaGkgPj4+IDI0LAogICAgICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgICAgICBoaSAmIDI1NSwKICAgICAgICAgIGxvID4+PiAyNCwKICAgICAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGxvID4+PiA4ICYgMjU1LAogICAgICAgICAgbG8gJiAyNTUKICAgICAgICBdOwogICAgICB9OwogICAgICBMb25nNC5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMyKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHsKICAgICAgICByZXR1cm4gbGUgPyBMb25nNC5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZzQuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZzQuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmc0KGJ5dGVzWzBdIHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbM10gPDwgMjQsIGJ5dGVzWzRdIHwgYnl0ZXNbNV0gPDwgOCB8IGJ5dGVzWzZdIDw8IDE2IHwgYnl0ZXNbN10gPDwgMjQsIHVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZzQuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmc0KGJ5dGVzWzRdIDw8IDI0IHwgYnl0ZXNbNV0gPDwgMTYgfCBieXRlc1s2XSA8PCA4IHwgYnl0ZXNbN10sIGJ5dGVzWzBdIDw8IDI0IHwgYnl0ZXNbMV0gPDwgMTYgfCBieXRlc1syXSA8PCA4IHwgYnl0ZXNbM10sIHVuc2lnbmVkKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gKGRpc2FibGVkKTpub2RlX21vZHVsZXMvLnBucG0vZ2VuZXJpYy1maWxlaGFuZGxlQDMuMS4xL25vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2xvY2FsRmlsZQogIHZhciByZXF1aXJlX2xvY2FsRmlsZSA9IF9fY29tbW9uSlMoewogICAgIihkaXNhYmxlZCk6bm9kZV9tb2R1bGVzLy5wbnBtL2dlbmVyaWMtZmlsZWhhbmRsZUAzLjEuMS9ub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9sb2NhbEZpbGUiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzCiAgdmFyIHJlcXVpcmVfY29tbW9uMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgVFlQRURfT0sgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIFVpbnQxNkFycmF5ICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgSW50MzJBcnJheSAhPT0gInVuZGVmaW5lZCI7CiAgICAgIGZ1bmN0aW9uIF9oYXMob2JqLCBrZXkpIHsKICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTsKICAgICAgfQogICAgICBleHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uKG9iaikgewogICAgICAgIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgICAgICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHsKICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7CiAgICAgICAgICBpZiAoIXNvdXJjZSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICJtdXN0IGJlIG5vbi1vYmplY3QiKTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7CiAgICAgICAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHsKICAgICAgICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9iajsKICAgICAgfTsKICAgICAgZXhwb3J0cy5zaHJpbmtCdWYgPSBmdW5jdGlvbihidWYsIHNpemUpIHsKICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgewogICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICB9CiAgICAgICAgaWYgKGJ1Zi5zdWJhcnJheSkgewogICAgICAgICAgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsKICAgICAgICB9CiAgICAgICAgYnVmLmxlbmd0aCA9IHNpemU7CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgdmFyIGZuVHlwZWQgPSB7CiAgICAgICAgYXJyYXlTZXQ6IGZ1bmN0aW9uKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7CiAgICAgICAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHsKICAgICAgICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY19vZmZzLCBzcmNfb2ZmcyArIGxlbiksIGRlc3Rfb2Zmcyk7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24oY2h1bmtzKSB7CiAgICAgICAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7CiAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pOwogICAgICAgICAgcG9zID0gMDsKICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIGNodW5rID0gY2h1bmtzW2ldOwogICAgICAgICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpOwogICAgICAgICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgIH07CiAgICAgIHZhciBmblVudHlwZWQgPSB7CiAgICAgICAgYXJyYXlTZXQ6IGZ1bmN0aW9uKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uKGNodW5rcykgewogICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbihvbikgewogICAgICAgIGlmIChvbikgewogICAgICAgICAgZXhwb3J0cy5CdWY4ID0gVWludDhBcnJheTsKICAgICAgICAgIGV4cG9ydHMuQnVmMTYgPSBVaW50MTZBcnJheTsKICAgICAgICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5OwogICAgICAgICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGV4cG9ydHMuQnVmOCA9IEFycmF5OwogICAgICAgICAgZXhwb3J0cy5CdWYxNiA9IEFycmF5OwogICAgICAgICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5OwogICAgICAgICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMKICB2YXIgcmVxdWlyZV90cmVlcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciBaX0ZJWEVEID0gNDsKICAgICAgdmFyIFpfQklOQVJZID0gMDsKICAgICAgdmFyIFpfVEVYVCA9IDE7CiAgICAgIHZhciBaX1VOS05PV04gPSAyOwogICAgICBmdW5jdGlvbiB6ZXJvKGJ1ZikgewogICAgICAgIHZhciBsZW4gPSBidWYubGVuZ3RoOwogICAgICAgIHdoaWxlICgtLWxlbiA+PSAwKSB7CiAgICAgICAgICBidWZbbGVuXSA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciBTVE9SRURfQkxPQ0sgPSAwOwogICAgICB2YXIgU1RBVElDX1RSRUVTID0gMTsKICAgICAgdmFyIERZTl9UUkVFUyA9IDI7CiAgICAgIHZhciBNSU5fTUFUQ0ggPSAzOwogICAgICB2YXIgTUFYX01BVENIID0gMjU4OwogICAgICB2YXIgTEVOR1RIX0NPREVTID0gMjk7CiAgICAgIHZhciBMSVRFUkFMUyA9IDI1NjsKICAgICAgdmFyIExfQ09ERVMgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7CiAgICAgIHZhciBEX0NPREVTID0gMzA7CiAgICAgIHZhciBCTF9DT0RFUyA9IDE5OwogICAgICB2YXIgSEVBUF9TSVpFID0gMiAqIExfQ09ERVMgKyAxOwogICAgICB2YXIgTUFYX0JJVFMgPSAxNTsKICAgICAgdmFyIEJ1Zl9zaXplID0gMTY7CiAgICAgIHZhciBNQVhfQkxfQklUUyA9IDc7CiAgICAgIHZhciBFTkRfQkxPQ0sgPSAyNTY7CiAgICAgIHZhciBSRVBfM182ID0gMTY7CiAgICAgIHZhciBSRVBaXzNfMTAgPSAxNzsKICAgICAgdmFyIFJFUFpfMTFfMTM4ID0gMTg7CiAgICAgIHZhciBleHRyYV9sYml0cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwXTsKICAgICAgdmFyIGV4dHJhX2RiaXRzID0gWzAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxM107CiAgICAgIHZhciBleHRyYV9ibGJpdHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMiwgMywgN107CiAgICAgIHZhciBibF9vcmRlciA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTsKICAgICAgdmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7CiAgICAgIHZhciBzdGF0aWNfbHRyZWUgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpOwogICAgICB6ZXJvKHN0YXRpY19sdHJlZSk7CiAgICAgIHZhciBzdGF0aWNfZHRyZWUgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpOwogICAgICB6ZXJvKHN0YXRpY19kdHJlZSk7CiAgICAgIHZhciBfZGlzdF9jb2RlID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pOwogICAgICB6ZXJvKF9kaXN0X2NvZGUpOwogICAgICB2YXIgX2xlbmd0aF9jb2RlID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpOwogICAgICB6ZXJvKF9sZW5ndGhfY29kZSk7CiAgICAgIHZhciBiYXNlX2xlbmd0aCA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpOwogICAgICB6ZXJvKGJhc2VfbGVuZ3RoKTsKICAgICAgdmFyIGJhc2VfZGlzdCA9IG5ldyBBcnJheShEX0NPREVTKTsKICAgICAgemVybyhiYXNlX2Rpc3QpOwogICAgICBmdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHsKICAgICAgICB0aGlzLnN0YXRpY190cmVlID0gc3RhdGljX3RyZWU7CiAgICAgICAgdGhpcy5leHRyYV9iaXRzID0gZXh0cmFfYml0czsKICAgICAgICB0aGlzLmV4dHJhX2Jhc2UgPSBleHRyYV9iYXNlOwogICAgICAgIHRoaXMuZWxlbXMgPSBlbGVtczsKICAgICAgICB0aGlzLm1heF9sZW5ndGggPSBtYXhfbGVuZ3RoOwogICAgICAgIHRoaXMuaGFzX3N0cmVlID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoOwogICAgICB9CiAgICAgIHZhciBzdGF0aWNfbF9kZXNjOwogICAgICB2YXIgc3RhdGljX2RfZGVzYzsKICAgICAgdmFyIHN0YXRpY19ibF9kZXNjOwogICAgICBmdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7CiAgICAgICAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOwogICAgICAgIHRoaXMubWF4X2NvZGUgPSAwOwogICAgICAgIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRfY29kZShkaXN0KSB7CiAgICAgICAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSB3ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gdyA+Pj4gOCAmIDI1NTsKICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkgewogICAgICAgIGlmIChzLmJpX3ZhbGlkID4gQnVmX3NpemUgLSBsZW5ndGgpIHsKICAgICAgICAgIHMuYmlfYnVmIHw9IHZhbHVlIDw8IHMuYmlfdmFsaWQgJiA2NTUzNTsKICAgICAgICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7CiAgICAgICAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IEJ1Zl9zaXplIC0gcy5iaV92YWxpZDsKICAgICAgICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHMuYmlfYnVmIHw9IHZhbHVlIDw8IHMuYmlfdmFsaWQgJiA2NTUzNTsKICAgICAgICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkgewogICAgICAgIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXSwgdHJlZVtjICogMiArIDFdKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikgewogICAgICAgIHZhciByZXMgPSAwOwogICAgICAgIGRvIHsKICAgICAgICAgIHJlcyB8PSBjb2RlICYgMTsKICAgICAgICAgIGNvZGUgPj4+PSAxOwogICAgICAgICAgcmVzIDw8PSAxOwogICAgICAgIH0gd2hpbGUgKC0tbGVuID4gMCk7CiAgICAgICAgcmV0dXJuIHJlcyA+Pj4gMTsKICAgICAgfQogICAgICBmdW5jdGlvbiBiaV9mbHVzaChzKSB7CiAgICAgICAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7CiAgICAgICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICAgICAgcy5iaV9idWYgPSAwOwogICAgICAgICAgcy5iaV92YWxpZCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHsKICAgICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAyNTU7CiAgICAgICAgICBzLmJpX2J1ZiA+Pj0gODsKICAgICAgICAgIHMuYmlfdmFsaWQgLT0gODsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKSB7CiAgICAgICAgdmFyIHRyZWUgPSBkZXNjLmR5bl90cmVlOwogICAgICAgIHZhciBtYXhfY29kZSA9IGRlc2MubWF4X2NvZGU7CiAgICAgICAgdmFyIHN0cmVlID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7CiAgICAgICAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTsKICAgICAgICB2YXIgZXh0cmEgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzOwogICAgICAgIHZhciBiYXNlID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTsKICAgICAgICB2YXIgbWF4X2xlbmd0aCA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7CiAgICAgICAgdmFyIGg7CiAgICAgICAgdmFyIG4sIG07CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIHhiaXRzOwogICAgICAgIHZhciBmOwogICAgICAgIHZhciBvdmVyZmxvdyA9IDA7CiAgICAgICAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdID0gMDsKICAgICAgICB9CiAgICAgICAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0gPSAwOwogICAgICAgIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHsKICAgICAgICAgIG4gPSBzLmhlYXBbaF07CiAgICAgICAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0gKiAyICsgMV0gKyAxOwogICAgICAgICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7CiAgICAgICAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoOwogICAgICAgICAgICBvdmVyZmxvdysrOwogICAgICAgICAgfQogICAgICAgICAgdHJlZVtuICogMiArIDFdID0gYml0czsKICAgICAgICAgIGlmIChuID4gbWF4X2NvZGUpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdKys7CiAgICAgICAgICB4Yml0cyA9IDA7CiAgICAgICAgICBpZiAobiA+PSBiYXNlKSB7CiAgICAgICAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdOwogICAgICAgICAgfQogICAgICAgICAgZiA9IHRyZWVbbiAqIDJdOwogICAgICAgICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTsKICAgICAgICAgIGlmIChoYXNfc3RyZWUpIHsKICAgICAgICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXSArIHhiaXRzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKG92ZXJmbG93ID09PSAwKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGRvIHsKICAgICAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTsKICAgICAgICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7CiAgICAgICAgICAgIGJpdHMtLTsKICAgICAgICAgIH0KICAgICAgICAgIHMuYmxfY291bnRbYml0c10tLTsKICAgICAgICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7CiAgICAgICAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07CiAgICAgICAgICBvdmVyZmxvdyAtPSAyOwogICAgICAgIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7CiAgICAgICAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7CiAgICAgICAgICBuID0gcy5ibF9jb3VudFtiaXRzXTsKICAgICAgICAgIHdoaWxlIChuICE9PSAwKSB7CiAgICAgICAgICAgIG0gPSBzLmhlYXBbLS1oXTsKICAgICAgICAgICAgaWYgKG0gPiBtYXhfY29kZSkgewogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0cmVlW20gKiAyICsgMV0gIT09IGJpdHMpIHsKICAgICAgICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0pICogdHJlZVttICogMl07CiAgICAgICAgICAgICAgdHJlZVttICogMiArIDFdID0gYml0czsKICAgICAgICAgICAgfQogICAgICAgICAgICBuLS07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpIHsKICAgICAgICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7CiAgICAgICAgdmFyIGNvZGUgPSAwOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciBuOwogICAgICAgIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykgewogICAgICAgICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0gPDwgMTsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7CiAgICAgICAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdOwogICAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHRyZWVbbiAqIDJdID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHsKICAgICAgICB2YXIgbjsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgbGVuZ3RoOwogICAgICAgIHZhciBjb2RlOwogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOwogICAgICAgIGxlbmd0aCA9IDA7CiAgICAgICAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykgewogICAgICAgICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7CiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgMSA8PCBleHRyYV9sYml0c1tjb2RlXTsgbisrKSB7CiAgICAgICAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlOwogICAgICAgIGRpc3QgPSAwOwogICAgICAgIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7CiAgICAgICAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0OwogICAgICAgICAgZm9yIChuID0gMDsgbiA8IDEgPDwgZXh0cmFfZGJpdHNbY29kZV07IG4rKykgewogICAgICAgICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkaXN0ID4+PSA3OwogICAgICAgIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7CiAgICAgICAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7CiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgMSA8PCBleHRyYV9kYml0c1tjb2RlXSAtIDc7IG4rKykgewogICAgICAgICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHsKICAgICAgICAgIGJsX2NvdW50W2JpdHNdID0gMDsKICAgICAgICB9CiAgICAgICAgbiA9IDA7CiAgICAgICAgd2hpbGUgKG4gPD0gMTQzKSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDg7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs4XSsrOwogICAgICAgIH0KICAgICAgICB3aGlsZSAobiA8PSAyNTUpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gOTsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzldKys7CiAgICAgICAgfQogICAgICAgIHdoaWxlIChuIDw9IDI3OSkgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA3OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbN10rKzsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKG4gPD0gMjg3KSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDg7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs4XSsrOwogICAgICAgIH0KICAgICAgICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpOwogICAgICAgIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHsKICAgICAgICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdID0gNTsKICAgICAgICAgIHN0YXRpY19kdHJlZVtuICogMl0gPSBiaV9yZXZlcnNlKG4sIDUpOwogICAgICAgIH0KICAgICAgICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpOwogICAgICAgIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgRF9DT0RFUywgTUFYX0JJVFMpOwogICAgICAgIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCBCTF9DT0RFUywgTUFYX0JMX0JJVFMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluaXRfYmxvY2socykgewogICAgICAgIHZhciBuOwogICAgICAgIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyBuKyspIHsKICAgICAgICAgIHMuZHluX2x0cmVlW24gKiAyXSA9IDA7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHsKICAgICAgICAgIHMuZHluX2R0cmVlW24gKiAyXSA9IDA7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzLmJsX3RyZWVbbiAqIDJdID0gMDsKICAgICAgICB9CiAgICAgICAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0gPSAxOwogICAgICAgIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7CiAgICAgICAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmlfd2luZHVwKHMpIHsKICAgICAgICBpZiAocy5iaV92YWxpZCA+IDgpIHsKICAgICAgICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7CiAgICAgICAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkgewogICAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjsKICAgICAgICB9CiAgICAgICAgcy5iaV9idWYgPSAwOwogICAgICAgIHMuYmlfdmFsaWQgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcikgewogICAgICAgIGJpX3dpbmR1cChzKTsKICAgICAgICBpZiAoaGVhZGVyKSB7CiAgICAgICAgICBwdXRfc2hvcnQocywgbGVuKTsKICAgICAgICAgIHB1dF9zaG9ydChzLCB+bGVuKTsKICAgICAgICB9CiAgICAgICAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpOwogICAgICAgIHMucGVuZGluZyArPSBsZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkgewogICAgICAgIHZhciBfbjIgPSBuICogMjsKICAgICAgICB2YXIgX20yID0gbSAqIDI7CiAgICAgICAgcmV0dXJuIHRyZWVbX24yXSA8IHRyZWVbX20yXSB8fCB0cmVlW19uMl0gPT09IHRyZWVbX20yXSAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspIHsKICAgICAgICB2YXIgdiA9IHMuaGVhcFtrXTsKICAgICAgICB2YXIgaiA9IGsgPDwgMTsKICAgICAgICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7CiAgICAgICAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiYgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7CiAgICAgICAgICAgIGorKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBzLmhlYXBba10gPSBzLmhlYXBbal07CiAgICAgICAgICBrID0gajsKICAgICAgICAgIGogPDw9IDE7CiAgICAgICAgfQogICAgICAgIHMuaGVhcFtrXSA9IHY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKSB7CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIGxjOwogICAgICAgIHZhciBseCA9IDA7CiAgICAgICAgdmFyIGNvZGU7CiAgICAgICAgdmFyIGV4dHJhOwogICAgICAgIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGRpc3QgPSBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDggfCBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXTsKICAgICAgICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07CiAgICAgICAgICAgIGx4Kys7CiAgICAgICAgICAgIGlmIChkaXN0ID09PSAwKSB7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsKICAgICAgICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdOwogICAgICAgICAgICAgIGlmIChleHRyYSAhPT0gMCkgewogICAgICAgICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07CiAgICAgICAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZGlzdC0tOwogICAgICAgICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsKICAgICAgICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdOwogICAgICAgICAgICAgIGlmIChleHRyYSAhPT0gMCkgewogICAgICAgICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07CiAgICAgICAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTsKICAgICAgICB9CiAgICAgICAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYykgewogICAgICAgIHZhciB0cmVlID0gZGVzYy5keW5fdHJlZTsKICAgICAgICB2YXIgc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTsKICAgICAgICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlOwogICAgICAgIHZhciBlbGVtcyA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zOwogICAgICAgIHZhciBuLCBtOwogICAgICAgIHZhciBtYXhfY29kZSA9IC0xOwogICAgICAgIHZhciBub2RlOwogICAgICAgIHMuaGVhcF9sZW4gPSAwOwogICAgICAgIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7CiAgICAgICAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHsKICAgICAgICAgIGlmICh0cmVlW24gKiAyXSAhPT0gMCkgewogICAgICAgICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjsKICAgICAgICAgICAgcy5kZXB0aFtuXSA9IDA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0cmVlW24gKiAyICsgMV0gPSAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHsKICAgICAgICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwOwogICAgICAgICAgdHJlZVtub2RlICogMl0gPSAxOwogICAgICAgICAgcy5kZXB0aFtub2RlXSA9IDA7CiAgICAgICAgICBzLm9wdF9sZW4tLTsKICAgICAgICAgIGlmIChoYXNfc3RyZWUpIHsKICAgICAgICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTsKICAgICAgICBmb3IgKG4gPSBzLmhlYXBfbGVuID4+IDE7IG4gPj0gMTsgbi0tKSB7CiAgICAgICAgICBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOwogICAgICAgIH0KICAgICAgICBub2RlID0gZWxlbXM7CiAgICAgICAgZG8gewogICAgICAgICAgbiA9IHMuaGVhcFsxXTsKICAgICAgICAgIHMuaGVhcFsxXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dOwogICAgICAgICAgcHFkb3duaGVhcChzLCB0cmVlLCAxKTsKICAgICAgICAgIG0gPSBzLmhlYXBbMV07CiAgICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47CiAgICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07CiAgICAgICAgICB0cmVlW25vZGUgKiAyXSA9IHRyZWVbbiAqIDJdICsgdHJlZVttICogMl07CiAgICAgICAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7CiAgICAgICAgICB0cmVlW24gKiAyICsgMV0gPSB0cmVlW20gKiAyICsgMV0gPSBub2RlOwogICAgICAgICAgcy5oZWFwWzFdID0gbm9kZSsrOwogICAgICAgICAgcHFkb3duaGVhcChzLCB0cmVlLCAxKTsKICAgICAgICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpOwogICAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzFdOwogICAgICAgIGdlbl9iaXRsZW4ocywgZGVzYyk7CiAgICAgICAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpIHsKICAgICAgICB2YXIgbjsKICAgICAgICB2YXIgcHJldmxlbiA9IC0xOwogICAgICAgIHZhciBjdXJsZW47CiAgICAgICAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07CiAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICB2YXIgbWF4X2NvdW50ID0gNzsKICAgICAgICB2YXIgbWluX2NvdW50ID0gNDsKICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICB9CiAgICAgICAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXSA9IDY1NTM1OwogICAgICAgIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykgewogICAgICAgICAgY3VybGVuID0gbmV4dGxlbjsKICAgICAgICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV07CiAgICAgICAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7CiAgICAgICAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXSArPSBjb3VudDsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7CiAgICAgICAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsKICAgICAgICAgICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0rKzsKICAgICAgICAgICAgfQogICAgICAgICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdKys7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7CiAgICAgICAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXSsrOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0rKzsKICAgICAgICAgIH0KICAgICAgICAgIGNvdW50ID0gMDsKICAgICAgICAgIHByZXZsZW4gPSBjdXJsZW47CiAgICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBtYXhfY291bnQgPSA2OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNzsKICAgICAgICAgICAgbWluX2NvdW50ID0gNDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIHByZXZsZW4gPSAtMTsKICAgICAgICB2YXIgY3VybGVuOwogICAgICAgIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOwogICAgICAgIHZhciBjb3VudCA9IDA7CiAgICAgICAgdmFyIG1heF9jb3VudCA9IDc7CiAgICAgICAgdmFyIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykgewogICAgICAgICAgY3VybGVuID0gbmV4dGxlbjsKICAgICAgICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV07CiAgICAgICAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOwogICAgICAgICAgICB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7CiAgICAgICAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOwogICAgICAgICAgICAgIGNvdW50LS07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkgewogICAgICAgICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpOwogICAgICAgICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTsKICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpOwogICAgICAgICAgfQogICAgICAgICAgY291bnQgPSAwOwogICAgICAgICAgcHJldmxlbiA9IGN1cmxlbjsKICAgICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDY7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtYXhfY291bnQgPSA3OwogICAgICAgICAgICBtaW5fY291bnQgPSA0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHsKICAgICAgICB2YXIgbWF4X2JsaW5kZXg7CiAgICAgICAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7CiAgICAgICAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7CiAgICAgICAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpOwogICAgICAgIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHsKICAgICAgICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0OwogICAgICAgIHJldHVybiBtYXhfYmxpbmRleDsKICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2RlcykgewogICAgICAgIHZhciByYW5rOwogICAgICAgIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOwogICAgICAgIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCA1KTsKICAgICAgICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsIDQpOwogICAgICAgIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHsKICAgICAgICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0sIDMpOwogICAgICAgIH0KICAgICAgICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOwogICAgICAgIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7CiAgICAgICAgdmFyIGJsYWNrX21hc2sgPSA0MDkzNjI0NDQ3OwogICAgICAgIHZhciBuOwogICAgICAgIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHsKICAgICAgICAgIGlmIChibGFja19tYXNrICYgMSAmJiBzLmR5bl9sdHJlZVtuICogMl0gIT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIFpfQklOQVJZOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5keW5fbHRyZWVbOSAqIDJdICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0gIT09IDAgfHwgcy5keW5fbHRyZWVbMTMgKiAyXSAhPT0gMCkgewogICAgICAgICAgcmV0dXJuIFpfVEVYVDsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7CiAgICAgICAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdICE9PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBaX1RFWFQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBaX0JJTkFSWTsKICAgICAgfQogICAgICB2YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlOwogICAgICBmdW5jdGlvbiBfdHJfaW5pdChzKSB7CiAgICAgICAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7CiAgICAgICAgICB0cl9zdGF0aWNfaW5pdCgpOwogICAgICAgICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7CiAgICAgICAgfQogICAgICAgIHMubF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTsKICAgICAgICBzLmRfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7CiAgICAgICAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpOwogICAgICAgIHMuYmlfYnVmID0gMDsKICAgICAgICBzLmJpX3ZhbGlkID0gMDsKICAgICAgICBpbml0X2Jsb2NrKHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSB7CiAgICAgICAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7CiAgICAgICAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl9hbGlnbihzKSB7CiAgICAgICAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTsKICAgICAgICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpOwogICAgICAgIGJpX2ZsdXNoKHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpIHsKICAgICAgICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOwogICAgICAgIHZhciBtYXhfYmxpbmRleCA9IDA7CiAgICAgICAgaWYgKHMubGV2ZWwgPiAwKSB7CiAgICAgICAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7CiAgICAgICAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpOwogICAgICAgICAgfQogICAgICAgICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7CiAgICAgICAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTsKICAgICAgICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTsKICAgICAgICAgIG9wdF9sZW5iID0gcy5vcHRfbGVuICsgMyArIDcgPj4+IDM7CiAgICAgICAgICBzdGF0aWNfbGVuYiA9IHMuc3RhdGljX2xlbiArIDMgKyA3ID4+PiAzOwogICAgICAgICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7CiAgICAgICAgICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmI7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iICYmIGJ1ZiAhPT0gLTEpIHsKICAgICAgICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTsKICAgICAgICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7CiAgICAgICAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsKICAgICAgICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7CiAgICAgICAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTsKICAgICAgICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7CiAgICAgICAgfQogICAgICAgIGluaXRfYmxvY2socyk7CiAgICAgICAgaWYgKGxhc3QpIHsKICAgICAgICAgIGJpX3dpbmR1cChzKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdID0gZGlzdCA+Pj4gOCAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMjU1OwogICAgICAgIHMubGFzdF9saXQrKzsKICAgICAgICBpZiAoZGlzdCA9PT0gMCkgewogICAgICAgICAgcy5keW5fbHRyZWVbbGMgKiAyXSsrOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzLm1hdGNoZXMrKzsKICAgICAgICAgIGRpc3QtLTsKICAgICAgICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdKys7CiAgICAgICAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXSsrOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDE7CiAgICAgIH0KICAgICAgZXhwb3J0cy5fdHJfaW5pdCA9IF90cl9pbml0OwogICAgICBleHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrOwogICAgICBleHBvcnRzLl90cl9mbHVzaF9ibG9jayA9IF90cl9mbHVzaF9ibG9jazsKICAgICAgZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7CiAgICAgIGV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcwogIHZhciByZXF1aXJlX2FkbGVyMzIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7CiAgICAgICAgdmFyIHMxID0gYWRsZXIgJiA2NTUzNSB8IDAsIHMyID0gYWRsZXIgPj4+IDE2ICYgNjU1MzUgfCAwLCBuID0gMDsKICAgICAgICB3aGlsZSAobGVuICE9PSAwKSB7CiAgICAgICAgICBuID0gbGVuID4gMmUzID8gMmUzIDogbGVuOwogICAgICAgICAgbGVuIC09IG47CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIHMxID0gczEgKyBidWZbcG9zKytdIHwgMDsKICAgICAgICAgICAgczIgPSBzMiArIHMxIHwgMDsKICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICBzMSAlPSA2NTUyMTsKICAgICAgICAgIHMyICU9IDY1NTIxOwogICAgICAgIH0KICAgICAgICByZXR1cm4gczEgfCBzMiA8PCAxNiB8IDA7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMKICB2YXIgcmVxdWlyZV9jcmMzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBtYWtlVGFibGUoKSB7CiAgICAgICAgdmFyIGMsIHRhYmxlID0gW107CiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykgewogICAgICAgICAgYyA9IG47CiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykgewogICAgICAgICAgICBjID0gYyAmIDEgPyAzOTg4MjkyMzg0IF4gYyA+Pj4gMSA6IGMgPj4+IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0YWJsZVtuXSA9IGM7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0YWJsZTsKICAgICAgfQogICAgICB2YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTsKICAgICAgZnVuY3Rpb24gY3JjMzIyKGNyYywgYnVmLCBsZW4sIHBvcykgewogICAgICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjsKICAgICAgICBjcmMgXj0gLTE7CiAgICAgICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7CiAgICAgICAgICBjcmMgPSBjcmMgPj4+IDggXiB0WyhjcmMgXiBidWZbaV0pICYgMjU1XTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyYyBeIC0xOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gY3JjMzIyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMKICB2YXIgcmVxdWlyZV9tZXNzYWdlczIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7CiAgICAgICAgMjogIm5lZWQgZGljdGlvbmFyeSIsCiAgICAgICAgMTogInN0cmVhbSBlbmQiLAogICAgICAgIDA6ICIiLAogICAgICAgICItMSI6ICJmaWxlIGVycm9yIiwKICAgICAgICAiLTIiOiAic3RyZWFtIGVycm9yIiwKICAgICAgICAiLTMiOiAiZGF0YSBlcnJvciIsCiAgICAgICAgIi00IjogImluc3VmZmljaWVudCBtZW1vcnkiLAogICAgICAgICItNSI6ICJidWZmZXIgZXJyb3IiLAogICAgICAgICItNiI6ICJpbmNvbXBhdGlibGUgdmVyc2lvbiIKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMKICB2YXIgcmVxdWlyZV9kZWZsYXRlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICB2YXIgdHJlZXMgPSByZXF1aXJlX3RyZWVzKCk7CiAgICAgIHZhciBhZGxlcjMyID0gcmVxdWlyZV9hZGxlcjMyKCk7CiAgICAgIHZhciBjcmMzMjIgPSByZXF1aXJlX2NyYzMyKCk7CiAgICAgIHZhciBtc2cgPSByZXF1aXJlX21lc3NhZ2VzMigpOwogICAgICB2YXIgWl9OT19GTFVTSCA9IDA7CiAgICAgIHZhciBaX1BBUlRJQUxfRkxVU0ggPSAxOwogICAgICB2YXIgWl9GVUxMX0ZMVVNIID0gMzsKICAgICAgdmFyIFpfRklOSVNIID0gNDsKICAgICAgdmFyIFpfQkxPQ0sgPSA1OwogICAgICB2YXIgWl9PSyA9IDA7CiAgICAgIHZhciBaX1NUUkVBTV9FTkQgPSAxOwogICAgICB2YXIgWl9TVFJFQU1fRVJST1IgPSAtMjsKICAgICAgdmFyIFpfREFUQV9FUlJPUiA9IC0zOwogICAgICB2YXIgWl9CVUZfRVJST1IgPSAtNTsKICAgICAgdmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xOwogICAgICB2YXIgWl9GSUxURVJFRCA9IDE7CiAgICAgIHZhciBaX0hVRkZNQU5fT05MWSA9IDI7CiAgICAgIHZhciBaX1JMRSA9IDM7CiAgICAgIHZhciBaX0ZJWEVEID0gNDsKICAgICAgdmFyIFpfREVGQVVMVF9TVFJBVEVHWSA9IDA7CiAgICAgIHZhciBaX1VOS05PV04gPSAyOwogICAgICB2YXIgWl9ERUZMQVRFRCA9IDg7CiAgICAgIHZhciBNQVhfTUVNX0xFVkVMID0gOTsKICAgICAgdmFyIE1BWF9XQklUUyA9IDE1OwogICAgICB2YXIgREVGX01FTV9MRVZFTCA9IDg7CiAgICAgIHZhciBMRU5HVEhfQ09ERVMgPSAyOTsKICAgICAgdmFyIExJVEVSQUxTID0gMjU2OwogICAgICB2YXIgTF9DT0RFUyA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUzsKICAgICAgdmFyIERfQ09ERVMgPSAzMDsKICAgICAgdmFyIEJMX0NPREVTID0gMTk7CiAgICAgIHZhciBIRUFQX1NJWkUgPSAyICogTF9DT0RFUyArIDE7CiAgICAgIHZhciBNQVhfQklUUyA9IDE1OwogICAgICB2YXIgTUlOX01BVENIID0gMzsKICAgICAgdmFyIE1BWF9NQVRDSCA9IDI1ODsKICAgICAgdmFyIE1JTl9MT09LQUhFQUQgPSBNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxOwogICAgICB2YXIgUFJFU0VUX0RJQ1QgPSAzMjsKICAgICAgdmFyIElOSVRfU1RBVEUgPSA0MjsKICAgICAgdmFyIEVYVFJBX1NUQVRFID0gNjk7CiAgICAgIHZhciBOQU1FX1NUQVRFID0gNzM7CiAgICAgIHZhciBDT01NRU5UX1NUQVRFID0gOTE7CiAgICAgIHZhciBIQ1JDX1NUQVRFID0gMTAzOwogICAgICB2YXIgQlVTWV9TVEFURSA9IDExMzsKICAgICAgdmFyIEZJTklTSF9TVEFURSA9IDY2NjsKICAgICAgdmFyIEJTX05FRURfTU9SRSA9IDE7CiAgICAgIHZhciBCU19CTE9DS19ET05FID0gMjsKICAgICAgdmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsKICAgICAgdmFyIEJTX0ZJTklTSF9ET05FID0gNDsKICAgICAgdmFyIE9TX0NPREUgPSAzOwogICAgICBmdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7CiAgICAgICAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTsKICAgICAgICByZXR1cm4gZXJyb3JDb2RlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJhbmsoZikgewogICAgICAgIHJldHVybiAoZiA8PCAxKSAtIChmID4gNCA/IDkgOiAwKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB6ZXJvKGJ1ZikgewogICAgICAgIHZhciBsZW4gPSBidWYubGVuZ3RoOwogICAgICAgIHdoaWxlICgtLWxlbiA+PSAwKSB7CiAgICAgICAgICBidWZbbGVuXSA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkgewogICAgICAgIHZhciBzID0gc3RybS5zdGF0ZTsKICAgICAgICB2YXIgbGVuID0gcy5wZW5kaW5nOwogICAgICAgIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkgewogICAgICAgICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgfQogICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7CiAgICAgICAgc3RybS5uZXh0X291dCArPSBsZW47CiAgICAgICAgcy5wZW5kaW5nX291dCArPSBsZW47CiAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gbGVuOwogICAgICAgIHN0cm0uYXZhaWxfb3V0IC09IGxlbjsKICAgICAgICBzLnBlbmRpbmcgLT0gbGVuOwogICAgICAgIGlmIChzLnBlbmRpbmcgPT09IDApIHsKICAgICAgICAgIHMucGVuZGluZ19vdXQgPSAwOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHsKICAgICAgICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgcy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7CiAgICAgICAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgZmx1c2hfcGVuZGluZyhzLnN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikgewogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiA+Pj4gOCAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAyNTU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkgewogICAgICAgIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luOwogICAgICAgIGlmIChsZW4gPiBzaXplKSB7CiAgICAgICAgICBsZW4gPSBzaXplOwogICAgICAgIH0KICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgc3RybS5hdmFpbF9pbiAtPSBsZW47CiAgICAgICAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpOwogICAgICAgIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7CiAgICAgICAgfSBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMjIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTsKICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X2luICs9IGxlbjsKICAgICAgICBzdHJtLnRvdGFsX2luICs9IGxlbjsKICAgICAgICByZXR1cm4gbGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7CiAgICAgICAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsKICAgICAgICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgdmFyIG1hdGNoOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsKICAgICAgICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsKICAgICAgICB2YXIgbGltaXQgPSBzLnN0cnN0YXJ0ID4gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEID8gcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMDsKICAgICAgICB2YXIgX3dpbiA9IHMud2luZG93OwogICAgICAgIHZhciB3bWFzayA9IHMud19tYXNrOwogICAgICAgIHZhciBwcmV2ID0gcy5wcmV2OwogICAgICAgIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIOwogICAgICAgIHZhciBzY2FuX2VuZDEgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdOwogICAgICAgIHZhciBzY2FuX2VuZCA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTsKICAgICAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHsKICAgICAgICAgIGNoYWluX2xlbmd0aCA+Pj0gMjsKICAgICAgICB9CiAgICAgICAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgewogICAgICAgICAgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOwogICAgICAgIH0KICAgICAgICBkbyB7CiAgICAgICAgICBtYXRjaCA9IGN1cl9tYXRjaDsKICAgICAgICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICE9PSBzY2FuX2VuZCB8fCBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8IF93aW5bbWF0Y2hdICE9PSBfd2luW3NjYW5dIHx8IF93aW5bKyttYXRjaF0gIT09IF93aW5bc2NhbiArIDFdKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgc2NhbiArPSAyOwogICAgICAgICAgbWF0Y2grKzsKICAgICAgICAgIGRvIHsKICAgICAgICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgc2NhbiA8IHN0cmVuZCk7CiAgICAgICAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7CiAgICAgICAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIOwogICAgICAgICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7CiAgICAgICAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7CiAgICAgICAgICAgIGJlc3RfbGVuID0gbGVuOwogICAgICAgICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBzY2FuX2VuZDEgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdOwogICAgICAgICAgICBzY2FuX2VuZCA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTsKICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApOwogICAgICAgIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkgewogICAgICAgICAgcmV0dXJuIGJlc3RfbGVuOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcy5sb29rYWhlYWQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmlsbF93aW5kb3cocykgewogICAgICAgIHZhciBfd19zaXplID0gcy53X3NpemU7CiAgICAgICAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjsKICAgICAgICBkbyB7CiAgICAgICAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDsKICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7CiAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7CiAgICAgICAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTsKICAgICAgICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplOwogICAgICAgICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7CiAgICAgICAgICAgIG4gPSBzLmhhc2hfc2l6ZTsKICAgICAgICAgICAgcCA9IG47CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBtID0gcy5oZWFkWy0tcF07CiAgICAgICAgICAgICAgcy5oZWFkW3BdID0gbSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwOwogICAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgICBuID0gX3dfc2l6ZTsKICAgICAgICAgICAgcCA9IG47CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBtID0gcy5wcmV2Wy0tcF07CiAgICAgICAgICAgICAgcy5wcmV2W3BdID0gbSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwOwogICAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgICBtb3JlICs9IF93X3NpemU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7CiAgICAgICAgICBzLmxvb2thaGVhZCArPSBuOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDsKICAgICAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7CiAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyOwogICAgICAgICAgICAgIHN0cisrOwogICAgICAgICAgICAgIHMuaW5zZXJ0LS07CiAgICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIG1heF9ibG9ja19zaXplID0gNjU1MzU7CiAgICAgICAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkgewogICAgICAgICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1OwogICAgICAgIH0KICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkOwogICAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTsKICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7CiAgICAgICAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDsKICAgICAgICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHsKICAgICAgICB2YXIgaGFzaF9oZWFkOwogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaGFzaF9oZWFkID0gMDsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaGFzaF9oZWFkICE9PSAwICYmIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTsKICAgICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdOwogICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGhhc2hfaGVhZDsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIHZhciBtYXhfaW5zZXJ0OwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGhhc2hfaGVhZCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgfQogICAgICAgICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDsKICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgIGlmIChoYXNoX2hlYWQgIT09IDAgJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiYgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7CiAgICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2KSkgewogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHsKICAgICAgICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7CiAgICAgICAgICAgIHMucHJldl9sZW5ndGggLT0gMjsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkgewogICAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7CiAgICAgICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7CiAgICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkgewogICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7CiAgICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkgewogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgdmFyIHByZXY7CiAgICAgICAgdmFyIHNjYW4sIHN0cmVuZDsKICAgICAgICB2YXIgX3dpbiA9IHMud2luZG93OwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHsKICAgICAgICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxOwogICAgICAgICAgICBwcmV2ID0gX3dpbltzY2FuXTsKICAgICAgICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7CiAgICAgICAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBzY2FuIDwgc3RyZW5kKTsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTsKICAgICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkgewogICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTsKICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHsKICAgICAgICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7CiAgICAgICAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5OwogICAgICAgIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDsKICAgICAgICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjsKICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jOwogICAgICB9CiAgICAgIHZhciBjb25maWd1cmF0aW9uX3RhYmxlOwogICAgICBjb25maWd1cmF0aW9uX3RhYmxlID0gWwogICAgICAgIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLAogICAgICAgIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLAogICAgICAgIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLAogICAgICAgIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KQogICAgICBdOwogICAgICBmdW5jdGlvbiBsbV9pbml0KHMpIHsKICAgICAgICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplOwogICAgICAgIHplcm8ocy5oZWFkKTsKICAgICAgICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTsKICAgICAgICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoOwogICAgICAgIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7CiAgICAgICAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47CiAgICAgICAgcy5zdHJzdGFydCA9IDA7CiAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICBzLmluc19oID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7CiAgICAgICAgdGhpcy5zdHJtID0gbnVsbDsKICAgICAgICB0aGlzLnN0YXR1cyA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7CiAgICAgICAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsKICAgICAgICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICB0aGlzLnBlbmRpbmcgPSAwOwogICAgICAgIHRoaXMud3JhcCA9IDA7CiAgICAgICAgdGhpcy5nemhlYWQgPSBudWxsOwogICAgICAgIHRoaXMuZ3ppbmRleCA9IDA7CiAgICAgICAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOwogICAgICAgIHRoaXMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgIHRoaXMud19zaXplID0gMDsKICAgICAgICB0aGlzLndfYml0cyA9IDA7CiAgICAgICAgdGhpcy53X21hc2sgPSAwOwogICAgICAgIHRoaXMud2luZG93ID0gbnVsbDsKICAgICAgICB0aGlzLndpbmRvd19zaXplID0gMDsKICAgICAgICB0aGlzLnByZXYgPSBudWxsOwogICAgICAgIHRoaXMuaGVhZCA9IG51bGw7CiAgICAgICAgdGhpcy5pbnNfaCA9IDA7CiAgICAgICAgdGhpcy5oYXNoX3NpemUgPSAwOwogICAgICAgIHRoaXMuaGFzaF9iaXRzID0gMDsKICAgICAgICB0aGlzLmhhc2hfbWFzayA9IDA7CiAgICAgICAgdGhpcy5oYXNoX3NoaWZ0ID0gMDsKICAgICAgICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5wcmV2X21hdGNoID0gMDsKICAgICAgICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgdGhpcy5zdHJzdGFydCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9zdGFydCA9IDA7CiAgICAgICAgdGhpcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHRoaXMucHJldl9sZW5ndGggPSAwOwogICAgICAgIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5sZXZlbCA9IDA7CiAgICAgICAgdGhpcy5zdHJhdGVneSA9IDA7CiAgICAgICAgdGhpcy5nb29kX21hdGNoID0gMDsKICAgICAgICB0aGlzLm5pY2VfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMuZHluX2x0cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpOwogICAgICAgIHRoaXMuZHluX2R0cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7CiAgICAgICAgdGhpcy5ibF90cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpOwogICAgICAgIHplcm8odGhpcy5keW5fbHRyZWUpOwogICAgICAgIHplcm8odGhpcy5keW5fZHRyZWUpOwogICAgICAgIHplcm8odGhpcy5ibF90cmVlKTsKICAgICAgICB0aGlzLmxfZGVzYyA9IG51bGw7CiAgICAgICAgdGhpcy5kX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuYmxfZGVzYyA9IG51bGw7CiAgICAgICAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpOwogICAgICAgIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOwogICAgICAgIHplcm8odGhpcy5oZWFwKTsKICAgICAgICB0aGlzLmhlYXBfbGVuID0gMDsKICAgICAgICB0aGlzLmhlYXBfbWF4ID0gMDsKICAgICAgICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7CiAgICAgICAgemVybyh0aGlzLmRlcHRoKTsKICAgICAgICB0aGlzLmxfYnVmID0gMDsKICAgICAgICB0aGlzLmxpdF9idWZzaXplID0gMDsKICAgICAgICB0aGlzLmxhc3RfbGl0ID0gMDsKICAgICAgICB0aGlzLmRfYnVmID0gMDsKICAgICAgICB0aGlzLm9wdF9sZW4gPSAwOwogICAgICAgIHRoaXMuc3RhdGljX2xlbiA9IDA7CiAgICAgICAgdGhpcy5tYXRjaGVzID0gMDsKICAgICAgICB0aGlzLmluc2VydCA9IDA7CiAgICAgICAgdGhpcy5iaV9idWYgPSAwOwogICAgICAgIHRoaXMuYmlfdmFsaWQgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkgewogICAgICAgIHZhciBzOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7CiAgICAgICAgfQogICAgICAgIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7CiAgICAgICAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047CiAgICAgICAgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgcy5wZW5kaW5nID0gMDsKICAgICAgICBzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICBpZiAocy53cmFwIDwgMCkgewogICAgICAgICAgcy53cmFwID0gLXMud3JhcDsKICAgICAgICB9CiAgICAgICAgcy5zdGF0dXMgPSBzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURTsKICAgICAgICBzdHJtLmFkbGVyID0gcy53cmFwID09PSAyID8gMCA6IDE7CiAgICAgICAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDsKICAgICAgICB0cmVlcy5fdHJfaW5pdChzKTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkgewogICAgICAgIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pOwogICAgICAgIGlmIChyZXQgPT09IFpfT0spIHsKICAgICAgICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHsKICAgICAgICBpZiAoIXN0cm0pIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgdmFyIHdyYXAgPSAxOwogICAgICAgIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7CiAgICAgICAgICBsZXZlbCA9IDY7CiAgICAgICAgfQogICAgICAgIGlmICh3aW5kb3dCaXRzIDwgMCkgewogICAgICAgICAgd3JhcCA9IDA7CiAgICAgICAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHsKICAgICAgICAgIHdyYXAgPSAyOwogICAgICAgICAgd2luZG93Qml0cyAtPSAxNjsKICAgICAgICB9CiAgICAgICAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8IHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8IHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyA9PT0gOCkgewogICAgICAgICAgd2luZG93Qml0cyA9IDk7CiAgICAgICAgfQogICAgICAgIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpOwogICAgICAgIHN0cm0uc3RhdGUgPSBzOwogICAgICAgIHMuc3RybSA9IHN0cm07CiAgICAgICAgcy53cmFwID0gd3JhcDsKICAgICAgICBzLmd6aGVhZCA9IG51bGw7CiAgICAgICAgcy53X2JpdHMgPSB3aW5kb3dCaXRzOwogICAgICAgIHMud19zaXplID0gMSA8PCBzLndfYml0czsKICAgICAgICBzLndfbWFzayA9IHMud19zaXplIC0gMTsKICAgICAgICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNzsKICAgICAgICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7CiAgICAgICAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7CiAgICAgICAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpOwogICAgICAgIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTsKICAgICAgICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpOwogICAgICAgIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7CiAgICAgICAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgbWVtTGV2ZWwgKyA2OwogICAgICAgIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0OwogICAgICAgIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpOwogICAgICAgIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTsKICAgICAgICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7CiAgICAgICAgcy5sZXZlbCA9IGxldmVsOwogICAgICAgIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTsKICAgICAgICBzLm1ldGhvZCA9IG1ldGhvZDsKICAgICAgICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7CiAgICAgICAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHsKICAgICAgICB2YXIgb2xkX2ZsdXNoLCBzOwogICAgICAgIHZhciBiZWcsIHZhbDsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkgewogICAgICAgICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmICghc3RybS5vdXRwdXQgfHwgIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBzdHJtLmF2YWlsX291dCA9PT0gMCA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzLnN0cm0gPSBzdHJtOwogICAgICAgIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDsKICAgICAgICBzLmxhc3RfZmx1c2ggPSBmbHVzaDsKICAgICAgICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLndyYXAgPT09IDIpIHsKICAgICAgICAgICAgc3RybS5hZGxlciA9IDA7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDMxKTsKICAgICAgICAgICAgcHV0X2J5dGUocywgMTM5KTsKICAgICAgICAgICAgcHV0X2J5dGUocywgOCk7CiAgICAgICAgICAgIGlmICghcy5nemhlYWQpIHsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6IHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgPyA0IDogMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICsgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgKyAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICsgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICsgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiA4ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lID4+IDE2ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lID4+IDI0ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6IHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgPyA0IDogMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAyNTUpOwogICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDI1NSk7CiAgICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGhlYWRlciA9IFpfREVGTEFURUQgKyAocy53X2JpdHMgLSA4IDw8IDQpIDw8IDg7CiAgICAgICAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xOwogICAgICAgICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMDsKICAgICAgICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMTsKICAgICAgICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMzsKICAgICAgICAgICAgfQogICAgICAgICAgICBoZWFkZXIgfD0gbGV2ZWxfZmxhZ3MgPDwgNjsKICAgICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsKICAgICAgICAgICAgICBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGVhZGVyICs9IDMxIC0gaGVhZGVyICUgMzE7CiAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTsKICAgICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsKICAgICAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7CiAgICAgICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDY1NTM1KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzdHJtLmFkbGVyID0gMTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhKSB7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiA2NTUzNSkpIHsKICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAyNTUpOwogICAgICAgICAgICAgIHMuZ3ppbmRleCsrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMjIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkgewogICAgICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLm5hbWUpIHsKICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICAgIHZhbCA9IDE7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAyNTU7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZhbCA9IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7CiAgICAgICAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7CiAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMjIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHsKICAgICAgICAgICAgICBzLmd6aW5kZXggPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5jb21tZW50KSB7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMjIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgICB2YWwgPSAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMjU1OwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB2YWwgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwdXRfYnl0ZShzLCB2YWwpOwogICAgICAgICAgICB9IHdoaWxlICh2YWwgIT09IDApOwogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodmFsID09PSAwKSB7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHsKICAgICAgICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHsKICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiYgZmx1c2ggIT09IFpfRklOSVNIKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7CiAgICAgICAgfQogICAgICAgIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8IGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpIHsKICAgICAgICAgIHZhciBic3RhdGUgPSBzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOiBzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCk7CiAgICAgICAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHsKICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7CiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7CiAgICAgICAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpOwogICAgICAgICAgICB9IGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7CiAgICAgICAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7CiAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHsKICAgICAgICAgICAgICAgIHplcm8ocy5oZWFkKTsKICAgICAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDsKICAgICAgICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgewogICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChzLndyYXAgPD0gMCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VORDsKICAgICAgICB9CiAgICAgICAgaWYgKHMud3JhcCA9PT0gMikgewogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDggJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiAxNiAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDI0ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiA+PiA4ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gPj4gMTYgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiA+PiAyNCAmIDI1NSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTsKICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiA2NTUzNSk7CiAgICAgICAgfQogICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgaWYgKHMud3JhcCA+IDApIHsKICAgICAgICAgIHMud3JhcCA9IC1zLndyYXA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkgewogICAgICAgIHZhciBzdGF0dXM7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzOwogICAgICAgIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiYgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJiBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiYgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJiBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiYgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgICAgICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHsKICAgICAgICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoOwogICAgICAgIHZhciBzOwogICAgICAgIHZhciBzdHIsIG47CiAgICAgICAgdmFyIHdyYXA7CiAgICAgICAgdmFyIGF2YWlsOwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBpbnB1dDsKICAgICAgICB2YXIgdG1wRGljdDsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgd3JhcCA9IHMud3JhcDsKICAgICAgICBpZiAod3JhcCA9PT0gMiB8fCB3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFIHx8IHMubG9va2FoZWFkKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmICh3cmFwID09PSAxKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTsKICAgICAgICB9CiAgICAgICAgcy53cmFwID0gMDsKICAgICAgICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkgewogICAgICAgICAgaWYgKHdyYXAgPT09IDApIHsKICAgICAgICAgICAgemVybyhzLmhlYWQpOwogICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDsKICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7CiAgICAgICAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTsKICAgICAgICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0OwogICAgICAgICAgZGljdExlbmd0aCA9IHMud19zaXplOwogICAgICAgIH0KICAgICAgICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjsKICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7CiAgICAgICAgc3RybS5uZXh0X2luID0gMDsKICAgICAgICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTsKICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICBzdHIgPSBzLnN0cnN0YXJ0OwogICAgICAgICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpOwogICAgICAgICAgZG8gewogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjsKICAgICAgICAgICAgc3RyKys7CiAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgcy5zdHJzdGFydCA9IHN0cjsKICAgICAgICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgIH0KICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0OwogICAgICAgIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7CiAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgc3RybS5pbnB1dCA9IGlucHV0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDsKICAgICAgICBzLndyYXAgPSB3cmFwOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDsKICAgICAgZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7CiAgICAgIGV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0OwogICAgICBleHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwOwogICAgICBleHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyOwogICAgICBleHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlOwogICAgICBleHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kOwogICAgICBleHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7CiAgICAgIGV4cG9ydHMuZGVmbGF0ZUluZm8gPSAicGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcwogIHZhciByZXF1aXJlX3N0cmluZ3MgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICB2YXIgU1RSX0FQUExZX09LID0gdHJ1ZTsKICAgICAgdmFyIFNUUl9BUFBMWV9VSUFfT0sgPSB0cnVlOwogICAgICB0cnkgewogICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWzBdKTsKICAgICAgfSBjYXRjaCAoX18pIHsKICAgICAgICBTVFJfQVBQTFlfT0sgPSBmYWxzZTsKICAgICAgfQogICAgICB0cnkgewogICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOwogICAgICB9IGNhdGNoIChfXykgewogICAgICAgIFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsKICAgICAgfQogICAgICB2YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpOwogICAgICBmb3IgKHEgPSAwOyBxIDwgMjU2OyBxKyspIHsKICAgICAgICBfdXRmOGxlbltxXSA9IHEgPj0gMjUyID8gNiA6IHEgPj0gMjQ4ID8gNSA6IHEgPj0gMjQwID8gNCA6IHEgPj0gMjI0ID8gMyA6IHEgPj0gMTkyID8gMiA6IDE7CiAgICAgIH0KICAgICAgdmFyIHE7CiAgICAgIF91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsKICAgICAgZXhwb3J0cy5zdHJpbmcyYnVmID0gZnVuY3Rpb24oc3RyKSB7CiAgICAgICAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7CiAgICAgICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykgewogICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTsKICAgICAgICAgIGlmICgoYyAmIDY0NTEyKSA9PT0gNTUyOTYgJiYgbV9wb3MgKyAxIDwgc3RyX2xlbikgewogICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7CiAgICAgICAgICAgIGlmICgoYzIgJiA2NDUxMikgPT09IDU2MzIwKSB7CiAgICAgICAgICAgICAgYyA9IDY1NTM2ICsgKGMgLSA1NTI5NiA8PCAxMCkgKyAoYzIgLSA1NjMyMCk7CiAgICAgICAgICAgICAgbV9wb3MrKzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgYnVmX2xlbiArPSBjIDwgMTI4ID8gMSA6IGMgPCAyMDQ4ID8gMiA6IGMgPCA2NTUzNiA/IDMgOiA0OwogICAgICAgIH0KICAgICAgICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTsKICAgICAgICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7CiAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpOwogICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5NiAmJiBtX3BvcyArIDEgPCBzdHJfbGVuKSB7CiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTsKICAgICAgICAgICAgaWYgKChjMiAmIDY0NTEyKSA9PT0gNTYzMjApIHsKICAgICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAtIDU1Mjk2IDw8IDEwKSArIChjMiAtIDU2MzIwKTsKICAgICAgICAgICAgICBtX3BvcysrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYyA8IDEyOCkgewogICAgICAgICAgICBidWZbaSsrXSA9IGM7CiAgICAgICAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTkyIHwgYyA+Pj4gNjsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjICYgNjM7CiAgICAgICAgICB9IGVsc2UgaWYgKGMgPCA2NTUzNikgewogICAgICAgICAgICBidWZbaSsrXSA9IDIyNCB8IGMgPj4+IDEyOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgPj4+IDYgJiA2MzsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjICYgNjM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBidWZbaSsrXSA9IDI0MCB8IGMgPj4+IDE4OwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgPj4+IDEyICYgNjM7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gNiAmIDYzOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikgewogICAgICAgIGlmIChsZW4gPCA2NTUzNCkgewogICAgICAgICAgaWYgKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LIHx8ICFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSB7CiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQogICAgICBleHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbihidWYpIHsKICAgICAgICByZXR1cm4gYnVmMmJpbnN0cmluZyhidWYsIGJ1Zi5sZW5ndGgpOwogICAgICB9OwogICAgICBleHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbihzdHIpIHsKICAgICAgICB2YXIgYnVmID0gbmV3IHV0aWxzLkJ1Zjgoc3RyLmxlbmd0aCk7CiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH07CiAgICAgIGV4cG9ydHMuYnVmMnN0cmluZyA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7CiAgICAgICAgdmFyIGksIG91dCwgYywgY19sZW47CiAgICAgICAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoOwogICAgICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTsKICAgICAgICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOyApIHsKICAgICAgICAgIGMgPSBidWZbaSsrXTsKICAgICAgICAgIGlmIChjIDwgMTI4KSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTsKICAgICAgICAgIGlmIChjX2xlbiA+IDQpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gNjU1MzM7CiAgICAgICAgICAgIGkgKz0gY19sZW4gLSAxOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAzMSA6IGNfbGVuID09PSAzID8gMTUgOiA3OwogICAgICAgICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7CiAgICAgICAgICAgIGMgPSBjIDw8IDYgfCBidWZbaSsrXSAmIDYzOwogICAgICAgICAgICBjX2xlbi0tOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGNfbGVuID4gMSkgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA2NTUzMzsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYyA8IDY1NTM2KSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjIC09IDY1NTM2OwogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA1NTI5NiB8IGMgPj4gMTAgJiAxMDIzOwogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA1NjMyMCB8IGMgJiAxMDIzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTsKICAgICAgfTsKICAgICAgZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24oYnVmLCBtYXgpIHsKICAgICAgICB2YXIgcG9zOwogICAgICAgIG1heCA9IG1heCB8fCBidWYubGVuZ3RoOwogICAgICAgIGlmIChtYXggPiBidWYubGVuZ3RoKSB7CiAgICAgICAgICBtYXggPSBidWYubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBwb3MgPSBtYXggLSAxOwogICAgICAgIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgIHBvcy0tOwogICAgICAgIH0KICAgICAgICBpZiAocG9zIDwgMCkgewogICAgICAgICAgcmV0dXJuIG1heDsKICAgICAgICB9CiAgICAgICAgaWYgKHBvcyA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIG1heDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCA/IHBvcyA6IG1heDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMKICB2YXIgcmVxdWlyZV96c3RyZWFtID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gWlN0cmVhbSgpIHsKICAgICAgICB0aGlzLmlucHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfaW4gPSAwOwogICAgICAgIHRoaXMuYXZhaWxfaW4gPSAwOwogICAgICAgIHRoaXMudG90YWxfaW4gPSAwOwogICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfb3V0ID0gMDsKICAgICAgICB0aGlzLmF2YWlsX291dCA9IDA7CiAgICAgICAgdGhpcy50b3RhbF9vdXQgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7CiAgICAgICAgdGhpcy5kYXRhX3R5cGUgPSAyOwogICAgICAgIHRoaXMuYWRsZXIgPSAwOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfZGVmbGF0ZTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlX2RlZmxhdGUoKTsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciBzdHJpbmdzID0gcmVxdWlyZV9zdHJpbmdzKCk7CiAgICAgIHZhciBtc2cgPSByZXF1aXJlX21lc3NhZ2VzMigpOwogICAgICB2YXIgWlN0cmVhbSA9IHJlcXVpcmVfenN0cmVhbSgpOwogICAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICB2YXIgWl9OT19GTFVTSCA9IDA7CiAgICAgIHZhciBaX0ZJTklTSCA9IDQ7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX1NZTkNfRkxVU0gyID0gMjsKICAgICAgdmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xOwogICAgICB2YXIgWl9ERUZBVUxUX1NUUkFURUdZID0gMDsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICBmdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpCiAgICAgICAgICByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7CiAgICAgICAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHsKICAgICAgICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sCiAgICAgICAgICBtZXRob2Q6IFpfREVGTEFURUQsCiAgICAgICAgICBjaHVua1NpemU6IDE2Mzg0LAogICAgICAgICAgd2luZG93Qml0czogMTUsCiAgICAgICAgICBtZW1MZXZlbDogOCwKICAgICAgICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksCiAgICAgICAgICB0bzogIiIKICAgICAgICB9LCBvcHRpb25zIHx8IHt9KTsKICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zOwogICAgICAgIGlmIChvcHQucmF3ICYmIG9wdC53aW5kb3dCaXRzID4gMCkgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIGlmIChvcHQuZ3ppcCAmJiBvcHQud2luZG93Qml0cyA+IDAgJiYgb3B0LndpbmRvd0JpdHMgPCAxNikgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7CiAgICAgICAgfQogICAgICAgIHRoaXMuZXJyID0gMDsKICAgICAgICB0aGlzLm1zZyA9ICIiOwogICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7CiAgICAgICAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIodGhpcy5zdHJtLCBvcHQubGV2ZWwsIG9wdC5tZXRob2QsIG9wdC53aW5kb3dCaXRzLCBvcHQubWVtTGV2ZWwsIG9wdC5zdHJhdGVneSk7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC5oZWFkZXIpIHsKICAgICAgICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7CiAgICAgICAgfQogICAgICAgIGlmIChvcHQuZGljdGlvbmFyeSkgewogICAgICAgICAgdmFyIGRpY3Q7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpOwogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlOwogICAgICAgIH0KICAgICAgfQogICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBzdGF0dXMsIF9tb2RlOwogICAgICAgIGlmICh0aGlzLmVuZGVkKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIF9tb2RlID0gbW9kZSA9PT0gfn5tb2RlID8gbW9kZSA6IG1vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7CiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAic3RyaW5nIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTsKICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RybS5pbnB1dCA9IGRhdGE7CiAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9pbiA9IDA7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoOwogICAgICAgIGRvIHsKICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7CiAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSAwOwogICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9tb2RlKTsKICAgICAgICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHsKICAgICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIMikpIHsKICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IFpfU1RSRUFNX0VORCk7CiAgICAgICAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkgewogICAgICAgICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTsKICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSzsKICAgICAgICB9CiAgICAgICAgaWYgKF9tb2RlID09PSBaX1NZTkNfRkxVU0gyKSB7CiAgICAgICAgICB0aGlzLm9uRW5kKFpfT0spOwogICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9OwogICAgICBEZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihjaHVuaykgewogICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspOwogICAgICB9OwogICAgICBEZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHN0YXR1cykgewogICAgICAgIGlmIChzdGF0dXMgPT09IFpfT0spIHsKICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbigiIik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuZXJyID0gc3RhdHVzOwogICAgICAgIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZzsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykgewogICAgICAgIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpOwogICAgICAgIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpOwogICAgICAgIGlmIChkZWZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IGRlZmxhdG9yLm1zZyB8fCBtc2dbZGVmbGF0b3IuZXJyXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5yYXcgPSB0cnVlOwogICAgICAgIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5nemlwID0gdHJ1ZTsKICAgICAgICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTsKICAgICAgZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTsKICAgICAgZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdzsKICAgICAgZXhwb3J0cy5nemlwID0gZ3ppcDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMKICB2YXIgcmVxdWlyZV9pbmZmYXN0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIEJBRCA9IDMwOwogICAgICB2YXIgVFlQRSA9IDEyOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICB2YXIgX2luOwogICAgICAgIHZhciBsYXN0OwogICAgICAgIHZhciBfb3V0OwogICAgICAgIHZhciBiZWc7CiAgICAgICAgdmFyIGVuZDsKICAgICAgICB2YXIgZG1heDsKICAgICAgICB2YXIgd3NpemU7CiAgICAgICAgdmFyIHdoYXZlOwogICAgICAgIHZhciB3bmV4dDsKICAgICAgICB2YXIgc193aW5kb3c7CiAgICAgICAgdmFyIGhvbGQ7CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIGxjb2RlOwogICAgICAgIHZhciBkY29kZTsKICAgICAgICB2YXIgbG1hc2s7CiAgICAgICAgdmFyIGRtYXNrOwogICAgICAgIHZhciBoZXJlOwogICAgICAgIHZhciBvcDsKICAgICAgICB2YXIgbGVuOwogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBmcm9tOwogICAgICAgIHZhciBmcm9tX3NvdXJjZTsKICAgICAgICB2YXIgaW5wdXQsIG91dHB1dDsKICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgX2luID0gc3RybS5uZXh0X2luOwogICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTsKICAgICAgICBfb3V0ID0gc3RybS5uZXh0X291dDsKICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgICAgICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpOwogICAgICAgIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpOwogICAgICAgIGRtYXggPSBzdGF0ZS5kbWF4OwogICAgICAgIHdzaXplID0gc3RhdGUud3NpemU7CiAgICAgICAgd2hhdmUgPSBzdGF0ZS53aGF2ZTsKICAgICAgICB3bmV4dCA9IHN0YXRlLnduZXh0OwogICAgICAgIHNfd2luZG93ID0gc3RhdGUud2luZG93OwogICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzOwogICAgICAgIGxjb2RlID0gc3RhdGUubGVuY29kZTsKICAgICAgICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlOwogICAgICAgIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxOwogICAgICAgIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTsKICAgICAgICB0b3A6CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGlmIChiaXRzIDwgMTUpIHsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgfQogICAgICAgICAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTsKICAgICAgICAgICAgZG9sZW46CiAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHsKICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wICYgMTYpIHsKICAgICAgICAgICAgICAgICAgbGVuID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBvcCAmPSAxNTsKICAgICAgICAgICAgICAgICAgaWYgKG9wKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgbGVuICs9IGhvbGQgJiAoMSA8PCBvcCkgLSAxOwogICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgMTUpIHsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTsKICAgICAgICAgICAgICAgICAgZG9kaXN0OgogICAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgICAgaWYgKG9wICYgMTYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICAgICAgb3AgJj0gMTU7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoMSA8PCBvcCkgLSAxOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHduZXh0IDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gMzsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IDM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiA2NTUzNSkgKyAoaG9sZCAmICgxIDw8IG9wKSAtIDEpXTsKICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgZG9kaXN0OwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSBjb2RlIjsKICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgNjU1MzUpICsgKGhvbGQgJiAoMSA8PCBvcCkgLSAxKV07CiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGRvbGVuOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcCAmIDMyKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpOwogICAgICAgIGxlbiA9IGJpdHMgPj4gMzsKICAgICAgICBfaW4gLT0gbGVuOwogICAgICAgIGJpdHMgLT0gbGVuIDw8IDM7CiAgICAgICAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7CiAgICAgICAgc3RybS5uZXh0X2luID0gX2luOwogICAgICAgIHN0cm0ubmV4dF9vdXQgPSBfb3V0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCk7CiAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpOwogICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgIHJldHVybjsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzCiAgdmFyIHJlcXVpcmVfaW5mdHJlZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciBNQVhCSVRTID0gMTU7CiAgICAgIHZhciBFTk9VR0hfTEVOUyA9IDg1MjsKICAgICAgdmFyIEVOT1VHSF9ESVNUUyA9IDU5MjsKICAgICAgdmFyIENPREVTID0gMDsKICAgICAgdmFyIExFTlMgPSAxOwogICAgICB2YXIgRElTVFMgPSAyOwogICAgICB2YXIgbGJhc2UgPSBbCiAgICAgICAgMywKICAgICAgICA0LAogICAgICAgIDUsCiAgICAgICAgNiwKICAgICAgICA3LAogICAgICAgIDgsCiAgICAgICAgOSwKICAgICAgICAxMCwKICAgICAgICAxMSwKICAgICAgICAxMywKICAgICAgICAxNSwKICAgICAgICAxNywKICAgICAgICAxOSwKICAgICAgICAyMywKICAgICAgICAyNywKICAgICAgICAzMSwKICAgICAgICAzNSwKICAgICAgICA0MywKICAgICAgICA1MSwKICAgICAgICA1OSwKICAgICAgICA2NywKICAgICAgICA4MywKICAgICAgICA5OSwKICAgICAgICAxMTUsCiAgICAgICAgMTMxLAogICAgICAgIDE2MywKICAgICAgICAxOTUsCiAgICAgICAgMjI3LAogICAgICAgIDI1OCwKICAgICAgICAwLAogICAgICAgIDAKICAgICAgXTsKICAgICAgdmFyIGxleHQgPSBbCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMTYsCiAgICAgICAgNzIsCiAgICAgICAgNzgKICAgICAgXTsKICAgICAgdmFyIGRiYXNlID0gWwogICAgICAgIDEsCiAgICAgICAgMiwKICAgICAgICAzLAogICAgICAgIDQsCiAgICAgICAgNSwKICAgICAgICA3LAogICAgICAgIDksCiAgICAgICAgMTMsCiAgICAgICAgMTcsCiAgICAgICAgMjUsCiAgICAgICAgMzMsCiAgICAgICAgNDksCiAgICAgICAgNjUsCiAgICAgICAgOTcsCiAgICAgICAgMTI5LAogICAgICAgIDE5MywKICAgICAgICAyNTcsCiAgICAgICAgMzg1LAogICAgICAgIDUxMywKICAgICAgICA3NjksCiAgICAgICAgMTAyNSwKICAgICAgICAxNTM3LAogICAgICAgIDIwNDksCiAgICAgICAgMzA3MywKICAgICAgICA0MDk3LAogICAgICAgIDYxNDUsCiAgICAgICAgODE5MywKICAgICAgICAxMjI4OSwKICAgICAgICAxNjM4NSwKICAgICAgICAyNDU3NywKICAgICAgICAwLAogICAgICAgIDAKICAgICAgXTsKICAgICAgdmFyIGRleHQgPSBbCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjIsCiAgICAgICAgMjIsCiAgICAgICAgMjMsCiAgICAgICAgMjMsCiAgICAgICAgMjQsCiAgICAgICAgMjQsCiAgICAgICAgMjUsCiAgICAgICAgMjUsCiAgICAgICAgMjYsCiAgICAgICAgMjYsCiAgICAgICAgMjcsCiAgICAgICAgMjcsCiAgICAgICAgMjgsCiAgICAgICAgMjgsCiAgICAgICAgMjksCiAgICAgICAgMjksCiAgICAgICAgNjQsCiAgICAgICAgNjQKICAgICAgXTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpIHsKICAgICAgICB2YXIgYml0cyA9IG9wdHMuYml0czsKICAgICAgICB2YXIgbGVuID0gMDsKICAgICAgICB2YXIgc3ltID0gMDsKICAgICAgICB2YXIgbWluID0gMCwgbWF4ID0gMDsKICAgICAgICB2YXIgcm9vdCA9IDA7CiAgICAgICAgdmFyIGN1cnIgPSAwOwogICAgICAgIHZhciBkcm9wID0gMDsKICAgICAgICB2YXIgbGVmdCA9IDA7CiAgICAgICAgdmFyIHVzZWQgPSAwOwogICAgICAgIHZhciBodWZmID0gMDsKICAgICAgICB2YXIgaW5jcjsKICAgICAgICB2YXIgZmlsbDsKICAgICAgICB2YXIgbG93OwogICAgICAgIHZhciBtYXNrOwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBiYXNlID0gbnVsbDsKICAgICAgICB2YXIgYmFzZV9pbmRleCA9IDA7CiAgICAgICAgdmFyIGVuZDsKICAgICAgICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOwogICAgICAgIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsKICAgICAgICB2YXIgZXh0cmEgPSBudWxsOwogICAgICAgIHZhciBleHRyYV9pbmRleCA9IDA7CiAgICAgICAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7CiAgICAgICAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIGNvdW50W2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykgewogICAgICAgICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKzsKICAgICAgICB9CiAgICAgICAgcm9vdCA9IGJpdHM7CiAgICAgICAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHsKICAgICAgICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocm9vdCA+IG1heCkgewogICAgICAgICAgcm9vdCA9IG1heDsKICAgICAgICB9CiAgICAgICAgaWYgKG1heCA9PT0gMCkgewogICAgICAgICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAxIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAxIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgICAgb3B0cy5iaXRzID0gMTsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHsKICAgICAgICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocm9vdCA8IG1pbikgewogICAgICAgICAgcm9vdCA9IG1pbjsKICAgICAgICB9CiAgICAgICAgbGVmdCA9IDE7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgICBsZWZ0IC09IGNvdW50W2xlbl07CiAgICAgICAgICBpZiAobGVmdCA8IDApIHsKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgb2Zmc1sxXSA9IDA7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykgewogICAgICAgICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07CiAgICAgICAgfQogICAgICAgIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7CiAgICAgICAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkgewogICAgICAgICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlID09PSBDT0RFUykgewogICAgICAgICAgYmFzZSA9IGV4dHJhID0gd29yazsKICAgICAgICAgIGVuZCA9IDE5OwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykgewogICAgICAgICAgYmFzZSA9IGxiYXNlOwogICAgICAgICAgYmFzZV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBleHRyYSA9IGxleHQ7CiAgICAgICAgICBleHRyYV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBlbmQgPSAyNTY7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJhc2UgPSBkYmFzZTsKICAgICAgICAgIGV4dHJhID0gZGV4dDsKICAgICAgICAgIGVuZCA9IC0xOwogICAgICAgIH0KICAgICAgICBodWZmID0gMDsKICAgICAgICBzeW0gPSAwOwogICAgICAgIGxlbiA9IG1pbjsKICAgICAgICBuZXh0ID0gdGFibGVfaW5kZXg7CiAgICAgICAgY3VyciA9IHJvb3Q7CiAgICAgICAgZHJvcCA9IDA7CiAgICAgICAgbG93ID0gLTE7CiAgICAgICAgdXNlZCA9IDEgPDwgcm9vdDsKICAgICAgICBtYXNrID0gdXNlZCAtIDE7CiAgICAgICAgaWYgKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TIHx8IHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpIHsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7CiAgICAgICAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSAwOwogICAgICAgICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTsKICAgICAgICAgIH0gZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07CiAgICAgICAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSAzMiArIDY0OwogICAgICAgICAgICBoZXJlX3ZhbCA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBpbmNyID0gMSA8PCBsZW4gLSBkcm9wOwogICAgICAgICAgZmlsbCA9IDEgPDwgY3VycjsKICAgICAgICAgIG1pbiA9IGZpbGw7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGZpbGwgLT0gaW5jcjsKICAgICAgICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSBoZXJlX2JpdHMgPDwgMjQgfCBoZXJlX29wIDw8IDE2IHwgaGVyZV92YWwgfCAwOwogICAgICAgICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7CiAgICAgICAgICBpbmNyID0gMSA8PCBsZW4gLSAxOwogICAgICAgICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7CiAgICAgICAgICAgIGluY3IgPj49IDE7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5jciAhPT0gMCkgewogICAgICAgICAgICBodWZmICY9IGluY3IgLSAxOwogICAgICAgICAgICBodWZmICs9IGluY3I7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBodWZmID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHN5bSsrOwogICAgICAgICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkgewogICAgICAgICAgICBpZiAobGVuID09PSBtYXgpIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7CiAgICAgICAgICAgIGlmIChkcm9wID09PSAwKSB7CiAgICAgICAgICAgICAgZHJvcCA9IHJvb3Q7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbmV4dCArPSBtaW47CiAgICAgICAgICAgIGN1cnIgPSBsZW4gLSBkcm9wOwogICAgICAgICAgICBsZWZ0ID0gMSA8PCBjdXJyOwogICAgICAgICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHsKICAgICAgICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTsKICAgICAgICAgICAgICBpZiAobGVmdCA8PSAwKSB7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY3VycisrOwogICAgICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdXNlZCArPSAxIDw8IGN1cnI7CiAgICAgICAgICAgIGlmICh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUyB8fCB0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSB7CiAgICAgICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbG93ID0gaHVmZiAmIG1hc2s7CiAgICAgICAgICAgIHRhYmxlW2xvd10gPSByb290IDw8IDI0IHwgY3VyciA8PCAxNiB8IG5leHQgLSB0YWJsZV9pbmRleCB8IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChodWZmICE9PSAwKSB7CiAgICAgICAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgIH0KICAgICAgICBvcHRzLmJpdHMgPSByb290OwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcwogIHZhciByZXF1aXJlX2luZmxhdGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciBhZGxlcjMyID0gcmVxdWlyZV9hZGxlcjMyKCk7CiAgICAgIHZhciBjcmMzMjIgPSByZXF1aXJlX2NyYzMyKCk7CiAgICAgIHZhciBpbmZsYXRlX2Zhc3QgPSByZXF1aXJlX2luZmZhc3QoKTsKICAgICAgdmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlX2luZnRyZWVzKCk7CiAgICAgIHZhciBDT0RFUyA9IDA7CiAgICAgIHZhciBMRU5TID0gMTsKICAgICAgdmFyIERJU1RTID0gMjsKICAgICAgdmFyIFpfRklOSVNIID0gNDsKICAgICAgdmFyIFpfQkxPQ0sgPSA1OwogICAgICB2YXIgWl9UUkVFUyA9IDY7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX05FRURfRElDVCA9IDI7CiAgICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yOwogICAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7CiAgICAgIHZhciBaX01FTV9FUlJPUiA9IC00OwogICAgICB2YXIgWl9CVUZfRVJST1IgPSAtNTsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICB2YXIgSEVBRCA9IDE7CiAgICAgIHZhciBGTEFHUyA9IDI7CiAgICAgIHZhciBUSU1FID0gMzsKICAgICAgdmFyIE9TID0gNDsKICAgICAgdmFyIEVYTEVOID0gNTsKICAgICAgdmFyIEVYVFJBID0gNjsKICAgICAgdmFyIE5BTUUgPSA3OwogICAgICB2YXIgQ09NTUVOVCA9IDg7CiAgICAgIHZhciBIQ1JDID0gOTsKICAgICAgdmFyIERJQ1RJRCA9IDEwOwogICAgICB2YXIgRElDVCA9IDExOwogICAgICB2YXIgVFlQRSA9IDEyOwogICAgICB2YXIgVFlQRURPID0gMTM7CiAgICAgIHZhciBTVE9SRUQgPSAxNDsKICAgICAgdmFyIENPUFlfID0gMTU7CiAgICAgIHZhciBDT1BZID0gMTY7CiAgICAgIHZhciBUQUJMRSA9IDE3OwogICAgICB2YXIgTEVOTEVOUyA9IDE4OwogICAgICB2YXIgQ09ERUxFTlMgPSAxOTsKICAgICAgdmFyIExFTl8gPSAyMDsKICAgICAgdmFyIExFTiA9IDIxOwogICAgICB2YXIgTEVORVhUID0gMjI7CiAgICAgIHZhciBESVNUID0gMjM7CiAgICAgIHZhciBESVNURVhUID0gMjQ7CiAgICAgIHZhciBNQVRDSCA9IDI1OwogICAgICB2YXIgTElUID0gMjY7CiAgICAgIHZhciBDSEVDSyA9IDI3OwogICAgICB2YXIgTEVOR1RIID0gMjg7CiAgICAgIHZhciBET05FID0gMjk7CiAgICAgIHZhciBCQUQgPSAzMDsKICAgICAgdmFyIE1FTSA9IDMxOwogICAgICB2YXIgU1lOQyA9IDMyOwogICAgICB2YXIgRU5PVUdIX0xFTlMgPSA4NTI7CiAgICAgIHZhciBFTk9VR0hfRElTVFMgPSA1OTI7CiAgICAgIHZhciBNQVhfV0JJVFMgPSAxNTsKICAgICAgdmFyIERFRl9XQklUUyA9IE1BWF9XQklUUzsKICAgICAgZnVuY3Rpb24genN3YXAzMihxKSB7CiAgICAgICAgcmV0dXJuIChxID4+PiAyNCAmIDI1NSkgKyAocSA+Pj4gOCAmIDY1MjgwKSArICgocSAmIDY1MjgwKSA8PCA4KSArICgocSAmIDI1NSkgPDwgMjQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHsKICAgICAgICB0aGlzLm1vZGUgPSAwOwogICAgICAgIHRoaXMubGFzdCA9IGZhbHNlOwogICAgICAgIHRoaXMud3JhcCA9IDA7CiAgICAgICAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOwogICAgICAgIHRoaXMuZmxhZ3MgPSAwOwogICAgICAgIHRoaXMuZG1heCA9IDA7CiAgICAgICAgdGhpcy5jaGVjayA9IDA7CiAgICAgICAgdGhpcy50b3RhbCA9IDA7CiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDsKICAgICAgICB0aGlzLndiaXRzID0gMDsKICAgICAgICB0aGlzLndzaXplID0gMDsKICAgICAgICB0aGlzLndoYXZlID0gMDsKICAgICAgICB0aGlzLnduZXh0ID0gMDsKICAgICAgICB0aGlzLndpbmRvdyA9IG51bGw7CiAgICAgICAgdGhpcy5ob2xkID0gMDsKICAgICAgICB0aGlzLmJpdHMgPSAwOwogICAgICAgIHRoaXMubGVuZ3RoID0gMDsKICAgICAgICB0aGlzLm9mZnNldCA9IDA7CiAgICAgICAgdGhpcy5leHRyYSA9IDA7CiAgICAgICAgdGhpcy5sZW5jb2RlID0gbnVsbDsKICAgICAgICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsKICAgICAgICB0aGlzLmxlbmJpdHMgPSAwOwogICAgICAgIHRoaXMuZGlzdGJpdHMgPSAwOwogICAgICAgIHRoaXMubmNvZGUgPSAwOwogICAgICAgIHRoaXMubmxlbiA9IDA7CiAgICAgICAgdGhpcy5uZGlzdCA9IDA7CiAgICAgICAgdGhpcy5oYXZlID0gMDsKICAgICAgICB0aGlzLm5leHQgPSBudWxsOwogICAgICAgIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOwogICAgICAgIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOwogICAgICAgIHRoaXMubGVuZHluID0gbnVsbDsKICAgICAgICB0aGlzLmRpc3RkeW4gPSBudWxsOwogICAgICAgIHRoaXMuc2FuZSA9IDA7CiAgICAgICAgdGhpcy5iYWNrID0gMDsKICAgICAgICB0aGlzLndhcyA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwOwogICAgICAgIHN0cm0ubXNnID0gIiI7CiAgICAgICAgaWYgKHN0YXRlLndyYXApIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTsKICAgICAgICB9CiAgICAgICAgc3RhdGUubW9kZSA9IEhFQUQ7CiAgICAgICAgc3RhdGUubGFzdCA9IDA7CiAgICAgICAgc3RhdGUuaGF2ZWRpY3QgPSAwOwogICAgICAgIHN0YXRlLmRtYXggPSAzMjc2ODsKICAgICAgICBzdGF0ZS5oZWFkID0gbnVsbDsKICAgICAgICBzdGF0ZS5ob2xkID0gMDsKICAgICAgICBzdGF0ZS5iaXRzID0gMDsKICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTsKICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTsKICAgICAgICBzdGF0ZS5zYW5lID0gMTsKICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBzdGF0ZS53c2l6ZSA9IDA7CiAgICAgICAgc3RhdGUud2hhdmUgPSAwOwogICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHsKICAgICAgICB2YXIgd3JhcDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAod2luZG93Qml0cyA8IDApIHsKICAgICAgICAgIHdyYXAgPSAwOwogICAgICAgICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxOwogICAgICAgICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkgewogICAgICAgICAgICB3aW5kb3dCaXRzICY9IDE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7CiAgICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIH0KICAgICAgICBzdGF0ZS53cmFwID0gd3JhcDsKICAgICAgICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7CiAgICAgICAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykgewogICAgICAgIHZhciByZXQ7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTsKICAgICAgICBzdHJtLnN0YXRlID0gc3RhdGU7CiAgICAgICAgc3RhdGUud2luZG93ID0gbnVsbDsKICAgICAgICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpOwogICAgICAgIGlmIChyZXQgIT09IFpfT0spIHsKICAgICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHsKICAgICAgICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7CiAgICAgIH0KICAgICAgdmFyIHZpcmdpbiA9IHRydWU7CiAgICAgIHZhciBsZW5maXg7CiAgICAgIHZhciBkaXN0Zml4OwogICAgICBmdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkgewogICAgICAgIGlmICh2aXJnaW4pIHsKICAgICAgICAgIHZhciBzeW07CiAgICAgICAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTsKICAgICAgICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpOwogICAgICAgICAgc3ltID0gMDsKICAgICAgICAgIHdoaWxlIChzeW0gPCAxNDQpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA4OwogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKHN5bSA8IDI1NikgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMjgwKSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gNzsKICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzeW0gPCAyODgpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA4OwogICAgICAgICAgfQogICAgICAgICAgaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pOwogICAgICAgICAgc3ltID0gMDsKICAgICAgICAgIHdoaWxlIChzeW0gPCAzMikgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7CiAgICAgICAgICB9CiAgICAgICAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pOwogICAgICAgICAgdmlyZ2luID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7CiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7CiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4OwogICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHsKICAgICAgICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0czsKICAgICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICAgIHN0YXRlLndoYXZlID0gMDsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTsKICAgICAgICB9CiAgICAgICAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHsKICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApOwogICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7CiAgICAgICAgICBpZiAoZGlzdCA+IGNvcHkpIHsKICAgICAgICAgICAgZGlzdCA9IGNvcHk7CiAgICAgICAgICB9CiAgICAgICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpOwogICAgICAgICAgY29weSAtPSBkaXN0OwogICAgICAgICAgaWYgKGNvcHkpIHsKICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApOwogICAgICAgICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7CiAgICAgICAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGF0ZS53bmV4dCArPSBkaXN0OwogICAgICAgICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7CiAgICAgICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7CiAgICAgICAgICAgICAgc3RhdGUud2hhdmUgKz0gZGlzdDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIHZhciBpbnB1dCwgb3V0cHV0OwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBwdXQ7CiAgICAgICAgdmFyIGhhdmUsIGxlZnQ7CiAgICAgICAgdmFyIGhvbGQ7CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIF9pbiwgX291dDsKICAgICAgICB2YXIgY29weTsKICAgICAgICB2YXIgZnJvbTsKICAgICAgICB2YXIgZnJvbV9zb3VyY2U7CiAgICAgICAgdmFyIGhlcmUgPSAwOwogICAgICAgIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOwogICAgICAgIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIHJldDsKICAgICAgICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOwogICAgICAgIHZhciBvcHRzOwogICAgICAgIHZhciBuOwogICAgICAgIHZhciBvcmRlciA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8ICFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPOwogICAgICAgIH0KICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDsKICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICBfaW4gPSBoYXZlOwogICAgICAgIF9vdXQgPSBsZWZ0OwogICAgICAgIHJldCA9IFpfT0s7CiAgICAgICAgaW5mX2xlYXZlOgogICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUubW9kZSkgewogICAgICAgICAgICAgIGNhc2UgSEVBRDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCAmIDIgJiYgaG9sZCA9PT0gMzU2MTUpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSAwOwogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTsKICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgKCgoaG9sZCAmIDI1NSkgPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKGhvbGQgJiAxNSkgIT09IFpfREVGTEFURUQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA0OwogICAgICAgICAgICAgICAgYml0cyAtPSA0OwogICAgICAgICAgICAgICAgbGVuID0gKGhvbGQgJiAxNSkgKyA4OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIHdpbmRvdyBzaXplIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiA1MTIgPyBESUNUSUQgOiBUWVBFOwogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgRkxBR1M6CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDsKICAgICAgICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAyNTUpICE9PSBaX0RFRkxBVEVEKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1NzM0NCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ1bmtub3duIGhlYWRlciBmbGFncyBzZXQiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9IGhvbGQgPj4gOCAmIDE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7CiAgICAgICAgICAgICAgY2FzZSBUSU1FOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsyXSA9IGhvbGQgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzNdID0gaG9sZCA+Pj4gMjQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gT1M7CiAgICAgICAgICAgICAgY2FzZSBPUzoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gaG9sZCA+PiA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMjIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjsKICAgICAgICAgICAgICBjYXNlIEVYTEVOOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMTAyNCkgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkOwogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBOwogICAgICAgICAgICAgIGNhc2UgRVhUUkE6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAxMDI0KSB7CiAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBoYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUuaGVhZC5leHRyYSwgaW5wdXQsIG5leHQsIGNvcHksIGxlbik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMjIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7CiAgICAgICAgICAgICAgY2FzZSBOQU1FOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMjA0OCkgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjb3B5ID0gMDsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdOwogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJiBzdGF0ZS5sZW5ndGggPCA2NTUzNikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICAgICAgICBuZXh0ICs9IGNvcHk7CiAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UOwogICAgICAgICAgICAgIGNhc2UgQ09NTUVOVDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDQwOTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY29weSA9IDA7CiAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTsKICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiYgc3RhdGUubGVuZ3RoIDwgNjU1MzYpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpOwogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDOwogICAgICAgICAgICAgIGNhc2UgSENSQzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgNjU1MzUpKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaGVhZGVyIGNyYyBtaXNtYXRjaCI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSBzdGF0ZS5mbGFncyA+PiA5ICYgMTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgRElDVElEOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpOwogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESUNUOwogICAgICAgICAgICAgIGNhc2UgRElDVDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlOwogICAgICAgICAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICAgICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDE7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICBjYXNlIFRZUEU6CiAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhc2UgVFlQRURPOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxhc3QgPSBob2xkICYgMTsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAxOwogICAgICAgICAgICAgICAgYml0cyAtPSAxOwogICAgICAgICAgICAgICAgc3dpdGNoIChob2xkICYgMykgewogICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsKICAgICAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYmxvY2sgdHlwZSI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBTVE9SRUQ6CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7CiAgICAgICAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKGhvbGQgJiA2NTUzNSkgIT09IChob2xkID4+PiAxNiBeIDY1NTM1KSkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgNjU1MzU7CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfOwogICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjYXNlIENPUFlfOgogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7CiAgICAgICAgICAgICAgY2FzZSBDT1BZOgogICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBoYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBsZWZ0OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBsZWZ0IC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIHB1dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgVEFCTEU6CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDMxKSArIDI1NzsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA1OwogICAgICAgICAgICAgICAgYml0cyAtPSA1OwogICAgICAgICAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDMxKSArIDE7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNTsKICAgICAgICAgICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAxNSkgKyA0OwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDQ7CiAgICAgICAgICAgICAgICBiaXRzIC09IDQ7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5oYXZlID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TOwogICAgICAgICAgICAgIGNhc2UgTEVOTEVOUzoKICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gaG9sZCAmIDc7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAzOwogICAgICAgICAgICAgICAgICBiaXRzIC09IDM7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3OwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9OwogICAgICAgICAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0czsKICAgICAgICAgICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5oYXZlID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUzsKICAgICAgICAgICAgICBjYXNlIENPREVMRU5TOgogICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHsKICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyOwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiOwogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdOwogICAgICAgICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDMpOwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IDI7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzOwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgNyk7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMzsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gMzsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7CiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgbGVuID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMTI3KTsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA3OwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSA3OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiOwogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5OwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9OwogICAgICAgICAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2OwogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluOwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7CiAgICAgICAgICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0czsKICAgICAgICAgICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZXMgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsKICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY2FzZSBMRU5fOgogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgICAgICBjYXNlIExFTjoKICAgICAgICAgICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0OwogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgICAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7CiAgICAgICAgICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgICAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICAgICAgICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICAgICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgICAgICAgICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gMDsKICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKDEgPDwgc3RhdGUubGVuYml0cykgLSAxXTsKICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMjQwKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wOwogICAgICAgICAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArICgoaG9sZCAmICgxIDw8IGxhc3RfYml0cyArIGxhc3Rfb3ApIC0gMSkgPj4gbGFzdF9iaXRzKV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChsYXN0X2JpdHMgKyBoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0czsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikgewogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYgNjQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7CiAgICAgICAgICAgICAgY2FzZSBMRU5FWFQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgbiA9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKDEgPDwgc3RhdGUuZXh0cmEpIC0gMTsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7CiAgICAgICAgICAgICAgY2FzZSBESVNUOgogICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKGhlcmVfb3AgJiAyNDApID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7CiAgICAgICAgICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArICgoaG9sZCAmICgxIDw8IGxhc3RfYml0cyArIGxhc3Rfb3ApIC0gMSkgPj4gbGFzdF9iaXRzKV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChsYXN0X2JpdHMgKyBoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0czsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUOwogICAgICAgICAgICAgIGNhc2UgRElTVEVYVDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5leHRyYSkgewogICAgICAgICAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoMSA8PCBzdGF0ZS5leHRyYSkgLSAxOwogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIOwogICAgICAgICAgICAgIGNhc2UgTUFUQ0g6CiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0OwogICAgICAgICAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDsKICAgICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gbGVmdDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGxlZnQgLT0gY29weTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU47CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIExJVDoKICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICBsZWZ0LS07CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBDSEVDSzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIF9vdXQgLT0gbGVmdDsKICAgICAgICAgICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDsKICAgICAgICAgICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDsKICAgICAgICAgICAgICAgICAgaWYgKF9vdXQpIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSBzdGF0ZS5mbGFncyA/IGNyYzMyMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgX291dCA9IGxlZnQ7CiAgICAgICAgICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGRhdGEgY2hlY2siOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDsKICAgICAgICAgICAgICBjYXNlIExFTkdUSDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiA0Mjk0OTY3Mjk1KSkgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImluY29ycmVjdCBsZW5ndGggY2hlY2siOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7CiAgICAgICAgICAgICAgY2FzZSBET05FOgogICAgICAgICAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EOwogICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgIGNhc2UgQkFEOgogICAgICAgICAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SOwogICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgIGNhc2UgTUVNOgogICAgICAgICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgICAgICAgIGNhc2UgU1lOQzoKICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICBpZiAoc3RhdGUud3NpemUgfHwgX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJiAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpIHsKICAgICAgICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IE1FTTsKICAgICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBfaW4gLT0gc3RybS5hdmFpbF9pbjsKICAgICAgICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIHN0cm0udG90YWxfaW4gKz0gX2luOwogICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7CiAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDsKICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSBzdGF0ZS5mbGFncyA/IGNyYzMyMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KTsKICAgICAgICB9CiAgICAgICAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICsgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7CiAgICAgICAgaWYgKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykgewogICAgICAgICAgcmV0ID0gWl9CVUZfRVJST1I7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLndpbmRvdykgewogICAgICAgICAgc3RhdGUud2luZG93ID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgc3RybS5zdGF0ZSA9IG51bGw7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUuaGVhZCA9IGhlYWQ7CiAgICAgICAgaGVhZC5kb25lID0gZmFsc2U7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkgewogICAgICAgIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIHZhciBkaWN0aWQ7CiAgICAgICAgdmFyIHJldDsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHsKICAgICAgICAgIGRpY3RpZCA9IDE7CiAgICAgICAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7CiAgICAgICAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykgewogICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7CiAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgc3RhdGUubW9kZSA9IE1FTTsKICAgICAgICAgIHJldHVybiBaX01FTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUuaGF2ZWRpY3QgPSAxOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0OwogICAgICBleHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyOwogICAgICBleHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwOwogICAgICBleHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7CiAgICAgIGV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyOwogICAgICBleHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlOwogICAgICBleHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kOwogICAgICBleHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyOwogICAgICBleHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7CiAgICAgIGV4cG9ydHMuaW5mbGF0ZUluZm8gPSAicGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMKICB2YXIgcmVxdWlyZV9jb25zdGFudHMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gewogICAgICAgIFpfTk9fRkxVU0g6IDAsCiAgICAgICAgWl9QQVJUSUFMX0ZMVVNIOiAxLAogICAgICAgIFpfU1lOQ19GTFVTSDogMiwKICAgICAgICBaX0ZVTExfRkxVU0g6IDMsCiAgICAgICAgWl9GSU5JU0g6IDQsCiAgICAgICAgWl9CTE9DSzogNSwKICAgICAgICBaX1RSRUVTOiA2LAogICAgICAgIFpfT0s6IDAsCiAgICAgICAgWl9TVFJFQU1fRU5EOiAxLAogICAgICAgIFpfTkVFRF9ESUNUOiAyLAogICAgICAgIFpfRVJSTk86IC0xLAogICAgICAgIFpfU1RSRUFNX0VSUk9SOiAtMiwKICAgICAgICBaX0RBVEFfRVJST1I6IC0zLAogICAgICAgIFpfQlVGX0VSUk9SOiAtNSwKICAgICAgICBaX05PX0NPTVBSRVNTSU9OOiAwLAogICAgICAgIFpfQkVTVF9TUEVFRDogMSwKICAgICAgICBaX0JFU1RfQ09NUFJFU1NJT046IDksCiAgICAgICAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAtMSwKICAgICAgICBaX0ZJTFRFUkVEOiAxLAogICAgICAgIFpfSFVGRk1BTl9PTkxZOiAyLAogICAgICAgIFpfUkxFOiAzLAogICAgICAgIFpfRklYRUQ6IDQsCiAgICAgICAgWl9ERUZBVUxUX1NUUkFURUdZOiAwLAogICAgICAgIFpfQklOQVJZOiAwLAogICAgICAgIFpfVEVYVDogMSwKICAgICAgICBaX1VOS05PV046IDIsCiAgICAgICAgWl9ERUZMQVRFRDogOAogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMKICB2YXIgcmVxdWlyZV9nemhlYWRlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBHWmhlYWRlcigpIHsKICAgICAgICB0aGlzLnRleHQgPSAwOwogICAgICAgIHRoaXMudGltZSA9IDA7CiAgICAgICAgdGhpcy54ZmxhZ3MgPSAwOwogICAgICAgIHRoaXMub3MgPSAwOwogICAgICAgIHRoaXMuZXh0cmEgPSBudWxsOwogICAgICAgIHRoaXMuZXh0cmFfbGVuID0gMDsKICAgICAgICB0aGlzLm5hbWUgPSAiIjsKICAgICAgICB0aGlzLmNvbW1lbnQgPSAiIjsKICAgICAgICB0aGlzLmhjcmMgPSAwOwogICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcwogIHZhciByZXF1aXJlX2luZmxhdGUyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZV9pbmZsYXRlKCk7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICB2YXIgc3RyaW5ncyA9IHJlcXVpcmVfc3RyaW5ncygpOwogICAgICB2YXIgYyA9IHJlcXVpcmVfY29uc3RhbnRzKCk7CiAgICAgIHZhciBtc2cgPSByZXF1aXJlX21lc3NhZ2VzMigpOwogICAgICB2YXIgWlN0cmVhbSA9IHJlcXVpcmVfenN0cmVhbSgpOwogICAgICB2YXIgR1poZWFkZXIgPSByZXF1aXJlX2d6aGVhZGVyKCk7CiAgICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7CiAgICAgIGZ1bmN0aW9uIEluZmxhdGUyKG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZTIpKQogICAgICAgICAgcmV0dXJuIG5ldyBJbmZsYXRlMihvcHRpb25zKTsKICAgICAgICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oewogICAgICAgICAgY2h1bmtTaXplOiAxNjM4NCwKICAgICAgICAgIHdpbmRvd0JpdHM6IDAsCiAgICAgICAgICB0bzogIiIKICAgICAgICB9LCBvcHRpb25zIHx8IHt9KTsKICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zOwogICAgICAgIGlmIChvcHQucmF3ICYmIG9wdC53aW5kb3dCaXRzID49IDAgJiYgb3B0LndpbmRvd0JpdHMgPCAxNikgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7CiAgICAgICAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsKICAgICAgICAgICAgb3B0LndpbmRvd0JpdHMgPSAtMTU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChvcHQud2luZG93Qml0cyA+PSAwICYmIG9wdC53aW5kb3dCaXRzIDwgMTYgJiYgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHsKICAgICAgICAgIG9wdC53aW5kb3dCaXRzICs9IDMyOwogICAgICAgIH0KICAgICAgICBpZiAob3B0LndpbmRvd0JpdHMgPiAxNSAmJiBvcHQud2luZG93Qml0cyA8IDQ4KSB7CiAgICAgICAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7CiAgICAgICAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLmVyciA9IDA7CiAgICAgICAgdGhpcy5tc2cgPSAiIjsKICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7CiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpOwogICAgICAgIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgIHZhciBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKHRoaXMuc3RybSwgb3B0LndpbmRvd0JpdHMpOwogICAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9PSykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTsKICAgICAgICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTsKICAgICAgICBpZiAob3B0LmRpY3Rpb25hcnkpIHsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgICAgb3B0LmRpY3Rpb25hcnkgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAob3B0LnJhdykgewogICAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9PSykgewogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgSW5mbGF0ZTIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihkYXRhLCBtb2RlKSB7CiAgICAgICAgdmFyIHN0cm0gPSB0aGlzLnN0cm07CiAgICAgICAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7CiAgICAgICAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTsKICAgICAgICB2YXIgc3RhdHVzLCBfbW9kZTsKICAgICAgICB2YXIgbmV4dF9vdXRfdXRmOCwgdGFpbCwgdXRmOHN0cjsKICAgICAgICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlOwogICAgICAgIGlmICh0aGlzLmVuZGVkKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIF9tb2RlID0gbW9kZSA9PT0gfn5tb2RlID8gbW9kZSA6IG1vZGUgPT09IHRydWUgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIOwogICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7CiAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBkYXRhOwogICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfaW4gPSAwOwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDsKICAgICAgICBkbyB7CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpOwogICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gMDsKICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOwogICAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7CiAgICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3Rpb25hcnkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7CiAgICAgICAgICAgIHN0YXR1cyA9IGMuWl9PSzsKICAgICAgICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0cm0ubmV4dF9vdXQpIHsKICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkgewogICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTsKICAgICAgICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODsKICAgICAgICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpOwogICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7CiAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7CiAgICAgICAgICAgICAgICBpZiAodGFpbCkgewogICAgICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTsKICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkgewogICAgICAgICAgX21vZGUgPSBjLlpfRklOSVNIOwogICAgICAgIH0KICAgICAgICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHsKICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7CiAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSzsKICAgICAgICB9CiAgICAgICAgaWYgKF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkgewogICAgICAgICAgdGhpcy5vbkVuZChjLlpfT0spOwogICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9OwogICAgICBJbmZsYXRlMi5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oY2h1bmspIHsKICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTsKICAgICAgfTsKICAgICAgSW5mbGF0ZTIucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24oc3RhdHVzKSB7CiAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX09LKSB7CiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oIiIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB0aGlzLmVyciA9IHN0YXR1czsKICAgICAgICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICB2YXIgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZTIob3B0aW9ucyk7CiAgICAgICAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7CiAgICAgICAgaWYgKGluZmxhdG9yLmVycikgewogICAgICAgICAgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaW5mbGF0b3IucmVzdWx0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKICAgICAgICBvcHRpb25zLnJhdyA9IHRydWU7CiAgICAgICAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpOwogICAgICB9CiAgICAgIGV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGUyOwogICAgICBleHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlOwogICAgICBleHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3OwogICAgICBleHBvcnRzLnVuZ3ppcCA9IGluZmxhdGU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcwogIHZhciByZXF1aXJlX3Bha28gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGFzc2lnbiA9IHJlcXVpcmVfY29tbW9uMigpLmFzc2lnbjsKICAgICAgdmFyIGRlZmxhdGUgPSByZXF1aXJlX2RlZmxhdGUyKCk7CiAgICAgIHZhciBpbmZsYXRlID0gcmVxdWlyZV9pbmZsYXRlMigpOwogICAgICB2YXIgY29uc3RhbnRzID0gcmVxdWlyZV9jb25zdGFudHMoKTsKICAgICAgdmFyIHBha28gPSB7fTsKICAgICAgYXNzaWduKHBha28sIGRlZmxhdGUsIGluZmxhdGUsIGNvbnN0YW50cyk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFrbzsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2J1ZmZlci1jcmMzMkAwLjIuMTMvbm9kZV9tb2R1bGVzL2J1ZmZlci1jcmMzMi9pbmRleC5qcwogIHZhciByZXF1aXJlX2J1ZmZlcl9jcmMzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9idWZmZXItY3JjMzJAMC4yLjEzL25vZGVfbW9kdWxlcy9idWZmZXItY3JjMzIvaW5kZXguanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBCdWZmZXI4ID0gcmVxdWlyZV9idWZmZXIoKS5CdWZmZXI7CiAgICAgIHZhciBDUkNfVEFCTEUgPSBbCiAgICAgICAgMCwKICAgICAgICAxOTk2OTU5ODk0LAogICAgICAgIDM5OTM5MTk3ODgsCiAgICAgICAgMjU2NzUyNDc5NCwKICAgICAgICAxMjQ2MzQxMzcsCiAgICAgICAgMTg4NjA1NzYxNSwKICAgICAgICAzOTE1NjIxNjg1LAogICAgICAgIDI2NTczOTIwMzUsCiAgICAgICAgMjQ5MjY4Mjc0LAogICAgICAgIDIwNDQ1MDgzMjQsCiAgICAgICAgMzc3MjExNTIzMCwKICAgICAgICAyNTQ3MTc3ODY0LAogICAgICAgIDE2Mjk0MTk5NSwKICAgICAgICAyMTI1NTYxMDIxLAogICAgICAgIDM4ODc2MDcwNDcsCiAgICAgICAgMjQyODQ0NDA0OSwKICAgICAgICA0OTg1MzY1NDgsCiAgICAgICAgMTc4OTkyNzY2NiwKICAgICAgICA0MDg5MDE2NjQ4LAogICAgICAgIDIyMjcwNjEyMTQsCiAgICAgICAgNDUwNTQ4ODYxLAogICAgICAgIDE4NDMyNTg2MDMsCiAgICAgICAgNDEwNzU4MDc1MywKICAgICAgICAyMjExNjc3NjM5LAogICAgICAgIDMyNTg4Mzk5MCwKICAgICAgICAxNjg0Nzc3MTUyLAogICAgICAgIDQyNTExMjIwNDIsCiAgICAgICAgMjMyMTkyNjYzNiwKICAgICAgICAzMzU2MzM0ODcsCiAgICAgICAgMTY2MTM2NTQ2NSwKICAgICAgICA0MTk1MzAyNzU1LAogICAgICAgIDIzNjYxMTUzMTcsCiAgICAgICAgOTk3MDczMDk2LAogICAgICAgIDEyODE5NTM4ODYsCiAgICAgICAgMzU3OTg1NTMzMiwKICAgICAgICAyNzI0Njg4MjQyLAogICAgICAgIDEwMDY4ODgxNDUsCiAgICAgICAgMTI1ODYwNzY4NywKICAgICAgICAzNTI0MTAxNjI5LAogICAgICAgIDI3Njg5NDI0NDMsCiAgICAgICAgOTAxMDk3NzIyLAogICAgICAgIDExMTkwMDA2ODQsCiAgICAgICAgMzY4NjUxNzIwNiwKICAgICAgICAyODk4MDY1NzI4LAogICAgICAgIDg1MzA0NDQ1MSwKICAgICAgICAxMTcyMjY2MTAxLAogICAgICAgIDM3MDUwMTU3NTksCiAgICAgICAgMjg4MjYxNjY2NSwKICAgICAgICA2NTE3Njc5ODAsCiAgICAgICAgMTM3MzUwMzU0NiwKICAgICAgICAzMzY5NTU0MzA0LAogICAgICAgIDMyMTgxMDQ1OTgsCiAgICAgICAgNTY1NTA3MjUzLAogICAgICAgIDE0NTQ2MjE3MzEsCiAgICAgICAgMzQ4NTExMTcwNSwKICAgICAgICAzMDk5NDM2MzAzLAogICAgICAgIDY3MTI2Njk3NCwKICAgICAgICAxNTk0MTk4MDI0LAogICAgICAgIDMzMjI3MzA5MzAsCiAgICAgICAgMjk3MDM0NzgxMiwKICAgICAgICA3OTU4MzU1MjcsCiAgICAgICAgMTQ4MzIzMDIyNSwKICAgICAgICAzMjQ0MzY3Mjc1LAogICAgICAgIDMwNjAxNDk1NjUsCiAgICAgICAgMTk5NDE0NjE5MiwKICAgICAgICAzMTE1ODUzNCwKICAgICAgICAyNTYzOTA3NzcyLAogICAgICAgIDQwMjM3MTc5MzAsCiAgICAgICAgMTkwNzQ1OTQ2NSwKICAgICAgICAxMTI2MzcyMTUsCiAgICAgICAgMjY4MDE1MzI1MywKICAgICAgICAzOTA0NDI3MDU5LAogICAgICAgIDIwMTM3NzYyOTAsCiAgICAgICAgMjUxNzIyMDM2LAogICAgICAgIDI1MTcyMTUzNzQsCiAgICAgICAgMzc3NTgzMDA0MCwKICAgICAgICAyMTM3NjU2NzYzLAogICAgICAgIDE0MTM3NjgxMywKICAgICAgICAyNDM5Mjc3NzE5LAogICAgICAgIDM4NjUyNzEyOTcsCiAgICAgICAgMTgwMjE5NTQ0NCwKICAgICAgICA0NzY4NjQ4NjYsCiAgICAgICAgMjIzODAwMTM2OCwKICAgICAgICA0MDY2NTA4ODc4LAogICAgICAgIDE4MTIzNzA5MjUsCiAgICAgICAgNDUzMDkyNzMxLAogICAgICAgIDIxODE2MjUwMjUsCiAgICAgICAgNDExMTQ1MTIyMywKICAgICAgICAxNzA2MDg4OTAyLAogICAgICAgIDMxNDA0MjcwNCwKICAgICAgICAyMzQ0NTMyMjAyLAogICAgICAgIDQyNDAwMTc1MzIsCiAgICAgICAgMTY1ODY1ODI3MSwKICAgICAgICAzNjY2MTk5NzcsCiAgICAgICAgMjM2MjY3MDMyMywKICAgICAgICA0MjI0OTk0NDA1LAogICAgICAgIDEzMDM1MzU5NjAsCiAgICAgICAgOTg0OTYxNDg2LAogICAgICAgIDI3NDcwMDcwOTIsCiAgICAgICAgMzU2OTAzNzUzOCwKICAgICAgICAxMjU2MTcwODE3LAogICAgICAgIDEwMzc2MDQzMTEsCiAgICAgICAgMjc2NTIxMDczMywKICAgICAgICAzNTU0MDc5OTk1LAogICAgICAgIDExMzEwMTQ1MDYsCiAgICAgICAgODc5Njc5OTk2LAogICAgICAgIDI5MDkyNDM0NjIsCiAgICAgICAgMzY2Mzc3MTg1NiwKICAgICAgICAxMTQxMTI0NDY3LAogICAgICAgIDg1NTg0MjI3NywKICAgICAgICAyODUyODAxNjMxLAogICAgICAgIDM3MDg2NDg2NDksCiAgICAgICAgMTM0MjUzMzk0OCwKICAgICAgICA2NTQ0NTkzMDYsCiAgICAgICAgMzE4ODM5NjA0OCwKICAgICAgICAzMzczMDE1MTc0LAogICAgICAgIDE0NjY0Nzk5MDksCiAgICAgICAgNTQ0MTc5NjM1LAogICAgICAgIDMxMTA1MjM5MTMsCiAgICAgICAgMzQ2MjUyMjAxNSwKICAgICAgICAxNTkxNjcxMDU0LAogICAgICAgIDcwMjEzODc3NiwKICAgICAgICAyOTY2NDYwNDUwLAogICAgICAgIDMzNTI3OTk0MTIsCiAgICAgICAgMTUwNDkxODgwNywKICAgICAgICA3ODM1NTE4NzMsCiAgICAgICAgMzA4MjY0MDQ0MywKICAgICAgICAzMjMzNDQyOTg5LAogICAgICAgIDM5ODgyOTIzODQsCiAgICAgICAgMjU5NjI1NDY0NiwKICAgICAgICA2MjMxNzA2OCwKICAgICAgICAxOTU3ODEwODQyLAogICAgICAgIDM5Mzk4NDU5NDUsCiAgICAgICAgMjY0NzgxNjExMSwKICAgICAgICA4MTQ3MDk5NywKICAgICAgICAxOTQzODAzNTIzLAogICAgICAgIDM4MTQ5MTg5MzAsCiAgICAgICAgMjQ4OTU5NjgwNCwKICAgICAgICAyMjUyNzQ0MzAsCiAgICAgICAgMjA1Mzc5MDM3NiwKICAgICAgICAzODI2MTc1NzU1LAogICAgICAgIDI0NjY5MDYwMTMsCiAgICAgICAgMTY3ODE2NzQzLAogICAgICAgIDIwOTc2NTEzNzcsCiAgICAgICAgNDAyNzU1MjU4MCwKICAgICAgICAyMjY1NDkwMzg2LAogICAgICAgIDUwMzQ0NDA3MiwKICAgICAgICAxNzYyMDUwODE0LAogICAgICAgIDQxNTA0MTcyNDUsCiAgICAgICAgMjE1NDEyOTM1NSwKICAgICAgICA0MjY1MjIyMjUsCiAgICAgICAgMTg1MjUwNzg3OSwKICAgICAgICA0Mjc1MzEzNTI2LAogICAgICAgIDIzMTIzMTc5MjAsCiAgICAgICAgMjgyNzUzNjI2LAogICAgICAgIDE3NDI1NTU4NTIsCiAgICAgICAgNDE4OTcwODE0MywKICAgICAgICAyMzk0ODc3OTQ1LAogICAgICAgIDM5NzkxNzc2MywKICAgICAgICAxNjIyMTgzNjM3LAogICAgICAgIDM2MDQzOTA4ODgsCiAgICAgICAgMjcxNDg2NjU1OCwKICAgICAgICA5NTM3Mjk3MzIsCiAgICAgICAgMTM0MDA3NjYyNiwKICAgICAgICAzNTE4NzE5OTg1LAogICAgICAgIDI3OTczNjA5OTksCiAgICAgICAgMTA2ODgyODM4MSwKICAgICAgICAxMjE5NjM4ODU5LAogICAgICAgIDM2MjQ3NDE4NTAsCiAgICAgICAgMjkzNjY3NTE0OCwKICAgICAgICA5MDYxODU0NjIsCiAgICAgICAgMTA5MDgxMjUxMiwKICAgICAgICAzNzQ3NjcyMDAzLAogICAgICAgIDI4MjUzNzk2NjksCiAgICAgICAgODI5MzI5MTM1LAogICAgICAgIDExODEzMzUxNjEsCiAgICAgICAgMzQxMjE3NzgwNCwKICAgICAgICAzMTYwODM0ODQyLAogICAgICAgIDYyODA4NTQwOCwKICAgICAgICAxMzgyNjA1MzY2LAogICAgICAgIDM0MjMzNjkxMDksCiAgICAgICAgMzEzODA3ODQ2NywKICAgICAgICA1NzA1NjIyMzMsCiAgICAgICAgMTQyNjQwMDgxNSwKICAgICAgICAzMzE3MzE2NTQyLAogICAgICAgIDI5OTg3MzM2MDgsCiAgICAgICAgNzMzMjM5OTU0LAogICAgICAgIDE1NTUyNjE5NTYsCiAgICAgICAgMzI2ODkzNTU5MSwKICAgICAgICAzMDUwMzYwNjI1LAogICAgICAgIDc1MjQ1OTQwMywKICAgICAgICAxNTQxMzIwMjIxLAogICAgICAgIDI2MDcwNzE5MjAsCiAgICAgICAgMzk2NTk3MzAzMCwKICAgICAgICAxOTY5OTIyOTcyLAogICAgICAgIDQwNzM1NDk4LAogICAgICAgIDI2MTc4MzcyMjUsCiAgICAgICAgMzk0MzU3NzE1MSwKICAgICAgICAxOTEzMDg3ODc3LAogICAgICAgIDgzOTA4MzcxLAogICAgICAgIDI1MTIzNDE2MzQsCiAgICAgICAgMzgwMzc0MDY5MiwKICAgICAgICAyMDc1MjA4NjIyLAogICAgICAgIDIxMzI2MTExMiwKICAgICAgICAyNDYzMjcyNjAzLAogICAgICAgIDM4NTU5OTAyODUsCiAgICAgICAgMjA5NDg1NDA3MSwKICAgICAgICAxOTg5NTg4ODEsCiAgICAgICAgMjI2MjAyOTAxMiwKICAgICAgICA0MDU3MjYwNjEwLAogICAgICAgIDE3NTkzNTk5OTIsCiAgICAgICAgNTM0NDE0MTkwLAogICAgICAgIDIxNzY3MTg1NDEsCiAgICAgICAgNDEzOTMyOTExNSwKICAgICAgICAxODczODM2MDAxLAogICAgICAgIDQxNDY2NDU2NywKICAgICAgICAyMjgyMjQ4OTM0LAogICAgICAgIDQyNzkyMDAzNjgsCiAgICAgICAgMTcxMTY4NDU1NCwKICAgICAgICAyODUyODExMTYsCiAgICAgICAgMjQwNTgwMTcyNywKICAgICAgICA0MTY3MjE2NzQ1LAogICAgICAgIDE2MzQ0Njc3OTUsCiAgICAgICAgMzc2MjI5NzAxLAogICAgICAgIDI2ODUwNjc4OTYsCiAgICAgICAgMzYwODAwNzQwNiwKICAgICAgICAxMzA4OTE4NjEyLAogICAgICAgIDk1NjU0MzkzOCwKICAgICAgICAyODA4NTU1MTA1LAogICAgICAgIDM0OTU5NTgyNjMsCiAgICAgICAgMTIzMTYzNjMwMSwKICAgICAgICAxMDQ3NDI3MDM1LAogICAgICAgIDI5MzI5NTk4MTgsCiAgICAgICAgMzY1NDcwMzgzNiwKICAgICAgICAxMDg4MzU5MjcwLAogICAgICAgIDkzNjkxOGUzLAogICAgICAgIDI4NDc3MTQ4OTksCiAgICAgICAgMzczNjgzNzgyOSwKICAgICAgICAxMjAyOTAwODYzLAogICAgICAgIDgxNzIzMzg5NywKICAgICAgICAzMTgzMzQyMTA4LAogICAgICAgIDM0MDEyMzcxMzAsCiAgICAgICAgMTQwNDI3NzU1MiwKICAgICAgICA2MTU4MTgxNTAsCiAgICAgICAgMzEzNDIwNzQ5MywKICAgICAgICAzNDUzNDIxMjAzLAogICAgICAgIDE0MjM4NTc0NDksCiAgICAgICAgNjAxNDUwNDMxLAogICAgICAgIDMwMDk4Mzc2MTQsCiAgICAgICAgMzI5NDcxMDQ1NiwKICAgICAgICAxNTY3MTAzNzQ2LAogICAgICAgIDcxMTkyODcyNCwKICAgICAgICAzMDIwNjY4NDcxLAogICAgICAgIDMyNzIzODAwNjUsCiAgICAgICAgMTUxMDMzNDIzNSwKICAgICAgICA3NTUxNjcxMTcKICAgICAgXTsKICAgICAgaWYgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAidW5kZWZpbmVkIikgewogICAgICAgIENSQ19UQUJMRSA9IG5ldyBJbnQzMkFycmF5KENSQ19UQUJMRSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW5zdXJlQnVmZmVyKGlucHV0KSB7CiAgICAgICAgaWYgKEJ1ZmZlcjguaXNCdWZmZXIoaW5wdXQpKSB7CiAgICAgICAgICByZXR1cm4gaW5wdXQ7CiAgICAgICAgfQogICAgICAgIHZhciBoYXNOZXdCdWZmZXJBUEkgPSB0eXBlb2YgQnVmZmVyOC5hbGxvYyA9PT0gImZ1bmN0aW9uIiAmJiB0eXBlb2YgQnVmZmVyOC5mcm9tID09PSAiZnVuY3Rpb24iOwogICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICByZXR1cm4gaGFzTmV3QnVmZmVyQVBJID8gQnVmZmVyOC5hbGxvYyhpbnB1dCkgOiBuZXcgQnVmZmVyOChpbnB1dCk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICByZXR1cm4gaGFzTmV3QnVmZmVyQVBJID8gQnVmZmVyOC5mcm9tKGlucHV0KSA6IG5ldyBCdWZmZXI4KGlucHV0KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbnB1dCBtdXN0IGJlIGJ1ZmZlciwgbnVtYmVyLCBvciBzdHJpbmcsIHJlY2VpdmVkICIgKyB0eXBlb2YgaW5wdXQpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBidWZmZXJpemVJbnQobnVtKSB7CiAgICAgICAgdmFyIHRtcCA9IGVuc3VyZUJ1ZmZlcig0KTsKICAgICAgICB0bXAud3JpdGVJbnQzMkJFKG51bSwgMCk7CiAgICAgICAgcmV0dXJuIHRtcDsKICAgICAgfQogICAgICBmdW5jdGlvbiBfY3JjMzIoYnVmLCBwcmV2aW91cykgewogICAgICAgIGJ1ZiA9IGVuc3VyZUJ1ZmZlcihidWYpOwogICAgICAgIGlmIChCdWZmZXI4LmlzQnVmZmVyKHByZXZpb3VzKSkgewogICAgICAgICAgcHJldmlvdXMgPSBwcmV2aW91cy5yZWFkVUludDMyQkUoMCk7CiAgICAgICAgfQogICAgICAgIHZhciBjcmMgPSB+fnByZXZpb3VzIF4gLTE7CiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBidWYubGVuZ3RoOyBuKyspIHsKICAgICAgICAgIGNyYyA9IENSQ19UQUJMRVsoY3JjIF4gYnVmW25dKSAmIDI1NV0gXiBjcmMgPj4+IDg7CiAgICAgICAgfQogICAgICAgIHJldHVybiBjcmMgXiAtMTsKICAgICAgfQogICAgICBmdW5jdGlvbiBjcmMzMjIoKSB7CiAgICAgICAgcmV0dXJuIGJ1ZmZlcml6ZUludChfY3JjMzIuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7CiAgICAgIH0KICAgICAgY3JjMzIyLnNpZ25lZCA9IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiBfY3JjMzIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsKICAgICAgfTsKICAgICAgY3JjMzIyLnVuc2lnbmVkID0gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIF9jcmMzMi5hcHBseShudWxsLCBhcmd1bWVudHMpID4+PiAwOwogICAgICB9OwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGNyYzMyMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL29iamVjdC5lbnRyaWVzLXBvbnlmaWxsQDEuMC4xL25vZGVfbW9kdWxlcy9vYmplY3QuZW50cmllcy1wb255ZmlsbC9lbnRyaWVzLmpzCiAgdmFyIHJlcXVpcmVfZW50cmllcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9vYmplY3QuZW50cmllcy1wb255ZmlsbEAxLjAuMS9ub2RlX21vZHVsZXMvb2JqZWN0LmVudHJpZXMtcG9ueWZpbGwvZW50cmllcy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgaGFzID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7CiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOwogICAgICB9OwogICAgICB2YXIgaXNFbnVtZXJhYmxlID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7CiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHByb3ApOwogICAgICB9OwogICAgICBmdW5jdGlvbiBlbnRyaWVzMihvYmopIHsKICAgICAgICBpZiAob2JqID09IG51bGwpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCIpOwogICAgICAgIH0KICAgICAgICB2YXIgcGFpcnMgPSBbXTsKICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7CiAgICAgICAgICBpZiAoaGFzKG9iaiwga2V5KSAmJiBpc0VudW1lcmFibGUob2JqLCBrZXkpKSB7CiAgICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgb2JqW2tleV1dKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBhaXJzOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZW50cmllczI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9vYmplY3QuZW50cmllcy1wb255ZmlsbEAxLjAuMS9ub2RlX21vZHVsZXMvb2JqZWN0LmVudHJpZXMtcG9ueWZpbGwvaW5kZXguanMKICB2YXIgcmVxdWlyZV9vYmplY3QgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vb2JqZWN0LmVudHJpZXMtcG9ueWZpbGxAMS4wLjEvbm9kZV9tb2R1bGVzL29iamVjdC5lbnRyaWVzLXBvbnlmaWxsL2luZGV4LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBPYmplY3QuZW50cmllcyA9PT0gImZ1bmN0aW9uIiA/IE9iamVjdC5lbnRyaWVzIDogcmVxdWlyZV9lbnRyaWVzKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGxAMS43LjUvbm9kZV9tb2R1bGVzL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbC9kaXN0L2Nqcy1wb255ZmlsbC5qcwogIHZhciByZXF1aXJlX2Nqc19wb255ZmlsbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGxAMS43LjUvbm9kZV9tb2R1bGVzL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbC9kaXN0L2Nqcy1wb255ZmlsbC5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgewogICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgewogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07CiAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7CiAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7CiAgICAgICAgICBpZiAoInZhbHVlIiBpbiBkZXNjcmlwdG9yKQogICAgICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgewogICAgICAgIGlmIChwcm90b1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsKICAgICAgICBpZiAoc3RhdGljUHJvcHMpCiAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOwogICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgInByb3RvdHlwZSIsIHsKICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZQogICAgICAgIH0pOwogICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsKICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICJmdW5jdGlvbiIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7CiAgICAgICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsICJwcm90b3R5cGUiLCB7CiAgICAgICAgICB3cml0YWJsZTogZmFsc2UKICAgICAgICB9KTsKICAgICAgICBpZiAoc3VwZXJDbGFzcykKICAgICAgICAgIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsKICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mMihvMikgewogICAgICAgICAgcmV0dXJuIG8yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobzIpOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgewogICAgICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YyKG8yLCBwMikgewogICAgICAgICAgbzIuX19wcm90b19fID0gcDI7CiAgICAgICAgICByZXR1cm4gbzI7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHRyeSB7CiAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkgewogICAgICAgICAgfSkpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYyKSB7CiAgICAgICAgaWYgKHNlbGYyID09PSB2b2lkIDApIHsKICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzZWxmMjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmMiwgY2FsbCkgewogICAgICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIGNhbGwgPT09ICJmdW5jdGlvbiIpKSB7CiAgICAgICAgICByZXR1cm4gY2FsbDsKICAgICAgICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWQiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZjIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7CiAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgewogICAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7CiAgICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgewogICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOwogICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgewogICAgICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7CiAgICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsKICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqZWN0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9nZXQoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSAidW5kZWZpbmVkIiAmJiBSZWZsZWN0LmdldCkgewogICAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQyKHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7CiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmICghYmFzZSkKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmIChkZXNjLmdldCkgewogICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlOwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICB2YXIgRW1pdHRlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBFbWl0dGVyMigpIHsKICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyMik7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgImxpc3RlbmVycyIsIHsKICAgICAgICAgICAgdmFsdWU6IHt9LAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIyLCBbewogICAgICAgICAga2V5OiAiYWRkRXZlbnRMaXN0ZW5lciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgewogICAgICAgICAgICBpZiAoISh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgewogICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7CiAgICAgICAgICAgICAgY2FsbGJhY2ssCiAgICAgICAgICAgICAgb3B0aW9ucwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJyZW1vdmVFdmVudExpc3RlbmVyIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW3R5cGVdOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIGlmIChzdGFja1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spIHsKICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmICghKGV2ZW50LnR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdOwogICAgICAgICAgICB2YXIgc3RhY2tUb0NhbGwgPSBzdGFjay5zbGljZSgpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrVG9DYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHN0YWNrVG9DYWxsW2ldOwogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vcHRpb25zICYmIGxpc3RlbmVyLm9wdGlvbnMub25jZSkgewogICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGxpc3RlbmVyLmNhbGxiYWNrKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gRW1pdHRlcjI7CiAgICAgIH0oKTsKICAgICAgdmFyIEFib3J0U2lnbmFsID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9FbWl0dGVyKSB7CiAgICAgICAgX2luaGVyaXRzKEFib3J0U2lnbmFsMiwgX0VtaXR0ZXIpOwogICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWJvcnRTaWduYWwyKTsKICAgICAgICBmdW5jdGlvbiBBYm9ydFNpZ25hbDIoKSB7CiAgICAgICAgICB2YXIgX3RoaXM7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRTaWduYWwyKTsKICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7CiAgICAgICAgICBpZiAoIV90aGlzLmxpc3RlbmVycykgewogICAgICAgICAgICBFbWl0dGVyLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOwogICAgICAgICAgfQogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAiYWJvcnRlZCIsIHsKICAgICAgICAgICAgdmFsdWU6IGZhbHNlLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgIm9uYWJvcnQiLCB7CiAgICAgICAgICAgIHZhbHVlOiBudWxsLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgInJlYXNvbiIsIHsKICAgICAgICAgICAgdmFsdWU6IHZvaWQgMCwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gX3RoaXM7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhBYm9ydFNpZ25hbDIsIFt7CiAgICAgICAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIHJldHVybiAiW29iamVjdCBBYm9ydFNpZ25hbF0iOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImRpc3BhdGNoRXZlbnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHsKICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICJhYm9ydCIpIHsKICAgICAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlOwogICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbmFib3J0ID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgICAgICB0aGlzLm9uYWJvcnQuY2FsbCh0aGlzLCBldmVudCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEFib3J0U2lnbmFsMi5wcm90b3R5cGUpLCAiZGlzcGF0Y2hFdmVudCIsIHRoaXMpLmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gQWJvcnRTaWduYWwyOwogICAgICB9KEVtaXR0ZXIpOwogICAgICB2YXIgQWJvcnRDb250cm9sbGVyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkgewogICAgICAgIGZ1bmN0aW9uIEFib3J0Q29udHJvbGxlcjIoKSB7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRDb250cm9sbGVyMik7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgInNpZ25hbCIsIHsKICAgICAgICAgICAgdmFsdWU6IG5ldyBBYm9ydFNpZ25hbCgpLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgX2NyZWF0ZUNsYXNzKEFib3J0Q29udHJvbGxlcjIsIFt7CiAgICAgICAgICBrZXk6ICJhYm9ydCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7CiAgICAgICAgICAgIHZhciBldmVudDsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBldmVudCA9IG5ldyBFdmVudCgiYWJvcnQiKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7CiAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTsKICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9ICJhYm9ydCI7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCJFdmVudCIpOwogICAgICAgICAgICAgICAgICBldmVudC5pbml0RXZlbnQoImFib3J0IiwgZmFsc2UsIGZhbHNlKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZXZlbnQgPSB7CiAgICAgICAgICAgICAgICAgIHR5cGU6ICJhYm9ydCIsCiAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLAogICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZQogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHNpZ25hbFJlYXNvbiA9IHJlYXNvbjsKICAgICAgICAgICAgaWYgKHNpZ25hbFJlYXNvbiA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbiA9IG5ldyBFcnJvcigiVGhpcyBvcGVyYXRpb24gd2FzIGFib3J0ZWQiKTsKICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbi5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRE9NRXhjZXB0aW9uKCJzaWduYWwgaXMgYWJvcnRlZCB3aXRob3V0IHJlYXNvbiIpOwogICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbiA9IG5ldyBFcnJvcigiVGhpcyBvcGVyYXRpb24gd2FzIGFib3J0ZWQiKTsKICAgICAgICAgICAgICAgICAgc2lnbmFsUmVhc29uLm5hbWUgPSAiQWJvcnRFcnJvciI7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlYXNvbiA9IHNpZ25hbFJlYXNvbjsKICAgICAgICAgICAgdGhpcy5zaWduYWwuZGlzcGF0Y2hFdmVudChldmVudCk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAidG9TdHJpbmciLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gIltvYmplY3QgQWJvcnRDb250cm9sbGVyXSI7CiAgICAgICAgICB9CiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBBYm9ydENvbnRyb2xsZXIyOwogICAgICB9KCk7CiAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAidW5kZWZpbmVkIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHsKICAgICAgICBBYm9ydENvbnRyb2xsZXIucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAiQWJvcnRDb250cm9sbGVyIjsKICAgICAgICBBYm9ydFNpZ25hbC5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICJBYm9ydFNpZ25hbCI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9seWZpbGxOZWVkZWQoc2VsZjIpIHsKICAgICAgICBpZiAoc2VsZjIuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCkgewogICAgICAgICAgY29uc29sZS5sb2coIl9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEw9dHJ1ZSBpcyBzZXQsIHdpbGwgZm9yY2UgaW5zdGFsbCBwb2x5ZmlsbCIpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0eXBlb2Ygc2VsZjIuUmVxdWVzdCA9PT0gImZ1bmN0aW9uIiAmJiAhc2VsZjIuUmVxdWVzdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoInNpZ25hbCIpIHx8ICFzZWxmMi5BYm9ydENvbnRyb2xsZXI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYWJvcnRhYmxlRmV0Y2hEZWNvcmF0b3IocGF0Y2hUYXJnZXRzKSB7CiAgICAgICAgaWYgKHR5cGVvZiBwYXRjaFRhcmdldHMgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHBhdGNoVGFyZ2V0cyA9IHsKICAgICAgICAgICAgZmV0Y2g6IHBhdGNoVGFyZ2V0cwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgdmFyIF9wYXRjaFRhcmdldHMgPSBwYXRjaFRhcmdldHMsIGZldGNoMiA9IF9wYXRjaFRhcmdldHMuZmV0Y2gsIF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMuUmVxdWVzdCwgTmF0aXZlUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9PT0gdm9pZCAwID8gZmV0Y2gyLlJlcXVlc3QgOiBfcGF0Y2hUYXJnZXRzJFJlcXVlc3QsIE5hdGl2ZUFib3J0Q29udHJvbGxlciA9IF9wYXRjaFRhcmdldHMuQWJvcnRDb250cm9sbGVyLCBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0UgPSBfcGF0Y2hUYXJnZXRzLl9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwsIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwgPSBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3BhdGNoVGFyZ2V0cyRfX0ZPUkNFOwogICAgICAgIGlmICghcG9seWZpbGxOZWVkZWQoewogICAgICAgICAgZmV0Y2g6IGZldGNoMiwKICAgICAgICAgIFJlcXVlc3Q6IE5hdGl2ZVJlcXVlc3QsCiAgICAgICAgICBBYm9ydENvbnRyb2xsZXI6IE5hdGl2ZUFib3J0Q29udHJvbGxlciwKICAgICAgICAgIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwKICAgICAgICB9KSkgewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgZmV0Y2g6IGZldGNoMiwKICAgICAgICAgICAgUmVxdWVzdAogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgdmFyIFJlcXVlc3QgPSBOYXRpdmVSZXF1ZXN0OwogICAgICAgIGlmIChSZXF1ZXN0ICYmICFSZXF1ZXN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgic2lnbmFsIikgfHwgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCkgewogICAgICAgICAgUmVxdWVzdCA9IGZ1bmN0aW9uIFJlcXVlc3QyKGlucHV0LCBpbml0MikgewogICAgICAgICAgICB2YXIgc2lnbmFsOwogICAgICAgICAgICBpZiAoaW5pdDIgJiYgaW5pdDIuc2lnbmFsKSB7CiAgICAgICAgICAgICAgc2lnbmFsID0gaW5pdDIuc2lnbmFsOwogICAgICAgICAgICAgIGRlbGV0ZSBpbml0Mi5zaWduYWw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgTmF0aXZlUmVxdWVzdChpbnB1dCwgaW5pdDIpOwogICAgICAgICAgICBpZiAoc2lnbmFsKSB7CiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVlc3QsICJzaWduYWwiLCB7CiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsCiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICAgIHZhbHVlOiBzaWduYWwKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVxdWVzdDsKICAgICAgICAgIH07CiAgICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZSA9IE5hdGl2ZVJlcXVlc3QucHJvdG90eXBlOwogICAgICAgIH0KICAgICAgICB2YXIgcmVhbEZldGNoID0gZmV0Y2gyOwogICAgICAgIHZhciBhYm9ydGFibGVGZXRjaCA9IGZ1bmN0aW9uIGFib3J0YWJsZUZldGNoMihpbnB1dCwgaW5pdDIpIHsKICAgICAgICAgIHZhciBzaWduYWwgPSBSZXF1ZXN0ICYmIFJlcXVlc3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaW5wdXQpID8gaW5wdXQuc2lnbmFsIDogaW5pdDIgPyBpbml0Mi5zaWduYWwgOiB2b2lkIDA7CiAgICAgICAgICBpZiAoc2lnbmFsKSB7CiAgICAgICAgICAgIHZhciBhYm9ydEVycm9yOwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGFib3J0RXJyb3IgPSBuZXcgRE9NRXhjZXB0aW9uKCJBYm9ydGVkIiwgIkFib3J0RXJyb3IiKTsKICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgYWJvcnRFcnJvciA9IG5ldyBFcnJvcigiQWJvcnRlZCIpOwogICAgICAgICAgICAgIGFib3J0RXJyb3IubmFtZSA9ICJBYm9ydEVycm9yIjsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYWJvcnRFcnJvcik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGNhbmNlbGxhdGlvbiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKF8sIHJlamVjdCkgewogICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChhYm9ydEVycm9yKTsKICAgICAgICAgICAgICB9LCB7CiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBpZiAoaW5pdDIgJiYgaW5pdDIuc2lnbmFsKSB7CiAgICAgICAgICAgICAgZGVsZXRlIGluaXQyLnNpZ25hbDsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtjYW5jZWxsYXRpb24sIHJlYWxGZXRjaChpbnB1dCwgaW5pdDIpXSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVhbEZldGNoKGlucHV0LCBpbml0Mik7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gewogICAgICAgICAgZmV0Y2g6IGFib3J0YWJsZUZldGNoLAogICAgICAgICAgUmVxdWVzdAogICAgICAgIH07CiAgICAgIH0KICAgICAgZXhwb3J0cy5BYm9ydENvbnRyb2xsZXIgPSBBYm9ydENvbnRyb2xsZXI7CiAgICAgIGV4cG9ydHMuQWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbDsKICAgICAgZXhwb3J0cy5hYm9ydGFibGVGZXRjaCA9IGFib3J0YWJsZUZldGNoRGVjb3JhdG9yOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vYWJvcnRhYmxlLXByb21pc2UtY2FjaGVAMS41LjAvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9hYm9ydGNvbnRyb2xsZXItcG9ueWZpbGwuanMKICB2YXIgcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYWJvcnRhYmxlLXByb21pc2UtY2FjaGVAMS41LjAvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9hYm9ydGNvbnRyb2xsZXItcG9ueWZpbGwuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMuQWJvcnRTaWduYWwgPSBleHBvcnRzLkFib3J0Q29udHJvbGxlciA9IHZvaWQgMDsKICAgICAgdmFyIGNqc19wb255ZmlsbF8xID0gcmVxdWlyZV9janNfcG9ueWZpbGwoKTsKICAgICAgdmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiBzZWxmOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiB3aW5kb3c7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgcmV0dXJuIGdsb2JhbDsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QiKTsKICAgICAgfTsKICAgICAgdmFyIEFib3J0Q29udHJvbGxlciA9IHR5cGVvZiBnZXRHbG9iYWwoKS5BYm9ydENvbnRyb2xsZXIgPT09ICJ1bmRlZmluZWQiID8gY2pzX3BvbnlmaWxsXzEuQWJvcnRDb250cm9sbGVyIDogZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyOwogICAgICBleHBvcnRzLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlcjsKICAgICAgdmFyIEFib3J0U2lnbmFsID0gdHlwZW9mIGdldEdsb2JhbCgpLkFib3J0Q29udHJvbGxlciA9PT0gInVuZGVmaW5lZCIgPyBjanNfcG9ueWZpbGxfMS5BYm9ydFNpZ25hbCA6IGdldEdsb2JhbCgpLkFib3J0U2lnbmFsOwogICAgICBleHBvcnRzLkFib3J0U2lnbmFsID0gQWJvcnRTaWduYWw7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlci5qcwogIHZhciByZXF1aXJlX0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlci5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xID0gcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwoKTsKICAgICAgdmFyIE51bGxTaWduYWwgPSBjbGFzcyB7CiAgICAgIH07CiAgICAgIHZhciBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIgPSBjbGFzcyB7CiAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICB0aGlzLnNpZ25hbHMgPSBuZXcgU2V0KCk7CiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBhYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGxfMS5BYm9ydENvbnRyb2xsZXIoKTsKICAgICAgICB9CiAgICAgICAgYWRkU2lnbmFsKHNpZ25hbCA9IG5ldyBOdWxsU2lnbmFsKCkpIHsKICAgICAgICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IGFkZCBhIHNpZ25hbCwgYWxyZWFkeSBhYm9ydGVkISIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5zaWduYWxzLmFkZChzaWduYWwpOwogICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7CiAgICAgICAgICAgIHRoaXMuaGFuZGxlQWJvcnRlZChzaWduYWwpOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IiwgKCkgPT4gewogICAgICAgICAgICAgIHRoaXMuaGFuZGxlQWJvcnRlZChzaWduYWwpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaGFuZGxlQWJvcnRlZChzaWduYWwpIHsKICAgICAgICAgIHRoaXMuc2lnbmFscy5kZWxldGUoc2lnbmFsKTsKICAgICAgICAgIGlmICh0aGlzLnNpZ25hbHMuc2l6ZSA9PT0gMCkgewogICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBnZXQgc2lnbmFsKCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbDsKICAgICAgICB9CiAgICAgICAgYWJvcnQoKSB7CiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gQWdncmVnYXRlQWJvcnRDb250cm9sbGVyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vYWJvcnRhYmxlLXByb21pc2UtY2FjaGVAMS41LjAvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlci5qcwogIHZhciByZXF1aXJlX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlciA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IFNldCgpOwogICAgICAgIH0KICAgICAgICBhZGRDYWxsYmFjayhjYWxsYmFjayA9ICgpID0+IHsKICAgICAgICB9KSB7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5hZGQoY2FsbGJhY2spOwogICAgICAgICAgY2FsbGJhY2sodGhpcy5jdXJyZW50TWVzc2FnZSk7CiAgICAgICAgfQogICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UpIHsKICAgICAgICAgIHRoaXMuY3VycmVudE1lc3NhZ2UgPSBtZXNzYWdlOwogICAgICAgICAgdGhpcy5jYWxsYmFja3MuZm9yRWFjaCgoZWx0KSA9PiB7CiAgICAgICAgICAgIGVsdChtZXNzYWdlKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcwogIHZhciByZXF1aXJlX0Fib3J0YWJsZVByb21pc2VDYWNoZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgImRlZmF1bHQiOiBtb2QgfTsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xID0gcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwoKTsKICAgICAgdmFyIEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfQWdncmVnYXRlQWJvcnRDb250cm9sbGVyKCkpOwogICAgICB2YXIgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyKCkpOwogICAgICB2YXIgQWJvcnRhYmxlUHJvbWlzZUNhY2hlMiA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3Rvcih7IGZpbGwsIGNhY2hlIH0pIHsKICAgICAgICAgIGlmICh0eXBlb2YgZmlsbCAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBmaWxsIGZ1bmN0aW9uIik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGNhY2hlICE9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBjYWNoZSBvYmplY3QiKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgY2FjaGUuZ2V0ICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBjYWNoZS5zZXQgIT09ICJmdW5jdGlvbiIgfHwgdHlwZW9mIGNhY2hlLmRlbGV0ZSAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJjYWNoZSBtdXN0IGltcGxlbWVudCBnZXQoa2V5KSwgc2V0KGtleSwgdmFsKSwgYW5kIGFuZCBkZWxldGUoa2V5KSIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlOwogICAgICAgICAgdGhpcy5maWxsQ2FsbGJhY2sgPSBmaWxsOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgaXNBYm9ydEV4Y2VwdGlvbihleGNlcHRpb24pIHsKICAgICAgICAgIHJldHVybiBleGNlcHRpb24ubmFtZSA9PT0gIkFib3J0RXJyb3IiIHx8IGV4Y2VwdGlvbi5jb2RlID09PSAiRVJSX0FCT1JURUQiIHx8IGV4Y2VwdGlvbi5tZXNzYWdlID09PSAiQWJvcnRFcnJvcjogYWJvcnRlZCIgfHwgZXhjZXB0aW9uLm1lc3NhZ2UgPT09ICJFcnJvcjogYWJvcnRlZCI7CiAgICAgICAgfQogICAgICAgIGV2aWN0KGtleSwgZW50cnkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmdldChrZXkpID09PSBlbnRyeSkgewogICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmaWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgY29uc3QgYWJvcnRlciA9IG5ldyBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXJfMS5kZWZhdWx0KCk7CiAgICAgICAgICBjb25zdCBzdGF0dXNSZXBvcnRlciA9IG5ldyBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcl8xLmRlZmF1bHQoKTsKICAgICAgICAgIHN0YXR1c1JlcG9ydGVyLmFkZENhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgIGNvbnN0IG5ld0VudHJ5ID0gewogICAgICAgICAgICBhYm9ydGVyLAogICAgICAgICAgICBwcm9taXNlOiB0aGlzLmZpbGxDYWxsYmFjayhkYXRhLCBhYm9ydGVyLnNpZ25hbCwgKG1lc3NhZ2UpID0+IHsKICAgICAgICAgICAgICBzdGF0dXNSZXBvcnRlci5jYWxsYmFjayhtZXNzYWdlKTsKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIHNldHRsZWQ6IGZhbHNlLAogICAgICAgICAgICBzdGF0dXNSZXBvcnRlciwKICAgICAgICAgICAgZ2V0IGFib3J0ZWQoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWJvcnRlci5zaWduYWwuYWJvcnRlZDsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIG5ld0VudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICBuZXdFbnRyeS5hYm9ydGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsICgpID0+IHsKICAgICAgICAgICAgaWYgKCFuZXdFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgdGhpcy5ldmljdChrZXksIG5ld0VudHJ5KTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBuZXdFbnRyeS5wcm9taXNlLnRoZW4oKCkgPT4gewogICAgICAgICAgICBuZXdFbnRyeS5zZXR0bGVkID0gdHJ1ZTsKICAgICAgICAgIH0sICgpID0+IHsKICAgICAgICAgICAgbmV3RW50cnkuc2V0dGxlZCA9IHRydWU7CiAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4gewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpOwogICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgfSk7CiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIG5ld0VudHJ5KTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGNoZWNrU2luZ2xlUHJvbWlzZShwcm9taXNlLCBzaWduYWwpIHsKICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrRm9yU2luZ2xlQWJvcnQoKSB7CiAgICAgICAgICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcigiYWJvcnRlZCIpLCB7IGNvZGU6ICJFUlJfQUJPUlRFRCIgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4gewogICAgICAgICAgICBjaGVja0ZvclNpbmdsZUFib3J0KCk7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgICB9LCAoZXJyb3IpID0+IHsKICAgICAgICAgICAgY2hlY2tGb3JTaW5nbGVBYm9ydCgpOwogICAgICAgICAgICB0aHJvdyBlcnJvcjsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBoYXMoa2V5KSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KTsKICAgICAgICB9CiAgICAgICAgZ2V0KGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgaWYgKCFzaWduYWwgJiYgZGF0YSBpbnN0YW5jZW9mIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xLkFib3J0U2lnbmFsKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoInNlY29uZCBnZXQgYXJndW1lbnQgYXBwZWFycyB0byBiZSBhbiBBYm9ydFNpZ25hbCwgcGVyaGFwcyB5b3UgbWVhbnQgdG8gcGFzcyBgbnVsbGAgZm9yIHRoZSBmaWxsIGRhdGE/Iik7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIGlmIChjYWNoZUVudHJ5KSB7CiAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LmFib3J0ZWQgJiYgIWNhY2hlRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBjYWNoZUVudHJ5KTsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCBkYXRhLCBzaWduYWwsIHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkucHJvbWlzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYWNoZUVudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICAgIGNhY2hlRW50cnkuc3RhdHVzUmVwb3J0ZXIuYWRkQ2FsbGJhY2soc3RhdHVzQ2FsbGJhY2spOwogICAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UoY2FjaGVFbnRyeS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5maWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UodGhpcy5jYWNoZS5nZXQoa2V5KS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgIH0KICAgICAgICBkZWxldGUoa2V5KSB7CiAgICAgICAgICBjb25zdCBjYWNoZWRFbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICBpZiAoY2FjaGVkRW50cnkpIHsKICAgICAgICAgICAgaWYgKCFjYWNoZWRFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgY2FjaGVkRW50cnkuYWJvcnRlci5hYm9ydCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNsZWFyKCkgewogICAgICAgICAgY29uc3Qga2V5SXRlciA9IHRoaXMuY2FjaGUua2V5cygpOwogICAgICAgICAgbGV0IGRlbGV0ZUNvdW50ID0gMDsKICAgICAgICAgIGZvciAobGV0IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpOyAhcmVzdWx0LmRvbmU7IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpKSB7CiAgICAgICAgICAgIHRoaXMuZGVsZXRlKHJlc3VsdC52YWx1ZSk7CiAgICAgICAgICAgIGRlbGV0ZUNvdW50ICs9IDE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZGVsZXRlQ291bnQ7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzLmRlZmF1bHQgPSBBYm9ydGFibGVQcm9taXNlQ2FjaGUyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vYWJvcnRhYmxlLXByb21pc2UtY2FjaGVAMS41LjAvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9pbmRleC5qcwogIHZhciByZXF1aXJlX2VzbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL2luZGV4LmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX19pbXBvcnREZWZhdWx0ID0gZXhwb3J0cyAmJiBleHBvcnRzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbihtb2QpIHsKICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyAiZGVmYXVsdCI6IG1vZCB9OwogICAgICB9OwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgQWJvcnRhYmxlUHJvbWlzZUNhY2hlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9BYm9ydGFibGVQcm9taXNlQ2FjaGUoKSk7CiAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IEFib3J0YWJsZVByb21pc2VDYWNoZV8xLmRlZmF1bHQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9xdWljay1scnVAMi4wLjAvbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcwogIHZhciByZXF1aXJlX3F1aWNrX2xydSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9xdWljay1scnVAMi4wLjAvbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgUXVpY2tMUlUzID0gY2xhc3MgewogICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkgewogICAgICAgICAgaWYgKCEob3B0aW9ucy5tYXhTaXplICYmIG9wdGlvbnMubWF4U2l6ZSA+IDApKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImBtYXhTaXplYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwIik7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLm1heFNpemUgPSBvcHRpb25zLm1heFNpemU7CiAgICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpOwogICAgICAgICAgdGhpcy5vbGRDYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICAgIHRoaXMuX3NpemUgPSAwOwogICAgICAgIH0KICAgICAgICBfc2V0KGtleSwgdmFsdWUpIHsKICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgdGhpcy5fc2l6ZSsrOwogICAgICAgICAgaWYgKHRoaXMuX3NpemUgPj0gdGhpcy5tYXhTaXplKSB7CiAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwOwogICAgICAgICAgICB0aGlzLm9sZENhY2hlID0gdGhpcy5jYWNoZTsKICAgICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZ2V0KGtleSkgewogICAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMub2xkQ2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICAgIHRoaXMuX3NldChrZXksIHZhbHVlKTsKICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzZXQoa2V5LCB2YWx1ZSkgewogICAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgaGFzKGtleSkgewogICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSkgfHwgdGhpcy5vbGRDYWNoZS5oYXMoa2V5KTsKICAgICAgICB9CiAgICAgICAgcGVlayhrZXkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMub2xkQ2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGRlbGV0ZShrZXkpIHsKICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgaWYgKGRlbGV0ZWQpIHsKICAgICAgICAgICAgdGhpcy5fc2l6ZS0tOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXMub2xkQ2FjaGUuZGVsZXRlKGtleSkgfHwgZGVsZXRlZDsKICAgICAgICB9CiAgICAgICAgY2xlYXIoKSB7CiAgICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7CiAgICAgICAgICB0aGlzLm9sZENhY2hlLmNsZWFyKCk7CiAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICB9CiAgICAgICAgKmtleXMoKSB7CiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXldIG9mIHRoaXMpIHsKICAgICAgICAgICAgeWllbGQga2V5OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAqdmFsdWVzKCkgewogICAgICAgICAgZm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgdGhpcykgewogICAgICAgICAgICB5aWVsZCB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgKltTeW1ib2wuaXRlcmF0b3JdKCkgewogICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuY2FjaGUpIHsKICAgICAgICAgICAgeWllbGQgaXRlbTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLm9sZENhY2hlKSB7CiAgICAgICAgICAgIGNvbnN0IFtrZXldID0gaXRlbTsKICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgICAgeWllbGQgaXRlbTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBnZXQgc2l6ZSgpIHsKICAgICAgICAgIGxldCBvbGRDYWNoZVNpemUgPSAwOwogICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5vbGRDYWNoZS5rZXlzKCkpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgICAgb2xkQ2FjaGVTaXplKys7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplICsgb2xkQ2FjaGVTaXplOwogICAgICAgIH0KICAgICAgfTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBRdWlja0xSVTM7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9jcm9zcy1mZXRjaEAzLjEuOC9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbHlmaWxsLmpzCiAgdmFyIHJlcXVpcmVfYnJvd3Nlcl9wb2x5ZmlsbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9jcm9zcy1mZXRjaEAzLjEuOC9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbHlmaWxsLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgKGZ1bmN0aW9uKHNlbGYyKSB7CiAgICAgICAgdmFyIGlycmVsZXZhbnQgPSBmdW5jdGlvbihleHBvcnRzMikgewogICAgICAgICAgdmFyIHN1cHBvcnQgPSB7CiAgICAgICAgICAgIHNlYXJjaFBhcmFtczogIlVSTFNlYXJjaFBhcmFtcyIgaW4gc2VsZjIsCiAgICAgICAgICAgIGl0ZXJhYmxlOiAiU3ltYm9sIiBpbiBzZWxmMiAmJiAiaXRlcmF0b3IiIGluIFN5bWJvbCwKICAgICAgICAgICAgYmxvYjogIkZpbGVSZWFkZXIiIGluIHNlbGYyICYmICJCbG9iIiBpbiBzZWxmMiAmJiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgbmV3IEJsb2IoKTsKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0oKSwKICAgICAgICAgICAgZm9ybURhdGE6ICJGb3JtRGF0YSIgaW4gc2VsZjIsCiAgICAgICAgICAgIGFycmF5QnVmZmVyOiAiQXJyYXlCdWZmZXIiIGluIHNlbGYyCiAgICAgICAgICB9OwogICAgICAgICAgZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHsKICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHsKICAgICAgICAgICAgdmFyIHZpZXdDbGFzc2VzID0gWwogICAgICAgICAgICAgICJbb2JqZWN0IEludDhBcnJheV0iLAogICAgICAgICAgICAgICJbb2JqZWN0IFVpbnQ4QXJyYXldIiwKICAgICAgICAgICAgICAiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0iLAogICAgICAgICAgICAgICJbb2JqZWN0IEludDE2QXJyYXldIiwKICAgICAgICAgICAgICAiW29iamVjdCBVaW50MTZBcnJheV0iLAogICAgICAgICAgICAgICJbb2JqZWN0IEludDMyQXJyYXldIiwKICAgICAgICAgICAgICAiW29iamVjdCBVaW50MzJBcnJheV0iLAogICAgICAgICAgICAgICJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLAogICAgICAgICAgICAgICJbb2JqZWN0IEZsb2F0NjRBcnJheV0iCiAgICAgICAgICAgIF07CiAgICAgICAgICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHsKICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTE7CiAgICAgICAgICAgIH07CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHsKICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAic3RyaW5nIikgewogICAgICAgICAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKC9bXmEtejAtOVwtIyQlJicqKy5eX2B8fl0vaS50ZXN0KG5hbWUpKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHsKICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHsKICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gewogICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTsKICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHZhbHVlID09PSB2b2lkIDAsIHZhbHVlIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwogICAgICAgICAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkgewogICAgICAgICAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykgewogICAgICAgICAgICB0aGlzLm1hcCA9IHt9OwogICAgICAgICAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHsKICAgICAgICAgICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsKICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKTsKICAgICAgICAgICAgICB9LCB0aGlzKTsKICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7CiAgICAgICAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikgewogICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pOwogICAgICAgICAgICAgIH0sIHRoaXMpOwogICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHsKICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pOwogICAgICAgICAgICAgIH0sIHRoaXMpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkgewogICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTsKICAgICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7CiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdOwogICAgICAgICAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAiLCAiICsgdmFsdWUgOiB2YWx1ZTsKICAgICAgICAgIH07CiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZVsiZGVsZXRlIl0gPSBmdW5jdGlvbihuYW1lKSB7CiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXTsKICAgICAgICAgIH07CiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7CiAgICAgICAgICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpOwogICAgICAgICAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGw7CiAgICAgICAgICB9OwogICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSk7CiAgICAgICAgICB9OwogICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHsKICAgICAgICAgICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7CiAgICAgICAgICB9OwogICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7CiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHsKICAgICAgICAgICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHsKICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107CiAgICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgewogICAgICAgICAgICAgIGl0ZW1zLnB1c2gobmFtZSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpOwogICAgICAgICAgfTsKICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTsKICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgICAgICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpOwogICAgICAgICAgfTsKICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107CiAgICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgewogICAgICAgICAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpOwogICAgICAgICAgfTsKICAgICAgICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7CiAgICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkgewogICAgICAgICAgICBpZiAoYm9keS5ib2R5VXNlZCkgewogICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCJBbHJlYWR5IHJlYWQiKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYm9keS5ib2R5VXNlZCA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHsKICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7CiAgICAgICAgICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7CiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTsKICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7CiAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpOwogICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpOwogICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKTsKICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7CiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTsKICAgICAgICAgICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBjaGFycy5qb2luKCIiKTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1ZikgewogICAgICAgICAgICBpZiAoYnVmLnNsaWNlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKTsKICAgICAgICAgICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTsKICAgICAgICAgICAgICByZXR1cm4gdmlldy5idWZmZXI7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIEJvZHkoKSB7CiAgICAgICAgICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7CiAgICAgICAgICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5OwogICAgICAgICAgICAgIGlmICghYm9keSkgewogICAgICAgICAgICAgICAgdGhpcy5fYm9keVRleHQgPSAiIjsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5OwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHsKICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHsKICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHsKICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkgewogICAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpOwogICAgICAgICAgICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHsKICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgiY29udGVudC10eXBlIikpIHsKICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgiY29udGVudC10eXBlIiwgInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOCIpOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoImNvbnRlbnQtdHlwZSIsIHRoaXMuX2JvZHlCbG9iLnR5cGUpOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgiY29udGVudC10eXBlIiwgImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Iik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwogICAgICAgICAgICBpZiAoc3VwcG9ydC5ibG9iKSB7CiAgICAgICAgICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTsKICAgICAgICAgICAgICAgIGlmIChyZWplY3RlZCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYik7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikgewogICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkgewogICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYiIpOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTsKICAgICAgICAgICAgICBpZiAocmVqZWN0ZWQpIHsKICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RlZDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQiKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwogICAgICAgICAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkgewogICAgICAgICAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgbWV0aG9kcyA9IFsiREVMRVRFIiwgIkdFVCIsICJIRUFEIiwgIk9QVElPTlMiLCAiUE9TVCIsICJQVVQiXTsKICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHsKICAgICAgICAgICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKTsKICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZDsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5OwogICAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7CiAgICAgICAgICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJBbHJlYWR5IHJlYWQiKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7CiAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzOwogICAgICAgICAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7CiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2Q7CiAgICAgICAgICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTsKICAgICAgICAgICAgICB0aGlzLnNpZ25hbCA9IGlucHV0LnNpZ25hbDsKICAgICAgICAgICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHsKICAgICAgICAgICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7CiAgICAgICAgICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICJzYW1lLW9yaWdpbiI7CiAgICAgICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykgewogICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgIkdFVCIpOwogICAgICAgICAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7CiAgICAgICAgICAgIHRoaXMuc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgfHwgdGhpcy5zaWduYWw7CiAgICAgICAgICAgIHRoaXMucmVmZXJyZXIgPSBudWxsOwogICAgICAgICAgICBpZiAoKHRoaXMubWV0aG9kID09PSAiR0VUIiB8fCB0aGlzLm1ldGhvZCA9PT0gIkhFQUQiKSAmJiBib2R5KSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLl9pbml0Qm9keShib2R5KTsKICAgICAgICAgIH0KICAgICAgICAgIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pOwogICAgICAgICAgfTsKICAgICAgICAgIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7CiAgICAgICAgICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKCk7CiAgICAgICAgICAgIGJvZHkudHJpbSgpLnNwbGl0KCImIikuZm9yRWFjaChmdW5jdGlvbihieXRlcykgewogICAgICAgICAgICAgIGlmIChieXRlcykgewogICAgICAgICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoIj0iKTsKICAgICAgICAgICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cKy9nLCAiICIpOwogICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbigiPSIpLnJlcGxhY2UoL1wrL2csICIgIik7CiAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBmb3JtOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHsKICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpOwogICAgICAgICAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXHI/XG5bXHQgXSsvZywgIiAiKTsKICAgICAgICAgICAgcHJlUHJvY2Vzc2VkSGVhZGVycy5zcGxpdCgvXHI/XG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHsKICAgICAgICAgICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCI6Iik7CiAgICAgICAgICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpOwogICAgICAgICAgICAgIGlmIChrZXkpIHsKICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oIjoiKS50cmltKCk7CiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICByZXR1cm4gaGVhZGVyczsKICAgICAgICAgIH0KICAgICAgICAgIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSk7CiAgICAgICAgICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykgewogICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHsKICAgICAgICAgICAgICBvcHRpb25zID0ge307CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy50eXBlID0gImRlZmF1bHQiOwogICAgICAgICAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB2b2lkIDAgPyAyMDAgOiBvcHRpb25zLnN0YXR1czsKICAgICAgICAgICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDsKICAgICAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gInN0YXR1c1RleHQiIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAiT0siOwogICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpOwogICAgICAgICAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICIiOwogICAgICAgICAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7CiAgICAgICAgICB9CiAgICAgICAgICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTsKICAgICAgICAgIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7CiAgICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cywKICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsCiAgICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSwKICAgICAgICAgICAgICB1cmw6IHRoaXMudXJsCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfTsKICAgICAgICAgIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogMCwgc3RhdHVzVGV4dDogIiIgfSk7CiAgICAgICAgICAgIHJlc3BvbnNlLnR5cGUgPSAiZXJyb3IiOwogICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7CiAgICAgICAgICB9OwogICAgICAgICAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdOwogICAgICAgICAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykgewogICAgICAgICAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkludmFsaWQgc3RhdHVzIGNvZGUiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzLCBoZWFkZXJzOiB7IGxvY2F0aW9uOiB1cmwgfSB9KTsKICAgICAgICAgIH07CiAgICAgICAgICBleHBvcnRzMi5ET01FeGNlcHRpb24gPSBzZWxmMi5ET01FeGNlcHRpb247CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBuZXcgZXhwb3J0czIuRE9NRXhjZXB0aW9uKCk7CiAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgZXhwb3J0czIuRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSwgbmFtZSkgewogICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7CiAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTsKICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKTsKICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGV4cG9ydHMyLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7CiAgICAgICAgICAgIGV4cG9ydHMyLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBleHBvcnRzMi5ET01FeGNlcHRpb247CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBmZXRjaDIoaW5wdXQsIGluaXQyKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0Mik7CiAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IGV4cG9ydHMyLkRPTUV4Y2VwdGlvbigiQWJvcnRlZCIsICJBYm9ydEVycm9yIikpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7CiAgICAgICAgICAgICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7CiAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7CiAgICAgICAgICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cywKICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsCiAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgIiIpCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSAicmVzcG9uc2VVUkwiIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoIlgtUmVxdWVzdC1VUkwiKTsKICAgICAgICAgICAgICAgIHZhciBib2R5ID0gInJlc3BvbnNlIiBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0OwogICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkIikpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWQiKSk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBleHBvcnRzMi5ET01FeGNlcHRpb24oIkFib3J0ZWQiLCAiQWJvcnRFcnJvciIpKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7CiAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICJpbmNsdWRlIikgewogICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAib21pdCIpIHsKICAgICAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKCJyZXNwb25zZVR5cGUiIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHsKICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAiYmxvYiI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7CiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsKSB7CiAgICAgICAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsIGFib3J0WGhyKTsKICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7CiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigiYWJvcnQiLCBhYm9ydFhocik7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gInVuZGVmaW5lZCIgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICAgIGZldGNoMi5wb2x5ZmlsbCA9IHRydWU7CiAgICAgICAgICBpZiAoIXNlbGYyLmZldGNoKSB7CiAgICAgICAgICAgIHNlbGYyLmZldGNoID0gZmV0Y2gyOwogICAgICAgICAgICBzZWxmMi5IZWFkZXJzID0gSGVhZGVyczsKICAgICAgICAgICAgc2VsZjIuUmVxdWVzdCA9IFJlcXVlc3Q7CiAgICAgICAgICAgIHNlbGYyLlJlc3BvbnNlID0gUmVzcG9uc2U7CiAgICAgICAgICB9CiAgICAgICAgICBleHBvcnRzMi5IZWFkZXJzID0gSGVhZGVyczsKICAgICAgICAgIGV4cG9ydHMyLlJlcXVlc3QgPSBSZXF1ZXN0OwogICAgICAgICAgZXhwb3J0czIuUmVzcG9uc2UgPSBSZXNwb25zZTsKICAgICAgICAgIGV4cG9ydHMyLmZldGNoID0gZmV0Y2gyOwogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgICAgICByZXR1cm4gZXhwb3J0czI7CiAgICAgICAgfSh7fSk7CiAgICAgIH0pKHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiBleHBvcnRzKTsKICAgIH0KICB9KTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvYmFtL2JhbS13b3JrZXIudHM/d29ya2VyJmlubGluZT93b3JrZXJfZmlsZQogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvd29ya2VyLm1qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X3dvcmtlciA9IF9fdG9Nb2R1bGUocmVxdWlyZV93b3JrZXIoKSk7CiAgdmFyIGV4cG9zZSA9IGltcG9ydF93b3JrZXIuZGVmYXVsdC5leHBvc2U7CiAgdmFyIHJlZ2lzdGVyU2VyaWFsaXplciA9IGltcG9ydF93b3JrZXIuZGVmYXVsdC5yZWdpc3RlclNlcmlhbGl6ZXI7CiAgdmFyIFRyYW5zZmVyID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LlRyYW5zZmVyOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmFtQDEuMS4xOC9ub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JhbUAxLjEuMTgvbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9lc20vYmFpLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfbG9uZyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb25nKCkpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmFtQDEuMS4xOC9ub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS92aXJ0dWFsT2Zmc2V0LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBWaXJ0dWFsT2Zmc2V0ID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoYmxvY2tQb3NpdGlvbiwgZGF0YVBvc2l0aW9uKSB7CiAgICAgIHRoaXMuYmxvY2tQb3NpdGlvbiA9IGJsb2NrUG9zaXRpb247CiAgICAgIHRoaXMuZGF0YVBvc2l0aW9uID0gZGF0YVBvc2l0aW9uOwogICAgfQogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLmJsb2NrUG9zaXRpb259OiR7dGhpcy5kYXRhUG9zaXRpb259YDsKICAgIH0KICAgIGNvbXBhcmVUbyhiKSB7CiAgICAgIHJldHVybiB0aGlzLmJsb2NrUG9zaXRpb24gLSBiLmJsb2NrUG9zaXRpb24gfHwgdGhpcy5kYXRhUG9zaXRpb24gLSBiLmRhdGFQb3NpdGlvbjsKICAgIH0KICAgIHN0YXRpYyBtaW4oLi4uYXJncykgewogICAgICBsZXQgbWluOwogICAgICBsZXQgaSA9IDA7CiAgICAgIGZvciAoOyAhbWluOyBpICs9IDEpIHsKICAgICAgICBtaW4gPSBhcmdzW2ldOwogICAgICB9CiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgIGlmIChtaW4uY29tcGFyZVRvKGFyZ3NbaV0pID4gMCkgewogICAgICAgICAgbWluID0gYXJnc1tpXTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG1pbjsKICAgIH0KICB9OwogIGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgb2Zmc2V0ID0gMCwgYmlnZW5kaWFuID0gZmFsc2UpIHsKICAgIGlmIChiaWdlbmRpYW4pIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJiaWctZW5kaWFuIHZpcnR1YWwgZmlsZSBvZmZzZXRzIG5vdCBpbXBsZW1lbnRlZCIpOwogICAgfQogICAgcmV0dXJuIG5ldyBWaXJ0dWFsT2Zmc2V0KGJ5dGVzW29mZnNldCArIDddICogMTA5OTUxMTYyNzc3NiArIGJ5dGVzW29mZnNldCArIDZdICogNDI5NDk2NzI5NiArIGJ5dGVzW29mZnNldCArIDVdICogMTY3NzcyMTYgKyBieXRlc1tvZmZzZXQgKyA0XSAqIDY1NTM2ICsgYnl0ZXNbb2Zmc2V0ICsgM10gKiAyNTYgKyBieXRlc1tvZmZzZXQgKyAyXSwgYnl0ZXNbb2Zmc2V0ICsgMV0gPDwgOCB8IGJ5dGVzW29mZnNldF0pOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JhbUAxLjEuMTgvbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9lc20vY2h1bmsuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIENodW5rID0gY2xhc3MgewogICAgY29uc3RydWN0b3IobWludiwgbWF4diwgYmluLCBmZXRjaGVkU2l6ZSA9IHZvaWQgMCkgewogICAgICB0aGlzLm1pbnYgPSBtaW52OwogICAgICB0aGlzLm1heHYgPSBtYXh2OwogICAgICB0aGlzLmJpbiA9IGJpbjsKICAgICAgdGhpcy5fZmV0Y2hlZFNpemUgPSBmZXRjaGVkU2l6ZTsKICAgIH0KICAgIHRvVW5pcXVlU3RyaW5nKCkgewogICAgICByZXR1cm4gYCR7dGhpcy5taW52fS4uJHt0aGlzLm1heHZ9IChiaW4gJHt0aGlzLmJpbn0sIGZldGNoZWRTaXplICR7dGhpcy5mZXRjaGVkU2l6ZSgpfSlgOwogICAgfQogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiB0aGlzLnRvVW5pcXVlU3RyaW5nKCk7CiAgICB9CiAgICBjb21wYXJlVG8oYikgewogICAgICByZXR1cm4gdGhpcy5taW52LmNvbXBhcmVUbyhiLm1pbnYpIHx8IHRoaXMubWF4di5jb21wYXJlVG8oYi5tYXh2KSB8fCB0aGlzLmJpbiAtIGIuYmluOwogICAgfQogICAgZmV0Y2hlZFNpemUoKSB7CiAgICAgIGlmICh0aGlzLl9mZXRjaGVkU2l6ZSAhPT0gdm9pZCAwKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoZWRTaXplOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLm1heHYuYmxvY2tQb3NpdGlvbiArICgxIDw8IDE2KSAtIHRoaXMubWludi5ibG9ja1Bvc2l0aW9uOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCtiYW1AMS4xLjE4L25vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZXNtL2luZGV4RmlsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgSW5kZXhGaWxlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoeyBmaWxlaGFuZGxlLCByZW5hbWVSZWZTZXEgPSAobikgPT4gbiB9KSB7CiAgICAgIHRoaXMuZmlsZWhhbmRsZSA9IGZpbGVoYW5kbGU7CiAgICAgIHRoaXMucmVuYW1lUmVmU2VxID0gcmVuYW1lUmVmU2VxOwogICAgfQogICAgX2ZpbmRGaXJzdERhdGEoZGF0YSwgdmlydHVhbE9mZnNldCkgewogICAgICBjb25zdCBjdXJyZW50RmRsID0gZGF0YS5maXJzdERhdGFMaW5lOwogICAgICBpZiAoY3VycmVudEZkbCkgewogICAgICAgIGRhdGEuZmlyc3REYXRhTGluZSA9IGN1cnJlbnRGZGwuY29tcGFyZVRvKHZpcnR1YWxPZmZzZXQpID4gMCA/IHZpcnR1YWxPZmZzZXQgOiBjdXJyZW50RmRsOwogICAgICB9IGVsc2UgewogICAgICAgIGRhdGEuZmlyc3REYXRhTGluZSA9IHZpcnR1YWxPZmZzZXQ7CiAgICAgIH0KICAgIH0KICAgIGFzeW5jIHBhcnNlKG9wdHMgPSB7fSkgewogICAgICBpZiAoIXRoaXMuc2V0dXBQKSB7CiAgICAgICAgdGhpcy5zZXR1cFAgPSB0aGlzLl9wYXJzZShvcHRzKS5jYXRjaCgoZSkgPT4gewogICAgICAgICAgdGhpcy5zZXR1cFAgPSB2b2lkIDA7CiAgICAgICAgICB0aHJvdyBlOwogICAgICAgIH0pOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLnNldHVwUDsKICAgIH0KICAgIGFzeW5jIGhhc1JlZlNlcShzZXFJZCwgb3B0cyA9IHt9KSB7CiAgICAgIHJldHVybiAhISgoYXdhaXQgdGhpcy5wYXJzZShvcHRzKSkuaW5kaWNlc1tzZXFJZF0gfHwge30pLmJpbkluZGV4OwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCtiYW1AMS4xLjE4L25vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZXNtL3V0aWwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gdGltZW91dChtcykgewogICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7CiAgfQogIGZ1bmN0aW9uIGxvbmdUb051bWJlcihsb25nKSB7CiAgICBpZiAobG9uZy5ncmVhdGVyVGhhbihOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgfHwgbG9uZy5sZXNzVGhhbihOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbnRlZ2VyIG92ZXJmbG93Iik7CiAgICB9CiAgICByZXR1cm4gbG9uZy50b051bWJlcigpOwogIH0KICBmdW5jdGlvbiBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCkgewogICAgaWYgKCFzaWduYWwpIHsKICAgICAgcmV0dXJuOwogICAgfQogICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7CiAgICAgIGlmICh0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSAidW5kZWZpbmVkIikgewogICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oImFib3J0ZWQiLCAiQWJvcnRFcnJvciIpOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoImFib3J0ZWQiKTsKICAgICAgICBlLmNvZGUgPSAiRVJSX0FCT1JURUQiOwogICAgICAgIHRocm93IGU7CiAgICAgIH0KICAgIH0KICB9CiAgYXN5bmMgZnVuY3Rpb24gYWJvcnRCcmVha1BvaW50KHNpZ25hbCkgewogICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7CiAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCk7CiAgfQogIGZ1bmN0aW9uIGNhbk1lcmdlQmxvY2tzKGNodW5rMSwgY2h1bmsyKSB7CiAgICByZXR1cm4gY2h1bmsyLm1pbnYuYmxvY2tQb3NpdGlvbiAtIGNodW5rMS5tYXh2LmJsb2NrUG9zaXRpb24gPCA2NWUzICYmIGNodW5rMi5tYXh2LmJsb2NrUG9zaXRpb24gLSBjaHVuazEubWludi5ibG9ja1Bvc2l0aW9uIDwgNWU2OwogIH0KICBmdW5jdGlvbiBtYWtlT3B0cyhvYmogPSB7fSkgewogICAgcmV0dXJuICJhYm9ydGVkIiBpbiBvYmogPyB7IHNpZ25hbDogb2JqIH0gOiBvYmo7CiAgfQogIGZ1bmN0aW9uIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbG93ZXN0KSB7CiAgICBjb25zdCBtZXJnZWRDaHVua3MgPSBbXTsKICAgIGxldCBsYXN0Q2h1bmsgPSBudWxsOwogICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIGNodW5rczsKICAgIH0KICAgIGNodW5rcy5zb3J0KChjMCwgYzEpID0+IHsKICAgICAgY29uc3QgZGlmID0gYzAubWludi5ibG9ja1Bvc2l0aW9uIC0gYzEubWludi5ibG9ja1Bvc2l0aW9uOwogICAgICBpZiAoZGlmICE9PSAwKSB7CiAgICAgICAgcmV0dXJuIGRpZjsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gYzAubWludi5kYXRhUG9zaXRpb24gLSBjMS5taW52LmRhdGFQb3NpdGlvbjsKICAgICAgfQogICAgfSk7CiAgICBjaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IHsKICAgICAgaWYgKCFsb3dlc3QgfHwgY2h1bmsubWF4di5jb21wYXJlVG8obG93ZXN0KSA+IDApIHsKICAgICAgICBpZiAobGFzdENodW5rID09PSBudWxsKSB7CiAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7CiAgICAgICAgICBsYXN0Q2h1bmsgPSBjaHVuazsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKGNhbk1lcmdlQmxvY2tzKGxhc3RDaHVuaywgY2h1bmspKSB7CiAgICAgICAgICAgIGlmIChjaHVuay5tYXh2LmNvbXBhcmVUbyhsYXN0Q2h1bmsubWF4dikgPiAwKSB7CiAgICAgICAgICAgICAgbGFzdENodW5rLm1heHYgPSBjaHVuay5tYXh2OwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7CiAgICAgICAgICAgIGxhc3RDaHVuayA9IGNodW5rOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSk7CiAgICByZXR1cm4gbWVyZ2VkQ2h1bmtzOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JhbUAxLjEuMTgvbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9lc20vYmFpLmpzCiAgdmFyIEJBSV9NQUdJQyA9IDIxNTc4MDUwOwogIGZ1bmN0aW9uIHJvdW5kRG93bihuLCBtdWx0aXBsZSkgewogICAgcmV0dXJuIG4gLSBuICUgbXVsdGlwbGU7CiAgfQogIGZ1bmN0aW9uIHJvdW5kVXAobiwgbXVsdGlwbGUpIHsKICAgIHJldHVybiBuIC0gbiAlIG11bHRpcGxlICsgbXVsdGlwbGU7CiAgfQogIHZhciBCQUkgPSBjbGFzcyBleHRlbmRzIEluZGV4RmlsZSB7CiAgICBwYXJzZVBzZXVkb0JpbihieXRlcywgb2Zmc2V0KSB7CiAgICAgIGNvbnN0IGxpbmVDb3VudCA9IGxvbmdUb051bWJlcihpbXBvcnRfbG9uZy5kZWZhdWx0LmZyb21CeXRlc0xFKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzLCBvZmZzZXQgKyAxNiwgb2Zmc2V0ICsgMjQpLCB0cnVlKSk7CiAgICAgIHJldHVybiB7IGxpbmVDb3VudCB9OwogICAgfQogICAgYXN5bmMgbGluZUNvdW50KHJlZklkLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgcHJvbSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGNvbnN0IGluZGV4ID0gcHJvbS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFpbmRleCkgewogICAgICAgIHJldHVybiAtMTsKICAgICAgfQogICAgICBjb25zdCByZXQgPSBpbmRleC5zdGF0cyB8fCB7fTsKICAgICAgcmV0dXJuIHJldC5saW5lQ291bnQgPT09IHZvaWQgMCA/IC0xIDogcmV0LmxpbmVDb3VudDsKICAgIH0KICAgIGZldGNoQmFpKG9wdHMgPSB7fSkgewogICAgICBpZiAoIXRoaXMuYmFpUCkgewogICAgICAgIHRoaXMuYmFpUCA9IHRoaXMuZmlsZWhhbmRsZS5yZWFkRmlsZShvcHRzKS5jYXRjaCgoZSkgPT4gewogICAgICAgICAgdGhpcy5iYWlQID0gdm9pZCAwOwogICAgICAgICAgdGhyb3cgZTsKICAgICAgICB9KTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5iYWlQOwogICAgfQogICAgYXN5bmMgX3BhcnNlKCkgewogICAgICBjb25zdCBkYXRhID0geyBiYWk6IHRydWUsIG1heEJsb2NrU2l6ZTogMSA8PCAxNiB9OwogICAgICBjb25zdCBieXRlcyA9IGF3YWl0IHRoaXMuZmV0Y2hCYWkoKTsKICAgICAgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSAhPT0gQkFJX01BR0lDKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJOb3QgYSBCQUkgZmlsZSIpOwogICAgICB9CiAgICAgIGRhdGEucmVmQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRSg0KTsKICAgICAgY29uc3QgZGVwdGggPSA1OwogICAgICBjb25zdCBiaW5MaW1pdCA9ICgoMSA8PCAoZGVwdGggKyAxKSAqIDMpIC0gMSkgLyA3OwogICAgICBkYXRhLmluZGljZXMgPSBuZXcgQXJyYXkoZGF0YS5yZWZDb3VudCk7CiAgICAgIGxldCBjdXJyT2Zmc2V0ID0gODsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLnJlZkNvdW50OyBpICs9IDEpIHsKICAgICAgICBjb25zdCBiaW5Db3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgIGxldCBzdGF0czsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgYmluSW5kZXggPSB7fTsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJpbkNvdW50OyBqICs9IDEpIHsKICAgICAgICAgIGNvbnN0IGJpbiA9IGJ5dGVzLnJlYWRVSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgIGlmIChiaW4gPT09IGJpbkxpbWl0ICsgMSkgewogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICAgIHN0YXRzID0gdGhpcy5wYXJzZVBzZXVkb0JpbihieXRlcywgY3Vyck9mZnNldCk7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMzI7CiAgICAgICAgICB9IGVsc2UgaWYgKGJpbiA+IGJpbkxpbWl0ICsgMSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImJhaSBpbmRleCBjb250YWlucyB0b28gbWFueSBiaW5zLCBwbGVhc2UgdXNlIENTSSIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IG5ldyBBcnJheShjaHVua0NvdW50KTsKICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjaHVua0NvdW50OyBrICs9IDEpIHsKICAgICAgICAgICAgICBjb25zdCB1ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICBjb25zdCB2ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgOCk7CiAgICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNjsKICAgICAgICAgICAgICB0aGlzLl9maW5kRmlyc3REYXRhKGRhdGEsIHUpOwogICAgICAgICAgICAgIGNodW5rc1trXSA9IG5ldyBDaHVuayh1LCB2LCBiaW4pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJpbkluZGV4W2Jpbl0gPSBjaHVua3M7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxpbmVhckNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgIGNvbnN0IGxpbmVhckluZGV4ID0gbmV3IEFycmF5KGxpbmVhckNvdW50KTsKICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGxpbmVhckNvdW50OyBrICs9IDEpIHsKICAgICAgICAgIGxpbmVhckluZGV4W2tdID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgIGN1cnJPZmZzZXQgKz0gODsKICAgICAgICAgIHRoaXMuX2ZpbmRGaXJzdERhdGEoZGF0YSwgbGluZWFySW5kZXhba10pOwogICAgICAgIH0KICAgICAgICBkYXRhLmluZGljZXNbaV0gPSB7IGJpbkluZGV4LCBsaW5lYXJJbmRleCwgc3RhdHMgfTsKICAgICAgfQogICAgICByZXR1cm4gZGF0YTsKICAgIH0KICAgIGFzeW5jIGluZGV4Q292KHNlcUlkLCBzdGFydCwgZW5kLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgdiA9IDE2Mzg0OwogICAgICBjb25zdCByYW5nZSA9IHN0YXJ0ICE9PSB2b2lkIDA7CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGNvbnN0IHNlcUlkeCA9IGluZGV4RGF0YS5pbmRpY2VzW3NlcUlkXTsKICAgICAgaWYgKCFzZXFJZHgpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3QgeyBsaW5lYXJJbmRleCA9IFtdLCBzdGF0cyB9ID0gc2VxSWR4OwogICAgICBpZiAoIWxpbmVhckluZGV4Lmxlbmd0aCkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCBlID0gZW5kICE9PSB2b2lkIDAgPyByb3VuZFVwKGVuZCwgdikgOiAobGluZWFySW5kZXgubGVuZ3RoIC0gMSkgKiB2OwogICAgICBjb25zdCBzID0gc3RhcnQgIT09IHZvaWQgMCA/IHJvdW5kRG93bihzdGFydCwgdikgOiAwOwogICAgICBsZXQgZGVwdGhzOwogICAgICBpZiAocmFuZ2UpIHsKICAgICAgICBkZXB0aHMgPSBuZXcgQXJyYXkoKGUgLSBzKSAvIHYpOwogICAgICB9IGVsc2UgewogICAgICAgIGRlcHRocyA9IG5ldyBBcnJheShsaW5lYXJJbmRleC5sZW5ndGggLSAxKTsKICAgICAgfQogICAgICBjb25zdCB0b3RhbFNpemUgPSBsaW5lYXJJbmRleFtsaW5lYXJJbmRleC5sZW5ndGggLSAxXS5ibG9ja1Bvc2l0aW9uOwogICAgICBpZiAoZSA+IChsaW5lYXJJbmRleC5sZW5ndGggLSAxKSAqIHYpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInF1ZXJ5IG91dHNpZGUgb2YgcmFuZ2Ugb2YgbGluZWFyIGluZGV4Iik7CiAgICAgIH0KICAgICAgbGV0IGN1cnJlbnRQb3MgPSBsaW5lYXJJbmRleFtzIC8gdl0uYmxvY2tQb3NpdGlvbjsKICAgICAgZm9yIChsZXQgaSA9IHMgLyB2LCBqID0gMDsgaSA8IGUgLyB2OyBpKyssIGorKykgewogICAgICAgIGRlcHRoc1tqXSA9IHsKICAgICAgICAgIHNjb3JlOiBsaW5lYXJJbmRleFtpICsgMV0uYmxvY2tQb3NpdGlvbiAtIGN1cnJlbnRQb3MsCiAgICAgICAgICBzdGFydDogaSAqIHYsCiAgICAgICAgICBlbmQ6IGkgKiB2ICsgdgogICAgICAgIH07CiAgICAgICAgY3VycmVudFBvcyA9IGxpbmVhckluZGV4W2kgKyAxXS5ibG9ja1Bvc2l0aW9uOwogICAgICB9CiAgICAgIHJldHVybiBkZXB0aHMubWFwKChkKSA9PiB7CiAgICAgICAgcmV0dXJuIHsgLi4uZCwgc2NvcmU6IGQuc2NvcmUgKiBzdGF0cy5saW5lQ291bnQgLyB0b3RhbFNpemUgfTsKICAgICAgfSk7CiAgICB9CiAgICByZWcyYmlucyhiZWcsIGVuZCkgewogICAgICBlbmQgLT0gMTsKICAgICAgcmV0dXJuIFsKICAgICAgICBbMCwgMF0sCiAgICAgICAgWzEgKyAoYmVnID4+IDI2KSwgMSArIChlbmQgPj4gMjYpXSwKICAgICAgICBbOSArIChiZWcgPj4gMjMpLCA5ICsgKGVuZCA+PiAyMyldLAogICAgICAgIFs3MyArIChiZWcgPj4gMjApLCA3MyArIChlbmQgPj4gMjApXSwKICAgICAgICBbNTg1ICsgKGJlZyA+PiAxNyksIDU4NSArIChlbmQgPj4gMTcpXSwKICAgICAgICBbNDY4MSArIChiZWcgPj4gMTQpLCA0NjgxICsgKGVuZCA+PiAxNCldCiAgICAgIF07CiAgICB9CiAgICBhc3luYyBibG9ja3NGb3JSYW5nZShyZWZJZCwgbWluLCBtYXgsIG9wdHMgPSB7fSkgewogICAgICBpZiAobWluIDwgMCkgewogICAgICAgIG1pbiA9IDA7CiAgICAgIH0KICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3QgYmEgPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghYmEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdCaW5zID0gdGhpcy5yZWcyYmlucyhtaW4sIG1heCk7CiAgICAgIGNvbnN0IGNodW5rcyA9IFtdOwogICAgICBmb3IgKGNvbnN0IFtzdGFydCwgZW5kXSBvZiBvdmVybGFwcGluZ0JpbnMpIHsKICAgICAgICBmb3IgKGxldCBiaW4gPSBzdGFydDsgYmluIDw9IGVuZDsgYmluKyspIHsKICAgICAgICAgIGlmIChiYS5iaW5JbmRleFtiaW5dKSB7CiAgICAgICAgICAgIGNvbnN0IGJpbkNodW5rcyA9IGJhLmJpbkluZGV4W2Jpbl07CiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgYmluQ2h1bmtzLmxlbmd0aDsgKytjKSB7CiAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IENodW5rKGJpbkNodW5rc1tjXS5taW52LCBiaW5DaHVua3NbY10ubWF4diwgYmluKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc3QgbmludHYgPSBiYS5saW5lYXJJbmRleC5sZW5ndGg7CiAgICAgIGxldCBsb3dlc3QgPSBudWxsOwogICAgICBjb25zdCBtaW5MaW4gPSBNYXRoLm1pbihtaW4gPj4gMTQsIG5pbnR2IC0gMSk7CiAgICAgIGNvbnN0IG1heExpbiA9IE1hdGgubWluKG1heCA+PiAxNCwgbmludHYgLSAxKTsKICAgICAgZm9yIChsZXQgaSA9IG1pbkxpbjsgaSA8PSBtYXhMaW47ICsraSkgewogICAgICAgIGNvbnN0IHZwID0gYmEubGluZWFySW5kZXhbaV07CiAgICAgICAgaWYgKHZwKSB7CiAgICAgICAgICBpZiAoIWxvd2VzdCB8fCB2cC5jb21wYXJlVG8obG93ZXN0KSA8IDApIHsKICAgICAgICAgICAgbG93ZXN0ID0gdnA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIGxvd2VzdCk7CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JhbUAxLjEuMTgvbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9lc20vY3NpLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfbG9uZzMgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbG9uZygpKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JnemYtZmlsZWhhbmRsZUAxLjQuNy9ub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JnemYtZmlsZWhhbmRsZUAxLjQuNy9ub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS9iZ3pGaWxlaGFuZGxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyNiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9nZW5lcmljLWZpbGVoYW5kbGVAMy4xLjEvbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vaW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb2NhbEZpbGUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbG9jYWxGaWxlKCkpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vZ2VuZXJpYy1maWxlaGFuZGxlQDMuMS4xL25vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL3JlbW90ZUZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXIyID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKICB2YXIgUmVtb3RlRmlsZSA9IGNsYXNzIHsKICAgIGFzeW5jIGdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSkgewogICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmJ1ZmZlciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIHJldHVybiByZXNwb25zZS5idWZmZXIoKTsKICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UuYXJyYXlCdWZmZXIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTsKICAgICAgICByZXR1cm4gaW1wb3J0X2J1ZmZlcjIuQnVmZmVyLmZyb20ocmVzcCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiaW52YWxpZCBIVFRQIHJlc3BvbnNlIG9iamVjdCwgaGFzIG5vIGJ1ZmZlciBtZXRob2QsIGFuZCBubyBhcnJheUJ1ZmZlciBtZXRob2QiKTsKICAgICAgfQogICAgfQogICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRzID0ge30pIHsKICAgICAgdGhpcy5iYXNlT3ZlcnJpZGVzID0ge307CiAgICAgIHRoaXMudXJsID0gc291cmNlOwogICAgICBjb25zdCBmZXRjaDIgPSBvcHRzLmZldGNoIHx8IGdsb2JhbFRoaXMuZmV0Y2guYmluZChnbG9iYWxUaGlzKTsKICAgICAgaWYgKCFmZXRjaDIpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBubyBmZXRjaCBmdW5jdGlvbiBzdXBwbGllZCwgYW5kIG5vbmUgZm91bmQgaW4gZ2xvYmFsIGVudmlyb25tZW50YCk7CiAgICAgIH0KICAgICAgaWYgKG9wdHMub3ZlcnJpZGVzKSB7CiAgICAgICAgdGhpcy5iYXNlT3ZlcnJpZGVzID0gb3B0cy5vdmVycmlkZXM7CiAgICAgIH0KICAgICAgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uID0gZmV0Y2gyOwogICAgfQogICAgYXN5bmMgZmV0Y2goaW5wdXQsIGluaXQyKSB7CiAgICAgIGxldCByZXNwb25zZTsKICAgICAgdHJ5IHsKICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbihpbnB1dCwgaW5pdDIpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKGAke2V9YC5pbmNsdWRlcygiRmFpbGVkIHRvIGZldGNoIikpIHsKICAgICAgICAgIGNvbnNvbGUud2FybihgZ2VuZXJpYy1maWxlaGFuZGxlOiByZWZldGNoaW5nICR7aW5wdXR9IHRvIGF0dGVtcHQgdG8gd29yayBhcm91bmQgY2hyb21lIENPUlMgaGVhZGVyIGNhY2hpbmcgYnVnYCk7CiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbihpbnB1dCwgewogICAgICAgICAgICAuLi5pbml0MiwKICAgICAgICAgICAgY2FjaGU6ICJyZWxvYWQiCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHJlc3BvbnNlOwogICAgfQogICAgYXN5bmMgcmVhZChidWZmZXIsIG9mZnNldCA9IDAsIGxlbmd0aCwgcG9zaXRpb24gPSAwLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgIGlmIChsZW5ndGggPCBJbmZpbml0eSkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tJHtwb3NpdGlvbiArIGxlbmd0aH1gOwogICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gSW5maW5pdHkgJiYgcG9zaXRpb24gIT09IDApIHsKICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LWA7CiAgICAgIH0KICAgICAgY29uc3QgYXJncyA9IHsKICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsCiAgICAgICAgLi4ub3ZlcnJpZGVzLAogICAgICAgIGhlYWRlcnM6IHsKICAgICAgICAgIC4uLmhlYWRlcnMsCiAgICAgICAgICAuLi5vdmVycmlkZXMuaGVhZGVycywKICAgICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcy5oZWFkZXJzCiAgICAgICAgfSwKICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgIHJlZGlyZWN0OiAiZm9sbG93IiwKICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgc2lnbmFsCiAgICAgIH07CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncyk7CiAgICAgIGlmICghcmVzcG9uc2Uub2spIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gJHt0aGlzLnVybH1gKTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgJiYgcG9zaXRpb24gPT09IDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHsKICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICAgICAgY29uc3QgYnl0ZXNDb3BpZWQgPSByZXNwb25zZURhdGEuY29weShidWZmZXIsIG9mZnNldCwgMCwgTWF0aC5taW4obGVuZ3RoLCByZXNwb25zZURhdGEubGVuZ3RoKSk7CiAgICAgICAgY29uc3QgcmVzID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoImNvbnRlbnQtcmFuZ2UiKTsKICAgICAgICBjb25zdCBzaXplTWF0Y2ggPSAvXC8oXGQrKSQvLmV4ZWMocmVzIHx8ICIiKTsKICAgICAgICBpZiAoc2l6ZU1hdGNoICYmIHNpemVNYXRjaFsxXSkgewogICAgICAgICAgdGhpcy5fc3RhdCA9IHsgc2l6ZTogcGFyc2VJbnQoc2l6ZU1hdGNoWzFdLCAxMCkgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYnl0ZXNSZWFkOiBieXRlc0NvcGllZCwgYnVmZmVyIH07CiAgICAgIH0KICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCIke3RoaXMudXJsfSBmZXRjaCByZXR1cm5lZCBzdGF0dXMgMjAwLCBleHBlY3RlZCAyMDYiKTsKICAgICAgfQogICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9IGZldGNoaW5nICR7dGhpcy51cmx9YCk7CiAgICB9CiAgICBhc3luYyByZWFkRmlsZShvcHRpb25zID0ge30pIHsKICAgICAgbGV0IGVuY29kaW5nOwogICAgICBsZXQgb3B0czsKICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAic3RyaW5nIikgewogICAgICAgIGVuY29kaW5nID0gb3B0aW9uczsKICAgICAgICBvcHRzID0ge307CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nOwogICAgICAgIG9wdHMgPSBvcHRpb25zOwogICAgICAgIGRlbGV0ZSBvcHRzLmVuY29kaW5nOwogICAgICB9CiAgICAgIGNvbnN0IHsgaGVhZGVycyA9IHt9LCBzaWduYWwsIG92ZXJyaWRlcyA9IHt9IH0gPSBvcHRzOwogICAgICBjb25zdCBhcmdzID0gewogICAgICAgIGhlYWRlcnMsCiAgICAgICAgbWV0aG9kOiAiR0VUIiwKICAgICAgICByZWRpcmVjdDogImZvbGxvdyIsCiAgICAgICAgbW9kZTogImNvcnMiLAogICAgICAgIHNpZ25hbCwKICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsCiAgICAgICAgLi4ub3ZlcnJpZGVzCiAgICAgIH07CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncyk7CiAgICAgIGlmICghcmVzcG9uc2UpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImdlbmVyaWMtZmlsZWhhbmRsZSBmYWlsZWQgdG8gZmV0Y2giKTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHsKICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKSwgewogICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMKICAgICAgICB9KTsKICAgICAgfQogICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1dGY4IikgewogICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7CiAgICAgIH0KICAgICAgaWYgKGVuY29kaW5nKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJGcm9tUmVzcG9uc2UocmVzcG9uc2UpOwogICAgfQogICAgYXN5bmMgc3RhdCgpIHsKICAgICAgaWYgKCF0aGlzLl9zdGF0KSB7CiAgICAgICAgY29uc3QgYnVmID0gaW1wb3J0X2J1ZmZlcjIuQnVmZmVyLmFsbG9jVW5zYWZlKDEwKTsKICAgICAgICBhd2FpdCB0aGlzLnJlYWQoYnVmLCAwLCAxMCwgMCk7CiAgICAgICAgaWYgKCF0aGlzLl9zdGF0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBkZXRlcm1pbmUgc2l6ZSBvZiBmaWxlIGF0ICR7dGhpcy51cmx9YCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB0aGlzLl9zdGF0OwogICAgfQogICAgYXN5bmMgY2xvc2UoKSB7CiAgICAgIHJldHVybjsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vZ2VuZXJpYy1maWxlaGFuZGxlQDMuMS4xL25vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2Jsb2JGaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyMyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9nZW5lcmljLWZpbGVoYW5kbGVAMy4xLjEvbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vZmlsZWhhbmRsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JnemYtZmlsZWhhbmRsZUAxLjQuNy9ub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS91bnppcC1wYWtvLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyNCA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CiAgdmFyIGltcG9ydF9wYWtvID0gX190b01vZHVsZShyZXF1aXJlX3Bha28oKSk7CiAgYXN5bmMgZnVuY3Rpb24gdW56aXAoaW5wdXREYXRhKSB7CiAgICB0cnkgewogICAgICBsZXQgc3RybTsKICAgICAgbGV0IHBvcyA9IDA7CiAgICAgIGxldCBpID0gMDsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGxldCB0b3RhbFNpemUgPSAwOwogICAgICBsZXQgaW5mbGF0b3I7CiAgICAgIGRvIHsKICAgICAgICBjb25zdCByZW1haW5pbmdJbnB1dCA9IGlucHV0RGF0YS5zdWJhcnJheShwb3MpOwogICAgICAgIGluZmxhdG9yID0gbmV3IGltcG9ydF9wYWtvLkluZmxhdGUoKTsKICAgICAgICAoeyBzdHJtIH0gPSBpbmZsYXRvcik7CiAgICAgICAgaW5mbGF0b3IucHVzaChyZW1haW5pbmdJbnB1dCwgaW1wb3J0X3Bha28uWl9TWU5DX0ZMVVNIKTsKICAgICAgICBpZiAoaW5mbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0b3IubXNnKTsKICAgICAgICB9CiAgICAgICAgcG9zICs9IHN0cm0ubmV4dF9pbjsKICAgICAgICBjaHVua3NbaV0gPSBpbmZsYXRvci5yZXN1bHQ7CiAgICAgICAgdG90YWxTaXplICs9IGNodW5rc1tpXS5sZW5ndGg7CiAgICAgICAgaSArPSAxOwogICAgICB9IHdoaWxlIChzdHJtLmF2YWlsX2luKTsKICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxTaXplKTsKICAgICAgZm9yIChsZXQgaTIgPSAwLCBvZmZzZXQgPSAwOyBpMiA8IGNodW5rcy5sZW5ndGg7IGkyKyspIHsKICAgICAgICByZXN1bHQuc2V0KGNodW5rc1tpMl0sIG9mZnNldCk7CiAgICAgICAgb2Zmc2V0ICs9IGNodW5rc1tpMl0ubGVuZ3RoOwogICAgICB9CiAgICAgIHJldHVybiBpbXBvcnRfYnVmZmVyNC5CdWZmZXIuZnJvbShyZXN1bHQpOwogICAgfSBjYXRjaCAoZSkgewogICAgICBpZiAoYCR7ZX1gLm1hdGNoKC9pbmNvcnJlY3QgaGVhZGVyIGNoZWNrLykpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInByb2JsZW0gZGVjb21wcmVzc2luZyBibG9jazogaW5jb3JyZWN0IGd6aXAgaGVhZGVyIGNoZWNrIik7CiAgICAgIH0KICAgICAgdGhyb3cgZTsKICAgIH0KICB9CiAgYXN5bmMgZnVuY3Rpb24gdW56aXBDaHVua1NsaWNlKGlucHV0RGF0YSwgY2h1bmspIHsKICAgIHRyeSB7CiAgICAgIGxldCBzdHJtOwogICAgICBjb25zdCB7IG1pbnYsIG1heHYgfSA9IGNodW5rOwogICAgICBsZXQgY3BvcyA9IG1pbnYuYmxvY2tQb3NpdGlvbjsKICAgICAgbGV0IGRwb3MgPSBtaW52LmRhdGFQb3NpdGlvbjsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGNvbnN0IGNwb3NpdGlvbnMgPSBbXTsKICAgICAgY29uc3QgZHBvc2l0aW9ucyA9IFtdOwogICAgICBsZXQgdG90YWxTaXplID0gMDsKICAgICAgbGV0IGkgPSAwOwogICAgICBkbyB7CiAgICAgICAgY29uc3QgcmVtYWluaW5nSW5wdXQgPSBpbnB1dERhdGEuc3ViYXJyYXkoY3BvcyAtIG1pbnYuYmxvY2tQb3NpdGlvbik7CiAgICAgICAgY29uc3QgaW5mbGF0b3IgPSBuZXcgaW1wb3J0X3Bha28uSW5mbGF0ZSgpOwogICAgICAgICh7IHN0cm0gfSA9IGluZmxhdG9yKTsKICAgICAgICBpbmZsYXRvci5wdXNoKHJlbWFpbmluZ0lucHV0LCBpbXBvcnRfcGFrby5aX1NZTkNfRkxVU0gpOwogICAgICAgIGlmIChpbmZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmZsYXRvci5tc2cpOwogICAgICAgIH0KICAgICAgICBjb25zdCBidWZmZXIyID0gaW5mbGF0b3IucmVzdWx0OwogICAgICAgIGNodW5rcy5wdXNoKGJ1ZmZlcjIpOwogICAgICAgIGxldCBsZW4gPSBidWZmZXIyLmxlbmd0aDsKICAgICAgICBjcG9zaXRpb25zLnB1c2goY3Bvcyk7CiAgICAgICAgZHBvc2l0aW9ucy5wdXNoKGRwb3MpOwogICAgICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAxICYmIG1pbnYuZGF0YVBvc2l0aW9uKSB7CiAgICAgICAgICBjaHVua3NbMF0gPSBjaHVua3NbMF0uc3ViYXJyYXkobWludi5kYXRhUG9zaXRpb24pOwogICAgICAgICAgbGVuID0gY2h1bmtzWzBdLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgY29uc3Qgb3JpZ0Nwb3MgPSBjcG9zOwogICAgICAgIGNwb3MgKz0gc3RybS5uZXh0X2luOwogICAgICAgIGRwb3MgKz0gbGVuOwogICAgICAgIGlmIChvcmlnQ3BvcyA+PSBtYXh2LmJsb2NrUG9zaXRpb24pIHsKICAgICAgICAgIGNodW5rc1tpXSA9IGNodW5rc1tpXS5zdWJhcnJheSgwLCBtYXh2LmJsb2NrUG9zaXRpb24gPT09IG1pbnYuYmxvY2tQb3NpdGlvbiA/IG1heHYuZGF0YVBvc2l0aW9uIC0gbWludi5kYXRhUG9zaXRpb24gKyAxIDogbWF4di5kYXRhUG9zaXRpb24gKyAxKTsKICAgICAgICAgIGNwb3NpdGlvbnMucHVzaChjcG9zKTsKICAgICAgICAgIGRwb3NpdGlvbnMucHVzaChkcG9zKTsKICAgICAgICAgIHRvdGFsU2l6ZSArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIHRvdGFsU2l6ZSArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgIGkrKzsKICAgICAgfSB3aGlsZSAoc3RybS5hdmFpbF9pbik7CiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsU2l6ZSk7CiAgICAgIGZvciAobGV0IGkyID0gMCwgb2Zmc2V0ID0gMDsgaTIgPCBjaHVua3MubGVuZ3RoOyBpMisrKSB7CiAgICAgICAgcmVzdWx0LnNldChjaHVua3NbaTJdLCBvZmZzZXQpOwogICAgICAgIG9mZnNldCArPSBjaHVua3NbaTJdLmxlbmd0aDsKICAgICAgfQogICAgICBjb25zdCBidWZmZXIgPSBpbXBvcnRfYnVmZmVyNC5CdWZmZXIuZnJvbShyZXN1bHQpOwogICAgICByZXR1cm4geyBidWZmZXIsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgaWYgKGAke2V9YC5tYXRjaCgvaW5jb3JyZWN0IGhlYWRlciBjaGVjay8pKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJwcm9ibGVtIGRlY29tcHJlc3NpbmcgYmxvY2s6IGluY29ycmVjdCBnemlwIGhlYWRlciBjaGVjayIpOwogICAgICB9CiAgICAgIHRocm93IGU7CiAgICB9CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmd6Zi1maWxlaGFuZGxlQDEuNC43L25vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2d6aUluZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfbG9uZzIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbG9uZygpKTsKICB2YXIgaW1wb3J0X2J1ZmZlcjUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmFtQDEuMS4xOC9ub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9jc2kuanMKICB2YXIgQ1NJMV9NQUdJQyA9IDIxNTgyNjU5OwogIHZhciBDU0kyX01BR0lDID0gMzgzNTk4NzU7CiAgZnVuY3Rpb24gbHNoaWZ0KG51bSwgYml0cykgewogICAgcmV0dXJuIG51bSAqIDIgKiogYml0czsKICB9CiAgZnVuY3Rpb24gcnNoaWZ0KG51bSwgYml0cykgewogICAgcmV0dXJuIE1hdGguZmxvb3IobnVtIC8gMiAqKiBiaXRzKTsKICB9CiAgdmFyIENTSSA9IGNsYXNzIGV4dGVuZHMgSW5kZXhGaWxlIHsKICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHsKICAgICAgc3VwZXIoYXJncyk7CiAgICAgIHRoaXMubWF4QmluTnVtYmVyID0gMDsKICAgICAgdGhpcy5kZXB0aCA9IDA7CiAgICAgIHRoaXMubWluU2hpZnQgPSAwOwogICAgfQogICAgYXN5bmMgbGluZUNvdW50KHJlZklkKSB7CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2UoKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgY29uc3QgaWR4ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoIWlkeCkgewogICAgICAgIHJldHVybiAtMTsKICAgICAgfQogICAgICBjb25zdCB7IHN0YXRzIH0gPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmIChzdGF0cykgewogICAgICAgIHJldHVybiBzdGF0cy5saW5lQ291bnQ7CiAgICAgIH0KICAgICAgcmV0dXJuIC0xOwogICAgfQogICAgYXN5bmMgaW5kZXhDb3YoKSB7CiAgICAgIHJldHVybiBbXTsKICAgIH0KICAgIHBhcnNlQXV4RGF0YShieXRlcywgb2Zmc2V0LCBhdXhMZW5ndGgpIHsKICAgICAgaWYgKGF1eExlbmd0aCA8IDMwKSB7CiAgICAgICAgcmV0dXJuIHt9OwogICAgICB9CiAgICAgIGNvbnN0IGRhdGEgPSB7fTsKICAgICAgZGF0YS5mb3JtYXRGbGFncyA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCk7CiAgICAgIGRhdGEuY29vcmRpbmF0ZVR5cGUgPSBkYXRhLmZvcm1hdEZsYWdzICYgNjU1MzYgPyAiemVyby1iYXNlZC1oYWxmLW9wZW4iIDogIjEtYmFzZWQtY2xvc2VkIjsKICAgICAgZGF0YS5mb3JtYXQgPSB7IDA6ICJnZW5lcmljIiwgMTogIlNBTSIsIDI6ICJWQ0YiIH1bZGF0YS5mb3JtYXRGbGFncyAmIDE1XTsKICAgICAgaWYgKCFkYXRhLmZvcm1hdCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBUYWJpeCBwcmVzZXQgZm9ybWF0IGZsYWdzICR7ZGF0YS5mb3JtYXRGbGFnc31gKTsKICAgICAgfQogICAgICBkYXRhLmNvbHVtbk51bWJlcnMgPSB7CiAgICAgICAgcmVmOiBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyA0KSwKICAgICAgICBzdGFydDogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgOCksCiAgICAgICAgZW5kOiBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAxMikKICAgICAgfTsKICAgICAgZGF0YS5tZXRhVmFsdWUgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAxNik7CiAgICAgIGRhdGEubWV0YUNoYXIgPSBkYXRhLm1ldGFWYWx1ZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YS5tZXRhVmFsdWUpIDogIiI7CiAgICAgIGRhdGEuc2tpcExpbmVzID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMjApOwogICAgICBjb25zdCBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDI0KTsKICAgICAgT2JqZWN0LmFzc2lnbihkYXRhLCB0aGlzLl9wYXJzZU5hbWVCeXRlcyhieXRlcy5zdWJhcnJheShvZmZzZXQgKyAyOCwgb2Zmc2V0ICsgMjggKyBuYW1lU2VjdGlvbkxlbmd0aCkpKTsKICAgICAgcmV0dXJuIGRhdGE7CiAgICB9CiAgICBfcGFyc2VOYW1lQnl0ZXMobmFtZXNCeXRlcykgewogICAgICBsZXQgY3VyclJlZklkID0gMDsKICAgICAgbGV0IGN1cnJOYW1lU3RhcnQgPSAwOwogICAgICBjb25zdCByZWZJZFRvTmFtZSA9IFtdOwogICAgICBjb25zdCByZWZOYW1lVG9JZCA9IHt9OwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzQnl0ZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBpZiAoIW5hbWVzQnl0ZXNbaV0pIHsKICAgICAgICAgIGlmIChjdXJyTmFtZVN0YXJ0IDwgaSkgewogICAgICAgICAgICBsZXQgcmVmTmFtZSA9IG5hbWVzQnl0ZXMudG9TdHJpbmcoInV0ZjgiLCBjdXJyTmFtZVN0YXJ0LCBpKTsKICAgICAgICAgICAgcmVmTmFtZSA9IHRoaXMucmVuYW1lUmVmU2VxKHJlZk5hbWUpOwogICAgICAgICAgICByZWZJZFRvTmFtZVtjdXJyUmVmSWRdID0gcmVmTmFtZTsKICAgICAgICAgICAgcmVmTmFtZVRvSWRbcmVmTmFtZV0gPSBjdXJyUmVmSWQ7CiAgICAgICAgICB9CiAgICAgICAgICBjdXJyTmFtZVN0YXJ0ID0gaSArIDE7CiAgICAgICAgICBjdXJyUmVmSWQgKz0gMTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH07CiAgICB9CiAgICBhc3luYyBfcGFyc2Uob3B0cykgewogICAgICBjb25zdCBkYXRhID0geyBjc2k6IHRydWUsIG1heEJsb2NrU2l6ZTogMSA8PCAxNiB9OwogICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZEZpbGUob3B0cyk7CiAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdW56aXAoYnVmZmVyKTsKICAgICAgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSA9PT0gQ1NJMV9NQUdJQykgewogICAgICAgIGRhdGEuY3NpVmVyc2lvbiA9IDE7CiAgICAgIH0gZWxzZSBpZiAoYnl0ZXMucmVhZFVJbnQzMkxFKDApID09PSBDU0kyX01BR0lDKSB7CiAgICAgICAgZGF0YS5jc2lWZXJzaW9uID0gMjsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIENTSSBmaWxlIik7CiAgICAgIH0KICAgICAgdGhpcy5taW5TaGlmdCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDQpOwogICAgICB0aGlzLmRlcHRoID0gYnl0ZXMucmVhZEludDMyTEUoOCk7CiAgICAgIHRoaXMubWF4QmluTnVtYmVyID0gKCgxIDw8ICh0aGlzLmRlcHRoICsgMSkgKiAzKSAtIDEpIC8gNzsKICAgICAgY29uc3QgYXV4TGVuZ3RoID0gYnl0ZXMucmVhZEludDMyTEUoMTIpOwogICAgICBpZiAoYXV4TGVuZ3RoKSB7CiAgICAgICAgT2JqZWN0LmFzc2lnbihkYXRhLCB0aGlzLnBhcnNlQXV4RGF0YShieXRlcywgMTYsIGF1eExlbmd0aCkpOwogICAgICB9CiAgICAgIGRhdGEucmVmQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRSgxNiArIGF1eExlbmd0aCk7CiAgICAgIGRhdGEuaW5kaWNlcyA9IG5ldyBBcnJheShkYXRhLnJlZkNvdW50KTsKICAgICAgbGV0IGN1cnJPZmZzZXQgPSAxNiArIGF1eExlbmd0aCArIDQ7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5yZWZDb3VudDsgaSArPSAxKSB7CiAgICAgICAgYXdhaXQgYWJvcnRCcmVha1BvaW50KG9wdHMuc2lnbmFsKTsKICAgICAgICBjb25zdCBiaW5Db3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICBjb25zdCBiaW5JbmRleCA9IHt9OwogICAgICAgIGxldCBzdGF0czsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJpbkNvdW50OyBqICs9IDEpIHsKICAgICAgICAgIGNvbnN0IGJpbiA9IGJ5dGVzLnJlYWRVSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgIGlmIChiaW4gPiB0aGlzLm1heEJpbk51bWJlcikgewogICAgICAgICAgICBzdGF0cyA9IHRoaXMucGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIGN1cnJPZmZzZXQgKyA0KTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSA0ICsgOCArIDQgKyAxNiArIDE2OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29uc3QgbG9mZnNldCA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldCArIDQpOwogICAgICAgICAgICB0aGlzLl9maW5kRmlyc3REYXRhKGRhdGEsIGxvZmZzZXQpOwogICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCArIDEyKTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNjsKICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ291bnQpOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNodW5rQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgICAgIGNvbnN0IHUgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgICAgIGNvbnN0IHYgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQgKyA4KTsKICAgICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDE2OwogICAgICAgICAgICAgIGNodW5rc1trXSA9IG5ldyBDaHVuayh1LCB2LCBiaW4pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJpbkluZGV4W2Jpbl0gPSBjaHVua3M7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGRhdGEuaW5kaWNlc1tpXSA9IHsgYmluSW5kZXgsIHN0YXRzIH07CiAgICAgIH0KICAgICAgcmV0dXJuIGRhdGE7CiAgICB9CiAgICBwYXJzZVBzZXVkb0JpbihieXRlcywgb2Zmc2V0KSB7CiAgICAgIGNvbnN0IGxpbmVDb3VudCA9IGxvbmdUb051bWJlcihpbXBvcnRfbG9uZzMuZGVmYXVsdC5mcm9tQnl0ZXNMRShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcywgb2Zmc2V0ICsgMjgsIG9mZnNldCArIDM2KSwgdHJ1ZSkpOwogICAgICByZXR1cm4geyBsaW5lQ291bnQgfTsKICAgIH0KICAgIGFzeW5jIGJsb2Nrc0ZvclJhbmdlKHJlZklkLCBtaW4sIG1heCwgb3B0cyA9IHt9KSB7CiAgICAgIGlmIChtaW4gPCAwKSB7CiAgICAgICAgbWluID0gMDsKICAgICAgfQogICAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpOwogICAgICBjb25zdCBiYSA9IGluZGV4RGF0YSA9PT0gbnVsbCB8fCBpbmRleERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFiYSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCBvdmVybGFwcGluZ0JpbnMgPSB0aGlzLnJlZzJiaW5zKG1pbiwgbWF4KTsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIG92ZXJsYXBwaW5nQmlucykgewogICAgICAgIGZvciAobGV0IGJpbiA9IHN0YXJ0OyBiaW4gPD0gZW5kOyBiaW4rKykgewogICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHsKICAgICAgICAgICAgY29uc3QgYmluQ2h1bmtzID0gYmEuYmluSW5kZXhbYmluXTsKICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBiaW5DaHVua3MubGVuZ3RoOyArK2MpIHsKICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQ2h1bmsoYmluQ2h1bmtzW2NdLm1pbnYsIGJpbkNodW5rc1tjXS5tYXh2LCBiaW4pKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gb3B0aW1pemVDaHVua3MoY2h1bmtzLCBuZXcgVmlydHVhbE9mZnNldCgwLCAwKSk7CiAgICB9CiAgICByZWcyYmlucyhiZWcsIGVuZCkgewogICAgICBiZWcgLT0gMTsKICAgICAgaWYgKGJlZyA8IDEpIHsKICAgICAgICBiZWcgPSAxOwogICAgICB9CiAgICAgIGlmIChlbmQgPiAyICoqIDUwKSB7CiAgICAgICAgZW5kID0gMiAqKiAzNDsKICAgICAgfQogICAgICBlbmQgLT0gMTsKICAgICAgbGV0IGwgPSAwOwogICAgICBsZXQgdCA9IDA7CiAgICAgIGxldCBzID0gdGhpcy5taW5TaGlmdCArIHRoaXMuZGVwdGggKiAzOwogICAgICBjb25zdCBiaW5zID0gW107CiAgICAgIGZvciAoOyBsIDw9IHRoaXMuZGVwdGg7IHMgLT0gMywgdCArPSBsc2hpZnQoMSwgbCAqIDMpLCBsICs9IDEpIHsKICAgICAgICBjb25zdCBiID0gdCArIHJzaGlmdChiZWcsIHMpOwogICAgICAgIGNvbnN0IGUgPSB0ICsgcnNoaWZ0KGVuZCwgcyk7CiAgICAgICAgaWYgKGUgLSBiICsgYmlucy5sZW5ndGggPiB0aGlzLm1heEJpbk51bWJlcikgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBxdWVyeSAke2JlZ30tJHtlbmR9IGlzIHRvbyBsYXJnZSBmb3IgY3VycmVudCBiaW5uaW5nIHNjaGVtZSAoc2hpZnQgJHt0aGlzLm1pblNoaWZ0fSwgZGVwdGggJHt0aGlzLmRlcHRofSksIHRyeSBhIHNtYWxsZXIgcXVlcnkgb3IgYSBjb2Fyc2VyIGluZGV4IGJpbm5pbmcgc2NoZW1lYCk7CiAgICAgICAgfQogICAgICAgIGJpbnMucHVzaChbYiwgZV0pOwogICAgICB9CiAgICAgIHJldHVybiBiaW5zOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCtiYW1AMS4xLjE4L25vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZXNtL2JhbUZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXJfY3JjMzIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyX2NyYzMyKCkpOwogIHZhciBpbXBvcnRfb2JqZWN0ID0gX190b01vZHVsZShyZXF1aXJlX29iamVjdCgpKTsKICB2YXIgaW1wb3J0X2Fib3J0YWJsZV9wcm9taXNlX2NhY2hlID0gX190b01vZHVsZShyZXF1aXJlX2VzbSgpKTsKICB2YXIgaW1wb3J0X3F1aWNrX2xydSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9xdWlja19scnUoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCtiYW1AMS4xLjE4L25vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZXNtL3JlY29yZC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JhbUAxLjEuMTgvbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9lc20vY29uc3RhbnRzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBjb25zdGFudHNfZGVmYXVsdCA9IHsKICAgIEJBTV9GUEFJUkVEOiAxLAogICAgQkFNX0ZQUk9QRVJfUEFJUjogMiwKICAgIEJBTV9GVU5NQVA6IDQsCiAgICBCQU1fRk1VTk1BUDogOCwKICAgIEJBTV9GUkVWRVJTRTogMTYsCiAgICBCQU1fRk1SRVZFUlNFOiAzMiwKICAgIEJBTV9GUkVBRDE6IDY0LAogICAgQkFNX0ZSRUFEMjogMTI4LAogICAgQkFNX0ZTRUNPTkRBUlk6IDI1NiwKICAgIEJBTV9GUUNGQUlMOiA1MTIsCiAgICBCQU1fRkRVUDogMTAyNCwKICAgIEJBTV9GU1VQUExFTUVOVEFSWTogMjA0OAogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCtiYW1AMS4xLjE4L25vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZXNtL3JlY29yZC5qcwogIHZhciBTRVFSRVRfREVDT0RFUiA9ICI9QUNNR1JTVlRXWUhLREJOIi5zcGxpdCgiIik7CiAgdmFyIENJR0FSX0RFQ09ERVIgPSAiTUlETlNIUD1YPz8/Pz8/PyIuc3BsaXQoIiIpOwogIHZhciBCYW1SZWNvcmQgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7CiAgICAgIHRoaXMuZGF0YSA9IHt9OwogICAgICB0aGlzLl90YWdMaXN0ID0gW107CiAgICAgIHRoaXMuX2FsbFRhZ3NQYXJzZWQgPSBmYWxzZTsKICAgICAgY29uc3QgeyBieXRlcywgZmlsZU9mZnNldCB9ID0gYXJnczsKICAgICAgY29uc3QgeyBieXRlQXJyYXksIHN0YXJ0IH0gPSBieXRlczsKICAgICAgdGhpcy5kYXRhID0ge307CiAgICAgIHRoaXMuYnl0ZXMgPSBieXRlczsKICAgICAgdGhpcy5faWQgPSBmaWxlT2Zmc2V0OwogICAgICB0aGlzLl9yZWZJRCA9IGJ5dGVBcnJheS5yZWFkSW50MzJMRShzdGFydCArIDQpOwogICAgICB0aGlzLmRhdGEuc3RhcnQgPSBieXRlQXJyYXkucmVhZEludDMyTEUoc3RhcnQgKyA4KTsKICAgICAgdGhpcy5mbGFncyA9IChieXRlQXJyYXkucmVhZEludDMyTEUoc3RhcnQgKyAxNikgJiA0Mjk0OTAxNzYwKSA+PiAxNjsKICAgIH0KICAgIGdldChmaWVsZCkgewogICAgICBpZiAodGhpc1tmaWVsZF0pIHsKICAgICAgICBpZiAodGhpcy5kYXRhW2ZpZWxkXSkgewogICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtmaWVsZF07CiAgICAgICAgfQogICAgICAgIHRoaXMuZGF0YVtmaWVsZF0gPSB0aGlzW2ZpZWxkXSgpOwogICAgICAgIHJldHVybiB0aGlzLmRhdGFbZmllbGRdOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLl9nZXQoZmllbGQudG9Mb3dlckNhc2UoKSk7CiAgICB9CiAgICBlbmQoKSB7CiAgICAgIHJldHVybiB0aGlzLmdldCgic3RhcnQiKSArIHRoaXMuZ2V0KCJsZW5ndGhfb25fcmVmIik7CiAgICB9CiAgICBzZXFfaWQoKSB7CiAgICAgIHJldHVybiB0aGlzLl9yZWZJRDsKICAgIH0KICAgIF9nZXQoZmllbGQpIHsKICAgICAgaWYgKGZpZWxkIGluIHRoaXMuZGF0YSkgewogICAgICAgIHJldHVybiB0aGlzLmRhdGFbZmllbGRdOwogICAgICB9CiAgICAgIHRoaXMuZGF0YVtmaWVsZF0gPSB0aGlzLl9wYXJzZVRhZyhmaWVsZCk7CiAgICAgIHJldHVybiB0aGlzLmRhdGFbZmllbGRdOwogICAgfQogICAgX3RhZ3MoKSB7CiAgICAgIHRoaXMuX3BhcnNlQWxsVGFncygpOwogICAgICBsZXQgdGFncyA9IFsic2VxIl07CiAgICAgIGlmICghdGhpcy5pc1NlZ21lbnRVbm1hcHBlZCgpKSB7CiAgICAgICAgdGFncy5wdXNoKCJzdGFydCIsICJlbmQiLCAic3RyYW5kIiwgInNjb3JlIiwgInF1YWwiLCAiTVEiLCAiQ0lHQVIiLCAibGVuZ3RoX29uX3JlZiIsICJ0ZW1wbGF0ZV9sZW5ndGgiKTsKICAgICAgfQogICAgICBpZiAodGhpcy5pc1BhaXJlZCgpKSB7CiAgICAgICAgdGFncy5wdXNoKCJuZXh0X3NlZ21lbnRfcG9zaXRpb24iLCAicGFpcl9vcmllbnRhdGlvbiIpOwogICAgICB9CiAgICAgIHRhZ3MgPSB0YWdzLmNvbmNhdCh0aGlzLl90YWdMaXN0IHx8IFtdKTsKICAgICAgT2JqZWN0LmtleXModGhpcy5kYXRhKS5mb3JFYWNoKChrKSA9PiB7CiAgICAgICAgaWYgKGtbMF0gIT09ICJfIiAmJiBrICE9PSAibmV4dF9zZXFfaWQiKSB7CiAgICAgICAgICB0YWdzLnB1c2goayk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgY29uc3Qgc2VlbiA9IHt9OwogICAgICByZXR1cm4gdGFncy5maWx0ZXIoKHQpID0+IHsKICAgICAgICBpZiAodCBpbiB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhW3RdID09PSB2b2lkIDAgfHwgdCA9PT0gIkNHIiB8fCB0ID09PSAiY2ciKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGx0ID0gdC50b0xvd2VyQ2FzZSgpOwogICAgICAgIGNvbnN0IHMgPSBzZWVuW2x0XTsKICAgICAgICBzZWVuW2x0XSA9IHRydWU7CiAgICAgICAgcmV0dXJuICFzOwogICAgICB9KTsKICAgIH0KICAgIHBhcmVudCgpIHsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIGNoaWxkcmVuKCkgewogICAgICByZXR1cm4gdGhpcy5nZXQoInN1YmZlYXR1cmVzIik7CiAgICB9CiAgICBpZCgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2lkOwogICAgfQogICAgbXEoKSB7CiAgICAgIGNvbnN0IG1xID0gKHRoaXMuZ2V0KCJfYmluX21xX25sIikgJiA2NTI4MCkgPj4gODsKICAgICAgcmV0dXJuIG1xID09PSAyNTUgPyB2b2lkIDAgOiBtcTsKICAgIH0KICAgIHNjb3JlKCkgewogICAgICByZXR1cm4gdGhpcy5nZXQoIm1xIik7CiAgICB9CiAgICBxdWFsKCkgewogICAgICB2YXIgX2E7CiAgICAgIHJldHVybiAoX2EgPSB0aGlzLnF1YWxSYXcoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmpvaW4oIiAiKTsKICAgIH0KICAgIHF1YWxSYXcoKSB7CiAgICAgIGlmICh0aGlzLmlzU2VnbWVudFVubWFwcGVkKCkpIHsKICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICB9CiAgICAgIGNvbnN0IHsgc3RhcnQsIGJ5dGVBcnJheSB9ID0gdGhpcy5ieXRlczsKICAgICAgY29uc3QgcCA9IHN0YXJ0ICsgMzYgKyB0aGlzLmdldCgiX2xfcmVhZF9uYW1lIikgKyB0aGlzLmdldCgiX25fY2lnYXJfb3AiKSAqIDQgKyB0aGlzLmdldCgiX3NlcV9ieXRlcyIpOwogICAgICBjb25zdCBsc2VxID0gdGhpcy5nZXQoInNlcV9sZW5ndGgiKTsKICAgICAgcmV0dXJuIGJ5dGVBcnJheS5zdWJhcnJheShwLCBwICsgbHNlcSk7CiAgICB9CiAgICBzdHJhbmQoKSB7CiAgICAgIHJldHVybiB0aGlzLmlzUmV2ZXJzZUNvbXBsZW1lbnRlZCgpID8gLTEgOiAxOwogICAgfQogICAgbXVsdGlfc2VnbWVudF9uZXh0X3NlZ21lbnRfc3RyYW5kKCkgewogICAgICBpZiAodGhpcy5pc01hdGVVbm1hcHBlZCgpKSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5pc01hdGVSZXZlcnNlQ29tcGxlbWVudGVkKCkgPyAtMSA6IDE7CiAgICB9CiAgICBuYW1lKCkgewogICAgICByZXR1cm4gdGhpcy5nZXQoIl9yZWFkX25hbWUiKTsKICAgIH0KICAgIF9yZWFkX25hbWUoKSB7CiAgICAgIGNvbnN0IG5sID0gdGhpcy5nZXQoIl9sX3JlYWRfbmFtZSIpOwogICAgICBjb25zdCB7IGJ5dGVBcnJheSwgc3RhcnQgfSA9IHRoaXMuYnl0ZXM7CiAgICAgIHJldHVybiBieXRlQXJyYXkudG9TdHJpbmcoImFzY2lpIiwgc3RhcnQgKyAzNiwgc3RhcnQgKyAzNiArIG5sIC0gMSk7CiAgICB9CiAgICBfcGFyc2VUYWcodGFnTmFtZSkgewogICAgICBpZiAodGhpcy5fYWxsVGFnc1BhcnNlZCkgewogICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgIH0KICAgICAgY29uc3QgeyBieXRlQXJyYXksIHN0YXJ0IH0gPSB0aGlzLmJ5dGVzOwogICAgICBsZXQgcCA9IHRoaXMuX3RhZ09mZnNldCB8fCBzdGFydCArIDM2ICsgdGhpcy5nZXQoIl9sX3JlYWRfbmFtZSIpICsgdGhpcy5nZXQoIl9uX2NpZ2FyX29wIikgKiA0ICsgdGhpcy5nZXQoIl9zZXFfYnl0ZXMiKSArIHRoaXMuZ2V0KCJzZXFfbGVuZ3RoIik7CiAgICAgIGNvbnN0IGJsb2NrRW5kID0gdGhpcy5ieXRlcy5lbmQ7CiAgICAgIGxldCBsY1RhZzsKICAgICAgd2hpbGUgKHAgPCBibG9ja0VuZCAmJiBsY1RhZyAhPT0gdGFnTmFtZSkgewogICAgICAgIGNvbnN0IHRhZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZUFycmF5W3BdLCBieXRlQXJyYXlbcCArIDFdKTsKICAgICAgICBsY1RhZyA9IHRhZy50b0xvd2VyQ2FzZSgpOwogICAgICAgIGNvbnN0IHR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVBcnJheVtwICsgMl0pOwogICAgICAgIHAgKz0gMzsKICAgICAgICBsZXQgdmFsdWU7CiAgICAgICAgc3dpdGNoICh0eXBlKSB7CiAgICAgICAgICBjYXNlICJBIjoKICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVBcnJheVtwXSk7CiAgICAgICAgICAgIHAgKz0gMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICJpIjoKICAgICAgICAgICAgdmFsdWUgPSBieXRlQXJyYXkucmVhZEludDMyTEUocCk7CiAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICJJIjoKICAgICAgICAgICAgdmFsdWUgPSBieXRlQXJyYXkucmVhZFVJbnQzMkxFKHApOwogICAgICAgICAgICBwICs9IDQ7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAiYyI6CiAgICAgICAgICAgIHZhbHVlID0gYnl0ZUFycmF5LnJlYWRJbnQ4KHApOwogICAgICAgICAgICBwICs9IDE7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAiQyI6CiAgICAgICAgICAgIHZhbHVlID0gYnl0ZUFycmF5LnJlYWRVSW50OChwKTsKICAgICAgICAgICAgcCArPSAxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgInMiOgogICAgICAgICAgICB2YWx1ZSA9IGJ5dGVBcnJheS5yZWFkSW50MTZMRShwKTsKICAgICAgICAgICAgcCArPSAyOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgIlMiOgogICAgICAgICAgICB2YWx1ZSA9IGJ5dGVBcnJheS5yZWFkVUludDE2TEUocCk7CiAgICAgICAgICAgIHAgKz0gMjsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICJmIjoKICAgICAgICAgICAgdmFsdWUgPSBieXRlQXJyYXkucmVhZEZsb2F0TEUocCk7CiAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICJaIjoKICAgICAgICAgIGNhc2UgIkgiOgogICAgICAgICAgICB2YWx1ZSA9ICIiOwogICAgICAgICAgICB3aGlsZSAocCA8PSBibG9ja0VuZCkgewogICAgICAgICAgICAgIGNvbnN0IGNjID0gYnl0ZUFycmF5W3ArK107CiAgICAgICAgICAgICAgaWYgKGNjID09PSAwKSB7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjYyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAiQiI6IHsKICAgICAgICAgICAgdmFsdWUgPSAiIjsKICAgICAgICAgICAgY29uc3QgY2MgPSBieXRlQXJyYXlbcCsrXTsKICAgICAgICAgICAgY29uc3QgQnR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNjKTsKICAgICAgICAgICAgY29uc3QgbGltaXQgPSBieXRlQXJyYXkucmVhZEludDMyTEUocCk7CiAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgaWYgKEJ0eXBlID09PSAiaSIpIHsKICAgICAgICAgICAgICBpZiAodGFnID09PSAiQ0ciKSB7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGxpbWl0OyBrKyspIHsKICAgICAgICAgICAgICAgICAgY29uc3QgY2lnb3AgPSBieXRlQXJyYXkucmVhZEludDMyTEUocCk7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGxvcCA9IGNpZ29wID4+IDQ7CiAgICAgICAgICAgICAgICAgIGNvbnN0IG9wID0gQ0lHQVJfREVDT0RFUltjaWdvcCAmIDE1XTsKICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gbG9wICsgb3A7CiAgICAgICAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBsaW1pdDsgaysrKSB7CiAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGJ5dGVBcnJheS5yZWFkSW50MzJMRShwKTsKICAgICAgICAgICAgICAgICAgaWYgKGsgKyAxIDwgbGltaXQpIHsKICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSAiLCI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgcCArPSA0OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoQnR5cGUgPT09ICJJIikgewogICAgICAgICAgICAgIGlmICh0YWcgPT09ICJDRyIpIHsKICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGltaXQ7IGsrKykgewogICAgICAgICAgICAgICAgICBjb25zdCBjaWdvcCA9IGJ5dGVBcnJheS5yZWFkVUludDMyTEUocCk7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGxvcCA9IGNpZ29wID4+IDQ7CiAgICAgICAgICAgICAgICAgIGNvbnN0IG9wID0gQ0lHQVJfREVDT0RFUltjaWdvcCAmIDE1XTsKICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gbG9wICsgb3A7CiAgICAgICAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBsaW1pdDsgaysrKSB7CiAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGJ5dGVBcnJheS5yZWFkVUludDMyTEUocCk7CiAgICAgICAgICAgICAgICAgIGlmIChrICsgMSA8IGxpbWl0KSB7CiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gIiwiOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKEJ0eXBlID09PSAicyIpIHsKICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGxpbWl0OyBrKyspIHsKICAgICAgICAgICAgICAgIHZhbHVlICs9IGJ5dGVBcnJheS5yZWFkSW50MTZMRShwKTsKICAgICAgICAgICAgICAgIGlmIChrICsgMSA8IGxpbWl0KSB7CiAgICAgICAgICAgICAgICAgIHZhbHVlICs9ICIsIjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHAgKz0gMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKEJ0eXBlID09PSAiUyIpIHsKICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGxpbWl0OyBrKyspIHsKICAgICAgICAgICAgICAgIHZhbHVlICs9IGJ5dGVBcnJheS5yZWFkVUludDE2TEUocCk7CiAgICAgICAgICAgICAgICBpZiAoayArIDEgPCBsaW1pdCkgewogICAgICAgICAgICAgICAgICB2YWx1ZSArPSAiLCI7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBwICs9IDI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChCdHlwZSA9PT0gImMiKSB7CiAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBsaW1pdDsgaysrKSB7CiAgICAgICAgICAgICAgICB2YWx1ZSArPSBieXRlQXJyYXkucmVhZEludDgocCk7CiAgICAgICAgICAgICAgICBpZiAoayArIDEgPCBsaW1pdCkgewogICAgICAgICAgICAgICAgICB2YWx1ZSArPSAiLCI7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBwICs9IDE7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChCdHlwZSA9PT0gIkMiKSB7CiAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBsaW1pdDsgaysrKSB7CiAgICAgICAgICAgICAgICB2YWx1ZSArPSBieXRlQXJyYXkucmVhZFVJbnQ4KHApOwogICAgICAgICAgICAgICAgaWYgKGsgKyAxIDwgbGltaXQpIHsKICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gIiwiOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcCArPSAxOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoQnR5cGUgPT09ICJmIikgewogICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGltaXQ7IGsrKykgewogICAgICAgICAgICAgICAgdmFsdWUgKz0gYnl0ZUFycmF5LnJlYWRGbG9hdExFKHApOwogICAgICAgICAgICAgICAgaWYgKGsgKyAxIDwgbGltaXQpIHsKICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gIiwiOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcCArPSA0OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBCQU0gdGFnIHR5cGUgJyR7dHlwZX0nLCB0YWdzIG1heSBiZSBpbmNvbXBsZXRlYCk7CiAgICAgICAgICAgIHZhbHVlID0gdm9pZCAwOwogICAgICAgICAgICBwID0gYmxvY2tFbmQ7CiAgICAgICAgfQogICAgICAgIHRoaXMuX3RhZ09mZnNldCA9IHA7CiAgICAgICAgdGhpcy5fdGFnTGlzdC5wdXNoKHRhZyk7CiAgICAgICAgaWYgKGxjVGFnID09PSB0YWdOYW1lKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgfQogICAgICAgIHRoaXMuZGF0YVtsY1RhZ10gPSB2YWx1ZTsKICAgICAgfQogICAgICB0aGlzLl9hbGxUYWdzUGFyc2VkID0gdHJ1ZTsKICAgICAgcmV0dXJuIHZvaWQgMDsKICAgIH0KICAgIF9wYXJzZUFsbFRhZ3MoKSB7CiAgICAgIHRoaXMuX3BhcnNlVGFnKCIiKTsKICAgIH0KICAgIF9wYXJzZUNpZ2FyKGNpZ2FyKSB7CiAgICAgIHJldHVybiBjaWdhci5tYXRjaCgvXGQrXEQvZykubWFwKChvcCkgPT4gW29wLm1hdGNoKC9cRC8pWzBdLnRvVXBwZXJDYXNlKCksIHBhcnNlSW50KG9wLCAxMCldKTsKICAgIH0KICAgIGlzUGFpcmVkKCkgewogICAgICByZXR1cm4gISEodGhpcy5mbGFncyAmIGNvbnN0YW50c19kZWZhdWx0LkJBTV9GUEFJUkVEKTsKICAgIH0KICAgIGlzUHJvcGVybHlQYWlyZWQoKSB7CiAgICAgIHJldHVybiAhISh0aGlzLmZsYWdzICYgY29uc3RhbnRzX2RlZmF1bHQuQkFNX0ZQUk9QRVJfUEFJUik7CiAgICB9CiAgICBpc1NlZ21lbnRVbm1hcHBlZCgpIHsKICAgICAgcmV0dXJuICEhKHRoaXMuZmxhZ3MgJiBjb25zdGFudHNfZGVmYXVsdC5CQU1fRlVOTUFQKTsKICAgIH0KICAgIGlzTWF0ZVVubWFwcGVkKCkgewogICAgICByZXR1cm4gISEodGhpcy5mbGFncyAmIGNvbnN0YW50c19kZWZhdWx0LkJBTV9GTVVOTUFQKTsKICAgIH0KICAgIGlzUmV2ZXJzZUNvbXBsZW1lbnRlZCgpIHsKICAgICAgcmV0dXJuICEhKHRoaXMuZmxhZ3MgJiBjb25zdGFudHNfZGVmYXVsdC5CQU1fRlJFVkVSU0UpOwogICAgfQogICAgaXNNYXRlUmV2ZXJzZUNvbXBsZW1lbnRlZCgpIHsKICAgICAgcmV0dXJuICEhKHRoaXMuZmxhZ3MgJiBjb25zdGFudHNfZGVmYXVsdC5CQU1fRk1SRVZFUlNFKTsKICAgIH0KICAgIGlzUmVhZDEoKSB7CiAgICAgIHJldHVybiAhISh0aGlzLmZsYWdzICYgY29uc3RhbnRzX2RlZmF1bHQuQkFNX0ZSRUFEMSk7CiAgICB9CiAgICBpc1JlYWQyKCkgewogICAgICByZXR1cm4gISEodGhpcy5mbGFncyAmIGNvbnN0YW50c19kZWZhdWx0LkJBTV9GUkVBRDIpOwogICAgfQogICAgaXNTZWNvbmRhcnkoKSB7CiAgICAgIHJldHVybiAhISh0aGlzLmZsYWdzICYgY29uc3RhbnRzX2RlZmF1bHQuQkFNX0ZTRUNPTkRBUlkpOwogICAgfQogICAgaXNGYWlsZWRRYygpIHsKICAgICAgcmV0dXJuICEhKHRoaXMuZmxhZ3MgJiBjb25zdGFudHNfZGVmYXVsdC5CQU1fRlFDRkFJTCk7CiAgICB9CiAgICBpc0R1cGxpY2F0ZSgpIHsKICAgICAgcmV0dXJuICEhKHRoaXMuZmxhZ3MgJiBjb25zdGFudHNfZGVmYXVsdC5CQU1fRkRVUCk7CiAgICB9CiAgICBpc1N1cHBsZW1lbnRhcnkoKSB7CiAgICAgIHJldHVybiAhISh0aGlzLmZsYWdzICYgY29uc3RhbnRzX2RlZmF1bHQuQkFNX0ZTVVBQTEVNRU5UQVJZKTsKICAgIH0KICAgIGNpZ2FyKCkgewogICAgICBpZiAodGhpcy5pc1NlZ21lbnRVbm1hcHBlZCgpKSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgICBjb25zdCB7IGJ5dGVBcnJheSwgc3RhcnQgfSA9IHRoaXMuYnl0ZXM7CiAgICAgIGNvbnN0IG51bUNpZ2FyT3BzID0gdGhpcy5nZXQoIl9uX2NpZ2FyX29wIik7CiAgICAgIGxldCBwID0gc3RhcnQgKyAzNiArIHRoaXMuZ2V0KCJfbF9yZWFkX25hbWUiKTsKICAgICAgY29uc3Qgc2VxTGVuID0gdGhpcy5nZXQoInNlcV9sZW5ndGgiKTsKICAgICAgbGV0IGNpZ2FyID0gIiI7CiAgICAgIGxldCBscmVmID0gMDsKICAgICAgbGV0IGNpZ29wID0gYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHApOwogICAgICBsZXQgbG9wID0gY2lnb3AgPj4gNDsKICAgICAgbGV0IG9wID0gQ0lHQVJfREVDT0RFUltjaWdvcCAmIDE1XTsKICAgICAgaWYgKG9wID09PSAiUyIgJiYgbG9wID09PSBzZXFMZW4pIHsKICAgICAgICBwICs9IDQ7CiAgICAgICAgY2lnb3AgPSBieXRlQXJyYXkucmVhZEludDMyTEUocCk7CiAgICAgICAgbG9wID0gY2lnb3AgPj4gNDsKICAgICAgICBvcCA9IENJR0FSX0RFQ09ERVJbY2lnb3AgJiAxNV07CiAgICAgICAgaWYgKG9wICE9PSAiTiIpIHsKICAgICAgICAgIGNvbnNvbGUud2FybigiQ0cgdGFnIHdpdGggbm8gTiB0YWciKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5kYXRhLmxlbmd0aF9vbl9yZWYgPSBsb3A7CiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCJDRyIpOwogICAgICB9IGVsc2UgewogICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbnVtQ2lnYXJPcHM7ICsrYykgewogICAgICAgICAgY2lnb3AgPSBieXRlQXJyYXkucmVhZEludDMyTEUocCk7CiAgICAgICAgICBsb3AgPSBjaWdvcCA+PiA0OwogICAgICAgICAgb3AgPSBDSUdBUl9ERUNPREVSW2NpZ29wICYgMTVdOwogICAgICAgICAgY2lnYXIgKz0gbG9wICsgb3A7CiAgICAgICAgICBpZiAob3AgIT09ICJIIiAmJiBvcCAhPT0gIlMiICYmIG9wICE9PSAiSSIpIHsKICAgICAgICAgICAgbHJlZiArPSBsb3A7CiAgICAgICAgICB9CiAgICAgICAgICBwICs9IDQ7CiAgICAgICAgfQogICAgICAgIHRoaXMuZGF0YS5sZW5ndGhfb25fcmVmID0gbHJlZjsKICAgICAgICByZXR1cm4gY2lnYXI7CiAgICAgIH0KICAgIH0KICAgIF9mbGFncygpIHsKICAgIH0KICAgIGxlbmd0aF9vbl9yZWYoKSB7CiAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoX29uX3JlZikgewogICAgICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoX29uX3JlZjsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLmdldCgiY2lnYXIiKTsKICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aF9vbl9yZWY7CiAgICAgIH0KICAgIH0KICAgIF9uX2NpZ2FyX29wKCkgewogICAgICByZXR1cm4gdGhpcy5nZXQoIl9mbGFnX25jIikgJiA2NTUzNTsKICAgIH0KICAgIF9sX3JlYWRfbmFtZSgpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0KCJfYmluX21xX25sIikgJiAyNTU7CiAgICB9CiAgICBfc2VxX2J5dGVzKCkgewogICAgICByZXR1cm4gdGhpcy5nZXQoInNlcV9sZW5ndGgiKSArIDEgPj4gMTsKICAgIH0KICAgIGdldFJlYWRCYXNlcygpIHsKICAgICAgcmV0dXJuIHRoaXMuc2VxKCk7CiAgICB9CiAgICBzZXEoKSB7CiAgICAgIGNvbnN0IHsgYnl0ZUFycmF5LCBzdGFydCB9ID0gdGhpcy5ieXRlczsKICAgICAgY29uc3QgcCA9IHN0YXJ0ICsgMzYgKyB0aGlzLmdldCgiX2xfcmVhZF9uYW1lIikgKyB0aGlzLmdldCgiX25fY2lnYXJfb3AiKSAqIDQ7CiAgICAgIGNvbnN0IHNlcUJ5dGVzID0gdGhpcy5nZXQoIl9zZXFfYnl0ZXMiKTsKICAgICAgY29uc3QgbGVuID0gdGhpcy5nZXQoInNlcV9sZW5ndGgiKTsKICAgICAgbGV0IGJ1ZiA9ICIiOwogICAgICBsZXQgaSA9IDA7CiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VxQnl0ZXM7ICsraikgewogICAgICAgIGNvbnN0IHNiID0gYnl0ZUFycmF5W3AgKyBqXTsKICAgICAgICBidWYgKz0gU0VRUkVUX0RFQ09ERVJbKHNiICYgMjQwKSA+PiA0XTsKICAgICAgICBpKys7CiAgICAgICAgaWYgKGkgPCBsZW4pIHsKICAgICAgICAgIGJ1ZiArPSBTRVFSRVRfREVDT0RFUltzYiAmIDE1XTsKICAgICAgICAgIGkrKzsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIGJ1ZjsKICAgIH0KICAgIGdldFBhaXJPcmllbnRhdGlvbigpIHsKICAgICAgaWYgKCF0aGlzLmlzU2VnbWVudFVubWFwcGVkKCkgJiYgIXRoaXMuaXNNYXRlVW5tYXBwZWQoKSAmJiB0aGlzLl9yZWZJRCA9PT0gdGhpcy5fbmV4dF9yZWZpZCgpKSB7CiAgICAgICAgY29uc3QgczEgPSB0aGlzLmlzUmV2ZXJzZUNvbXBsZW1lbnRlZCgpID8gIlIiIDogIkYiOwogICAgICAgIGNvbnN0IHMyID0gdGhpcy5pc01hdGVSZXZlcnNlQ29tcGxlbWVudGVkKCkgPyAiUiIgOiAiRiI7CiAgICAgICAgbGV0IG8xID0gIiAiOwogICAgICAgIGxldCBvMiA9ICIgIjsKICAgICAgICBpZiAodGhpcy5pc1JlYWQxKCkpIHsKICAgICAgICAgIG8xID0gIjEiOwogICAgICAgICAgbzIgPSAiMiI7CiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzUmVhZDIoKSkgewogICAgICAgICAgbzEgPSAiMiI7CiAgICAgICAgICBvMiA9ICIxIjsKICAgICAgICB9CiAgICAgICAgY29uc3QgdG1wID0gW107CiAgICAgICAgY29uc3QgaXNpemUgPSB0aGlzLnRlbXBsYXRlX2xlbmd0aCgpOwogICAgICAgIGlmIChpc2l6ZSA+IDApIHsKICAgICAgICAgIHRtcFswXSA9IHMxOwogICAgICAgICAgdG1wWzFdID0gbzE7CiAgICAgICAgICB0bXBbMl0gPSBzMjsKICAgICAgICAgIHRtcFszXSA9IG8yOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0bXBbMl0gPSBzMTsKICAgICAgICAgIHRtcFszXSA9IG8xOwogICAgICAgICAgdG1wWzBdID0gczI7CiAgICAgICAgICB0bXBbMV0gPSBvMjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRtcC5qb2luKCIiKTsKICAgICAgfQogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIF9iaW5fbXFfbmwoKSB7CiAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmJ5dGVBcnJheS5yZWFkSW50MzJMRSh0aGlzLmJ5dGVzLnN0YXJ0ICsgMTIpOwogICAgfQogICAgX2ZsYWdfbmMoKSB7CiAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmJ5dGVBcnJheS5yZWFkSW50MzJMRSh0aGlzLmJ5dGVzLnN0YXJ0ICsgMTYpOwogICAgfQogICAgc2VxX2xlbmd0aCgpIHsKICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHRoaXMuYnl0ZXMuc3RhcnQgKyAyMCk7CiAgICB9CiAgICBfbmV4dF9yZWZpZCgpIHsKICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHRoaXMuYnl0ZXMuc3RhcnQgKyAyNCk7CiAgICB9CiAgICBfbmV4dF9wb3MoKSB7CiAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmJ5dGVBcnJheS5yZWFkSW50MzJMRSh0aGlzLmJ5dGVzLnN0YXJ0ICsgMjgpOwogICAgfQogICAgdGVtcGxhdGVfbGVuZ3RoKCkgewogICAgICByZXR1cm4gdGhpcy5ieXRlcy5ieXRlQXJyYXkucmVhZEludDMyTEUodGhpcy5ieXRlcy5zdGFydCArIDMyKTsKICAgIH0KICAgIHRvSlNPTigpIHsKICAgICAgY29uc3QgZGF0YSA9IHt9OwogICAgICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKChrKSA9PiB7CiAgICAgICAgaWYgKGsuY2hhckF0KDApID09PSAiXyIgfHwgayA9PT0gImJ5dGVzIikgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBkYXRhW2tdID0gdGhpc1trXTsKICAgICAgfSk7CiAgICAgIHJldHVybiBkYXRhOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCtiYW1AMS4xLjE4L25vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZXNtL3NhbS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBwYXJzZUhlYWRlclRleHQodGV4dCkgewogICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KC9ccj9cbi8pOwogICAgY29uc3QgZGF0YSA9IFtdOwogICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4gewogICAgICBjb25zdCBbdGFnLCAuLi5maWVsZHNdID0gbGluZS5zcGxpdCgvXHQvKTsKICAgICAgY29uc3QgcGFyc2VkRmllbGRzID0gZmllbGRzLm1hcCgoZikgPT4gewogICAgICAgIGNvbnN0IFtmaWVsZFRhZywgdmFsdWVdID0gZi5zcGxpdCgiOiIsIDIpOwogICAgICAgIHJldHVybiB7IHRhZzogZmllbGRUYWcsIHZhbHVlIH07CiAgICAgIH0pOwogICAgICBpZiAodGFnKSB7CiAgICAgICAgZGF0YS5wdXNoKHsgdGFnOiB0YWcuc3Vic3RyKDEpLCBkYXRhOiBwYXJzZWRGaWVsZHMgfSk7CiAgICAgIH0KICAgIH0pOwogICAgcmV0dXJuIGRhdGE7CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmFtQDEuMS4xOC9ub2RlX21vZHVsZXMvQGdtb2QvYmFtL2VzbS9iYW1GaWxlLmpzCiAgdmFyIEJBTV9NQUdJQyA9IDIxODQwMTk0OwogIHZhciBibG9ja0xlbiA9IDEgPDwgMTY7CiAgZnVuY3Rpb24gZmxhdChhcnIpIHsKICAgIHJldHVybiBbXS5jb25jYXQoLi4uYXJyKTsKICB9CiAgYXN5bmMgZnVuY3Rpb24gZ2VuMmFycmF5KGdlbikgewogICAgY29uc3Qgb3V0ID0gW107CiAgICBmb3IgYXdhaXQgKGNvbnN0IHggb2YgZ2VuKSB7CiAgICAgIG91dC5wdXNoKHgpOwogICAgfQogICAgcmV0dXJuIG91dDsKICB9CiAgdmFyIEJhbUZpbGUgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3Rvcih7IGJhbUZpbGVoYW5kbGUsIGJhbVBhdGgsIGJhbVVybCwgYmFpUGF0aCwgYmFpRmlsZWhhbmRsZSwgYmFpVXJsLCBjc2lQYXRoLCBjc2lGaWxlaGFuZGxlLCBjc2lVcmwsIGZldGNoU2l6ZUxpbWl0LCBjaHVua1NpemVMaW1pdCwgeWllbGRUaHJlYWRUaW1lID0gMTAwLCByZW5hbWVSZWZTZXFzID0gKG4pID0+IG4gfSkgewogICAgICB0aGlzLmZlYXR1cmVDYWNoZSA9IG5ldyBpbXBvcnRfYWJvcnRhYmxlX3Byb21pc2VfY2FjaGUuZGVmYXVsdCh7CiAgICAgICAgY2FjaGU6IG5ldyBpbXBvcnRfcXVpY2tfbHJ1LmRlZmF1bHQoewogICAgICAgICAgbWF4U2l6ZTogNTAKICAgICAgICB9KSwKICAgICAgICBmaWxsOiBhc3luYyAoeyBjaHVuaywgb3B0cyB9LCBzaWduYWwpID0+IHsKICAgICAgICAgIGNvbnN0IHsgZGF0YSwgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucyB9ID0gYXdhaXQgdGhpcy5fcmVhZENodW5rKHsKICAgICAgICAgICAgY2h1bmssCiAgICAgICAgICAgIG9wdHM6IHsgLi4ub3B0cywgc2lnbmFsIH0KICAgICAgICAgIH0pOwogICAgICAgICAgY29uc3QgZmVhdHMgPSBhd2FpdCB0aGlzLnJlYWRCYW1GZWF0dXJlcyhkYXRhLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zLCBjaHVuayk7CiAgICAgICAgICByZXR1cm4gZmVhdHM7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgdGhpcy5yZW5hbWVSZWZTZXEgPSByZW5hbWVSZWZTZXFzOwogICAgICBpZiAoYmFtRmlsZWhhbmRsZSkgewogICAgICAgIHRoaXMuYmFtID0gYmFtRmlsZWhhbmRsZTsKICAgICAgfSBlbHNlIGlmIChiYW1QYXRoKSB7CiAgICAgICAgdGhpcy5iYW0gPSBuZXcgaW1wb3J0X2xvY2FsRmlsZS5kZWZhdWx0KGJhbVBhdGgpOwogICAgICB9IGVsc2UgaWYgKGJhbVVybCkgewogICAgICAgIHRoaXMuYmFtID0gbmV3IFJlbW90ZUZpbGUoYmFtVXJsKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInVuYWJsZSB0byBpbml0aWFsaXplIGJhbSIpOwogICAgICB9CiAgICAgIGlmIChjc2lGaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBDU0koeyBmaWxlaGFuZGxlOiBjc2lGaWxlaGFuZGxlIH0pOwogICAgICB9IGVsc2UgaWYgKGNzaVBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IENTSSh7IGZpbGVoYW5kbGU6IG5ldyBpbXBvcnRfbG9jYWxGaWxlLmRlZmF1bHQoY3NpUGF0aCkgfSk7CiAgICAgIH0gZWxzZSBpZiAoY3NpVXJsKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBDU0koeyBmaWxlaGFuZGxlOiBuZXcgUmVtb3RlRmlsZShjc2lVcmwpIH0pOwogICAgICB9IGVsc2UgaWYgKGJhaUZpbGVoYW5kbGUpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IEJBSSh7IGZpbGVoYW5kbGU6IGJhaUZpbGVoYW5kbGUgfSk7CiAgICAgIH0gZWxzZSBpZiAoYmFpUGF0aCkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgQkFJKHsgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChiYWlQYXRoKSB9KTsKICAgICAgfSBlbHNlIGlmIChiYWlVcmwpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IEJBSSh7IGZpbGVoYW5kbGU6IG5ldyBSZW1vdGVGaWxlKGJhaVVybCkgfSk7CiAgICAgIH0gZWxzZSBpZiAoYmFtUGF0aCkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgQkFJKHsgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChgJHtiYW1QYXRofS5iYWlgKSB9KTsKICAgICAgfSBlbHNlIGlmIChiYW1VcmwpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IEJBSSh7IGZpbGVoYW5kbGU6IG5ldyBSZW1vdGVGaWxlKGAke2JhbVVybH0uYmFpYCkgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ1bmFibGUgdG8gaW5mZXIgaW5kZXggZm9ybWF0Iik7CiAgICAgIH0KICAgICAgdGhpcy5mZXRjaFNpemVMaW1pdCA9IGZldGNoU2l6ZUxpbWl0IHx8IDVlODsKICAgICAgdGhpcy5jaHVua1NpemVMaW1pdCA9IGNodW5rU2l6ZUxpbWl0IHx8IDNlODsKICAgICAgdGhpcy55aWVsZFRocmVhZFRpbWUgPSB5aWVsZFRocmVhZFRpbWU7CiAgICB9CiAgICBhc3luYyBnZXRIZWFkZXIob3JpZ09wdHMgPSB7fSkgewogICAgICBjb25zdCBvcHRzID0gbWFrZU9wdHMob3JpZ09wdHMpOwogICAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLmluZGV4LnBhcnNlKG9wdHMpOwogICAgICBjb25zdCByZXQgPSBpbmRleERhdGEuZmlyc3REYXRhTGluZSA/IGluZGV4RGF0YS5maXJzdERhdGFMaW5lLmJsb2NrUG9zaXRpb24gKyA2NTUzNSA6IHZvaWQgMDsKICAgICAgbGV0IGJ1ZmZlcjsKICAgICAgaWYgKHJldCkgewogICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuYmFtLnJlYWQoaW1wb3J0X2J1ZmZlci5CdWZmZXIuYWxsb2MocmV0ICsgYmxvY2tMZW4pLCAwLCByZXQgKyBibG9ja0xlbiwgMCwgb3B0cyk7CiAgICAgICAgY29uc3QgeyBieXRlc1JlYWQgfSA9IHJlczsKICAgICAgICAoeyBidWZmZXIgfSA9IHJlcyk7CiAgICAgICAgaWYgKCFieXRlc1JlYWQpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiRXJyb3IgcmVhZGluZyBoZWFkZXIiKTsKICAgICAgICB9CiAgICAgICAgaWYgKGJ5dGVzUmVhZCA8IHJldCkgewogICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KDAsIGJ5dGVzUmVhZCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheSgwLCByZXQpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBidWZmZXIgPSBhd2FpdCB0aGlzLmJhbS5yZWFkRmlsZShvcHRzKTsKICAgICAgfQogICAgICBjb25zdCB1bmNiYSA9IGF3YWl0IHVuemlwKGJ1ZmZlcik7CiAgICAgIGlmICh1bmNiYS5yZWFkSW50MzJMRSgwKSAhPT0gQkFNX01BR0lDKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJOb3QgYSBCQU0gZmlsZSIpOwogICAgICB9CiAgICAgIGNvbnN0IGhlYWRMZW4gPSB1bmNiYS5yZWFkSW50MzJMRSg0KTsKICAgICAgdGhpcy5oZWFkZXIgPSB1bmNiYS50b1N0cmluZygidXRmOCIsIDgsIDggKyBoZWFkTGVuKTsKICAgICAgY29uc3QgeyBjaHJUb0luZGV4LCBpbmRleFRvQ2hyIH0gPSBhd2FpdCB0aGlzLl9yZWFkUmVmU2VxcyhoZWFkTGVuICsgOCwgNjU1MzUsIG9wdHMpOwogICAgICB0aGlzLmNoclRvSW5kZXggPSBjaHJUb0luZGV4OwogICAgICB0aGlzLmluZGV4VG9DaHIgPSBpbmRleFRvQ2hyOwogICAgICByZXR1cm4gcGFyc2VIZWFkZXJUZXh0KHRoaXMuaGVhZGVyKTsKICAgIH0KICAgIGFzeW5jIGdldEhlYWRlclRleHQob3B0cyA9IHt9KSB7CiAgICAgIGF3YWl0IHRoaXMuZ2V0SGVhZGVyKG9wdHMpOwogICAgICByZXR1cm4gdGhpcy5oZWFkZXI7CiAgICB9CiAgICBhc3luYyBfcmVhZFJlZlNlcXMoc3RhcnQsIHJlZlNlcUJ5dGVzLCBvcHRzID0ge30pIHsKICAgICAgaWYgKHN0YXJ0ID4gcmVmU2VxQnl0ZXMpIHsKICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFJlZlNlcXMoc3RhcnQsIHJlZlNlcUJ5dGVzICogMiwgb3B0cyk7CiAgICAgIH0KICAgICAgY29uc3Qgc2l6ZSA9IHJlZlNlcUJ5dGVzICsgYmxvY2tMZW47CiAgICAgIGNvbnN0IHsgYnl0ZXNSZWFkLCBidWZmZXIgfSA9IGF3YWl0IHRoaXMuYmFtLnJlYWQoaW1wb3J0X2J1ZmZlci5CdWZmZXIuYWxsb2Moc2l6ZSksIDAsIHJlZlNlcUJ5dGVzLCAwLCBvcHRzKTsKICAgICAgaWYgKCFieXRlc1JlYWQpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkVycm9yIHJlYWRpbmcgcmVmc2VxcyBmcm9tIGhlYWRlciIpOwogICAgICB9CiAgICAgIGNvbnN0IHVuY2JhID0gYXdhaXQgdW56aXAoYnVmZmVyLnN1YmFycmF5KDAsIE1hdGgubWluKGJ5dGVzUmVhZCwgcmVmU2VxQnl0ZXMpKSk7CiAgICAgIGNvbnN0IG5SZWYgPSB1bmNiYS5yZWFkSW50MzJMRShzdGFydCk7CiAgICAgIGxldCBwID0gc3RhcnQgKyA0OwogICAgICBjb25zdCBjaHJUb0luZGV4ID0ge307CiAgICAgIGNvbnN0IGluZGV4VG9DaHIgPSBbXTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuUmVmOyBpICs9IDEpIHsKICAgICAgICBjb25zdCBsTmFtZSA9IHVuY2JhLnJlYWRJbnQzMkxFKHApOwogICAgICAgIGNvbnN0IHJlZk5hbWUgPSB0aGlzLnJlbmFtZVJlZlNlcSh1bmNiYS50b1N0cmluZygidXRmOCIsIHAgKyA0LCBwICsgNCArIGxOYW1lIC0gMSkpOwogICAgICAgIGNvbnN0IGxSZWYgPSB1bmNiYS5yZWFkSW50MzJMRShwICsgbE5hbWUgKyA0KTsKICAgICAgICBjaHJUb0luZGV4W3JlZk5hbWVdID0gaTsKICAgICAgICBpbmRleFRvQ2hyLnB1c2goeyByZWZOYW1lLCBsZW5ndGg6IGxSZWYgfSk7CiAgICAgICAgcCA9IHAgKyA4ICsgbE5hbWU7CiAgICAgICAgaWYgKHAgPiB1bmNiYS5sZW5ndGgpIHsKICAgICAgICAgIGNvbnNvbGUud2FybihgQkFNIGhlYWRlciBpcyB2ZXJ5IGJpZy4gIFJlLWZldGNoaW5nICR7cmVmU2VxQnl0ZXN9IGJ5dGVzLmApOwogICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRSZWZTZXFzKHN0YXJ0LCByZWZTZXFCeXRlcyAqIDIsIG9wdHMpOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4geyBjaHJUb0luZGV4LCBpbmRleFRvQ2hyIH07CiAgICB9CiAgICBhc3luYyBnZXRSZWNvcmRzRm9yUmFuZ2UoY2hyLCBtaW4sIG1heCwgb3B0cyA9IHsKICAgICAgdmlld0FzUGFpcnM6IGZhbHNlLAogICAgICBwYWlyQWNyb3NzQ2hyOiBmYWxzZSwKICAgICAgbWF4SW5zZXJ0U2l6ZTogMmU1CiAgICB9KSB7CiAgICAgIHJldHVybiBmbGF0KGF3YWl0IGdlbjJhcnJheSh0aGlzLnN0cmVhbVJlY29yZHNGb3JSYW5nZShjaHIsIG1pbiwgbWF4LCBvcHRzKSkpOwogICAgfQogICAgYXN5bmMgKnN0cmVhbVJlY29yZHNGb3JSYW5nZShjaHIsIG1pbiwgbWF4LCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgeyBzaWduYWwgfSA9IG9wdHM7CiAgICAgIGNvbnN0IGNocklkID0gdGhpcy5jaHJUb0luZGV4ICYmIHRoaXMuY2hyVG9JbmRleFtjaHJdOwogICAgICBsZXQgY2h1bmtzOwogICAgICBpZiAoIShjaHJJZCA+PSAwKSkgewogICAgICAgIGNodW5rcyA9IFtdOwogICAgICB9IGVsc2UgewogICAgICAgIGNodW5rcyA9IGF3YWl0IHRoaXMuaW5kZXguYmxvY2tzRm9yUmFuZ2UoY2hySWQsIG1pbiAtIDEsIG1heCwgb3B0cyk7CiAgICAgICAgaWYgKCFjaHVua3MpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiRXJyb3IgaW4gaW5kZXggZmV0Y2giKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBhd2FpdCBhYm9ydEJyZWFrUG9pbnQoc2lnbmFsKTsKICAgICAgICBjb25zdCBzaXplID0gY2h1bmtzW2ldLmZldGNoZWRTaXplKCk7CiAgICAgICAgaWYgKHNpemUgPiB0aGlzLmNodW5rU2l6ZUxpbWl0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBtYW55IEJBTSBmZWF0dXJlcy4gQkFNIGNodW5rIHNpemUgJHtzaXplfSBieXRlcyBleGNlZWRzIGNodW5rU2l6ZUxpbWl0IG9mICR7dGhpcy5jaHVua1NpemVMaW1pdH1gKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc3QgdG90YWxTaXplID0gY2h1bmtzLm1hcCgocykgPT4gcy5mZXRjaGVkU2l6ZSgpKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTsKICAgICAgaWYgKHRvdGFsU2l6ZSA+IHRoaXMuZmV0Y2hTaXplTGltaXQpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRhdGEgc2l6ZSBvZiAke3RvdGFsU2l6ZS50b0xvY2FsZVN0cmluZygpfSBieXRlcyBleGNlZWRlZCBmZXRjaCBzaXplIGxpbWl0IG9mICR7dGhpcy5mZXRjaFNpemVMaW1pdC50b0xvY2FsZVN0cmluZygpfSBieXRlc2ApOwogICAgICB9CiAgICAgIHlpZWxkKiB0aGlzLl9mZXRjaENodW5rRmVhdHVyZXMoY2h1bmtzLCBjaHJJZCwgbWluLCBtYXgsIG9wdHMpOwogICAgfQogICAgYXN5bmMgKl9mZXRjaENodW5rRmVhdHVyZXMoY2h1bmtzLCBjaHJJZCwgbWluLCBtYXgsIG9wdHMpIHsKICAgICAgY29uc3QgeyB2aWV3QXNQYWlycyA9IGZhbHNlIH0gPSBvcHRzOwogICAgICBjb25zdCBmZWF0cyA9IFtdOwogICAgICBsZXQgZG9uZSA9IGZhbHNlOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGMgPSBjaHVua3NbaV07CiAgICAgICAgY29uc3QgcmVjb3JkcyA9IGF3YWl0IHRoaXMuZmVhdHVyZUNhY2hlLmdldChjLnRvU3RyaW5nKCksIHsKICAgICAgICAgIGNodW5rOiBjLAogICAgICAgICAgb3B0cwogICAgICAgIH0sIG9wdHMuc2lnbmFsKTsKICAgICAgICBjb25zdCByZWNzID0gW107CiAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHJlY29yZHMubGVuZ3RoOyBpMiArPSAxKSB7CiAgICAgICAgICBjb25zdCBmZWF0dXJlID0gcmVjb3Jkc1tpMl07CiAgICAgICAgICBpZiAoZmVhdHVyZS5zZXFfaWQoKSA9PT0gY2hySWQpIHsKICAgICAgICAgICAgaWYgKGZlYXR1cmUuZ2V0KCJzdGFydCIpID49IG1heCkgewogICAgICAgICAgICAgIGRvbmUgPSB0cnVlOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2V0KCJlbmQiKSA+PSBtaW4pIHsKICAgICAgICAgICAgICByZWNzLnB1c2goZmVhdHVyZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZmVhdHMucHVzaChyZWNzKTsKICAgICAgICB5aWVsZCByZWNzOwogICAgICAgIGlmIChkb25lKSB7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgICAgY2hlY2tBYm9ydFNpZ25hbChvcHRzLnNpZ25hbCk7CiAgICAgIGlmICh2aWV3QXNQYWlycykgewogICAgICAgIHlpZWxkIHRoaXMuZmV0Y2hQYWlycyhjaHJJZCwgZmVhdHMsIG9wdHMpOwogICAgICB9CiAgICB9CiAgICBhc3luYyBmZXRjaFBhaXJzKGNocklkLCBmZWF0cywgb3B0cykgewogICAgICBjb25zdCB7IHBhaXJBY3Jvc3NDaHIgPSBmYWxzZSwgbWF4SW5zZXJ0U2l6ZSA9IDJlNSB9ID0gb3B0czsKICAgICAgY29uc3QgdW5tYXRlZFBhaXJzID0ge307CiAgICAgIGNvbnN0IHJlYWRJZHMgPSB7fTsKICAgICAgZmVhdHMubWFwKChyZXQpID0+IHsKICAgICAgICBjb25zdCByZWFkTmFtZXMgPSB7fTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykgewogICAgICAgICAgY29uc3QgbmFtZSA9IHJldFtpXS5uYW1lKCk7CiAgICAgICAgICBjb25zdCBpZCA9IHJldFtpXS5pZCgpOwogICAgICAgICAgaWYgKCFyZWFkTmFtZXNbbmFtZV0pIHsKICAgICAgICAgICAgcmVhZE5hbWVzW25hbWVdID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHJlYWROYW1lc1tuYW1lXSsrOwogICAgICAgICAgcmVhZElkc1tpZF0gPSAxOwogICAgICAgIH0KICAgICAgICAoMCwgaW1wb3J0X29iamVjdC5kZWZhdWx0KShyZWFkTmFtZXMpLmZvckVhY2goKFtrLCB2XSkgPT4gewogICAgICAgICAgaWYgKHYgPT09IDEpIHsKICAgICAgICAgICAgdW5tYXRlZFBhaXJzW2tdID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfSk7CiAgICAgIGNvbnN0IG1hdGVQcm9taXNlcyA9IFtdOwogICAgICBmZWF0cy5tYXAoKHJldCkgPT4gewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBjb25zdCBmID0gcmV0W2ldOwogICAgICAgICAgY29uc3QgbmFtZSA9IGYubmFtZSgpOwogICAgICAgICAgY29uc3Qgc3RhcnQgPSBmLmdldCgic3RhcnQiKTsKICAgICAgICAgIGNvbnN0IHBuZXh0ID0gZi5fbmV4dF9wb3MoKTsKICAgICAgICAgIGNvbnN0IHJuZXh0ID0gZi5fbmV4dF9yZWZpZCgpOwogICAgICAgICAgaWYgKHVubWF0ZWRQYWlyc1tuYW1lXSAmJiAocGFpckFjcm9zc0NociB8fCBybmV4dCA9PT0gY2hySWQgJiYgTWF0aC5hYnMoc3RhcnQgLSBwbmV4dCkgPCBtYXhJbnNlcnRTaXplKSkgewogICAgICAgICAgICBtYXRlUHJvbWlzZXMucHVzaCh0aGlzLmluZGV4LmJsb2Nrc0ZvclJhbmdlKHJuZXh0LCBwbmV4dCwgcG5leHQgKyAxLCBvcHRzKSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9KTsKICAgICAgY29uc3QgbWF0ZUNodW5rcyA9IGZsYXQoYXdhaXQgUHJvbWlzZS5hbGwobWF0ZVByb21pc2VzKSkuc29ydCgpLmZpbHRlcigoaXRlbSwgcG9zLCBhcnkpID0+ICFwb3MgfHwgaXRlbS50b1N0cmluZygpICE9PSBhcnlbcG9zIC0gMV0udG9TdHJpbmcoKSk7CiAgICAgIGNvbnN0IG1hdGVUb3RhbFNpemUgPSBtYXRlQ2h1bmtzLm1hcCgocykgPT4gcy5mZXRjaGVkU2l6ZSgpKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTsKICAgICAgaWYgKG1hdGVUb3RhbFNpemUgPiB0aGlzLmZldGNoU2l6ZUxpbWl0KSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkYXRhIHNpemUgb2YgJHttYXRlVG90YWxTaXplLnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzIGV4Y2VlZGVkIGZldGNoIHNpemUgbGltaXQgb2YgJHt0aGlzLmZldGNoU2l6ZUxpbWl0LnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzYCk7CiAgICAgIH0KICAgICAgY29uc3QgbWF0ZUZlYXRQcm9taXNlcyA9IG1hdGVDaHVua3MubWFwKGFzeW5jIChjKSA9PiB7CiAgICAgICAgY29uc3QgeyBkYXRhLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zLCBjaHVuayB9ID0gYXdhaXQgdGhpcy5fcmVhZENodW5rKHsKICAgICAgICAgIGNodW5rOiBjLAogICAgICAgICAgb3B0cwogICAgICAgIH0pOwogICAgICAgIGNvbnN0IGZlYXRzMiA9IGF3YWl0IHRoaXMucmVhZEJhbUZlYXR1cmVzKGRhdGEsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMsIGNodW5rKTsKICAgICAgICBjb25zdCBtYXRlUmVjcyA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmVhdHMyLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICBjb25zdCBmZWF0dXJlID0gZmVhdHMyW2ldOwogICAgICAgICAgaWYgKHVubWF0ZWRQYWlyc1tmZWF0dXJlLmdldCgibmFtZSIpXSAmJiAhcmVhZElkc1tmZWF0dXJlLmlkKCldKSB7CiAgICAgICAgICAgIG1hdGVSZWNzLnB1c2goZmVhdHVyZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBtYXRlUmVjczsKICAgICAgfSk7CiAgICAgIHJldHVybiBmbGF0KGF3YWl0IFByb21pc2UuYWxsKG1hdGVGZWF0UHJvbWlzZXMpKTsKICAgIH0KICAgIGFzeW5jIF9yZWFkQ2h1bmsoeyBjaHVuaywgb3B0cyB9KSB7CiAgICAgIGNvbnN0IHNpemUgPSBjaHVuay5mZXRjaGVkU2l6ZSgpOwogICAgICBjb25zdCB7IGJ1ZmZlciwgYnl0ZXNSZWFkIH0gPSBhd2FpdCB0aGlzLmJhbS5yZWFkKGltcG9ydF9idWZmZXIuQnVmZmVyLmFsbG9jKHNpemUpLCAwLCBzaXplLCBjaHVuay5taW52LmJsb2NrUG9zaXRpb24sIG9wdHMpOwogICAgICBjb25zdCB7IGJ1ZmZlcjogZGF0YSwgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucyB9ID0gYXdhaXQgdW56aXBDaHVua1NsaWNlKGJ1ZmZlci5zdWJhcnJheSgwLCBNYXRoLm1pbihieXRlc1JlYWQsIHNpemUpKSwgY2h1bmspOwogICAgICByZXR1cm4geyBkYXRhLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zLCBjaHVuayB9OwogICAgfQogICAgYXN5bmMgcmVhZEJhbUZlYXR1cmVzKGJhLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zLCBjaHVuaykgewogICAgICBsZXQgYmxvY2tTdGFydCA9IDA7CiAgICAgIGNvbnN0IHNpbmsgPSBbXTsKICAgICAgbGV0IHBvcyA9IDA7CiAgICAgIGxldCBsYXN0ID0gK0RhdGUubm93KCk7CiAgICAgIHdoaWxlIChibG9ja1N0YXJ0ICsgNCA8IGJhLmxlbmd0aCkgewogICAgICAgIGNvbnN0IGJsb2NrU2l6ZSA9IGJhLnJlYWRJbnQzMkxFKGJsb2NrU3RhcnQpOwogICAgICAgIGNvbnN0IGJsb2NrRW5kID0gYmxvY2tTdGFydCArIDQgKyBibG9ja1NpemUgLSAxOwogICAgICAgIGlmIChkcG9zaXRpb25zKSB7CiAgICAgICAgICB3aGlsZSAoYmxvY2tTdGFydCArIGNodW5rLm1pbnYuZGF0YVBvc2l0aW9uID49IGRwb3NpdGlvbnNbcG9zKytdKSB7CiAgICAgICAgICB9CiAgICAgICAgICBwb3MtLTsKICAgICAgICB9CiAgICAgICAgaWYgKGJsb2NrRW5kIDwgYmEubGVuZ3RoKSB7CiAgICAgICAgICBjb25zdCBmZWF0dXJlID0gbmV3IEJhbVJlY29yZCh7CiAgICAgICAgICAgIGJ5dGVzOiB7CiAgICAgICAgICAgICAgYnl0ZUFycmF5OiBiYSwKICAgICAgICAgICAgICBzdGFydDogYmxvY2tTdGFydCwKICAgICAgICAgICAgICBlbmQ6IGJsb2NrRW5kCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGZpbGVPZmZzZXQ6IGNwb3NpdGlvbnMgPyBjcG9zaXRpb25zW3Bvc10gKiAoMSA8PCA4KSArIChibG9ja1N0YXJ0IC0gZHBvc2l0aW9uc1twb3NdKSArIGNodW5rLm1pbnYuZGF0YVBvc2l0aW9uICsgMSA6IGltcG9ydF9idWZmZXJfY3JjMzIuZGVmYXVsdC5zaWduZWQoYmEuc2xpY2UoYmxvY2tTdGFydCwgYmxvY2tFbmQpKQogICAgICAgICAgfSk7CiAgICAgICAgICBzaW5rLnB1c2goZmVhdHVyZSk7CiAgICAgICAgICBpZiAodGhpcy55aWVsZFRocmVhZFRpbWUgJiYgK0RhdGUubm93KCkgLSBsYXN0ID4gdGhpcy55aWVsZFRocmVhZFRpbWUpIHsKICAgICAgICAgICAgYXdhaXQgdGltZW91dCgxKTsKICAgICAgICAgICAgbGFzdCA9ICtEYXRlLm5vdygpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBibG9ja1N0YXJ0ID0gYmxvY2tFbmQgKyAxOwogICAgICB9CiAgICAgIHJldHVybiBzaW5rOwogICAgfQogICAgYXN5bmMgaGFzUmVmU2VxKHNlcU5hbWUpIHsKICAgICAgY29uc3QgcmVmSWQgPSB0aGlzLmNoclRvSW5kZXggJiYgdGhpcy5jaHJUb0luZGV4W3NlcU5hbWVdOwogICAgICByZXR1cm4gdGhpcy5pbmRleC5oYXNSZWZTZXEocmVmSWQpOwogICAgfQogICAgYXN5bmMgbGluZUNvdW50KHNlcU5hbWUpIHsKICAgICAgY29uc3QgcmVmSWQgPSB0aGlzLmNoclRvSW5kZXggJiYgdGhpcy5jaHJUb0luZGV4W3NlcU5hbWVdOwogICAgICByZXR1cm4gdGhpcy5pbmRleC5saW5lQ291bnQocmVmSWQpOwogICAgfQogICAgYXN5bmMgaW5kZXhDb3Yoc2VxTmFtZSwgc3RhcnQsIGVuZCkgewogICAgICBhd2FpdCB0aGlzLmluZGV4LnBhcnNlKCk7CiAgICAgIGNvbnN0IHNlcUlkID0gdGhpcy5jaHJUb0luZGV4ICYmIHRoaXMuY2hyVG9JbmRleFtzZXFOYW1lXTsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXguaW5kZXhDb3Yoc2VxSWQsIHN0YXJ0LCBlbmQpOwogICAgfQogICAgYXN5bmMgYmxvY2tzRm9yUmFuZ2Uoc2VxTmFtZSwgc3RhcnQsIGVuZCwgb3B0cykgewogICAgICBhd2FpdCB0aGlzLmluZGV4LnBhcnNlKCk7CiAgICAgIGNvbnN0IHNlcUlkID0gdGhpcy5jaHJUb0luZGV4ICYmIHRoaXMuY2hyVG9JbmRleFtzZXFOYW1lXTsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXguYmxvY2tzRm9yUmFuZ2Uoc2VxSWQsIHN0YXJ0LCBlbmQsIG9wdHMpOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCtiYW1AMS4xLjE4L25vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZXNtL2h0c2dldC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X3BvbHlmaWxsID0gX190b01vZHVsZShyZXF1aXJlX2Jyb3dzZXJfcG9seWZpbGwoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9xdWljay1scnVANi4xLjIvbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgUXVpY2tMUlUyID0gY2xhc3MgZXh0ZW5kcyBNYXAgewogICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7CiAgICAgIHN1cGVyKCk7CiAgICAgIGlmICghKG9wdGlvbnMubWF4U2l6ZSAmJiBvcHRpb25zLm1heFNpemUgPiAwKSkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImBtYXhTaXplYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwIik7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heEFnZSA9PT0gIm51bWJlciIgJiYgb3B0aW9ucy5tYXhBZ2UgPT09IDApIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJgbWF4QWdlYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwIik7CiAgICAgIH0KICAgICAgdGhpcy5tYXhTaXplID0gb3B0aW9ucy5tYXhTaXplOwogICAgICB0aGlzLm1heEFnZSA9IG9wdGlvbnMubWF4QWdlIHx8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsKICAgICAgdGhpcy5vbkV2aWN0aW9uID0gb3B0aW9ucy5vbkV2aWN0aW9uOwogICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpOwogICAgICB0aGlzLm9sZENhY2hlID0gbmV3IE1hcCgpOwogICAgICB0aGlzLl9zaXplID0gMDsKICAgIH0KICAgIF9lbWl0RXZpY3Rpb25zKGNhY2hlKSB7CiAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkV2aWN0aW9uICE9PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgY2FjaGUpIHsKICAgICAgICB0aGlzLm9uRXZpY3Rpb24oa2V5LCBpdGVtLnZhbHVlKTsKICAgICAgfQogICAgfQogICAgX2RlbGV0ZUlmRXhwaXJlZChrZXksIGl0ZW0pIHsKICAgICAgaWYgKHR5cGVvZiBpdGVtLmV4cGlyeSA9PT0gIm51bWJlciIgJiYgaXRlbS5leHBpcnkgPD0gRGF0ZS5ub3coKSkgewogICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkV2aWN0aW9uID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICB0aGlzLm9uRXZpY3Rpb24oa2V5LCBpdGVtLnZhbHVlKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKGtleSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgX2dldE9yRGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkgewogICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSk7CiAgICAgIGlmIChkZWxldGVkID09PSBmYWxzZSkgewogICAgICAgIHJldHVybiBpdGVtLnZhbHVlOwogICAgICB9CiAgICB9CiAgICBfZ2V0SXRlbVZhbHVlKGtleSwgaXRlbSkgewogICAgICByZXR1cm4gaXRlbS5leHBpcnkgPyB0aGlzLl9nZXRPckRlbGV0ZUlmRXhwaXJlZChrZXksIGl0ZW0pIDogaXRlbS52YWx1ZTsKICAgIH0KICAgIF9wZWVrKGtleSwgY2FjaGUpIHsKICAgICAgY29uc3QgaXRlbSA9IGNhY2hlLmdldChrZXkpOwogICAgICByZXR1cm4gdGhpcy5fZ2V0SXRlbVZhbHVlKGtleSwgaXRlbSk7CiAgICB9CiAgICBfc2V0KGtleSwgdmFsdWUpIHsKICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7CiAgICAgIHRoaXMuX3NpemUrKzsKICAgICAgaWYgKHRoaXMuX3NpemUgPj0gdGhpcy5tYXhTaXplKSB7CiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5fZW1pdEV2aWN0aW9ucyh0aGlzLm9sZENhY2hlKTsKICAgICAgICB0aGlzLm9sZENhY2hlID0gdGhpcy5jYWNoZTsKICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpOwogICAgICB9CiAgICB9CiAgICBfbW92ZVRvUmVjZW50KGtleSwgaXRlbSkgewogICAgICB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpOwogICAgICB0aGlzLl9zZXQoa2V5LCBpdGVtKTsKICAgIH0KICAgICpfZW50cmllc0FzY2VuZGluZygpIHsKICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMub2xkQ2FjaGUpIHsKICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtOwogICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgY29uc3QgZGVsZXRlZCA9IHRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHZhbHVlKTsKICAgICAgICAgIGlmIChkZWxldGVkID09PSBmYWxzZSkgewogICAgICAgICAgICB5aWVsZCBpdGVtOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5jYWNoZSkgewogICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07CiAgICAgICAgY29uc3QgZGVsZXRlZCA9IHRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHZhbHVlKTsKICAgICAgICBpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHsKICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBnZXQoa2V5KSB7CiAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEl0ZW1WYWx1ZShrZXksIGl0ZW0pOwogICAgICB9CiAgICAgIGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMub2xkQ2FjaGUuZ2V0KGtleSk7CiAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIGl0ZW0pID09PSBmYWxzZSkgewogICAgICAgICAgdGhpcy5fbW92ZVRvUmVjZW50KGtleSwgaXRlbSk7CiAgICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHNldChrZXksIHZhbHVlLCB7IG1heEFnZSA9IHRoaXMubWF4QWdlIH0gPSB7fSkgewogICAgICBjb25zdCBleHBpcnkgPSB0eXBlb2YgbWF4QWdlID09PSAibnVtYmVyIiAmJiBtYXhBZ2UgIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA/IERhdGUubm93KCkgKyBtYXhBZ2UgOiB2b2lkIDA7CiAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB7CiAgICAgICAgICB2YWx1ZSwKICAgICAgICAgIGV4cGlyeQogICAgICAgIH0pOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuX3NldChrZXksIHsgdmFsdWUsIGV4cGlyeSB9KTsKICAgICAgfQogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIGhhcyhrZXkpIHsKICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICByZXR1cm4gIXRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHRoaXMuY2FjaGUuZ2V0KGtleSkpOwogICAgICB9CiAgICAgIGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgcmV0dXJuICF0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB0aGlzLm9sZENhY2hlLmdldChrZXkpKTsKICAgICAgfQogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICBwZWVrKGtleSkgewogICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgIHJldHVybiB0aGlzLl9wZWVrKGtleSwgdGhpcy5jYWNoZSk7CiAgICAgIH0KICAgICAgaWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHsKICAgICAgICByZXR1cm4gdGhpcy5fcGVlayhrZXksIHRoaXMub2xkQ2FjaGUpOwogICAgICB9CiAgICB9CiAgICBkZWxldGUoa2V5KSB7CiAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICBpZiAoZGVsZXRlZCkgewogICAgICAgIHRoaXMuX3NpemUtLTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5vbGRDYWNoZS5kZWxldGUoa2V5KSB8fCBkZWxldGVkOwogICAgfQogICAgY2xlYXIoKSB7CiAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTsKICAgICAgdGhpcy5vbGRDYWNoZS5jbGVhcigpOwogICAgICB0aGlzLl9zaXplID0gMDsKICAgIH0KICAgIHJlc2l6ZShuZXdTaXplKSB7CiAgICAgIGlmICghKG5ld1NpemUgJiYgbmV3U2l6ZSA+IDApKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiYG1heFNpemVgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAiKTsKICAgICAgfQogICAgICBjb25zdCBpdGVtcyA9IFsuLi50aGlzLl9lbnRyaWVzQXNjZW5kaW5nKCldOwogICAgICBjb25zdCByZW1vdmVDb3VudCA9IGl0ZW1zLmxlbmd0aCAtIG5ld1NpemU7CiAgICAgIGlmIChyZW1vdmVDb3VudCA8IDApIHsKICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcChpdGVtcyk7CiAgICAgICAgdGhpcy5vbGRDYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICB0aGlzLl9zaXplID0gaXRlbXMubGVuZ3RoOwogICAgICB9IGVsc2UgewogICAgICAgIGlmIChyZW1vdmVDb3VudCA+IDApIHsKICAgICAgICAgIHRoaXMuX2VtaXRFdmljdGlvbnMoaXRlbXMuc2xpY2UoMCwgcmVtb3ZlQ291bnQpKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5vbGRDYWNoZSA9IG5ldyBNYXAoaXRlbXMuc2xpY2UocmVtb3ZlQ291bnQpKTsKICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpOwogICAgICAgIHRoaXMuX3NpemUgPSAwOwogICAgICB9CiAgICAgIHRoaXMubWF4U2l6ZSA9IG5ld1NpemU7CiAgICB9CiAgICAqa2V5cygpIHsKICAgICAgZm9yIChjb25zdCBba2V5XSBvZiB0aGlzKSB7CiAgICAgICAgeWllbGQga2V5OwogICAgICB9CiAgICB9CiAgICAqdmFsdWVzKCkgewogICAgICBmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiB0aGlzKSB7CiAgICAgICAgeWllbGQgdmFsdWU7CiAgICAgIH0KICAgIH0KICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuY2FjaGUpIHsKICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtOwogICAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7CiAgICAgICAgaWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7CiAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07CiAgICAgICAgfQogICAgICB9CiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLm9sZENhY2hlKSB7CiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTsKICAgICAgICBpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICBpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHsKICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWUudmFsdWVdOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQogICAgKmVudHJpZXNEZXNjZW5kaW5nKCkgewogICAgICBsZXQgaXRlbXMgPSBbLi4udGhpcy5jYWNoZV07CiAgICAgIGZvciAobGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgewogICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTsKICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtOwogICAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7CiAgICAgICAgaWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7CiAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07CiAgICAgICAgfQogICAgICB9CiAgICAgIGl0ZW1zID0gWy4uLnRoaXMub2xkQ2FjaGVdOwogICAgICBmb3IgKGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07CiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTsKICAgICAgICBpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICBpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHsKICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWUudmFsdWVdOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQogICAgKmVudHJpZXNBc2NlbmRpbmcoKSB7CiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX2VudHJpZXNBc2NlbmRpbmcoKSkgewogICAgICAgIHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTsKICAgICAgfQogICAgfQogICAgZ2V0IHNpemUoKSB7CiAgICAgIGlmICghdGhpcy5fc2l6ZSkgewogICAgICAgIHJldHVybiB0aGlzLm9sZENhY2hlLnNpemU7CiAgICAgIH0KICAgICAgbGV0IG9sZENhY2hlU2l6ZSA9IDA7CiAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMub2xkQ2FjaGUua2V5cygpKSB7CiAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICBvbGRDYWNoZVNpemUrKzsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuX3NpemUgKyBvbGRDYWNoZVNpemUsIHRoaXMubWF4U2l6ZSk7CiAgICB9CiAgICBlbnRyaWVzKCkgewogICAgICByZXR1cm4gdGhpcy5lbnRyaWVzQXNjZW5kaW5nKCk7CiAgICB9CiAgICBmb3JFYWNoKGNhbGxiYWNrRnVuY3Rpb24sIHRoaXNBcmd1bWVudCA9IHRoaXMpIHsKICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5lbnRyaWVzQXNjZW5kaW5nKCkpIHsKICAgICAgICBjYWxsYmFja0Z1bmN0aW9uLmNhbGwodGhpc0FyZ3VtZW50LCB2YWx1ZSwga2V5LCB0aGlzKTsKICAgICAgfQogICAgfQogICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkgewogICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoWy4uLnRoaXMuZW50cmllc0FzY2VuZGluZygpXSk7CiAgICB9CiAgfTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdXRpbHMudHMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9kMy1hcnJheUAyLjEyLjEvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2QzLWFycmF5QDIuMTIuMS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBhc2NlbmRpbmdfZGVmYXVsdChhLCBiKSB7CiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vZDMtYXJyYXlAMi4xMi4xL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0b3IuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmlzZWN0b3JfZGVmYXVsdChmKSB7CiAgICBsZXQgZGVsdGEgPSBmOwogICAgbGV0IGNvbXBhcmUgPSBmOwogICAgaWYgKGYubGVuZ3RoID09PSAxKSB7CiAgICAgIGRlbHRhID0gKGQsIHgpID0+IGYoZCkgLSB4OwogICAgICBjb21wYXJlID0gYXNjZW5kaW5nQ29tcGFyYXRvcihmKTsKICAgIH0KICAgIGZ1bmN0aW9uIGxlZnQoYSwgeCwgbG8sIGhpKSB7CiAgICAgIGlmIChsbyA9PSBudWxsKQogICAgICAgIGxvID0gMDsKICAgICAgaWYgKGhpID09IG51bGwpCiAgICAgICAgaGkgPSBhLmxlbmd0aDsKICAgICAgd2hpbGUgKGxvIDwgaGkpIHsKICAgICAgICBjb25zdCBtaWQgPSBsbyArIGhpID4+PiAxOwogICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKQogICAgICAgICAgbG8gPSBtaWQgKyAxOwogICAgICAgIGVsc2UKICAgICAgICAgIGhpID0gbWlkOwogICAgICB9CiAgICAgIHJldHVybiBsbzsKICAgIH0KICAgIGZ1bmN0aW9uIHJpZ2h0KGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIHdoaWxlIChsbyA8IGhpKSB7CiAgICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTsKICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkKICAgICAgICAgIGhpID0gbWlkOwogICAgICAgIGVsc2UKICAgICAgICAgIGxvID0gbWlkICsgMTsKICAgICAgfQogICAgICByZXR1cm4gbG87CiAgICB9CiAgICBmdW5jdGlvbiBjZW50ZXIoYSwgeCwgbG8sIGhpKSB7CiAgICAgIGlmIChsbyA9PSBudWxsKQogICAgICAgIGxvID0gMDsKICAgICAgaWYgKGhpID09IG51bGwpCiAgICAgICAgaGkgPSBhLmxlbmd0aDsKICAgICAgY29uc3QgaSA9IGxlZnQoYSwgeCwgbG8sIGhpIC0gMSk7CiAgICAgIHJldHVybiBpID4gbG8gJiYgZGVsdGEoYVtpIC0gMV0sIHgpID4gLWRlbHRhKGFbaV0sIHgpID8gaSAtIDEgOiBpOwogICAgfQogICAgcmV0dXJuIHsgbGVmdCwgY2VudGVyLCByaWdodCB9OwogIH0KICBmdW5jdGlvbiBhc2NlbmRpbmdDb21wYXJhdG9yKGYpIHsKICAgIHJldHVybiAoZCwgeCkgPT4gYXNjZW5kaW5nX2RlZmF1bHQoZihkKSwgeCk7CiAgfQoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy91dGlscy50cwogIHZhciBEYXRhU291cmNlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoZmlsZSwgY2hyb21TaXplcywgb3B0aW9ucykgewogICAgICB0aGlzLmZpbGUgPSBmaWxlOwogICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOwogICAgICB0aGlzLmNocm9tSW5mbyA9IHNpemVzVG9DaHJvbUluZm8oY2hyb21TaXplcyk7CiAgICAgIHRoaXMudGlsZXNldEluZm8gPSB0aWxlc2V0SW5mb0Zyb21DaHJvbUluZm8odGhpcy5jaHJvbUluZm8pOwogICAgfQogICAgY2hyb21JbmZvOwogICAgdGlsZXNldEluZm87CiAgfTsKICB2YXIgY2hyb21JbmZvQmlzZWN0b3IgPSBiaXNlY3Rvcl9kZWZhdWx0KChkKSA9PiBkLnBvcykubGVmdDsKICB2YXIgY2hyVG9BYnMgPSAoY2hyb20sIGNocm9tUG9zLCBjaHJvbUluZm8pID0+IGNocm9tSW5mby5jaHJQb3NpdGlvbnNbY2hyb21dLnBvcyArIGNocm9tUG9zOwogIHZhciBhYnNUb0NociA9IChhYnNQb3NpdGlvbiwgY2hyb21JbmZvKSA9PiB7CiAgICBpZiAoIWNocm9tSW5mbyB8fCAhY2hyb21JbmZvLmN1bVBvc2l0aW9ucyB8fCAhY2hyb21JbmZvLmN1bVBvc2l0aW9ucy5sZW5ndGgpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICBsZXQgaW5zZXJ0UG9pbnQgPSBjaHJvbUluZm9CaXNlY3RvcihjaHJvbUluZm8uY3VtUG9zaXRpb25zLCBhYnNQb3NpdGlvbik7CiAgICBjb25zdCBsYXN0Q2hyID0gY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tjaHJvbUluZm8uY3VtUG9zaXRpb25zLmxlbmd0aCAtIDFdLmNocjsKICAgIGNvbnN0IGxhc3RMZW5ndGggPSBjaHJvbUluZm8uY2hyb21MZW5ndGhzW2xhc3RDaHJdOwogICAgaW5zZXJ0UG9pbnQgLT0gaW5zZXJ0UG9pbnQgPiAwICYmIDE7CiAgICBsZXQgY2hyUG9zaXRpb24gPSBNYXRoLmZsb29yKGFic1Bvc2l0aW9uIC0gY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tpbnNlcnRQb2ludF0ucG9zKTsKICAgIGxldCBvZmZzZXQgPSAwOwogICAgaWYgKGNoclBvc2l0aW9uIDwgMCkgewogICAgICBvZmZzZXQgPSBjaHJQb3NpdGlvbiAtIDE7CiAgICAgIGNoclBvc2l0aW9uID0gMTsKICAgIH0KICAgIGlmIChpbnNlcnRQb2ludCA9PT0gY2hyb21JbmZvLmN1bVBvc2l0aW9ucy5sZW5ndGggLSAxICYmIGNoclBvc2l0aW9uID4gbGFzdExlbmd0aCkgewogICAgICBvZmZzZXQgPSBjaHJQb3NpdGlvbiAtIGxhc3RMZW5ndGg7CiAgICAgIGNoclBvc2l0aW9uID0gbGFzdExlbmd0aDsKICAgIH0KICAgIHJldHVybiBbY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tpbnNlcnRQb2ludF0uY2hyLCBjaHJQb3NpdGlvbiwgb2Zmc2V0LCBpbnNlcnRQb2ludF07CiAgfTsKICBmdW5jdGlvbiB0aWxlc2V0SW5mb0Zyb21DaHJvbUluZm8oY2hyb21JbmZvLCB0aWxlU2l6ZSA9IDEwMjQpIHsKICAgIHJldHVybiB7CiAgICAgIHRpbGVfc2l6ZTogdGlsZVNpemUsCiAgICAgIGJpbnNfcGVyX2RpbWVuc2lvbjogdGlsZVNpemUsCiAgICAgIG1heF96b29tOiBNYXRoLmNlaWwoTWF0aC5sb2coY2hyb21JbmZvLnRvdGFsTGVuZ3RoIC8gdGlsZVNpemUpIC8gTWF0aC5sb2coMikpLAogICAgICBtYXhfd2lkdGg6IGNocm9tSW5mby50b3RhbExlbmd0aCwKICAgICAgbWluX3BvczogWzBdLAogICAgICBtYXhfcG9zOiBbY2hyb21JbmZvLnRvdGFsTGVuZ3RoXQogICAgfTsKICB9CiAgZnVuY3Rpb24gc2l6ZXNUb0Nocm9tSW5mbyhzaXplcykgewogICAgY29uc3QgaW5mbyA9IHsKICAgICAgY3VtUG9zaXRpb25zOiBbXSwKICAgICAgY2hyb21MZW5ndGhzOiB7fSwKICAgICAgY2hyUG9zaXRpb25zOiB7fSwKICAgICAgdG90YWxMZW5ndGg6IDAKICAgIH07CiAgICBzaXplcy5mb3JFYWNoKChbY2hyLCBsZW5ndGhdLCBpKSA9PiB7CiAgICAgIGNvbnN0IGNoclBvc2l0aW9uID0geyBpZDogaSwgY2hyLCBwb3M6IGluZm8udG90YWxMZW5ndGggfTsKICAgICAgaW5mby5jaHJQb3NpdGlvbnNbY2hyXSA9IGNoclBvc2l0aW9uOwogICAgICBpbmZvLmNocm9tTGVuZ3Roc1tjaHJdID0gbGVuZ3RoOwogICAgICBpbmZvLmN1bVBvc2l0aW9ucy5wdXNoKGNoclBvc2l0aW9uKTsKICAgICAgaW5mby50b3RhbExlbmd0aCArPSBsZW5ndGg7CiAgICB9KTsKICAgIHJldHVybiB7CiAgICAgIC4uLmluZm8sCiAgICAgIGFic1RvQ2hyOiAoYWJzUG9zKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGFic1RvQ2hyKGFic1BvcywgaW5mbykgOiBudWxsLAogICAgICBjaHJUb0FiczogKFtjaHJOYW1lLCBjaHJQb3NdKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGNoclRvQWJzKGNock5hbWUsIGNoclBvcywgaW5mbykgOiBudWxsCiAgICB9OwogIH0KICB2YXIgUmVtb3RlRmlsZTIgPSBjbGFzcyBleHRlbmRzIFJlbW90ZUZpbGUgewogICAgcmVhZCA9IGFzeW5jIChidWZmZXIsIG9mZnNldCA9IDAsIGxlbmd0aCwgcG9zaXRpb24gPSAwLCBvcHRzID0ge30pID0+IHsKICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgIGlmIChsZW5ndGggPCBJbmZpbml0eSkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tJHtwb3NpdGlvbiArIGxlbmd0aH1gOwogICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gSW5maW5pdHkgJiYgcG9zaXRpb24gIT09IDApIHsKICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LWA7CiAgICAgIH0KICAgICAgY29uc3QgYXJncyA9IHsKICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsCiAgICAgICAgLi4ub3ZlcnJpZGVzLAogICAgICAgIGhlYWRlcnM6IHsKICAgICAgICAgIC4uLmhlYWRlcnMsCiAgICAgICAgICAuLi5vdmVycmlkZXMuaGVhZGVycywKICAgICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcy5oZWFkZXJzCiAgICAgICAgfSwKICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgIHJlZGlyZWN0OiAiZm9sbG93IiwKICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgc2lnbmFsCiAgICAgIH07CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncyk7CiAgICAgIGlmICghcmVzcG9uc2Uub2spIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gJHt0aGlzLnVybH1gKTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHsKICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICAgICAgY29uc3QgYnl0ZXNDb3BpZWQgPSByZXNwb25zZURhdGEuY29weShidWZmZXIsIG9mZnNldCwgMCwgTWF0aC5taW4obGVuZ3RoLCByZXNwb25zZURhdGEubGVuZ3RoKSk7CiAgICAgICAgY29uc3QgcmVzID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoImNvbnRlbnQtcmFuZ2UiKTsKICAgICAgICBjb25zdCBzaXplTWF0Y2ggPSAvXC8oXGQrKSQvLmV4ZWMocmVzIHx8ICIiKTsKICAgICAgICBpZiAoc2l6ZU1hdGNoICYmIHNpemVNYXRjaFsxXSkgewogICAgICAgICAgdGhpcy5fc3RhdCA9IHsgc2l6ZTogcGFyc2VJbnQoc2l6ZU1hdGNoWzFdLCAxMCkgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYnl0ZXNSZWFkOiBieXRlc0NvcGllZCwgYnVmZmVyIH07CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSBmZXRjaGluZyAke3RoaXMudXJsfWApOwogICAgfTsKICB9OwoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy9iYW0vYmFtLXdvcmtlci50cz93b3JrZXImaW5saW5lP3dvcmtlcl9maWxlCiAgZnVuY3Rpb24gcGFyc2VNRChtZFN0cmluZywgdXNlQ291bnRzKSB7CiAgICBsZXQgY3VyclBvcyA9IDA7CiAgICBsZXQgY3Vyck51bSA9IDA7CiAgICBsZXQgZGVsZXRpb25FbmNvdW50ZXJlZCA9IGZhbHNlOwogICAgbGV0IGJhbVNlcVNoaWZ0ID0gMDsKICAgIGNvbnN0IHN1YnN0aXR1dGlvbnMgPSBbXTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWRTdHJpbmcubGVuZ3RoOyBpKyspIHsKICAgICAgaWYgKG1kU3RyaW5nW2ldLm1hdGNoKC9bMC05XS9nKSkgewogICAgICAgIGN1cnJOdW0gPSBjdXJyTnVtICogMTAgKyArbWRTdHJpbmdbaV07CiAgICAgICAgZGVsZXRpb25FbmNvdW50ZXJlZCA9IGZhbHNlOwogICAgICB9IGVsc2UgaWYgKG1kU3RyaW5nW2ldID09PSAiXiIpIHsKICAgICAgICBkZWxldGlvbkVuY291bnRlcmVkID0gdHJ1ZTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjdXJyUG9zICs9IGN1cnJOdW07CiAgICAgICAgaWYgKHVzZUNvdW50cykgewogICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsKICAgICAgICAgICAgbGVuZ3RoOiBjdXJyTnVtLAogICAgICAgICAgICB0eXBlOiBtZFN0cmluZ1tpXQogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIGlmIChkZWxldGlvbkVuY291bnRlcmVkKSB7CiAgICAgICAgICBiYW1TZXFTaGlmdCAtPSAxOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgICBwb3M6IGN1cnJQb3MsCiAgICAgICAgICAgIGJhc2U6IG1kU3RyaW5nW2ldLAogICAgICAgICAgICBsZW5ndGg6IDEsCiAgICAgICAgICAgIGJhbVNlcVNoaWZ0CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgY3Vyck51bSA9IDA7CiAgICAgICAgY3VyclBvcyArPSAxOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gc3Vic3RpdHV0aW9uczsKICB9CiAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9ucyhzZWdtZW50LCBzZXEpIHsKICAgIGxldCBzdWJzdGl0dXRpb25zID0gW107CiAgICBsZXQgc29mdENsaXBwaW5nQXRSZWFkU3RhcnQgPSBudWxsOwogICAgaWYgKHNlZ21lbnQuY2lnYXIpIHsKICAgICAgY29uc3QgY2lnYXJTdWJzID0gcGFyc2VNRChzZWdtZW50LmNpZ2FyLCB0cnVlKTsKICAgICAgbGV0IGN1cnJQb3MgPSAwOwogICAgICBmb3IgKGNvbnN0IHN1YiBvZiBjaWdhclN1YnMpIHsKICAgICAgICBpZiAoc3ViLnR5cGUgPT09ICJYIikgewogICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsKICAgICAgICAgICAgcG9zOiBjdXJyUG9zLAogICAgICAgICAgICBsZW5ndGg6IHN1Yi5sZW5ndGgsCiAgICAgICAgICAgIHR5cGU6ICJYIgogICAgICAgICAgfSk7CiAgICAgICAgICBjdXJyUG9zICs9IHN1Yi5sZW5ndGg7CiAgICAgICAgfSBlbHNlIGlmIChzdWIudHlwZSA9PT0gIkkiKSB7CiAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgICBwb3M6IGN1cnJQb3MsCiAgICAgICAgICAgIGxlbmd0aDogc3ViLmxlbmd0aCwKICAgICAgICAgICAgdHlwZTogIkkiCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgaWYgKHN1Yi50eXBlID09PSAiRCIpIHsKICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7CiAgICAgICAgICAgIHBvczogY3VyclBvcywKICAgICAgICAgICAgbGVuZ3RoOiBzdWIubGVuZ3RoLAogICAgICAgICAgICB0eXBlOiAiRCIKICAgICAgICAgIH0pOwogICAgICAgICAgY3VyclBvcyArPSBzdWIubGVuZ3RoOwogICAgICAgIH0gZWxzZSBpZiAoc3ViLnR5cGUgPT09ICJOIikgewogICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsKICAgICAgICAgICAgcG9zOiBjdXJyUG9zLAogICAgICAgICAgICBsZW5ndGg6IHN1Yi5sZW5ndGgsCiAgICAgICAgICAgIHR5cGU6ICJOIgogICAgICAgICAgfSk7CiAgICAgICAgICBjdXJyUG9zICs9IHN1Yi5sZW5ndGg7CiAgICAgICAgfSBlbHNlIGlmIChzdWIudHlwZSA9PT0gIj0iIHx8IHN1Yi50eXBlID09PSAiTSIpIHsKICAgICAgICAgIGN1cnJQb3MgKz0gc3ViLmxlbmd0aDsKICAgICAgICB9IGVsc2UgewogICAgICAgIH0KICAgICAgfQogICAgICBjb25zdCBmaXJzdFN1YiA9IGNpZ2FyU3Vic1swXTsKICAgICAgY29uc3QgbGFzdFN1YiA9IGNpZ2FyU3Vic1tjaWdhclN1YnMubGVuZ3RoIC0gMV07CiAgICAgIGlmIChmaXJzdFN1Yi50eXBlID09PSAiUyIpIHsKICAgICAgICBzb2Z0Q2xpcHBpbmdBdFJlYWRTdGFydCA9IGZpcnN0U3ViOwogICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7CiAgICAgICAgICBwb3M6IC1maXJzdFN1Yi5sZW5ndGgsCiAgICAgICAgICB0eXBlOiAiUyIsCiAgICAgICAgICBsZW5ndGg6IGZpcnN0U3ViLmxlbmd0aAogICAgICAgIH0pOwogICAgICB9CiAgICAgIGlmIChsYXN0U3ViLnR5cGUgPT09ICJTIikgewogICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7CiAgICAgICAgICBwb3M6IHNlZ21lbnQuZW5kIC0gc2VnbWVudC5zdGFydCwKICAgICAgICAgIGxlbmd0aDogbGFzdFN1Yi5sZW5ndGgsCiAgICAgICAgICB0eXBlOiAiUyIKICAgICAgICB9KTsKICAgICAgfQogICAgICBpZiAoZmlyc3RTdWIudHlwZSA9PT0gIkgiKSB7CiAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsKICAgICAgICAgIHBvczogLWZpcnN0U3ViLmxlbmd0aCwKICAgICAgICAgIHR5cGU6ICJIIiwKICAgICAgICAgIGxlbmd0aDogZmlyc3RTdWIubGVuZ3RoCiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgaWYgKGxhc3RTdWIudHlwZSA9PT0gIkgiKSB7CiAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsKICAgICAgICAgIHBvczogc2VnbWVudC5lbmQgLSBzZWdtZW50LnN0YXJ0LAogICAgICAgICAgbGVuZ3RoOiBsYXN0U3ViLmxlbmd0aCwKICAgICAgICAgIHR5cGU6ICJIIgogICAgICAgIH0pOwogICAgICB9CiAgICB9CiAgICBpZiAoc2VnbWVudC5tZCkgewogICAgICBjb25zdCBtZFN1YnN0aXR1dGlvbnMgPSBwYXJzZU1EKHNlZ21lbnQubWQsIGZhbHNlKTsKICAgICAgbWRTdWJzdGl0dXRpb25zLmZvckVhY2goZnVuY3Rpb24oc3Vic3RpdHV0aW9uKSB7CiAgICAgICAgbGV0IHBvc1N0YXJ0ID0gc3Vic3RpdHV0aW9uWyJwb3MiXSArIHN1YnN0aXR1dGlvblsiYmFtU2VxU2hpZnQiXTsKICAgICAgICBsZXQgcG9zRW5kID0gcG9zU3RhcnQgKyBzdWJzdGl0dXRpb25bImxlbmd0aCJdOwogICAgICAgIGlmIChzb2Z0Q2xpcHBpbmdBdFJlYWRTdGFydCAhPT0gbnVsbCkgewogICAgICAgICAgcG9zU3RhcnQgKz0gc29mdENsaXBwaW5nQXRSZWFkU3RhcnQubGVuZ3RoOwogICAgICAgICAgcG9zRW5kICs9IHNvZnRDbGlwcGluZ0F0UmVhZFN0YXJ0Lmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgc3Vic3RpdHV0aW9uWyJ2YXJpYW50Il0gPSBzZXEuc3Vic3RyaW5nKHBvc1N0YXJ0LCBwb3NFbmQpOwogICAgICAgIGRlbGV0ZSBzdWJzdGl0dXRpb25bImJhbVNlcVNoaWZ0Il07CiAgICAgIH0pOwogICAgICBzdWJzdGl0dXRpb25zID0gbWRTdWJzdGl0dXRpb25zLmNvbmNhdChzdWJzdGl0dXRpb25zKTsKICAgIH0KICAgIHJldHVybiBzdWJzdGl0dXRpb25zOwogIH0KICB2YXIgYmFtUmVjb3JkVG9Kc29uID0gKGJhbVJlY29yZCwgY2hyTmFtZSwgY2hyT2Zmc2V0KSA9PiB7CiAgICBjb25zdCBzZXEgPSBiYW1SZWNvcmQuZ2V0KCJzZXEiKTsKICAgIGNvbnN0IHNlZ21lbnQgPSB7CiAgICAgIGlkOiBiYW1SZWNvcmQuX2lkLAogICAgICBuYW1lOiBiYW1SZWNvcmQuZ2V0KCJuYW1lIiksCiAgICAgIHN0YXJ0OiArYmFtUmVjb3JkLmRhdGEuc3RhcnQgKyAxICsgY2hyT2Zmc2V0LAogICAgICBlbmQ6ICtiYW1SZWNvcmQuZGF0YS5lbmQgKyAxICsgY2hyT2Zmc2V0LAogICAgICBtZDogYmFtUmVjb3JkLmdldCgiTUQiKSwKICAgICAgY2hyTmFtZSwKICAgICAgY2hyT2Zmc2V0LAogICAgICBjaWdhcjogYmFtUmVjb3JkLmdldCgiY2lnYXIiKSwKICAgICAgbWFwcTogYmFtUmVjb3JkLmdldCgibXEiKSwKICAgICAgc3RyYW5kOiBiYW1SZWNvcmQuZ2V0KCJzdHJhbmQiKSA9PT0gMSA/ICIrIiA6ICItIgogICAgfTsKICAgIHJldHVybiBPYmplY3QuYXNzaWduKHNlZ21lbnQsIHsgc3Vic3RpdHV0aW9uczogZ2V0U3Vic3RpdHV0aW9ucyhzZWdtZW50LCBzZXEpIH0pOwogIH07CiAgdmFyIEJhbUZpbGUyID0gY2xhc3MgZXh0ZW5kcyBCYW1GaWxlIHsKICAgIGhlYWRlclByb21pc2U7CiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7CiAgICAgIHN1cGVyKC4uLmFyZ3MpOwogICAgICB0aGlzLmhlYWRlclByb21pc2UgPSB0aGlzLmdldEhlYWRlcigpOwogICAgfQogICAgc3RhdGljIGZyb21VcmwodXJsLCBpbmRleFVybCwgdXJsRmV0Y2hPcHRpb25zLCBpbmRleFVybEZldGNoT3B0aW9ucykgewogICAgICByZXR1cm4gbmV3IEJhbUZpbGUyKHsKICAgICAgICBiYW1GaWxlaGFuZGxlOiBuZXcgUmVtb3RlRmlsZTIodXJsLCB7IG92ZXJyaWRlczogdXJsRmV0Y2hPcHRpb25zIH0pLAogICAgICAgIGJhaUZpbGVoYW5kbGU6IG5ldyBSZW1vdGVGaWxlMihpbmRleFVybCwgeyBvdmVycmlkZXM6IGluZGV4VXJsRmV0Y2hPcHRpb25zIH0pCiAgICAgIH0pOwogICAgfQogICAgZ2V0Q2hyb21OYW1lcygpIHsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXhUb0Noci5tYXAoKHYpID0+IHYucmVmTmFtZSk7CiAgICB9CiAgfTsKICB2YXIgZGF0YVNvdXJjZXMgPSBuZXcgTWFwKCk7CiAgdmFyIGJhbUZpbGVDYWNoZSA9IG5ldyBNYXAoKTsKICB2YXIgTUFYX1RJTEVTID0gMjA7CiAgdmFyIHRpbGVWYWx1ZXMgPSBuZXcgUXVpY2tMUlUyKHsgbWF4U2l6ZTogTUFYX1RJTEVTIH0pOwogIHZhciBpbml0ID0gYXN5bmMgKHVpZCwgYmFtLCBjaHJvbVNpemVzLCBvcHRpb25zID0ge30pID0+IHsKICAgIGlmICghYmFtRmlsZUNhY2hlLmhhcyhiYW0udXJsKSkgewogICAgICBjb25zdCBiYW1GaWxlMiA9IEJhbUZpbGUyLmZyb21VcmwoYmFtLnVybCwgYmFtLmluZGV4VXJsLCBvcHRpb25zLnVybEZldGNoT3B0aW9ucywgb3B0aW9ucy5pbmRleFVybEZldGNoT3B0aW9ucyk7CiAgICAgIGF3YWl0IGJhbUZpbGUyLmdldEhlYWRlcigpOwogICAgICBjb25zdCBmaXJzdENocm9tTmFtZUluSGVhZGVyID0gYmFtRmlsZTIuZ2V0Q2hyb21OYW1lcygpWzBdOwogICAgICBpZiAoZmlyc3RDaHJvbU5hbWVJbkhlYWRlcikgewogICAgICAgIGNvbnN0IGhlYWRlckhhc1ByZWZpeCA9IGZpcnN0Q2hyb21OYW1lSW5IZWFkZXIuaW5jbHVkZXMoImNociIpOwogICAgICAgIGNvbnN0IHNwZWNIYXNQcmVmaXggPSBjaHJvbVNpemVzWzBdPy5bMF0uaW5jbHVkZXMoImNociIpOwogICAgICAgIGlmIChoZWFkZXJIYXNQcmVmaXggJiYgIXNwZWNIYXNQcmVmaXgpIHsKICAgICAgICAgIGNocm9tU2l6ZXMgPSBjaHJvbVNpemVzLm1hcCgoW3MsIG5dKSA9PiBbYGNociR7c31gLCBuXSk7CiAgICAgICAgfSBlbHNlIGlmICghaGVhZGVySGFzUHJlZml4ICYmIHNwZWNIYXNQcmVmaXgpIHsKICAgICAgICAgIGNocm9tU2l6ZXMgPSBjaHJvbVNpemVzLm1hcCgoW3MsIG5dKSA9PiBbcy5yZXBsYWNlKCJjaHIiLCAiIiksIG5dKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgYmFtRmlsZUNhY2hlLnNldChiYW0udXJsLCBiYW1GaWxlMik7CiAgICB9CiAgICBjb25zdCBiYW1GaWxlID0gYmFtRmlsZUNhY2hlLmdldChiYW0udXJsKTsKICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgRGF0YVNvdXJjZShiYW1GaWxlLCBjaHJvbVNpemVzLCB7CiAgICAgIGxvYWRNYXRlczogZmFsc2UsCiAgICAgIG1heEluc2VydFNpemU6IDVlMywKICAgICAgZXh0cmFjdEp1bmN0aW9uOiBmYWxzZSwKICAgICAganVuY3Rpb25NaW5Db3ZlcmFnZTogMSwKICAgICAgLi4ub3B0aW9ucwogICAgfSk7CiAgICBkYXRhU291cmNlcy5zZXQodWlkLCBkYXRhU291cmNlKTsKICB9OwogIHZhciB0aWxlc2V0SW5mbyA9ICh1aWQpID0+IHsKICAgIHJldHVybiBkYXRhU291cmNlcy5nZXQodWlkKS50aWxlc2V0SW5mbzsKICB9OwogIHZhciB0aWxlID0gYXN5bmMgKHVpZCwgeiwgeCkgPT4gewogICAgY29uc3QgTUFYX1RJTEVfV0lEVEggPSAyZTU7CiAgICBjb25zdCBiYW0gPSBkYXRhU291cmNlcy5nZXQodWlkKTsKICAgIGNvbnN0IGluZm8gPSB0aWxlc2V0SW5mbyh1aWQpOwogICAgaWYgKCEoIm1heF93aWR0aCIgaW4gaW5mbykpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJ0aWxlc2V0SW5mbyBkb2VzIG5vdCBpbmNsdWRlIGBtYXhfd2lkdGhgLCB3aGljaCBpcyByZXF1aXJlZCBmb3IgdGhlIEdvc2xpbmcgQmFtRGF0YUZldGNoZXIuIik7CiAgICB9CiAgICBjb25zdCB0aWxlV2lkdGggPSAraW5mby5tYXhfd2lkdGggLyAyICoqICt6OwogICAgY29uc3QgcmVjb3JkUHJvbWlzZXMgPSBbXTsKICAgIGlmICh0aWxlV2lkdGggPiBNQVhfVElMRV9XSURUSCkgewogICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUoW10pKTsKICAgIH0KICAgIGxldCBtaW5YID0gaW5mby5taW5fcG9zWzBdICsgeCAqIHRpbGVXaWR0aDsKICAgIGNvbnN0IG1heFggPSBpbmZvLm1pbl9wb3NbMF0gKyAoeCArIDEpICogdGlsZVdpZHRoOwogICAgY29uc3QgeyBjaHJvbUxlbmd0aHMsIGN1bVBvc2l0aW9ucyB9ID0gYmFtLmNocm9tSW5mbzsKICAgIGNvbnN0IG9wdCA9IHsKICAgICAgdmlld0FzUGFpcnM6IGJhbS5vcHRpb25zLmxvYWRNYXRlcwogICAgfTsKICAgIHRpbGVWYWx1ZXMuc2V0KGAke3VpZH0uJHt6fS4ke3h9YCwgW10pOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdW1Qb3NpdGlvbnMubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3QgY2hyb21OYW1lID0gY3VtUG9zaXRpb25zW2ldLmNocjsKICAgICAgY29uc3QgY2hyb21TdGFydCA9IGN1bVBvc2l0aW9uc1tpXS5wb3M7CiAgICAgIGNvbnN0IGNocm9tRW5kID0gY3VtUG9zaXRpb25zW2ldLnBvcyArIGNocm9tTGVuZ3Roc1tjaHJvbU5hbWVdOwogICAgICBpZiAoY2hyb21TdGFydCA8PSBtaW5YICYmIG1pblggPCBjaHJvbUVuZCkgewogICAgICAgIGlmIChtYXhYID4gY2hyb21FbmQpIHsKICAgICAgICAgIHJlY29yZFByb21pc2VzLnB1c2goYmFtLmZpbGUuZ2V0UmVjb3Jkc0ZvclJhbmdlKGNocm9tTmFtZSwgbWluWCAtIGNocm9tU3RhcnQsIGNocm9tRW5kIC0gY2hyb21TdGFydCwgb3B0KS50aGVuKChyZWNvcmRzKSA9PiB7CiAgICAgICAgICAgIGNvbnN0IG1hcHBlZFJlY29yZHMgPSByZWNvcmRzLm1hcCgocmVjKSA9PiBiYW1SZWNvcmRUb0pzb24ocmVjLCBjaHJvbU5hbWUsIGN1bVBvc2l0aW9uc1tpXS5wb3MpKTsKICAgICAgICAgICAgdGlsZVZhbHVlcy5zZXQoYCR7dWlkfS4ke3p9LiR7eH1gLCB0aWxlVmFsdWVzLmdldChgJHt1aWR9LiR7en0uJHt4fWApLmNvbmNhdChtYXBwZWRSZWNvcmRzKSk7CiAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgIH0pKTsKICAgICAgICAgIG1pblggPSBjaHJvbUVuZDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBNYXRoLmZsb29yKG1pblggLSBjaHJvbVN0YXJ0KTsKICAgICAgICAgIGNvbnN0IGVuZFBvcyA9IE1hdGguY2VpbChtYXhYIC0gY2hyb21TdGFydCk7CiAgICAgICAgICByZWNvcmRQcm9taXNlcy5wdXNoKGJhbS5maWxlLmdldFJlY29yZHNGb3JSYW5nZShjaHJvbU5hbWUsIHN0YXJ0UG9zLCBlbmRQb3MsIG9wdCkudGhlbigocmVjb3JkcykgPT4gewogICAgICAgICAgICBjb25zdCBtYXBwZWRSZWNvcmRzID0gcmVjb3Jkcy5tYXAoKHJlYykgPT4gYmFtUmVjb3JkVG9Kc29uKHJlYywgY2hyb21OYW1lLCBjdW1Qb3NpdGlvbnNbaV0ucG9zKSk7CiAgICAgICAgICAgIHRpbGVWYWx1ZXMuc2V0KGAke3VpZH0uJHt6fS4ke3h9YCwgdGlsZVZhbHVlcy5nZXQoYCR7dWlkfS4ke3p9LiR7eH1gKS5jb25jYXQobWFwcGVkUmVjb3JkcykpOwogICAgICAgICAgICByZXR1cm4gW107CiAgICAgICAgICB9KSk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBQcm9taXNlLmFsbChyZWNvcmRQcm9taXNlcykudGhlbigodmFsdWVzKSA9PiB7CiAgICAgIHJldHVybiB2YWx1ZXMuZmxhdCgpOwogICAgfSk7CiAgfTsKICB2YXIgZmV0Y2hUaWxlc0RlYm91bmNlZCA9IGFzeW5jICh1aWQsIHRpbGVJZHMpID0+IHsKICAgIGNvbnN0IHRpbGVzID0ge307CiAgICBjb25zdCB2YWxpZFRpbGVJZHMgPSBbXTsKICAgIGNvbnN0IHRpbGVQcm9taXNlcyA9IFtdOwogICAgZm9yIChjb25zdCB0aWxlSWQgb2YgdGlsZUlkcykgewogICAgICBjb25zdCBwYXJ0cyA9IHRpbGVJZC5zcGxpdCgiLiIpOwogICAgICBjb25zdCB6ID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTsKICAgICAgY29uc3QgeCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7CiAgICAgIGlmIChOdW1iZXIuaXNOYU4oeCkgfHwgTnVtYmVyLmlzTmFOKHopKSB7CiAgICAgICAgY29uc29sZS53YXJuKCJJbnZhbGlkIHRpbGUgem9vbSBvciBwb3NpdGlvbjoiLCB6LCB4KTsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICB2YWxpZFRpbGVJZHMucHVzaCh0aWxlSWQpOwogICAgICB0aWxlUHJvbWlzZXMucHVzaCh0aWxlKHVpZCwgeiwgeCkpOwogICAgfQogICAgcmV0dXJuIFByb21pc2UuYWxsKHRpbGVQcm9taXNlcykudGhlbigodmFsdWVzKSA9PiB7CiAgICAgIHZhbHVlcy5mb3JFYWNoKChkLCBpKSA9PiB7CiAgICAgICAgY29uc3QgdmFsaWRUaWxlSWQgPSB2YWxpZFRpbGVJZHNbaV07CiAgICAgICAgdGlsZXNbdmFsaWRUaWxlSWRdID0gT2JqZWN0LmFzc2lnbihkLCB7IHRpbGVQb3NpdGlvbklkOiB2YWxpZFRpbGVJZCB9KTsKICAgICAgfSk7CiAgICAgIHJldHVybiB0aWxlczsKICAgIH0pOwogIH07CiAgdmFyIGdldFRhYnVsYXJEYXRhID0gKHVpZCwgdGlsZUlkcykgPT4gewogICAgY29uc3QgeyBvcHRpb25zIH0gPSBkYXRhU291cmNlcy5nZXQodWlkKTsKICAgIGNvbnN0IGFsbFNlZ21lbnRzID0ge307CiAgICBmb3IgKGNvbnN0IHRpbGVJZCBvZiB0aWxlSWRzKSB7CiAgICAgIGNvbnN0IHRpbGVWYWx1ZSA9IHRpbGVWYWx1ZXMuZ2V0KGAke3VpZH0uJHt0aWxlSWR9YCk7CiAgICAgIGlmICghdGlsZVZhbHVlKSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgaWYgKCJlcnJvciIgaW4gdGlsZVZhbHVlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpbGVWYWx1ZS5lcnJvcik7CiAgICAgIH0KICAgICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHRpbGVWYWx1ZSkgewogICAgICAgIGFsbFNlZ21lbnRzW3NlZ21lbnQuaWRdID0gewogICAgICAgICAgLi4uc2VnbWVudCwKICAgICAgICAgIHN1YnN0aXR1dGlvbnM6IEpTT04uc3RyaW5naWZ5KHNlZ21lbnQuc3Vic3RpdHV0aW9ucykKICAgICAgICB9OwogICAgICB9CiAgICB9CiAgICBjb25zdCBzZWdtZW50cyA9IE9iamVjdC52YWx1ZXMoYWxsU2VnbWVudHMpOwogICAgaWYgKG9wdGlvbnMubG9hZE1hdGVzKSB7CiAgICAgIGZpbmRNYXRlcyhzZWdtZW50cywgb3B0aW9ucy5tYXhJbnNlcnRTaXplKTsKICAgIH0KICAgIGxldCBvdXRwdXQ7CiAgICBpZiAob3B0aW9ucy5leHRyYWN0SnVuY3Rpb24pIHsKICAgICAgb3V0cHV0ID0gZmluZEp1bmN0aW9ucyhzZWdtZW50cywgb3B0aW9ucy5qdW5jdGlvbk1pbkNvdmVyYWdlKTsKICAgIH0gZWxzZSB7CiAgICAgIG91dHB1dCA9IHNlZ21lbnRzOwogICAgfQogICAgY29uc3QgYnVmZmVyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG91dHB1dCkpLmJ1ZmZlcjsKICAgIHJldHVybiBUcmFuc2ZlcihidWZmZXIsIFtidWZmZXJdKTsKICB9OwogIHZhciBncm91cEJ5ID0gKHhzLCBrZXkpID0+IHhzLnJlZHVjZSgocnYsIHgpID0+IHsKICAgIChydlt4W2tleV1dID0gcnZbeFtrZXldXSB8fCBbXSkucHVzaCh4KTsKICAgIHJldHVybiBydjsKICB9LCB7fSk7CiAgdmFyIGZpbmRNYXRlcyA9IChzZWdtZW50cywgbWF4SW5zZXJ0U2l6ZSA9IDApID0+IHsKICAgIGNvbnN0IHNlZ21lbnRzQnlSZWFkTmFtZSA9IGdyb3VwQnkoc2VnbWVudHMsICJuYW1lIik7CiAgICBPYmplY3QudmFsdWVzKHNlZ21lbnRzQnlSZWFkTmFtZSkuZm9yRWFjaCgoc2VnbWVudEdyb3VwKSA9PiB7CiAgICAgIGlmIChzZWdtZW50R3JvdXAubGVuZ3RoID09PSAyKSB7CiAgICAgICAgY29uc3QgcmVhZCA9IHNlZ21lbnRHcm91cFswXTsKICAgICAgICBjb25zdCBtYXRlID0gc2VnbWVudEdyb3VwWzFdOwogICAgICAgIHJlYWQubWF0ZUlkcyA9IFttYXRlLmlkXTsKICAgICAgICBtYXRlLm1hdGVJZHMgPSBbcmVhZC5pZF07CiAgICAgICAgY29uc3QgW2wsIHJdID0gW3JlYWQsIG1hdGVdLnNvcnQoKGEsIGIpID0+ICthLnN0YXJ0IC0gK2Iuc3RhcnQpOwogICAgICAgIGNvbnN0IGluc2VydFNpemUgPSBNYXRoLm1heCgwLCArci5zdGFydCAtICtsLmVuZCk7CiAgICAgICAgY29uc3QgbGFyZ2VJbnNlcnRTaXplID0gaW5zZXJ0U2l6ZSA+PSBtYXhJbnNlcnRTaXplOwogICAgICAgIGxldCBzdlR5cGU7CiAgICAgICAgaWYgKCFsYXJnZUluc2VydFNpemUpIHsKICAgICAgICAgIHN2VHlwZSA9ICJub3JtYWwgcmVhZCI7CiAgICAgICAgfSBlbHNlIGlmIChsLnN0cmFuZCA9PT0gIisiICYmIHIuc3RyYW5kID09PSAiLSIpIHsKICAgICAgICAgIHN2VHlwZSA9ICJkZWxldGlvbiAoKy0pIjsKICAgICAgICB9IGVsc2UgaWYgKGwuc3RyYW5kID09PSAiKyIgJiYgci5zdHJhbmQgPT09ICIrIikgewogICAgICAgICAgc3ZUeXBlID0gImludmVyc2lvbiAoKyspIjsKICAgICAgICB9IGVsc2UgaWYgKGwuc3RyYW5kID09PSAiLSIgJiYgci5zdHJhbmQgPT09ICItIikgewogICAgICAgICAgc3ZUeXBlID0gImludmVyc2lvbiAoLS0pIjsKICAgICAgICB9IGVsc2UgaWYgKGwuc3RyYW5kID09PSAiLSIgJiYgci5zdHJhbmQgPT09ICIrIikgewogICAgICAgICAgc3ZUeXBlID0gImR1cGxpY2F0aW9uICgtKykiOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdlR5cGUgPSBgKCR7bC5zdHJhbmR9JHtyLnN0cmFuZH0pYDsKICAgICAgICB9CiAgICAgICAgW3JlYWQsIG1hdGVdLmZvckVhY2goKGQpID0+IHsKICAgICAgICAgIGQuZm91bmRNYXRlID0gdHJ1ZTsKICAgICAgICAgIGQuaW5zZXJ0U2l6ZSA9IGluc2VydFNpemU7CiAgICAgICAgICBkLmxhcmdlSW5zZXJ0U2l6ZSA9IGxhcmdlSW5zZXJ0U2l6ZTsKICAgICAgICAgIGQuc3ZUeXBlID0gc3ZUeXBlOwogICAgICAgICAgZC5udW1NYXRlcyA9IDI7CiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgc2VnbWVudEdyb3VwLmZvckVhY2goKGQpID0+IHsKICAgICAgICAgIGQubWF0ZUlkcyA9IHNlZ21lbnRHcm91cC5maWx0ZXIoKG1hdGUpID0+IG1hdGUuaWQgIT09IGQuaWQpLm1hcCgobWF0ZSkgPT4gbWF0ZS5pZCk7CiAgICAgICAgICBkLmZvdW5kTWF0ZSA9IGZhbHNlOwogICAgICAgICAgZC5pbnNlcnRTaXplID0gLTE7CiAgICAgICAgICBkLmxhcmdlSW5zZXJ0U2l6ZSA9IGZhbHNlOwogICAgICAgICAgZC5zdlR5cGUgPSBzZWdtZW50R3JvdXAubGVuZ3RoID09PSAxID8gIm1hdGVzIG5vdCBmb3VuZCB3aXRoaW4gY2hyb21vc29tZSIgOiAibW9yZSB0aGFuIHR3byBtYXRlcyI7CiAgICAgICAgICBkLm51bU1hdGVzID0gc2VnbWVudEdyb3VwLmxlbmd0aDsKICAgICAgICB9KTsKICAgICAgfQogICAgfSk7CiAgICByZXR1cm4gc2VnbWVudHNCeVJlYWROYW1lOwogIH07CiAgdmFyIGZpbmRKdW5jdGlvbnMgPSAoc2VnbWVudHMsIG1pbkNvdmVyYWdlID0gMCkgPT4gewogICAgY29uc3QganVuY3Rpb25zID0gW107CiAgICBzZWdtZW50cy5mb3JFYWNoKChzZWdtZW50KSA9PiB7CiAgICAgIGNvbnN0IHN1YnN0aXR1dGlvbnMgPSBKU09OLnBhcnNlKHNlZ21lbnQuc3Vic3RpdHV0aW9ucyk7CiAgICAgIHN1YnN0aXR1dGlvbnMuZm9yRWFjaCgoc3ViKSA9PiB7CiAgICAgICAgY29uc3QgZG9uID0gc2VnbWVudC5zdGFydCArIHN1Yi5wb3M7CiAgICAgICAgY29uc3QgYWNjID0gc2VnbWVudC5zdGFydCArIHN1Yi5wb3MgKyBzdWIubGVuZ3RoOwogICAgICAgIGlmIChzZWdtZW50LnN0YXJ0IDwgZG9uICYmIGFjYyA8IHNlZ21lbnQuZW5kKSB7CiAgICAgICAgICBjb25zdCBqID0ganVuY3Rpb25zLmZpbmQoKGQpID0+IGQuc3RhcnQgPT09IGRvbiAmJiBkLmVuZCA9PT0gYWNjKTsKICAgICAgICAgIGlmIChqKSB7CiAgICAgICAgICAgIGouc2NvcmUgKz0gMTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGp1bmN0aW9ucy5wdXNoKHsgc3RhcnQ6IGRvbiwgZW5kOiBhY2MsIHNjb3JlOiAxIH0pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSk7CiAgICB9KTsKICAgIHJldHVybiBqdW5jdGlvbnMuZmlsdGVyKChkKSA9PiBkLnNjb3JlID49IG1pbkNvdmVyYWdlKTsKICB9OwogIHZhciB0aWxlRnVuY3Rpb25zID0gewogICAgaW5pdCwKICAgIHRpbGVzZXRJbmZvLAogICAgZmV0Y2hUaWxlc0RlYm91bmNlZCwKICAgIHRpbGUsCiAgICBnZXRUYWJ1bGFyRGF0YQogIH07CiAgZXhwb3NlKHRpbGVGdW5jdGlvbnMpOwp9KSgpOwovKiEKICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuCiAqCiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+CiAqIEBsaWNlbnNlICBNSVQKICovCi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovCg==";
const blob$3 = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs$3)], { type: "text/javascript;charset=utf-8" });
function Worker$4() {
  const objURL = blob$3 && (window.URL || window.webkitURL).createObjectURL(blob$3);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs$3, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const DEBOUNCE_TIME$3 = 200;
class BamDataFetcher {
  constructor(HGC, config2) {
    __publicField(this, "dataConfig", {});
    // required for higlass
    __publicField(this, "uid");
    __publicField(this, "fetchTimeout");
    __publicField(this, "toFetch");
    __publicField(this, "MAX_TILE_WIDTH", 2e4);
    __publicField(this, "worker");
    // This is set by us but is accessed in `fetchTilesDebounced`
    __publicField(this, "track");
    this.uid = HGC.libraries.slugid.nice();
    this.toFetch = /* @__PURE__ */ new Set();
    const { url, indexUrl, assembly, ...options } = config2;
    this.worker = spawn(new Worker$4()).then(async (worker) => {
      const chromSizes = Object.entries(computeChromSizes(assembly).size);
      await worker.init(this.uid, { url, indexUrl }, chromSizes, options);
      return worker;
    });
  }
  /*
   * Collect Tileset Information, such as tile size and genomic positions
   */
  async tilesetInfo(callback) {
    (await this.worker).tilesetInfo(this.uid).then(callback);
  }
  fetchTilesDebounced(receivedTiles, tileIds) {
    var _a;
    const { toFetch } = this;
    const thisZoomLevel = tileIds[0].split(".")[0];
    const toFetchZoomLevel = toFetch.size ? [...toFetch][0].split(".")[0] : null;
    if (thisZoomLevel !== toFetchZoomLevel) {
      for (const tileId of this.toFetch) {
        (_a = this.track) == null ? void 0 : _a.fetching.delete(tileId);
      }
      this.toFetch.clear();
    }
    tileIds.forEach((x) => this.toFetch.add(x));
    if (this.fetchTimeout) {
      clearTimeout(this.fetchTimeout);
    }
    this.fetchTimeout = setTimeout(() => {
      this.sendFetch(receivedTiles, [...this.toFetch]);
      this.toFetch.clear();
    }, DEBOUNCE_TIME$3);
  }
  async sendFetch(receivedTiles, tileIds) {
    (await this.worker).fetchTilesDebounced(this.uid, tileIds).then(receivedTiles);
  }
  async getTabularData(tileIds) {
    const buf = await (await this.worker).getTabularData(this.uid, tileIds);
    return JSON.parse(new TextDecoder().decode(buf));
  }
}
__publicField(BamDataFetcher, "config", { type: "bam" });
const encodedJs$2 = "KCgpID0+IHsKICB2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlOwogIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgdmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwogIHZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzOwogIHZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CiAgdmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogIHZhciBfX2VzbSA9IChmbiwgcmVzKSA9PiBmdW5jdGlvbiBfX2luaXQoKSB7CiAgICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltPYmplY3Qua2V5cyhmbilbMF1dKShmbiA9IDApKSwgcmVzOwogIH07CiAgdmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkgewogICAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbT2JqZWN0LmtleXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7CiAgfTsKICB2YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHsKICAgIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSAib2JqZWN0IiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gImZ1bmN0aW9uIikgewogICAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpCiAgICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSAiZGVmYXVsdCIpCiAgICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pOwogICAgfQogICAgcmV0dXJuIHRhcmdldDsKICB9OwogIHZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHsKICAgIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sICJkZWZhdWx0IiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgImRlZmF1bHQiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2Jhc2U2NC1qc0AxLjUuMS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfYmFzZTY0X2pzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2Jhc2U2NC1qc0AxLjUuMS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZXhwb3J0czIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7CiAgICAgIGV4cG9ydHMyLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXk7CiAgICAgIGV4cG9ydHMyLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5OwogICAgICB2YXIgbG9va3VwID0gW107CiAgICAgIHZhciByZXZMb29rdXAgPSBbXTsKICAgICAgdmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAidW5kZWZpbmVkIiA/IFVpbnQ4QXJyYXkgOiBBcnJheTsKICAgICAgdmFyIGNvZGUgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHsKICAgICAgICBsb29rdXBbaV0gPSBjb2RlW2ldOwogICAgICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTsKICAgICAgfQogICAgICB2YXIgaTsKICAgICAgdmFyIGxlbjsKICAgICAgcmV2TG9va3VwWyItIi5jaGFyQ29kZUF0KDApXSA9IDYyOwogICAgICByZXZMb29rdXBbIl8iLmNoYXJDb2RlQXQoMCldID0gNjM7CiAgICAgIGZ1bmN0aW9uIGdldExlbnMoYjY0KSB7CiAgICAgICAgdmFyIGxlbjIgPSBiNjQubGVuZ3RoOwogICAgICAgIGlmIChsZW4yICUgNCA+IDApIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCIpOwogICAgICAgIH0KICAgICAgICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZigiPSIpOwogICAgICAgIGlmICh2YWxpZExlbiA9PT0gLTEpCiAgICAgICAgICB2YWxpZExlbiA9IGxlbjI7CiAgICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW4yID8gMCA6IDQgLSB2YWxpZExlbiAlIDQ7CiAgICAgICAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBieXRlTGVuZ3RoKGI2NCkgewogICAgICAgIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpOwogICAgICAgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07CiAgICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07CiAgICAgICAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHsKICAgICAgICByZXR1cm4gKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHRvQnl0ZUFycmF5KGI2NCkgewogICAgICAgIHZhciB0bXA7CiAgICAgICAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7CiAgICAgICAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTsKICAgICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTsKICAgICAgICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKTsKICAgICAgICB2YXIgY3VyQnl0ZSA9IDA7CiAgICAgICAgdmFyIGxlbjIgPSBwbGFjZUhvbGRlcnNMZW4gPiAwID8gdmFsaWRMZW4gLSA0IDogdmFsaWRMZW47CiAgICAgICAgdmFyIGkyOwogICAgICAgIGZvciAoaTIgPSAwOyBpMiA8IGxlbjI7IGkyICs9IDQpIHsKICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDE4IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldIDw8IDEyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMildIDw8IDYgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAzKV07CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiAxNiAmIDI1NTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDggJiAyNTU7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikgewogICAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA+PiA0OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7CiAgICAgICAgfQogICAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHsKICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDEwIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldIDw8IDQgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAyKV0gPj4gMjsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDggJiAyNTU7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGFycjsKICAgICAgfQogICAgICBmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQobnVtKSB7CiAgICAgICAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiA2M10gKyBsb29rdXBbbnVtID4+IDEyICYgNjNdICsgbG9va3VwW251bSA+PiA2ICYgNjNdICsgbG9va3VwW251bSAmIDYzXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBlbmNvZGVDaHVuayh1aW50OCwgc3RhcnQsIGVuZCkgewogICAgICAgIHZhciB0bXA7CiAgICAgICAgdmFyIG91dHB1dCA9IFtdOwogICAgICAgIGZvciAodmFyIGkyID0gc3RhcnQ7IGkyIDwgZW5kOyBpMiArPSAzKSB7CiAgICAgICAgICB0bXAgPSAodWludDhbaTJdIDw8IDE2ICYgMTY3MTE2ODApICsgKHVpbnQ4W2kyICsgMV0gPDwgOCAmIDY1MjgwKSArICh1aW50OFtpMiArIDJdICYgMjU1KTsKICAgICAgICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCIiKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQnl0ZUFycmF5KHVpbnQ4KSB7CiAgICAgICAgdmFyIHRtcDsKICAgICAgICB2YXIgbGVuMiA9IHVpbnQ4Lmxlbmd0aDsKICAgICAgICB2YXIgZXh0cmFCeXRlcyA9IGxlbjIgJSAzOwogICAgICAgIHZhciBwYXJ0cyA9IFtdOwogICAgICAgIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzOwogICAgICAgIGZvciAodmFyIGkyID0gMCwgbGVuMjIgPSBsZW4yIC0gZXh0cmFCeXRlczsgaTIgPCBsZW4yMjsgaTIgKz0gbWF4Q2h1bmtMZW5ndGgpIHsKICAgICAgICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGkyLCBpMiArIG1heENodW5rTGVuZ3RoID4gbGVuMjIgPyBsZW4yMiA6IGkyICsgbWF4Q2h1bmtMZW5ndGgpKTsKICAgICAgICB9CiAgICAgICAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHsKICAgICAgICAgIHRtcCA9IHVpbnQ4W2xlbjIgLSAxXTsKICAgICAgICAgIHBhcnRzLnB1c2gobG9va3VwW3RtcCA+PiAyXSArIGxvb2t1cFt0bXAgPDwgNCAmIDYzXSArICI9PSIpOwogICAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikgewogICAgICAgICAgdG1wID0gKHVpbnQ4W2xlbjIgLSAyXSA8PCA4KSArIHVpbnQ4W2xlbjIgLSAxXTsKICAgICAgICAgIHBhcnRzLnB1c2gobG9va3VwW3RtcCA+PiAxMF0gKyBsb29rdXBbdG1wID4+IDQgJiA2M10gKyBsb29rdXBbdG1wIDw8IDIgJiA2M10gKyAiPSIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcGFydHMuam9pbigiIik7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2llZWU3NTRAMS4yLjEvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMKICB2YXIgcmVxdWlyZV9pZWVlNzU0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2llZWU3NTRAMS4yLjEvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgZXhwb3J0czIucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKICAgICAgICB2YXIgZSwgbTsKICAgICAgICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTsKICAgICAgICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTsKICAgICAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7CiAgICAgICAgdmFyIG5CaXRzID0gLTc7CiAgICAgICAgdmFyIGkgPSBpc0xFID8gbkJ5dGVzIC0gMSA6IDA7CiAgICAgICAgdmFyIGQgPSBpc0xFID8gLTEgOiAxOwogICAgICAgIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldOwogICAgICAgIGkgKz0gZDsKICAgICAgICBlID0gcyAmICgxIDw8IC1uQml0cykgLSAxOwogICAgICAgIHMgPj49IC1uQml0czsKICAgICAgICBuQml0cyArPSBlTGVuOwogICAgICAgIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTsKICAgICAgICBlID4+PSAtbkJpdHM7CiAgICAgICAgbkJpdHMgKz0gbUxlbjsKICAgICAgICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIGlmIChlID09PSAwKSB7CiAgICAgICAgICBlID0gMSAtIGVCaWFzOwogICAgICAgIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkgewogICAgICAgICAgcmV0dXJuIG0gPyBOYU4gOiAocyA/IC0xIDogMSkgKiBJbmZpbml0eTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTsKICAgICAgICAgIGUgPSBlIC0gZUJpYXM7CiAgICAgICAgfQogICAgICAgIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pOwogICAgICB9OwogICAgICBleHBvcnRzMi53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7CiAgICAgICAgdmFyIGUsIG0sIGM7CiAgICAgICAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7CiAgICAgICAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7CiAgICAgICAgdmFyIGVCaWFzID0gZU1heCA+PiAxOwogICAgICAgIHZhciBydCA9IG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwOwogICAgICAgIHZhciBpID0gaXNMRSA/IDAgOiBuQnl0ZXMgLSAxOwogICAgICAgIHZhciBkID0gaXNMRSA/IDEgOiAtMTsKICAgICAgICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7CiAgICAgICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7CiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHsKICAgICAgICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDsKICAgICAgICAgIGUgPSBlTWF4OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7CiAgICAgICAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7CiAgICAgICAgICAgIGUtLTsKICAgICAgICAgICAgYyAqPSAyOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7CiAgICAgICAgICAgIHZhbHVlICs9IHJ0IC8gYzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikgewogICAgICAgICAgICBlKys7CiAgICAgICAgICAgIGMgLz0gMjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkgewogICAgICAgICAgICBtID0gMDsKICAgICAgICAgICAgZSA9IGVNYXg7CiAgICAgICAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7CiAgICAgICAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTsKICAgICAgICAgICAgZSA9IGUgKyBlQmlhczsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTsKICAgICAgICAgICAgZSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAyNTUsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkgewogICAgICAgIH0KICAgICAgICBlID0gZSA8PCBtTGVuIHwgbTsKICAgICAgICBlTGVuICs9IG1MZW47CiAgICAgICAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMjU1LCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4OwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vYnVmZmVyQDYuMC4zL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMKICB2YXIgcmVxdWlyZV9idWZmZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYnVmZmVyQDYuMC4zL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgYmFzZTY0ID0gcmVxdWlyZV9iYXNlNjRfanMoKTsKICAgICAgdmFyIGllZWU3NTQgPSByZXF1aXJlX2llZWU3NTQoKTsKICAgICAgdmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIHR5cGVvZiBTeW1ib2xbImZvciJdID09PSAiZnVuY3Rpb24iID8gU3ltYm9sWyJmb3IiXSgibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20iKSA6IG51bGw7CiAgICAgIGV4cG9ydHMyLkJ1ZmZlciA9IEJ1ZmZlcjEwOwogICAgICBleHBvcnRzMi5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjsKICAgICAgZXhwb3J0czIuSU5TUEVDVF9NQVhfQllURVMgPSA1MDsKICAgICAgdmFyIEtfTUFYX0xFTkdUSCA9IDIxNDc0ODM2NDc7CiAgICAgIGV4cG9ydHMyLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEg7CiAgICAgIEJ1ZmZlcjEwLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpOwogICAgICBpZiAoIUJ1ZmZlcjEwLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgY29uc29sZS5lcnJvcigiVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5IGBidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQoKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpOwogICAgICAgICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiA0MjsKICAgICAgICAgIH0gfTsKICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpOwogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pOwogICAgICAgICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDI7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyMTAucHJvdG90eXBlLCAicGFyZW50IiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIodGhpcykpCiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlcjEwLnByb3RvdHlwZSwgIm9mZnNldCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKHRoaXMpKQogICAgICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIobGVuZ3RoKSB7CiAgICAgICAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIGxlbmd0aCArICciIGlzIGludmFsaWQgZm9yIG9wdGlvbiAic2l6ZSInKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTsKICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIxMC5wcm90b3R5cGUpOwogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gQnVmZmVyMTAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJzdHJpbmciIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnBvb2xTaXplID0gODE5MjsKICAgICAgZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTsKICAgICAgICB9CiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICIgKyB0eXBlb2YgdmFsdWUpOwogICAgICAgIH0KICAgICAgICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8IHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpIHsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICJ1bmRlZmluZWQiICYmIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHwgdmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpIHsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInZhbHVlIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpOwogICAgICAgIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHsKICAgICAgICAgIHJldHVybiBCdWZmZXIxMC5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKTsKICAgICAgICBpZiAoYikKICAgICAgICAgIHJldHVybiBiOwogICAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAidW5kZWZpbmVkIiAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgic3RyaW5nIiksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICIgKyB0eXBlb2YgdmFsdWUpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLmZyb20gPSBmdW5jdGlvbih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgIH07CiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIxMC5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKTsKICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlcjEwLCBVaW50OEFycmF5KTsKICAgICAgZnVuY3Rpb24gYXNzZXJ0U2l6ZShzaXplKSB7CiAgICAgICAgaWYgKHR5cGVvZiBzaXplICE9PSAibnVtYmVyIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignInNpemUiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKTsKICAgICAgICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlICInICsgc2l6ZSArICciIGlzIGludmFsaWQgZm9yIG9wdGlvbiAic2l6ZSInKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHsKICAgICAgICBhc3NlcnRTaXplKHNpemUpOwogICAgICAgIGlmIChzaXplIDw9IDApIHsKICAgICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSk7CiAgICAgICAgfQogICAgICAgIGlmIChmaWxsICE9PSB2b2lkIDApIHsKICAgICAgICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICJzdHJpbmciID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAuYWxsb2MgPSBmdW5jdGlvbihzaXplLCBmaWxsLCBlbmNvZGluZykgewogICAgICAgIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZyk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUpIHsKICAgICAgICBhc3NlcnRTaXplKHNpemUpOwogICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24oc2l6ZSkgewogICAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24oc2l6ZSkgewogICAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHJpbmcsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gInN0cmluZyIgfHwgZW5jb2RpbmcgPT09ICIiKSB7CiAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICB9CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0VuY29kaW5nKGVuY29kaW5nKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDA7CiAgICAgICAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpOwogICAgICAgIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKTsKICAgICAgICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHsKICAgICAgICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21BcnJheUxpa2UoYXJyYXkpIHsKICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDA7CiAgICAgICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUFycmF5VmlldyhhcnJheVZpZXcpIHsKICAgICAgICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7CiAgICAgICAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KTsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJvZmZzZXQiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpOwogICAgICAgIH0KICAgICAgICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignImxlbmd0aCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7CiAgICAgICAgfQogICAgICAgIGxldCBidWY7CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPT09IHZvaWQgMCAmJiBsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpOwogICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsKICAgICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlcjEwLnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iaikgewogICAgICAgIGlmIChCdWZmZXIxMC5pc0J1ZmZlcihvYmopKSB7CiAgICAgICAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDsKICAgICAgICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pOwogICAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICAgIH0KICAgICAgICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKTsKICAgICAgICAgIHJldHVybiBidWY7CiAgICAgICAgfQogICAgICAgIGlmIChvYmoubGVuZ3RoICE9PSB2b2lkIDApIHsKICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gIm51bWJlciIgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHsKICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iaik7CiAgICAgICAgfQogICAgICAgIGlmIChvYmoudHlwZSA9PT0gIkJ1ZmZlciIgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY2hlY2tlZChsZW5ndGgpIHsKICAgICAgICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHgiICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICIgYnl0ZXMiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGxlbmd0aCB8IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gU2xvd0J1ZmZlcihsZW5ndGgpIHsKICAgICAgICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsKICAgICAgICAgIGxlbmd0aCA9IDA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBCdWZmZXIxMC5hbGxvYygrbGVuZ3RoKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyMihiKSB7CiAgICAgICAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJiBiICE9PSBCdWZmZXIxMC5wcm90b3R5cGU7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHsKICAgICAgICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkKICAgICAgICAgIGEgPSBCdWZmZXIxMC5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpOwogICAgICAgIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKQogICAgICAgICAgYiA9IEJ1ZmZlcjEwLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aCk7CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyMTAuaXNCdWZmZXIoYikpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAiYnVmMSIsICJidWYyIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpOwogICAgICAgIH0KICAgICAgICBpZiAoYSA9PT0gYikKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCB4ID0gYS5sZW5ndGg7CiAgICAgICAgbGV0IHkgPSBiLmxlbmd0aDsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkgewogICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHsKICAgICAgICAgICAgeCA9IGFbaV07CiAgICAgICAgICAgIHkgPSBiW2ldOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHggPCB5KQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICh5IDwgeCkKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgICBCdWZmZXIxMC5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyhlbmNvZGluZykgewogICAgICAgIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7CiAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgY2FzZSAidXRmOCI6CiAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICBjYXNlICJhc2NpaSI6CiAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChsaXN0LCBsZW5ndGgpIHsKICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTsKICAgICAgICB9CiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyMTAuYWxsb2MoMCk7CiAgICAgICAgfQogICAgICAgIGxldCBpOwogICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyMTAuYWxsb2NVbnNhZmUobGVuZ3RoKTsKICAgICAgICBsZXQgcG9zID0gMDsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewogICAgICAgICAgbGV0IGJ1ZiA9IGxpc3RbaV07CiAgICAgICAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7CiAgICAgICAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkgewogICAgICAgICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIoYnVmKSkKICAgICAgICAgICAgICAgIGJ1ZiA9IEJ1ZmZlcjEwLmZyb20oYnVmKTsKICAgICAgICAgICAgICBidWYuY29weShidWZmZXIsIHBvcyk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoYnVmZmVyLCBidWYsIHBvcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKGJ1ZikpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpOwogICAgICAgICAgfQogICAgICAgICAgcG9zICs9IGJ1Zi5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWZmZXI7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgewogICAgICAgIGlmIChCdWZmZXIxMC5pc0J1ZmZlcihzdHJpbmcpKSB7CiAgICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHsKICAgICAgICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInN0cmluZyIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmcpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoOwogICAgICAgIGNvbnN0IG11c3RNYXRjaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZTsKICAgICAgICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgICAgIHJldHVybiBsZW47CiAgICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoOwogICAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICAgIHJldHVybiBsZW4gKiAyOwogICAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgICAgIHJldHVybiBsZW4gPj4+IDE7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAoIiIgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIEJ1ZmZlcjEwLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoOwogICAgICBmdW5jdGlvbiBzbG93VG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCB8fCBzdGFydCA8IDApIHsKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgfQogICAgICAgIGVuZCA+Pj49IDA7CiAgICAgICAgc3RhcnQgPj4+PSAwOwogICAgICAgIGlmIChlbmQgPD0gc3RhcnQpIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgaWYgKCFlbmNvZGluZykKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICIiKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7CiAgICAgIGZ1bmN0aW9uIHN3YXAoYiwgbiwgbSkgewogICAgICAgIGNvbnN0IGkgPSBiW25dOwogICAgICAgIGJbbl0gPSBiW21dOwogICAgICAgIGJbbV0gPSBpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDIgIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDQgIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyAzKTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDggIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyA3KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmIChsZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIxMC5wcm90b3R5cGUudG9TdHJpbmc7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMoYikgewogICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIoYikpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIik7CiAgICAgICAgaWYgKHRoaXMgPT09IGIpCiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICByZXR1cm4gQnVmZmVyMTAuY29tcGFyZSh0aGlzLCBiKSA9PT0gMDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkgewogICAgICAgIGxldCBzdHIgPSAiIjsKICAgICAgICBjb25zdCBtYXggPSBleHBvcnRzMi5JTlNQRUNUX01BWF9CWVRFUzsKICAgICAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCJoZXgiLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAiJDEgIikudHJpbSgpOwogICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkKICAgICAgICAgIHN0ciArPSAiIC4uLiAiOwogICAgICAgIHJldHVybiAiPEJ1ZmZlciAiICsgc3RyICsgIj4iOwogICAgICB9OwogICAgICBpZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkgewogICAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5pbnNwZWN0OwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkgewogICAgICAgIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHsKICAgICAgICAgIHRhcmdldCA9IEJ1ZmZlcjEwLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIodGFyZ2V0KSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJ0YXJnZXQiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiB0YXJnZXQpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgewogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsKICAgICAgICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc1N0YXJ0ID09PSB2b2lkIDApIHsKICAgICAgICAgIHRoaXNTdGFydCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzRW5kID09PSB2b2lkIDApIHsKICAgICAgICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigib3V0IG9mIHJhbmdlIGluZGV4Iik7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ID49IGVuZCkgewogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgfQogICAgICAgIHN0YXJ0ID4+Pj0gMDsKICAgICAgICBlbmQgPj4+PSAwOwogICAgICAgIHRoaXNTdGFydCA+Pj49IDA7CiAgICAgICAgdGhpc0VuZCA+Pj49IDA7CiAgICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDsKICAgICAgICBsZXQgeSA9IGVuZCAtIHN0YXJ0OwogICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpOwogICAgICAgIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpOwogICAgICAgIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkgewogICAgICAgICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7CiAgICAgICAgICAgIHggPSB0aGlzQ29weVtpXTsKICAgICAgICAgICAgeSA9IHRhcmdldENvcHlbaV07CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoeCA8IHkpCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKHkgPCB4KQogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7CiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0OwogICAgICAgICAgYnl0ZU9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMjE0NzQ4MzY0NykgewogICAgICAgICAgYnl0ZU9mZnNldCA9IDIxNDc0ODM2NDc7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTIxNDc0ODM2NDgpIHsKICAgICAgICAgIGJ5dGVPZmZzZXQgPSAtMjE0NzQ4MzY0ODsKICAgICAgICB9CiAgICAgICAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0OwogICAgICAgIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkgewogICAgICAgICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiBidWZmZXIubGVuZ3RoIC0gMTsKICAgICAgICB9CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwKQogICAgICAgICAgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0OwogICAgICAgIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgIGlmIChkaXIpCiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxOwogICAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHsKICAgICAgICAgIGlmIChkaXIpCiAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSAwOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikgewogICAgICAgICAgdmFsID0gQnVmZmVyMTAuZnJvbSh2YWwsIGVuY29kaW5nKTsKICAgICAgICB9CiAgICAgICAgaWYgKEJ1ZmZlcjEwLmlzQnVmZmVyKHZhbCkpIHsKICAgICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHZhbCA9IHZhbCAmIDI1NTsKICAgICAgICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICBpZiAoZGlyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXIiKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICAgICAgICBsZXQgaW5kZXhTaXplID0gMTsKICAgICAgICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDsKICAgICAgICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDsKICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHZvaWQgMCkgewogICAgICAgICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1Y3MyIiB8fCBlbmNvZGluZyA9PT0gInVjcy0yIiB8fCBlbmNvZGluZyA9PT0gInV0ZjE2bGUiIHx8IGVuY29kaW5nID09PSAidXRmLTE2bGUiKSB7CiAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikgewogICAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpbmRleFNpemUgPSAyOwogICAgICAgICAgICBhcnJMZW5ndGggLz0gMjsKICAgICAgICAgICAgdmFsTGVuZ3RoIC89IDI7CiAgICAgICAgICAgIGJ5dGVPZmZzZXQgLz0gMjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmVhZChidWYsIGkyKSB7CiAgICAgICAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7CiAgICAgICAgICAgIHJldHVybiBidWZbaTJdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaTIgKiBpbmRleFNpemUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBsZXQgaTsKICAgICAgICBpZiAoZGlyKSB7CiAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IC0xOwogICAgICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHsKICAgICAgICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpCiAgICAgICAgICAgICAgICBmb3VuZEluZGV4ID0gaTsKICAgICAgICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpCiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpCiAgICAgICAgICAgICAgICBpIC09IGkgLSBmb3VuZEluZGV4OwogICAgICAgICAgICAgIGZvdW5kSW5kZXggPSAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDsKICAgICAgICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7CiAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChmb3VuZCkKICAgICAgICAgICAgICByZXR1cm4gaTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBoZXhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwOwogICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7CiAgICAgICAgaWYgKCFsZW5ndGgpIHsKICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7CiAgICAgICAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7CiAgICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikgewogICAgICAgICAgbGVuZ3RoID0gc3RyTGVuIC8gMjsKICAgICAgICB9CiAgICAgICAgbGV0IGk7CiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpOwogICAgICAgICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpCiAgICAgICAgICAgIHJldHVybiBpOwogICAgICAgICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmFzZTY0V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1Y3MyV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHsKICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICBvZmZzZXQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB2b2lkIDAgJiYgdHlwZW9mIG9mZnNldCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIGVuY29kaW5nID0gb2Zmc2V0OwogICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICBvZmZzZXQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkgewogICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHsKICAgICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwOwogICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkKICAgICAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGVuY29kaW5nID0gbGVuZ3RoOwogICAgICAgICAgICBsZW5ndGggPSB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQiKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwIHx8IGxlbmd0aCA+IHJlbWFpbmluZykKICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcyIpOwogICAgICAgIH0KICAgICAgICBpZiAoIWVuY29kaW5nKQogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2U7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgICAgICAgIGVuY29kaW5nID0gKCIiICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgdHlwZTogIkJ1ZmZlciIsCiAgICAgICAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMCkKICAgICAgICB9OwogICAgICB9OwogICAgICBmdW5jdGlvbiBiYXNlNjRTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7CiAgICAgICAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwogICAgICAgIGNvbnN0IHJlcyA9IFtdOwogICAgICAgIGxldCBpID0gc3RhcnQ7CiAgICAgICAgd2hpbGUgKGkgPCBlbmQpIHsKICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXTsKICAgICAgICAgIGxldCBjb2RlUG9pbnQgPSBudWxsOwogICAgICAgICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSBmaXJzdEJ5dGUgPiAyMzkgPyA0IDogZmlyc3RCeXRlID4gMjIzID8gMyA6IGZpcnN0Qnl0ZSA+IDE5MSA/IDIgOiAxOwogICAgICAgICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkgewogICAgICAgICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHsKICAgICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMTI4KSB7CiAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwogICAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMzEpIDw8IDYgfCBzZWNvbmRCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMTI3KSB7CiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07CiAgICAgICAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdOwogICAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmICh0aGlyZEJ5dGUgJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTIgfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCA2IHwgdGhpcmRCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMjA0NyAmJiAodGVtcENvZGVQb2ludCA8IDU1Mjk2IHx8IHRlbXBDb2RlUG9pbnQgPiA1NzM0MykpIHsKICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07CiAgICAgICAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTsKICAgICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmIChmb3VydGhCeXRlICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMTUpIDw8IDE4IHwgKHNlY29uZEJ5dGUgJiA2MykgPDwgMTIgfCAodGhpcmRCeXRlICYgNjMpIDw8IDYgfCBmb3VydGhCeXRlICYgNjM7CiAgICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gNjU1MzUgJiYgdGVtcENvZGVQb2ludCA8IDExMTQxMTIpIHsKICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHsKICAgICAgICAgICAgY29kZVBvaW50ID0gNjU1MzM7CiAgICAgICAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiA2NTUzNSkgewogICAgICAgICAgICBjb2RlUG9pbnQgLT0gNjU1MzY7CiAgICAgICAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAxMDIzIHwgNTUyOTYpOwogICAgICAgICAgICBjb2RlUG9pbnQgPSA1NjMyMCB8IGNvZGVQb2ludCAmIDEwMjM7CiAgICAgICAgICB9CiAgICAgICAgICByZXMucHVzaChjb2RlUG9pbnQpOwogICAgICAgICAgaSArPSBieXRlc1BlclNlcXVlbmNlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcyk7CiAgICAgIH0KICAgICAgdmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gNDA5NjsKICAgICAgZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5KGNvZGVQb2ludHMpIHsKICAgICAgICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aDsKICAgICAgICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7CiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpOwogICAgICAgIH0KICAgICAgICBsZXQgcmVzID0gIiI7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHdoaWxlIChpIDwgbGVuKSB7CiAgICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgbGV0IHJldCA9ICIiOwogICAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDEyNyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbGF0aW4xU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgbGV0IHJldCA9ICIiOwogICAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaGV4U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikKICAgICAgICAgIGVuZCA9IGxlbjsKICAgICAgICBsZXQgb3V0ID0gIiI7CiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBvdXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpOwogICAgICAgIGxldCByZXMgPSAiIjsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikgewogICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBzdGFydCA9IH5+c3RhcnQ7CiAgICAgICAgZW5kID0gZW5kID09PSB2b2lkIDAgPyBsZW4gOiB+fmVuZDsKICAgICAgICBpZiAoc3RhcnQgPCAwKSB7CiAgICAgICAgICBzdGFydCArPSBsZW47CiAgICAgICAgICBpZiAoc3RhcnQgPCAwKQogICAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikgewogICAgICAgICAgc3RhcnQgPSBsZW47CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPCAwKSB7CiAgICAgICAgICBlbmQgKz0gbGVuOwogICAgICAgICAgaWYgKGVuZCA8IDApCiAgICAgICAgICAgIGVuZCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHsKICAgICAgICAgIGVuZCA9IGxlbjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KQogICAgICAgICAgZW5kID0gc3RhcnQ7CiAgICAgICAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTsKICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIxMC5wcm90b3R5cGUpOwogICAgICAgIHJldHVybiBuZXdCdWY7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGNoZWNrT2Zmc2V0KG9mZnNldCwgZXh0LCBsZW5ndGgpIHsKICAgICAgICBpZiAob2Zmc2V0ICUgMSAhPT0gMCB8fCBvZmZzZXQgPCAwKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm9mZnNldCBpcyBub3QgdWludCIpOwogICAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCIpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVWludExFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50QkUgPSBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aDJdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIHdoaWxlIChieXRlTGVuZ3RoMiA+IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGgyXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50OCA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDgob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAxXTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuICh0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2KSArIHRoaXNbb2Zmc2V0ICsgM10gKiAxNjc3NzIxNjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSAqIDE2Nzc3MjE2ICsgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdKTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsbyA9IGZpcnN0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQ7CiAgICAgICAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgbGFzdCAqIDIgKiogMjQ7CiAgICAgICAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFKG9mZnNldCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTsKICAgICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTsKICAgICAgICB9CiAgICAgICAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdOwogICAgICAgIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyBsYXN0OwogICAgICAgIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbyk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgbXVsICo9IDEyODsKICAgICAgICBpZiAodmFsID49IG11bCkKICAgICAgICAgIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpOwogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGxldCBpID0gYnl0ZUxlbmd0aDI7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXTsKICAgICAgICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsOwogICAgICAgIH0KICAgICAgICBtdWwgKj0gMTI4OwogICAgICAgIGlmICh2YWwgPj0gbXVsKQogICAgICAgICAgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMik7CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDgob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgaWYgKCEodGhpc1tvZmZzZXRdICYgMTI4KSkKICAgICAgICAgIHJldHVybiB0aGlzW29mZnNldF07CiAgICAgICAgcmV0dXJuICgyNTUgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7CiAgICAgICAgcmV0dXJuIHZhbCAmIDMyNzY4ID8gdmFsIHwgNDI5NDkwMTc2MCA6IHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8IHRoaXNbb2Zmc2V0XSA8PCA4OwogICAgICAgIHJldHVybiB2YWwgJiAzMjc2OCA/IHZhbCB8IDQyOTQ5MDE3NjAgOiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAzXSA8PCAyNDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCAyNCB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICsgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICsgKGxhc3QgPDwgMjQpOwogICAgICAgIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQoZmlyc3QgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XTsKICAgICAgICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgbGFzdCk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBjaGVja0ludChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKGJ1ZikpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCciYnVmZmVyIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7CiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJ2YWx1ZSIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpOwogICAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKSAtIDE7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApOwogICAgICAgIH0KICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKSAtIDE7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApOwogICAgICAgIH0KICAgICAgICBsZXQgaSA9IGJ5dGVMZW5ndGgyIC0gMTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnQ4ID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAyNTUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAxOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgNjU1MzUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludDE2QkUgPSBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDY1NTM1LCAwKTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCA0Mjk0OTY3Mjk1LCAwKTsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgNDI5NDk2NzI5NSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gd3J0QmlnVUludDY0TEUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkgewogICAgICAgIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNyk7CiAgICAgICAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICByZXR1cm4gb2Zmc2V0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHsKICAgICAgICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpOwogICAgICAgIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCArIDddID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyA2XSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgNV0gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDRdID0gbG87CiAgICAgICAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQgKyAzXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgMl0gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDFdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXRdID0gaGk7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDg7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgiMHhmZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgiMHhmZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMiAtIDEpOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBzdWIgPSAwOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7CiAgICAgICAgICAgIHN1YiA9IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsID4+IDApIC0gc3ViICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIgLSAxKTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBsaW1pdCAtIDEsIC1saW1pdCk7CiAgICAgICAgfQogICAgICAgIGxldCBpID0gYnl0ZUxlbmd0aDIgLSAxOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBzdWIgPSAwOwogICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkgewogICAgICAgICAgICBzdWIgPSAxOwogICAgICAgICAgfQogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCA+PiAwKSAtIHN1YiAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAxMjcsIC0xMjgpOwogICAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgICB2YWx1ZSA9IDI1NSArIHZhbHVlICsgMTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMzI3NjcsIC0zMjc2OCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAzMjc2NywgLTMyNzY4KTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCk7CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHZhbHVlID0gNDI5NDk2NzI5NSArIHZhbHVlICsgMTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCIweDgwMDAwMDAwMDAwMDAwMDAiKSwgQmlnSW50KCIweDdmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSh2YWx1ZSwgb2Zmc2V0ID0gMCkgewogICAgICAgIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCIweDgwMDAwMDAwMDAwMDAwMDAiKSwgQmlnSW50KCIweDdmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgICAgaWYgKG9mZnNldCA8IDApCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMzQwMjgyMzQ2NjM4NTI4ODZlMjIsIC0zNDAyODIzNDY2Mzg1Mjg4NmUyMik7CiAgICAgICAgfQogICAgICAgIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwgLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mik7CiAgICAgICAgfQogICAgICAgIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgODsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKHRhcmdldCkpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXIiKTsKICAgICAgICBpZiAoIXN0YXJ0KQogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIGlmICghZW5kICYmIGVuZCAhPT0gMCkKICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKQogICAgICAgICAgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoOwogICAgICAgIGlmICghdGFyZ2V0U3RhcnQpCiAgICAgICAgICB0YXJnZXRTdGFydCA9IDA7CiAgICAgICAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpCiAgICAgICAgICBlbmQgPSBzdGFydDsKICAgICAgICBpZiAoZW5kID09PSBzdGFydCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgaWYgKHRhcmdldFN0YXJ0IDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMiKTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgICBpZiAoZW5kIDwgMCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcyIpOwogICAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkKICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkgewogICAgICAgICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0OwogICAgICAgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHRhcmdldCwgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSwgdGFyZ2V0U3RhcnQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbGVuOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykgewogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikgewogICAgICAgICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBzdGFydDsKICAgICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBlbmQ7CiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB2b2lkIDAgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nIik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIiAmJiAhQnVmZmVyMTAuaXNFbmNvZGluZyhlbmNvZGluZykpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTsKICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSAidXRmOCIgJiYgY29kZSA8IDEyOCB8fCBlbmNvZGluZyA9PT0gImxhdGluMSIpIHsKICAgICAgICAgICAgICB2YWwgPSBjb2RlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikgewogICAgICAgICAgdmFsID0gdmFsICYgMjU1OwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gImJvb2xlYW4iKSB7CiAgICAgICAgICB2YWwgPSBOdW1iZXIodmFsKTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiT3V0IG9mIHJhbmdlIGluZGV4Iik7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPD0gc3RhcnQpIHsKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICBzdGFydCA9IHN0YXJ0ID4+PiAwOwogICAgICAgIGVuZCA9IGVuZCA9PT0gdm9pZCAwID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7CiAgICAgICAgaWYgKCF2YWwpCiAgICAgICAgICB2YWwgPSAwOwogICAgICAgIGxldCBpOwogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikgewogICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgICB0aGlzW2ldID0gdmFsOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zdCBieXRlcyA9IEJ1ZmZlcjEwLmlzQnVmZmVyKHZhbCkgPyB2YWwgOiBCdWZmZXIxMC5mcm9tKHZhbCwgZW5jb2RpbmcpOwogICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoOwogICAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgIicgKyB2YWwgKyAnIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCAidmFsdWUiJyk7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkgewogICAgICAgICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIHZhciBlcnJvcnMgPSB7fTsKICAgICAgZnVuY3Rpb24gRShzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHsKICAgICAgICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2UgewogICAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICAgIHN1cGVyKCk7CiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAibWVzc2FnZSIsIHsKICAgICAgICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLAogICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWA7CiAgICAgICAgICAgIHRoaXMuc3RhY2s7CiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5hbWU7CiAgICAgICAgICB9CiAgICAgICAgICBnZXQgY29kZSgpIHsKICAgICAgICAgICAgcmV0dXJuIHN5bTsKICAgICAgICAgIH0KICAgICAgICAgIHNldCBjb2RlKHZhbHVlKSB7CiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAiY29kZSIsIHsKICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICB2YWx1ZSwKICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICAgIHRvU3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YDsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICAgIEUoIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsIGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICBpZiAobmFtZSkgewogICAgICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2A7CiAgICAgICAgfQogICAgICAgIHJldHVybiAiQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcyI7CiAgICAgIH0sIFJhbmdlRXJyb3IpOwogICAgICBFKCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIGZ1bmN0aW9uKG5hbWUsIGFjdHVhbCkgewogICAgICAgIHJldHVybiBgVGhlICIke25hbWV9IiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gOwogICAgICB9LCBUeXBlRXJyb3IpOwogICAgICBFKCJFUlJfT1VUX09GX1JBTkdFIiwgZnVuY3Rpb24oc3RyLCByYW5nZSwgaW5wdXQpIHsKICAgICAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiAiJHtzdHJ9IiBpcyBvdXQgb2YgcmFuZ2UuYDsKICAgICAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dDsKICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikgewogICAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICJiaWdpbnQiKSB7CiAgICAgICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dCk7CiAgICAgICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7CiAgICAgICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKTsKICAgICAgICAgIH0KICAgICAgICAgIHJlY2VpdmVkICs9ICJuIjsKICAgICAgICB9CiAgICAgICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gOwogICAgICAgIHJldHVybiBtc2c7CiAgICAgIH0sIFJhbmdlRXJyb3IpOwogICAgICBmdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IodmFsKSB7CiAgICAgICAgbGV0IHJlcyA9ICIiOwogICAgICAgIGxldCBpID0gdmFsLmxlbmd0aDsKICAgICAgICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gIi0iID8gMSA6IDA7CiAgICAgICAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHsKICAgICAgICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YDsKICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aDIpIHsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBpZiAoYnVmW29mZnNldF0gPT09IHZvaWQgMCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aDJdID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoMiArIDEpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMikgewogICAgICAgIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgewogICAgICAgICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICJiaWdpbnQiID8gIm4iIDogIiI7CiAgICAgICAgICBsZXQgcmFuZ2U7CiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aDIgPiAzKSB7CiAgICAgICAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHsKICAgICAgICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoMiArIDEpICogOH0ke259YDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4IC0gMX0ke259YDsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWA7CiAgICAgICAgICB9CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoInZhbHVlIiwgcmFuZ2UsIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgyKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgbmFtZSkgewogICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICJudW1iZXIiLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJvdW5kc0Vycm9yKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHsKICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7CiAgICAgICAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSk7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAib2Zmc2V0IiwgImFuIGludGVnZXIiLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmIChsZW5ndGggPCAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAib2Zmc2V0IiwgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCwgdmFsdWUpOwogICAgICB9CiAgICAgIHZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2c7CiAgICAgIGZ1bmN0aW9uIGJhc2U2NGNsZWFuKHN0cikgewogICAgICAgIHN0ciA9IHN0ci5zcGxpdCgiPSIpWzBdOwogICAgICAgIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgIiIpOwogICAgICAgIGlmIChzdHIubGVuZ3RoIDwgMikKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHsKICAgICAgICAgIHN0ciA9IHN0ciArICI9IjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHN0cjsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHJpbmcsIHVuaXRzKSB7CiAgICAgICAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTsKICAgICAgICBsZXQgY29kZVBvaW50OwogICAgICAgIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7CiAgICAgICAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsOwogICAgICAgIGNvbnN0IGJ5dGVzID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgICBpZiAoY29kZVBvaW50ID4gNTUyOTUgJiYgY29kZVBvaW50IDwgNTczNDQpIHsKICAgICAgICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7CiAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDU2MzE5KSB7CiAgICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHsKICAgICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50OwogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCA1NjMyMCkgewogICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDU1Mjk2IDw8IDEwIHwgY29kZVBvaW50IC0gNTYzMjApICsgNjU1MzY7CiAgICAgICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICB9CiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDsKICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAxMjgpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMjA0OCkgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gNiB8IDE5MiwgY29kZVBvaW50ICYgNjMgfCAxMjgpOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCA2NTUzNikgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMTIgfCAyMjQsIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMTExNDExMikgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMTggfCAyNDAsIGNvZGVQb2ludCA+PiAxMiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgPj4gNiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29kZSBwb2ludCIpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZXM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikgewogICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDI1NSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlQXJyYXk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoc3RyLCB1bml0cykgewogICAgICAgIGxldCBjLCBoaSwgbG87CiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICAgIGhpID0gYyA+PiA4OwogICAgICAgICAgbG8gPSBjICUgMjU2OwogICAgICAgICAgYnl0ZUFycmF5LnB1c2gobG8pOwogICAgICAgICAgYnl0ZUFycmF5LnB1c2goaGkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZUFycmF5OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7CiAgICAgICAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGxldCBpOwogICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgaWYgKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCB8fCBpID49IHNyYy5sZW5ndGgpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpc0luc3RhbmNlKG9iaiwgdHlwZSkgewogICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8IG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBudW1iZXJJc05hTihvYmopIHsKICAgICAgICByZXR1cm4gb2JqICE9PSBvYmo7CiAgICAgIH0KICAgICAgdmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSBmdW5jdGlvbigpIHsKICAgICAgICBjb25zdCBhbHBoYWJldCA9ICIwMTIzNDU2Nzg5YWJjZGVmIjsKICAgICAgICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkgewogICAgICAgICAgY29uc3QgaTE2ID0gaSAqIDE2OwogICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7CiAgICAgICAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhYmxlOwogICAgICB9KCk7CiAgICAgIGZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZChmbikgewogICAgICAgIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAidW5kZWZpbmVkIiA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkKCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiQmlnSW50IG5vdCBzdXBwb3J0ZWQiKTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBzcmMvYWxpYXMvYnVmZmVyLXNoaW0uanMKICB2YXIgaW1wb3J0X2J1ZmZlcjsKICB2YXIgaW5pdF9idWZmZXJfc2hpbSA9IF9fZXNtKHsKICAgICJzcmMvYWxpYXMvYnVmZmVyLXNoaW0uanMiKCkgewogICAgICBpbXBvcnRfYnVmZmVyID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbEAxLjcuNS9ub2RlX21vZHVsZXMvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvY2pzLXBvbnlmaWxsLmpzCiAgdmFyIHJlcXVpcmVfY2pzX3BvbnlmaWxsID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbEAxLjcuNS9ub2RlX21vZHVsZXMvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvY2pzLXBvbnlmaWxsLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsKICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOwogICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOwogICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOwogICAgICAgICAgaWYgKCJ2YWx1ZSIgaW4gZGVzY3JpcHRvcikKICAgICAgICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsKICAgICAgICBpZiAocHJvdG9Qcm9wcykKICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7CiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsICJwcm90b3R5cGUiLCB7CiAgICAgICAgICB3cml0YWJsZTogZmFsc2UKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7CiAgICAgICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAiZnVuY3Rpb24iICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uIik7CiAgICAgICAgfQogICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgewogICAgICAgICAgY29uc3RydWN0b3I6IHsKICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCAicHJvdG90eXBlIiwgewogICAgICAgICAgd3JpdGFibGU6IGZhbHNlCiAgICAgICAgfSk7CiAgICAgICAgaWYgKHN1cGVyQ2xhc3MpCiAgICAgICAgICBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7CiAgICAgICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZjIobzIpIHsKICAgICAgICAgIHJldHVybiBvMi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8yKTsKICAgICAgICB9OwogICAgICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsKICAgICAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mMihvMiwgcDIpIHsKICAgICAgICAgIG8yLl9fcHJvdG9fXyA9IHAyOwogICAgICAgICAgcmV0dXJuIG8yOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgewogICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gInVuZGVmaW5lZCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB0cnkgewogICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHsKICAgICAgICAgIH0pKTsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmMikgewogICAgICAgIGlmIChzZWxmMiA9PT0gdm9pZCAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZCIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gc2VsZjI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZjIsIGNhbGwpIHsKICAgICAgICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09ICJvYmplY3QiIHx8IHR5cGVvZiBjYWxsID09PSAiZnVuY3Rpb24iKSkgewogICAgICAgICAgcmV0dXJuIGNhbGw7CiAgICAgICAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYyKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgewogICAgICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOwogICAgICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsKICAgICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OwogICAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsKICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsKICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsKICAgICAgICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgewogICAgICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7CiAgICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKQogICAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9iamVjdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBfZ2V0KCkgewogICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gInVuZGVmaW5lZCIgJiYgUmVmbGVjdC5nZXQpIHsKICAgICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0Mih0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgewogICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOwogICAgICAgICAgICBpZiAoIWJhc2UpCiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOwogICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHsKICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTsKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH0KICAgICAgdmFyIEVtaXR0ZXIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgZnVuY3Rpb24gRW1pdHRlcjIoKSB7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW1pdHRlcjIpOwogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJsaXN0ZW5lcnMiLCB7CiAgICAgICAgICAgIHZhbHVlOiB7fSwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhFbWl0dGVyMiwgW3sKICAgICAgICAgIGtleTogImFkZEV2ZW50TGlzdGVuZXIiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsKICAgICAgICAgICAgaWYgKCEodHlwZSBpbiB0aGlzLmxpc3RlbmVycykpIHsKICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2goewogICAgICAgICAgICAgIGNhbGxiYWNrLAogICAgICAgICAgICAgIG9wdGlvbnMKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykgewogICAgICAgICAgICBpZiAoISh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgewogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmxpc3RlbmVyc1t0eXBlXTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFjay5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgICBpZiAoc3RhY2tbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7CiAgICAgICAgICAgICAgICBzdGFjay5zcGxpY2UoaSwgMSk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZGlzcGF0Y2hFdmVudCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudCkgewogICAgICAgICAgICBpZiAoIShldmVudC50eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgewogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXTsKICAgICAgICAgICAgdmFyIHN0YWNrVG9DYWxsID0gc3RhY2suc2xpY2UoKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFja1RvQ2FsbC5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBzdGFja1RvQ2FsbFtpXTsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2suY2FsbCh0aGlzLCBldmVudCk7CiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgZTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAobGlzdGVuZXIub3B0aW9ucyAmJiBsaXN0ZW5lci5vcHRpb25zLm9uY2UpIHsKICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudC50eXBlLCBsaXN0ZW5lci5jYWxsYmFjayk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEVtaXR0ZXIyOwogICAgICB9KCk7CiAgICAgIHZhciBBYm9ydFNpZ25hbCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihfRW1pdHRlcikgewogICAgICAgIF9pbmhlcml0cyhBYm9ydFNpZ25hbDIsIF9FbWl0dGVyKTsKICAgICAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEFib3J0U2lnbmFsMik7CiAgICAgICAgZnVuY3Rpb24gQWJvcnRTaWduYWwyKCkgewogICAgICAgICAgdmFyIF90aGlzOwogICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFib3J0U2lnbmFsMik7CiAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpOwogICAgICAgICAgaWYgKCFfdGhpcy5saXN0ZW5lcnMpIHsKICAgICAgICAgICAgRW1pdHRlci5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTsKICAgICAgICAgIH0KICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgImFib3J0ZWQiLCB7CiAgICAgICAgICAgIHZhbHVlOiBmYWxzZSwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICJvbmFib3J0IiwgewogICAgICAgICAgICB2YWx1ZTogbnVsbCwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICJyZWFzb24iLCB7CiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDAsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0pOwogICAgICAgICAgcmV0dXJuIF90aGlzOwogICAgICAgIH0KICAgICAgICBfY3JlYXRlQ2xhc3MoQWJvcnRTaWduYWwyLCBbewogICAgICAgICAga2V5OiAidG9TdHJpbmciLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gIltvYmplY3QgQWJvcnRTaWduYWxdIjsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAiYWJvcnQiKSB7CiAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTsKICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub25hYm9ydCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICAgICAgdGhpcy5vbmFib3J0LmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihBYm9ydFNpZ25hbDIucHJvdG90eXBlKSwgImRpc3BhdGNoRXZlbnQiLCB0aGlzKS5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEFib3J0U2lnbmFsMjsKICAgICAgfShFbWl0dGVyKTsKICAgICAgdmFyIEFib3J0Q29udHJvbGxlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBBYm9ydENvbnRyb2xsZXIyKCkgewogICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFib3J0Q29udHJvbGxlcjIpOwogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJzaWduYWwiLCB7CiAgICAgICAgICAgIHZhbHVlOiBuZXcgQWJvcnRTaWduYWwoKSwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhBYm9ydENvbnRyb2xsZXIyLCBbewogICAgICAgICAga2V5OiAiYWJvcnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KHJlYXNvbikgewogICAgICAgICAgICB2YXIgZXZlbnQ7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnQoImFib3J0Iik7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5jcmVhdGVFdmVudCkgewogICAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7CiAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSAiYWJvcnQiOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgiRXZlbnQiKTsKICAgICAgICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCJhYm9ydCIsIGZhbHNlLCBmYWxzZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGV2ZW50ID0gewogICAgICAgICAgICAgICAgICB0eXBlOiAiYWJvcnQiLAogICAgICAgICAgICAgICAgICBidWJibGVzOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzaWduYWxSZWFzb24gPSByZWFzb247CiAgICAgICAgICAgIGlmIChzaWduYWxSZWFzb24gPT09IHZvaWQgMCkgewogICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRXJyb3IoIlRoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkIik7CiAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24ubmFtZSA9ICJBYm9ydEVycm9yIjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgc2lnbmFsUmVhc29uID0gbmV3IERPTUV4Y2VwdGlvbigic2lnbmFsIGlzIGFib3J0ZWQgd2l0aG91dCByZWFzb24iKTsKICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRXJyb3IoIlRoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkIik7CiAgICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbi5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnNpZ25hbC5yZWFzb24gPSBzaWduYWxSZWFzb247CiAgICAgICAgICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInRvU3RyaW5nIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHsKICAgICAgICAgICAgcmV0dXJuICJbb2JqZWN0IEFib3J0Q29udHJvbGxlcl0iOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gQWJvcnRDb250cm9sbGVyMjsKICAgICAgfSgpOwogICAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gInVuZGVmaW5lZCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7CiAgICAgICAgQWJvcnRDb250cm9sbGVyLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID0gIkFib3J0Q29udHJvbGxlciI7CiAgICAgICAgQWJvcnRTaWduYWwucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAiQWJvcnRTaWduYWwiOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvbHlmaWxsTmVlZGVkKHNlbGYyKSB7CiAgICAgICAgaWYgKHNlbGYyLl9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKCJfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMPXRydWUgaXMgc2V0LCB3aWxsIGZvcmNlIGluc3RhbGwgcG9seWZpbGwiKTsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdHlwZW9mIHNlbGYyLlJlcXVlc3QgPT09ICJmdW5jdGlvbiIgJiYgIXNlbGYyLlJlcXVlc3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KCJzaWduYWwiKSB8fCAhc2VsZjIuQWJvcnRDb250cm9sbGVyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFib3J0YWJsZUZldGNoRGVjb3JhdG9yKHBhdGNoVGFyZ2V0cykgewogICAgICAgIGlmICh0eXBlb2YgcGF0Y2hUYXJnZXRzID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBwYXRjaFRhcmdldHMgPSB7CiAgICAgICAgICAgIGZldGNoOiBwYXRjaFRhcmdldHMKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIHZhciBfcGF0Y2hUYXJnZXRzID0gcGF0Y2hUYXJnZXRzLCBmZXRjaCA9IF9wYXRjaFRhcmdldHMuZmV0Y2gsIF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMuUmVxdWVzdCwgTmF0aXZlUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9PT0gdm9pZCAwID8gZmV0Y2guUmVxdWVzdCA6IF9wYXRjaFRhcmdldHMkUmVxdWVzdCwgTmF0aXZlQWJvcnRDb250cm9sbGVyID0gX3BhdGNoVGFyZ2V0cy5BYm9ydENvbnRyb2xsZXIsIF9wYXRjaFRhcmdldHMkX19GT1JDRSA9IF9wYXRjaFRhcmdldHMuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCwgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCA9IF9wYXRjaFRhcmdldHMkX19GT1JDRSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0U7CiAgICAgICAgaWYgKCFwb2x5ZmlsbE5lZWRlZCh7CiAgICAgICAgICBmZXRjaCwKICAgICAgICAgIFJlcXVlc3Q6IE5hdGl2ZVJlcXVlc3QsCiAgICAgICAgICBBYm9ydENvbnRyb2xsZXI6IE5hdGl2ZUFib3J0Q29udHJvbGxlciwKICAgICAgICAgIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwKICAgICAgICB9KSkgewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgZmV0Y2gsCiAgICAgICAgICAgIFJlcXVlc3QKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIHZhciBSZXF1ZXN0ID0gTmF0aXZlUmVxdWVzdDsKICAgICAgICBpZiAoUmVxdWVzdCAmJiAhUmVxdWVzdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoInNpZ25hbCIpIHx8IF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwpIHsKICAgICAgICAgIFJlcXVlc3QgPSBmdW5jdGlvbiBSZXF1ZXN0MihpbnB1dCwgaW5pdDIpIHsKICAgICAgICAgICAgdmFyIHNpZ25hbDsKICAgICAgICAgICAgaWYgKGluaXQyICYmIGluaXQyLnNpZ25hbCkgewogICAgICAgICAgICAgIHNpZ25hbCA9IGluaXQyLnNpZ25hbDsKICAgICAgICAgICAgICBkZWxldGUgaW5pdDIuc2lnbmFsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IE5hdGl2ZVJlcXVlc3QoaW5wdXQsIGluaXQyKTsKICAgICAgICAgICAgaWYgKHNpZ25hbCkgewogICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1ZXN0LCAic2lnbmFsIiwgewogICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLAogICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICAgICAgICAgICAgICB2YWx1ZTogc2lnbmFsCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7CiAgICAgICAgICB9OwogICAgICAgICAgUmVxdWVzdC5wcm90b3R5cGUgPSBOYXRpdmVSZXF1ZXN0LnByb3RvdHlwZTsKICAgICAgICB9CiAgICAgICAgdmFyIHJlYWxGZXRjaCA9IGZldGNoOwogICAgICAgIHZhciBhYm9ydGFibGVGZXRjaCA9IGZ1bmN0aW9uIGFib3J0YWJsZUZldGNoMihpbnB1dCwgaW5pdDIpIHsKICAgICAgICAgIHZhciBzaWduYWwgPSBSZXF1ZXN0ICYmIFJlcXVlc3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaW5wdXQpID8gaW5wdXQuc2lnbmFsIDogaW5pdDIgPyBpbml0Mi5zaWduYWwgOiB2b2lkIDA7CiAgICAgICAgICBpZiAoc2lnbmFsKSB7CiAgICAgICAgICAgIHZhciBhYm9ydEVycm9yOwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGFib3J0RXJyb3IgPSBuZXcgRE9NRXhjZXB0aW9uKCJBYm9ydGVkIiwgIkFib3J0RXJyb3IiKTsKICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgYWJvcnRFcnJvciA9IG5ldyBFcnJvcigiQWJvcnRlZCIpOwogICAgICAgICAgICAgIGFib3J0RXJyb3IubmFtZSA9ICJBYm9ydEVycm9yIjsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYWJvcnRFcnJvcik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGNhbmNlbGxhdGlvbiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKF8sIHJlamVjdCkgewogICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChhYm9ydEVycm9yKTsKICAgICAgICAgICAgICB9LCB7CiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBpZiAoaW5pdDIgJiYgaW5pdDIuc2lnbmFsKSB7CiAgICAgICAgICAgICAgZGVsZXRlIGluaXQyLnNpZ25hbDsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtjYW5jZWxsYXRpb24sIHJlYWxGZXRjaChpbnB1dCwgaW5pdDIpXSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVhbEZldGNoKGlucHV0LCBpbml0Mik7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gewogICAgICAgICAgZmV0Y2g6IGFib3J0YWJsZUZldGNoLAogICAgICAgICAgUmVxdWVzdAogICAgICAgIH07CiAgICAgIH0KICAgICAgZXhwb3J0czIuQWJvcnRDb250cm9sbGVyID0gQWJvcnRDb250cm9sbGVyOwogICAgICBleHBvcnRzMi5BYm9ydFNpZ25hbCA9IEFib3J0U2lnbmFsOwogICAgICBleHBvcnRzMi5hYm9ydGFibGVGZXRjaCA9IGFib3J0YWJsZUZldGNoRGVjb3JhdG9yOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vYWJvcnRhYmxlLXByb21pc2UtY2FjaGVAMS41LjAvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9hYm9ydGNvbnRyb2xsZXItcG9ueWZpbGwuanMKICB2YXIgcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYWJvcnRhYmxlLXByb21pc2UtY2FjaGVAMS41LjAvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9hYm9ydGNvbnRyb2xsZXItcG9ueWZpbGwuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuQWJvcnRTaWduYWwgPSBleHBvcnRzMi5BYm9ydENvbnRyb2xsZXIgPSB2b2lkIDA7CiAgICAgIHZhciBjanNfcG9ueWZpbGxfMSA9IHJlcXVpcmVfY2pzX3BvbnlmaWxsKCk7CiAgICAgIHZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbigpIHsKICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICByZXR1cm4gc2VsZjsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICByZXR1cm4gd2luZG93OwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiBnbG9iYWw7CiAgICAgICAgfQogICAgICAgIHRocm93IG5ldyBFcnJvcigidW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Iik7CiAgICAgIH07CiAgICAgIHZhciBBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyID09PSAidW5kZWZpbmVkIiA/IGNqc19wb255ZmlsbF8xLkFib3J0Q29udHJvbGxlciA6IGdldEdsb2JhbCgpLkFib3J0Q29udHJvbGxlcjsKICAgICAgZXhwb3J0czIuQWJvcnRDb250cm9sbGVyID0gQWJvcnRDb250cm9sbGVyOwogICAgICB2YXIgQWJvcnRTaWduYWwgPSB0eXBlb2YgZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyID09PSAidW5kZWZpbmVkIiA/IGNqc19wb255ZmlsbF8xLkFib3J0U2lnbmFsIDogZ2V0R2xvYmFsKCkuQWJvcnRTaWduYWw7CiAgICAgIGV4cG9ydHMyLkFib3J0U2lnbmFsID0gQWJvcnRTaWduYWw7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlci5qcwogIHZhciByZXF1aXJlX0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlci5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsXzEgPSByZXF1aXJlX2Fib3J0Y29udHJvbGxlcl9wb255ZmlsbCgpOwogICAgICB2YXIgTnVsbFNpZ25hbCA9IGNsYXNzIHsKICAgICAgfTsKICAgICAgdmFyIEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlciA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgIHRoaXMuc2lnbmFscyA9IG5ldyBTZXQoKTsKICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xLkFib3J0Q29udHJvbGxlcigpOwogICAgICAgIH0KICAgICAgICBhZGRTaWduYWwoc2lnbmFsID0gbmV3IE51bGxTaWduYWwoKSkgewogICAgICAgICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgYWRkIGEgc2lnbmFsLCBhbHJlYWR5IGFib3J0ZWQhIik7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLnNpZ25hbHMuYWRkKHNpZ25hbCk7CiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgdGhpcy5oYW5kbGVBYm9ydGVkKHNpZ25hbCk7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigiYWJvcnQiLCAoKSA9PiB7CiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBYm9ydGVkKHNpZ25hbCk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBoYW5kbGVBYm9ydGVkKHNpZ25hbCkgewogICAgICAgICAgdGhpcy5zaWduYWxzLmRlbGV0ZShzaWduYWwpOwogICAgICAgICAgaWYgKHRoaXMuc2lnbmFscy5zaXplID09PSAwKSB7CiAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdldCBzaWduYWwoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsOwogICAgICAgIH0KICAgICAgICBhYm9ydCgpIHsKICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gQWdncmVnYXRlQWJvcnRDb250cm9sbGVyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vYWJvcnRhYmxlLXByb21pc2UtY2FjaGVAMS41LjAvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlci5qcwogIHZhciByZXF1aXJlX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIEFnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyID0gY2xhc3MgewogICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBuZXcgU2V0KCk7CiAgICAgICAgfQogICAgICAgIGFkZENhbGxiYWNrKGNhbGxiYWNrID0gKCkgPT4gewogICAgICAgIH0pIHsKICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7CiAgICAgICAgICBjYWxsYmFjayh0aGlzLmN1cnJlbnRNZXNzYWdlKTsKICAgICAgICB9CiAgICAgICAgY2FsbGJhY2sobWVzc2FnZSkgewogICAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZSA9IG1lc3NhZ2U7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKChlbHQpID0+IHsKICAgICAgICAgICAgZWx0KG1lc3NhZ2UpOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcwogIHZhciByZXF1aXJlX0Fib3J0YWJsZVByb21pc2VDYWNoZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfX2ltcG9ydERlZmF1bHQgPSBleHBvcnRzMiAmJiBleHBvcnRzMi5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgImRlZmF1bHQiOiBtb2QgfTsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBhYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGxfMSA9IHJlcXVpcmVfYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsKCk7CiAgICAgIHZhciBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcigpKTsKICAgICAgdmFyIEFnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcigpKTsKICAgICAgdmFyIEFib3J0YWJsZVByb21pc2VDYWNoZTIgPSBjbGFzcyB7CiAgICAgICAgY29uc3RydWN0b3IoeyBmaWxsLCBjYWNoZSB9KSB7CiAgICAgICAgICBpZiAodHlwZW9mIGZpbGwgIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwYXNzIGEgZmlsbCBmdW5jdGlvbiIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiBjYWNoZSAhPT0gIm9iamVjdCIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwYXNzIGEgY2FjaGUgb2JqZWN0Iik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGNhY2hlLmdldCAhPT0gImZ1bmN0aW9uIiB8fCB0eXBlb2YgY2FjaGUuc2V0ICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBjYWNoZS5kZWxldGUgIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiY2FjaGUgbXVzdCBpbXBsZW1lbnQgZ2V0KGtleSksIHNldChrZXksIHZhbCksIGFuZCBhbmQgZGVsZXRlKGtleSkiKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTsKICAgICAgICAgIHRoaXMuZmlsbENhbGxiYWNrID0gZmlsbDsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGlzQWJvcnRFeGNlcHRpb24oZXhjZXB0aW9uKSB7CiAgICAgICAgICByZXR1cm4gZXhjZXB0aW9uLm5hbWUgPT09ICJBYm9ydEVycm9yIiB8fCBleGNlcHRpb24uY29kZSA9PT0gIkVSUl9BQk9SVEVEIiB8fCBleGNlcHRpb24ubWVzc2FnZSA9PT0gIkFib3J0RXJyb3I6IGFib3J0ZWQiIHx8IGV4Y2VwdGlvbi5tZXNzYWdlID09PSAiRXJyb3I6IGFib3J0ZWQiOwogICAgICAgIH0KICAgICAgICBldmljdChrZXksIGVudHJ5KSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5nZXQoa2V5KSA9PT0gZW50cnkpIHsKICAgICAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZmlsbChrZXksIGRhdGEsIHNpZ25hbCwgc3RhdHVzQ2FsbGJhY2spIHsKICAgICAgICAgIGNvbnN0IGFib3J0ZXIgPSBuZXcgQWdncmVnYXRlQWJvcnRDb250cm9sbGVyXzEuZGVmYXVsdCgpOwogICAgICAgICAgY29uc3Qgc3RhdHVzUmVwb3J0ZXIgPSBuZXcgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXJfMS5kZWZhdWx0KCk7CiAgICAgICAgICBzdGF0dXNSZXBvcnRlci5hZGRDYWxsYmFjayhzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICBjb25zdCBuZXdFbnRyeSA9IHsKICAgICAgICAgICAgYWJvcnRlciwKICAgICAgICAgICAgcHJvbWlzZTogdGhpcy5maWxsQ2FsbGJhY2soZGF0YSwgYWJvcnRlci5zaWduYWwsIChtZXNzYWdlKSA9PiB7CiAgICAgICAgICAgICAgc3RhdHVzUmVwb3J0ZXIuY2FsbGJhY2sobWVzc2FnZSk7CiAgICAgICAgICAgIH0pLAogICAgICAgICAgICBzZXR0bGVkOiBmYWxzZSwKICAgICAgICAgICAgc3RhdHVzUmVwb3J0ZXIsCiAgICAgICAgICAgIGdldCBhYm9ydGVkKCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmFib3J0ZXIuc2lnbmFsLmFib3J0ZWQ7CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgICBuZXdFbnRyeS5hYm9ydGVyLmFkZFNpZ25hbChzaWduYWwpOwogICAgICAgICAgbmV3RW50cnkuYWJvcnRlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigiYWJvcnQiLCAoKSA9PiB7CiAgICAgICAgICAgIGlmICghbmV3RW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgbmV3RW50cnkucHJvbWlzZS50aGVuKCgpID0+IHsKICAgICAgICAgICAgbmV3RW50cnkuc2V0dGxlZCA9IHRydWU7CiAgICAgICAgICB9LCAoKSA9PiB7CiAgICAgICAgICAgIG5ld0VudHJ5LnNldHRsZWQgPSB0cnVlOwogICAgICAgICAgICB0aGlzLmV2aWN0KGtleSwgbmV3RW50cnkpOwogICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHsKICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTsKICAgICAgICAgICAgdGhyb3cgZTsKICAgICAgICAgIH0pOwogICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBjaGVja1NpbmdsZVByb21pc2UocHJvbWlzZSwgc2lnbmFsKSB7CiAgICAgICAgICBmdW5jdGlvbiBjaGVja0ZvclNpbmdsZUFib3J0KCkgewogICAgICAgICAgICBpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7CiAgICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoImFib3J0ZWQiKSwgeyBjb2RlOiAiRVJSX0FCT1JURUQiIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChyZXN1bHQpID0+IHsKICAgICAgICAgICAgY2hlY2tGb3JTaW5nbGVBYm9ydCgpOwogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgICAgfSwgKGVycm9yKSA9PiB7CiAgICAgICAgICAgIGNoZWNrRm9yU2luZ2xlQWJvcnQoKTsKICAgICAgICAgICAgdGhyb3cgZXJyb3I7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgaGFzKGtleSkgewogICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSk7CiAgICAgICAgfQogICAgICAgIGdldChrZXksIGRhdGEsIHNpZ25hbCwgc3RhdHVzQ2FsbGJhY2spIHsKICAgICAgICAgIGlmICghc2lnbmFsICYmIGRhdGEgaW5zdGFuY2VvZiBhYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGxfMS5BYm9ydFNpZ25hbCkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJzZWNvbmQgZ2V0IGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYW4gQWJvcnRTaWduYWwsIHBlcmhhcHMgeW91IG1lYW50IHRvIHBhc3MgYG51bGxgIGZvciB0aGUgZmlsbCBkYXRhPyIpOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICBpZiAoY2FjaGVFbnRyeSkgewogICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5hYm9ydGVkICYmICFjYWNoZUVudHJ5LnNldHRsZWQpIHsKICAgICAgICAgICAgICB0aGlzLmV2aWN0KGtleSwgY2FjaGVFbnRyeSk7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5LnByb21pc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2FjaGVFbnRyeS5hYm9ydGVyLmFkZFNpZ25hbChzaWduYWwpOwogICAgICAgICAgICBjYWNoZUVudHJ5LnN0YXR1c1JlcG9ydGVyLmFkZENhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgICAgcmV0dXJuIEFib3J0YWJsZVByb21pc2VDYWNoZTIuY2hlY2tTaW5nbGVQcm9taXNlKGNhY2hlRW50cnkucHJvbWlzZSwgc2lnbmFsKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuZmlsbChrZXksIGRhdGEsIHNpZ25hbCwgc3RhdHVzQ2FsbGJhY2spOwogICAgICAgICAgcmV0dXJuIEFib3J0YWJsZVByb21pc2VDYWNoZTIuY2hlY2tTaW5nbGVQcm9taXNlKHRoaXMuY2FjaGUuZ2V0KGtleSkucHJvbWlzZSwgc2lnbmFsKTsKICAgICAgICB9CiAgICAgICAgZGVsZXRlKGtleSkgewogICAgICAgICAgY29uc3QgY2FjaGVkRW50cnkgPSB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgaWYgKGNhY2hlZEVudHJ5KSB7CiAgICAgICAgICAgIGlmICghY2FjaGVkRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIGNhY2hlZEVudHJ5LmFib3J0ZXIuYWJvcnQoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjbGVhcigpIHsKICAgICAgICAgIGNvbnN0IGtleUl0ZXIgPSB0aGlzLmNhY2hlLmtleXMoKTsKICAgICAgICAgIGxldCBkZWxldGVDb3VudCA9IDA7CiAgICAgICAgICBmb3IgKGxldCByZXN1bHQgPSBrZXlJdGVyLm5leHQoKTsgIXJlc3VsdC5kb25lOyByZXN1bHQgPSBrZXlJdGVyLm5leHQoKSkgewogICAgICAgICAgICB0aGlzLmRlbGV0ZShyZXN1bHQudmFsdWUpOwogICAgICAgICAgICBkZWxldGVDb3VudCArPSAxOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGRlbGV0ZUNvdW50OwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IEFib3J0YWJsZVByb21pc2VDYWNoZTI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfZXNtID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX19pbXBvcnREZWZhdWx0ID0gZXhwb3J0czIgJiYgZXhwb3J0czIuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKG1vZCkgewogICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7ICJkZWZhdWx0IjogbW9kIH07CiAgICAgIH07CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgQWJvcnRhYmxlUHJvbWlzZUNhY2hlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9BYm9ydGFibGVQcm9taXNlQ2FjaGUoKSk7CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSBBYm9ydGFibGVQcm9taXNlQ2FjaGVfMS5kZWZhdWx0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcXVpY2stbHJ1QDQuMC4xL25vZGVfbW9kdWxlcy9xdWljay1scnUvaW5kZXguanMKICB2YXIgcmVxdWlyZV9xdWlja19scnUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcXVpY2stbHJ1QDQuMC4xL25vZGVfbW9kdWxlcy9xdWljay1scnUvaW5kZXguanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgUXVpY2tMUlUgPSBjbGFzcyB7CiAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7CiAgICAgICAgICBpZiAoIShvcHRpb25zLm1heFNpemUgJiYgb3B0aW9ucy5tYXhTaXplID4gMCkpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiYG1heFNpemVgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAiKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMubWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZTsKICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB0aGlzLm9sZENhY2hlID0gbmV3IE1hcCgpOwogICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICAgICAgfQogICAgICAgIF9zZXQoa2V5LCB2YWx1ZSkgewogICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICB0aGlzLl9zaXplKys7CiAgICAgICAgICBpZiAodGhpcy5fc2l6ZSA+PSB0aGlzLm1heFNpemUpIHsKICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICAgICAgICAgIHRoaXMub2xkQ2FjaGUgPSB0aGlzLmNhY2hlOwogICAgICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBnZXQoa2V5KSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5vbGRDYWNoZS5nZXQoa2V5KTsKICAgICAgICAgICAgdGhpcy5vbGRDYWNoZS5kZWxldGUoa2V5KTsKICAgICAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHNldChrZXksIHZhbHVlKSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMuX3NldChrZXksIHZhbHVlKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICBoYXMoa2V5KSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KSB8fCB0aGlzLm9sZENhY2hlLmhhcyhrZXkpOwogICAgICAgIH0KICAgICAgICBwZWVrKGtleSkgewogICAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5vbGRDYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZGVsZXRlKGtleSkgewogICAgICAgICAgY29uc3QgZGVsZXRlZCA9IHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7CiAgICAgICAgICBpZiAoZGVsZXRlZCkgewogICAgICAgICAgICB0aGlzLl9zaXplLS07CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpcy5vbGRDYWNoZS5kZWxldGUoa2V5KSB8fCBkZWxldGVkOwogICAgICAgIH0KICAgICAgICBjbGVhcigpIHsKICAgICAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTsKICAgICAgICAgIHRoaXMub2xkQ2FjaGUuY2xlYXIoKTsKICAgICAgICAgIHRoaXMuX3NpemUgPSAwOwogICAgICAgIH0KICAgICAgICAqa2V5cygpIHsKICAgICAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgdGhpcykgewogICAgICAgICAgICB5aWVsZCBrZXk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgICp2YWx1ZXMoKSB7CiAgICAgICAgICBmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiB0aGlzKSB7CiAgICAgICAgICAgIHlpZWxkIHZhbHVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7CiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5jYWNoZSkgewogICAgICAgICAgICB5aWVsZCBpdGVtOwogICAgICAgICAgfQogICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMub2xkQ2FjaGUpIHsKICAgICAgICAgICAgY29uc3QgW2tleV0gPSBpdGVtOwogICAgICAgICAgICBpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgICB5aWVsZCBpdGVtOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdldCBzaXplKCkgewogICAgICAgICAgbGV0IG9sZENhY2hlU2l6ZSA9IDA7CiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLm9sZENhY2hlLmtleXMoKSkgewogICAgICAgICAgICBpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgICBvbGRDYWNoZVNpemUrKzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemUgKyBvbGRDYWNoZVNpemU7CiAgICAgICAgfQogICAgICB9OwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBRdWlja0xSVTsKICAgIH0KICB9KTsKCiAgLy8gKGRpc2FibGVkKTpub2RlX21vZHVsZXMvLnBucG0vZ2VuZXJpYy1maWxlaGFuZGxlQDMuMS4xL25vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2xvY2FsRmlsZQogIHZhciByZXF1aXJlX2xvY2FsRmlsZSA9IF9fY29tbW9uSlMoewogICAgIihkaXNhYmxlZCk6bm9kZV9tb2R1bGVzLy5wbnBtL2dlbmVyaWMtZmlsZWhhbmRsZUAzLjEuMS9ub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9sb2NhbEZpbGUiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzCiAgdmFyIHJlcXVpcmVfY29tbW9uID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgVFlQRURfT0sgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIFVpbnQxNkFycmF5ICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgSW50MzJBcnJheSAhPT0gInVuZGVmaW5lZCI7CiAgICAgIGZ1bmN0aW9uIF9oYXMob2JqLCBrZXkpIHsKICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTsKICAgICAgfQogICAgICBleHBvcnRzMi5hc3NpZ24gPSBmdW5jdGlvbihvYmopIHsKICAgICAgICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7CiAgICAgICAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7CiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpOwogICAgICAgICAgaWYgKCFzb3VyY2UpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gIm9iamVjdCIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAibXVzdCBiZSBub24tb2JqZWN0Iik7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciBwIGluIHNvdXJjZSkgewogICAgICAgICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7CiAgICAgICAgICAgICAgb2JqW3BdID0gc291cmNlW3BdOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBvYmo7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLnNocmlua0J1ZiA9IGZ1bmN0aW9uKGJ1Ziwgc2l6ZSkgewogICAgICAgIGlmIChidWYubGVuZ3RoID09PSBzaXplKSB7CiAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgIH0KICAgICAgICBpZiAoYnVmLnN1YmFycmF5KSB7CiAgICAgICAgICByZXR1cm4gYnVmLnN1YmFycmF5KDAsIHNpemUpOwogICAgICAgIH0KICAgICAgICBidWYubGVuZ3RoID0gc2l6ZTsKICAgICAgICByZXR1cm4gYnVmOwogICAgICB9OwogICAgICB2YXIgZm5UeXBlZCA9IHsKICAgICAgICBhcnJheVNldDogZnVuY3Rpb24oZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHsKICAgICAgICAgIGlmIChzcmMuc3ViYXJyYXkgJiYgZGVzdC5zdWJhcnJheSkgewogICAgICAgICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihjaHVua3MpIHsKICAgICAgICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDsKICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7CiAgICAgICAgICBwb3MgPSAwOwogICAgICAgICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgY2h1bmsgPSBjaHVua3NbaV07CiAgICAgICAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7CiAgICAgICAgICAgIHBvcyArPSBjaHVuay5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgfTsKICAgICAgdmFyIGZuVW50eXBlZCA9IHsKICAgICAgICBhcnJheVNldDogZnVuY3Rpb24oZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24oY2h1bmtzKSB7CiAgICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0czIuc2V0VHlwZWQgPSBmdW5jdGlvbihvbikgewogICAgICAgIGlmIChvbikgewogICAgICAgICAgZXhwb3J0czIuQnVmOCA9IFVpbnQ4QXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5CdWYxNiA9IFVpbnQxNkFycmF5OwogICAgICAgICAgZXhwb3J0czIuQnVmMzIgPSBJbnQzMkFycmF5OwogICAgICAgICAgZXhwb3J0czIuYXNzaWduKGV4cG9ydHMyLCBmblR5cGVkKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZXhwb3J0czIuQnVmOCA9IEFycmF5OwogICAgICAgICAgZXhwb3J0czIuQnVmMTYgPSBBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjMyID0gQXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5hc3NpZ24oZXhwb3J0czIsIGZuVW50eXBlZCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5zZXRUeXBlZChUWVBFRF9PSyk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcwogIHZhciByZXF1aXJlX3RyZWVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIFpfRklYRUQgPSA0OwogICAgICB2YXIgWl9CSU5BUlkgPSAwOwogICAgICB2YXIgWl9URVhUID0gMTsKICAgICAgdmFyIFpfVU5LTk9XTiA9IDI7CiAgICAgIGZ1bmN0aW9uIHplcm8oYnVmKSB7CiAgICAgICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgd2hpbGUgKC0tbGVuID49IDApIHsKICAgICAgICAgIGJ1ZltsZW5dID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgdmFyIFNUT1JFRF9CTE9DSyA9IDA7CiAgICAgIHZhciBTVEFUSUNfVFJFRVMgPSAxOwogICAgICB2YXIgRFlOX1RSRUVTID0gMjsKICAgICAgdmFyIE1JTl9NQVRDSCA9IDM7CiAgICAgIHZhciBNQVhfTUFUQ0ggPSAyNTg7CiAgICAgIHZhciBMRU5HVEhfQ09ERVMgPSAyOTsKICAgICAgdmFyIExJVEVSQUxTID0gMjU2OwogICAgICB2YXIgTF9DT0RFUyA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUzsKICAgICAgdmFyIERfQ09ERVMgPSAzMDsKICAgICAgdmFyIEJMX0NPREVTID0gMTk7CiAgICAgIHZhciBIRUFQX1NJWkUgPSAyICogTF9DT0RFUyArIDE7CiAgICAgIHZhciBNQVhfQklUUyA9IDE1OwogICAgICB2YXIgQnVmX3NpemUgPSAxNjsKICAgICAgdmFyIE1BWF9CTF9CSVRTID0gNzsKICAgICAgdmFyIEVORF9CTE9DSyA9IDI1NjsKICAgICAgdmFyIFJFUF8zXzYgPSAxNjsKICAgICAgdmFyIFJFUFpfM18xMCA9IDE3OwogICAgICB2YXIgUkVQWl8xMV8xMzggPSAxODsKICAgICAgdmFyIGV4dHJhX2xiaXRzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDBdOwogICAgICB2YXIgZXh0cmFfZGJpdHMgPSBbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzXTsKICAgICAgdmFyIGV4dHJhX2JsYml0cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAyLCAzLCA3XTsKICAgICAgdmFyIGJsX29yZGVyID0gWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdOwogICAgICB2YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsKICAgICAgdmFyIHN0YXRpY19sdHJlZSA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7CiAgICAgIHplcm8oc3RhdGljX2x0cmVlKTsKICAgICAgdmFyIHN0YXRpY19kdHJlZSA9IG5ldyBBcnJheShEX0NPREVTICogMik7CiAgICAgIHplcm8oc3RhdGljX2R0cmVlKTsKICAgICAgdmFyIF9kaXN0X2NvZGUgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7CiAgICAgIHplcm8oX2Rpc3RfY29kZSk7CiAgICAgIHZhciBfbGVuZ3RoX2NvZGUgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7CiAgICAgIHplcm8oX2xlbmd0aF9jb2RlKTsKICAgICAgdmFyIGJhc2VfbGVuZ3RoID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7CiAgICAgIHplcm8oYmFzZV9sZW5ndGgpOwogICAgICB2YXIgYmFzZV9kaXN0ID0gbmV3IEFycmF5KERfQ09ERVMpOwogICAgICB6ZXJvKGJhc2VfZGlzdCk7CiAgICAgIGZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkgewogICAgICAgIHRoaXMuc3RhdGljX3RyZWUgPSBzdGF0aWNfdHJlZTsKICAgICAgICB0aGlzLmV4dHJhX2JpdHMgPSBleHRyYV9iaXRzOwogICAgICAgIHRoaXMuZXh0cmFfYmFzZSA9IGV4dHJhX2Jhc2U7CiAgICAgICAgdGhpcy5lbGVtcyA9IGVsZW1zOwogICAgICAgIHRoaXMubWF4X2xlbmd0aCA9IG1heF9sZW5ndGg7CiAgICAgICAgdGhpcy5oYXNfc3RyZWUgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7CiAgICAgIH0KICAgICAgdmFyIHN0YXRpY19sX2Rlc2M7CiAgICAgIHZhciBzdGF0aWNfZF9kZXNjOwogICAgICB2YXIgc3RhdGljX2JsX2Rlc2M7CiAgICAgIGZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHsKICAgICAgICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7CiAgICAgICAgdGhpcy5tYXhfY29kZSA9IDA7CiAgICAgICAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHsKICAgICAgICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHcgJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSB3ID4+PiA4ICYgMjU1OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKHMuYmlfdmFsaWQgPiBCdWZfc2l6ZSAtIGxlbmd0aCkgewogICAgICAgICAgcy5iaV9idWYgfD0gdmFsdWUgPDwgcy5iaV92YWxpZCAmIDY1NTM1OwogICAgICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgICAgICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gQnVmX3NpemUgLSBzLmJpX3ZhbGlkOwogICAgICAgICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcy5iaV9idWYgfD0gdmFsdWUgPDwgcy5iaV92YWxpZCAmIDY1NTM1OwogICAgICAgICAgcy5iaV92YWxpZCArPSBsZW5ndGg7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7CiAgICAgICAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLCB0cmVlW2MgKiAyICsgMV0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7CiAgICAgICAgdmFyIHJlcyA9IDA7CiAgICAgICAgZG8gewogICAgICAgICAgcmVzIHw9IGNvZGUgJiAxOwogICAgICAgICAgY29kZSA+Pj49IDE7CiAgICAgICAgICByZXMgPDw9IDE7CiAgICAgICAgfSB3aGlsZSAoLS1sZW4gPiAwKTsKICAgICAgICByZXR1cm4gcmVzID4+PiAxOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHsKICAgICAgICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHsKICAgICAgICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7CiAgICAgICAgICBzLmJpX2J1ZiA9IDA7CiAgICAgICAgICBzLmJpX3ZhbGlkID0gMDsKICAgICAgICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkgewogICAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDI1NTsKICAgICAgICAgIHMuYmlfYnVmID4+PSA4OwogICAgICAgICAgcy5iaV92YWxpZCAtPSA4OwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpIHsKICAgICAgICB2YXIgdHJlZSA9IGRlc2MuZHluX3RyZWU7CiAgICAgICAgdmFyIG1heF9jb2RlID0gZGVzYy5tYXhfY29kZTsKICAgICAgICB2YXIgc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTsKICAgICAgICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlOwogICAgICAgIHZhciBleHRyYSA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7CiAgICAgICAgdmFyIGJhc2UgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlOwogICAgICAgIHZhciBtYXhfbGVuZ3RoID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDsKICAgICAgICB2YXIgaDsKICAgICAgICB2YXIgbiwgbTsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgeGJpdHM7CiAgICAgICAgdmFyIGY7CiAgICAgICAgdmFyIG92ZXJmbG93ID0gMDsKICAgICAgICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHsKICAgICAgICAgIHMuYmxfY291bnRbYml0c10gPSAwOwogICAgICAgIH0KICAgICAgICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXSA9IDA7CiAgICAgICAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykgewogICAgICAgICAgbiA9IHMuaGVhcFtoXTsKICAgICAgICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXSAqIDIgKyAxXSArIDE7CiAgICAgICAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHsKICAgICAgICAgICAgYml0cyA9IG1heF9sZW5ndGg7CiAgICAgICAgICAgIG92ZXJmbG93Kys7CiAgICAgICAgICB9CiAgICAgICAgICB0cmVlW24gKiAyICsgMV0gPSBiaXRzOwogICAgICAgICAgaWYgKG4gPiBtYXhfY29kZSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHMuYmxfY291bnRbYml0c10rKzsKICAgICAgICAgIHhiaXRzID0gMDsKICAgICAgICAgIGlmIChuID49IGJhc2UpIHsKICAgICAgICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07CiAgICAgICAgICB9CiAgICAgICAgICBmID0gdHJlZVtuICogMl07CiAgICAgICAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpOwogICAgICAgICAgaWYgKGhhc19zdHJlZSkgewogICAgICAgICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdICsgeGJpdHMpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAob3ZlcmZsb3cgPT09IDApIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZG8gewogICAgICAgICAgYml0cyA9IG1heF9sZW5ndGggLSAxOwogICAgICAgICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsKICAgICAgICAgICAgYml0cy0tOwogICAgICAgICAgfQogICAgICAgICAgcy5ibF9jb3VudFtiaXRzXS0tOwogICAgICAgICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsKICAgICAgICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTsKICAgICAgICAgIG92ZXJmbG93IC09IDI7CiAgICAgICAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTsKICAgICAgICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHsKICAgICAgICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdOwogICAgICAgICAgd2hpbGUgKG4gIT09IDApIHsKICAgICAgICAgICAgbSA9IHMuaGVhcFstLWhdOwogICAgICAgICAgICBpZiAobSA+IG1heF9jb2RlKSB7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXSAhPT0gYml0cykgewogICAgICAgICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXSkgKiB0cmVlW20gKiAyXTsKICAgICAgICAgICAgICB0cmVlW20gKiAyICsgMV0gPSBiaXRzOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG4tLTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudCkgewogICAgICAgIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsKICAgICAgICB2YXIgY29kZSA9IDA7CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIG47CiAgICAgICAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7CiAgICAgICAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSA8PCAxOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV07CiAgICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgdHJlZVtuICogMl0gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkgewogICAgICAgIHZhciBuOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciBsZW5ndGg7CiAgICAgICAgdmFyIGNvZGU7CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7CiAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7CiAgICAgICAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDsKICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAxIDw8IGV4dHJhX2xiaXRzW2NvZGVdOyBuKyspIHsKICAgICAgICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7CiAgICAgICAgZGlzdCA9IDA7CiAgICAgICAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHsKICAgICAgICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7CiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgMSA8PCBleHRyYV9kYml0c1tjb2RlXTsgbisrKSB7CiAgICAgICAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGRpc3QgPj49IDc7CiAgICAgICAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHsKICAgICAgICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNzsKICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAxIDw8IGV4dHJhX2RiaXRzW2NvZGVdIC0gNzsgbisrKSB7CiAgICAgICAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykgewogICAgICAgICAgYmxfY291bnRbYml0c10gPSAwOwogICAgICAgIH0KICAgICAgICBuID0gMDsKICAgICAgICB3aGlsZSAobiA8PSAxNDMpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gODsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzhdKys7CiAgICAgICAgfQogICAgICAgIHdoaWxlIChuIDw9IDI1NSkgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA5OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbOV0rKzsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKG4gPD0gMjc5KSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDc7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs3XSsrOwogICAgICAgIH0KICAgICAgICB3aGlsZSAobiA8PSAyODcpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gODsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzhdKys7CiAgICAgICAgfQogICAgICAgIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7CiAgICAgICAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykgewogICAgICAgICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0gPSA1OwogICAgICAgICAgc3RhdGljX2R0cmVlW24gKiAyXSA9IGJpX3JldmVyc2UobiwgNSk7CiAgICAgICAgfQogICAgICAgIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7CiAgICAgICAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCBEX0NPREVTLCBNQVhfQklUUyk7CiAgICAgICAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7IG4rKykgewogICAgICAgICAgcy5keW5fbHRyZWVbbiAqIDJdID0gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykgewogICAgICAgICAgcy5keW5fZHRyZWVbbiAqIDJdID0gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsKICAgICAgICAgIHMuYmxfdHJlZVtuICogMl0gPSAwOwogICAgICAgIH0KICAgICAgICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXSA9IDE7CiAgICAgICAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDsKICAgICAgICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBiaV93aW5kdXAocykgewogICAgICAgIGlmIChzLmJpX3ZhbGlkID4gOCkgewogICAgICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgICAgICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7CiAgICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmOwogICAgICAgIH0KICAgICAgICBzLmJpX2J1ZiA9IDA7CiAgICAgICAgcy5iaV92YWxpZCA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKSB7CiAgICAgICAgYmlfd2luZHVwKHMpOwogICAgICAgIGlmIChoZWFkZXIpIHsKICAgICAgICAgIHB1dF9zaG9ydChzLCBsZW4pOwogICAgICAgICAgcHV0X3Nob3J0KHMsIH5sZW4pOwogICAgICAgIH0KICAgICAgICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7CiAgICAgICAgcy5wZW5kaW5nICs9IGxlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7CiAgICAgICAgdmFyIF9uMiA9IG4gKiAyOwogICAgICAgIHZhciBfbTIgPSBtICogMjsKICAgICAgICByZXR1cm4gdHJlZVtfbjJdIDwgdHJlZVtfbTJdIHx8IHRyZWVbX24yXSA9PT0gdHJlZVtfbTJdICYmIGRlcHRoW25dIDw9IGRlcHRoW21dOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaykgewogICAgICAgIHZhciB2ID0gcy5oZWFwW2tdOwogICAgICAgIHZhciBqID0gayA8PCAxOwogICAgICAgIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHsKICAgICAgICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJiBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsKICAgICAgICAgICAgaisrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTsKICAgICAgICAgIGsgPSBqOwogICAgICAgICAgaiA8PD0gMTsKICAgICAgICB9CiAgICAgICAgcy5oZWFwW2tdID0gdjsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpIHsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgbGM7CiAgICAgICAgdmFyIGx4ID0gMDsKICAgICAgICB2YXIgY29kZTsKICAgICAgICB2YXIgZXh0cmE7CiAgICAgICAgaWYgKHMubGFzdF9saXQgIT09IDApIHsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgZGlzdCA9IHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCB8IHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdOwogICAgICAgICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTsKICAgICAgICAgICAgbHgrKzsKICAgICAgICAgICAgaWYgKGRpc3QgPT09IDApIHsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOwogICAgICAgICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07CiAgICAgICAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7CiAgICAgICAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTsKICAgICAgICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBkaXN0LS07CiAgICAgICAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOwogICAgICAgICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07CiAgICAgICAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7CiAgICAgICAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTsKICAgICAgICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpOwogICAgICAgIH0KICAgICAgICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKSB7CiAgICAgICAgdmFyIHRyZWUgPSBkZXNjLmR5bl90cmVlOwogICAgICAgIHZhciBzdHJlZSA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlOwogICAgICAgIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7CiAgICAgICAgdmFyIGVsZW1zID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7CiAgICAgICAgdmFyIG4sIG07CiAgICAgICAgdmFyIG1heF9jb2RlID0gLTE7CiAgICAgICAgdmFyIG5vZGU7CiAgICAgICAgcy5oZWFwX2xlbiA9IDA7CiAgICAgICAgcy5oZWFwX21heCA9IEhFQVBfU0laRTsKICAgICAgICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykgewogICAgICAgICAgaWYgKHRyZWVbbiAqIDJdICE9PSAwKSB7CiAgICAgICAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuOwogICAgICAgICAgICBzLmRlcHRoW25dID0gMDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHdoaWxlIChzLmhlYXBfbGVuIDwgMikgewogICAgICAgICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDA7CiAgICAgICAgICB0cmVlW25vZGUgKiAyXSA9IDE7CiAgICAgICAgICBzLmRlcHRoW25vZGVdID0gMDsKICAgICAgICAgIHMub3B0X2xlbi0tOwogICAgICAgICAgaWYgKGhhc19zdHJlZSkgewogICAgICAgICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlOwogICAgICAgIGZvciAobiA9IHMuaGVhcF9sZW4gPj4gMTsgbiA+PSAxOyBuLS0pIHsKICAgICAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgbik7CiAgICAgICAgfQogICAgICAgIG5vZGUgPSBlbGVtczsKICAgICAgICBkbyB7CiAgICAgICAgICBuID0gcy5oZWFwWzFdOwogICAgICAgICAgcy5oZWFwWzFdID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07CiAgICAgICAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEpOwogICAgICAgICAgbSA9IHMuaGVhcFsxXTsKICAgICAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsKICAgICAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTsKICAgICAgICAgIHRyZWVbbm9kZSAqIDJdID0gdHJlZVtuICogMl0gKyB0cmVlW20gKiAyXTsKICAgICAgICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTsKICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IHRyZWVbbSAqIDIgKyAxXSA9IG5vZGU7CiAgICAgICAgICBzLmhlYXBbMV0gPSBub2RlKys7CiAgICAgICAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEpOwogICAgICAgIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7CiAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMV07CiAgICAgICAgZ2VuX2JpdGxlbihzLCBkZXNjKTsKICAgICAgICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSkgewogICAgICAgIHZhciBuOwogICAgICAgIHZhciBwcmV2bGVuID0gLTE7CiAgICAgICAgdmFyIGN1cmxlbjsKICAgICAgICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXTsKICAgICAgICB2YXIgY291bnQgPSAwOwogICAgICAgIHZhciBtYXhfY291bnQgPSA3OwogICAgICAgIHZhciBtaW5fY291bnQgPSA0OwogICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgIH0KICAgICAgICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdID0gNjU1MzU7CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7CiAgICAgICAgICBjdXJsZW4gPSBuZXh0bGVuOwogICAgICAgICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXTsKICAgICAgICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHsKICAgICAgICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdICs9IGNvdW50OwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHsKICAgICAgICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgewogICAgICAgICAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXSsrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0rKzsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHsKICAgICAgICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdKys7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXSsrOwogICAgICAgICAgfQogICAgICAgICAgY291bnQgPSAwOwogICAgICAgICAgcHJldmxlbiA9IGN1cmxlbjsKICAgICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDY7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtYXhfY291bnQgPSA3OwogICAgICAgICAgICBtaW5fY291bnQgPSA0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpIHsKICAgICAgICB2YXIgbjsKICAgICAgICB2YXIgcHJldmxlbiA9IC0xOwogICAgICAgIHZhciBjdXJsZW47CiAgICAgICAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07CiAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICB2YXIgbWF4X2NvdW50ID0gNzsKICAgICAgICB2YXIgbWluX2NvdW50ID0gNDsKICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7CiAgICAgICAgICBjdXJsZW4gPSBuZXh0bGVuOwogICAgICAgICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXTsKICAgICAgICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIH0gd2hpbGUgKC0tY291bnQgIT09IDApOwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHsKICAgICAgICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgewogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7CiAgICAgICAgICAgICAgY291bnQtLTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTsKICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7CiAgICAgICAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpOwogICAgICAgICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7CiAgICAgICAgICB9CiAgICAgICAgICBjb3VudCA9IDA7CiAgICAgICAgICBwcmV2bGVuID0gY3VybGVuOwogICAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNjsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDc7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykgewogICAgICAgIHZhciBtYXhfYmxpbmRleDsKICAgICAgICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTsKICAgICAgICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTsKICAgICAgICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7CiAgICAgICAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkgewogICAgICAgICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0gIT09IDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7CiAgICAgICAgcmV0dXJuIG1heF9ibGluZGV4OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKSB7CiAgICAgICAgdmFyIHJhbms7CiAgICAgICAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7CiAgICAgICAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsIDUpOwogICAgICAgIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgNCk7CiAgICAgICAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykgewogICAgICAgICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXSwgMyk7CiAgICAgICAgfQogICAgICAgIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7CiAgICAgICAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHsKICAgICAgICB2YXIgYmxhY2tfbWFzayA9IDQwOTM2MjQ0NDc7CiAgICAgICAgdmFyIG47CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkgewogICAgICAgICAgaWYgKGJsYWNrX21hc2sgJiAxICYmIHMuZHluX2x0cmVlW24gKiAyXSAhPT0gMCkgewogICAgICAgICAgICByZXR1cm4gWl9CSU5BUlk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLmR5bl9sdHJlZVs5ICogMl0gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXSAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMyAqIDJdICE9PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9URVhUOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHsKICAgICAgICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0gIT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIFpfVEVYVDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIFpfQklOQVJZOwogICAgICB9CiAgICAgIHZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7CiAgICAgIGZ1bmN0aW9uIF90cl9pbml0KHMpIHsKICAgICAgICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHsKICAgICAgICAgIHRyX3N0YXRpY19pbml0KCk7CiAgICAgICAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcy5sX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpOwogICAgICAgIHMuZF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTsKICAgICAgICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7CiAgICAgICAgcy5iaV9idWYgPSAwOwogICAgICAgIHMuYmlfdmFsaWQgPSAwOwogICAgICAgIGluaXRfYmxvY2socyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpIHsKICAgICAgICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsKICAgICAgICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX2FsaWduKHMpIHsKICAgICAgICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpOwogICAgICAgIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7CiAgICAgICAgYmlfZmx1c2gocyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgewogICAgICAgIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7CiAgICAgICAgdmFyIG1heF9ibGluZGV4ID0gMDsKICAgICAgICBpZiAocy5sZXZlbCA+IDApIHsKICAgICAgICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHsKICAgICAgICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7CiAgICAgICAgICB9CiAgICAgICAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTsKICAgICAgICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpOwogICAgICAgICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpOwogICAgICAgICAgb3B0X2xlbmIgPSBzLm9wdF9sZW4gKyAzICsgNyA+Pj4gMzsKICAgICAgICAgIHN0YXRpY19sZW5iID0gcy5zdGF0aWNfbGVuICsgMyArIDcgPj4+IDM7CiAgICAgICAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsKICAgICAgICAgICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OwogICAgICAgIH0KICAgICAgICBpZiAoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIgJiYgYnVmICE9PSAtMSkgewogICAgICAgICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpOwogICAgICAgIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHsKICAgICAgICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICAgICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsKICAgICAgICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpOwogICAgICAgICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTsKICAgICAgICB9CiAgICAgICAgaW5pdF9ibG9jayhzKTsKICAgICAgICBpZiAobGFzdCkgewogICAgICAgICAgYmlfd2luZHVwKHMpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gPSBkaXN0ID4+PiA4ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAyNTU7CiAgICAgICAgcy5sYXN0X2xpdCsrOwogICAgICAgIGlmIChkaXN0ID09PSAwKSB7CiAgICAgICAgICBzLmR5bl9sdHJlZVtsYyAqIDJdKys7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHMubWF0Y2hlcysrOwogICAgICAgICAgZGlzdC0tOwogICAgICAgICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0rKzsKICAgICAgICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdKys7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMTsKICAgICAgfQogICAgICBleHBvcnRzMi5fdHJfaW5pdCA9IF90cl9pbml0OwogICAgICBleHBvcnRzMi5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jazsKICAgICAgZXhwb3J0czIuX3RyX2ZsdXNoX2Jsb2NrID0gX3RyX2ZsdXNoX2Jsb2NrOwogICAgICBleHBvcnRzMi5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7CiAgICAgIGV4cG9ydHMyLl90cl9hbGlnbiA9IF90cl9hbGlnbjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMKICB2YXIgcmVxdWlyZV9hZGxlcjMyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7CiAgICAgICAgdmFyIHMxID0gYWRsZXIgJiA2NTUzNSB8IDAsIHMyID0gYWRsZXIgPj4+IDE2ICYgNjU1MzUgfCAwLCBuID0gMDsKICAgICAgICB3aGlsZSAobGVuICE9PSAwKSB7CiAgICAgICAgICBuID0gbGVuID4gMmUzID8gMmUzIDogbGVuOwogICAgICAgICAgbGVuIC09IG47CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIHMxID0gczEgKyBidWZbcG9zKytdIHwgMDsKICAgICAgICAgICAgczIgPSBzMiArIHMxIHwgMDsKICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICBzMSAlPSA2NTUyMTsKICAgICAgICAgIHMyICU9IDY1NTIxOwogICAgICAgIH0KICAgICAgICByZXR1cm4gczEgfCBzMiA8PCAxNiB8IDA7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gYWRsZXIzMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzCiAgdmFyIHJlcXVpcmVfY3JjMzIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBtYWtlVGFibGUoKSB7CiAgICAgICAgdmFyIGMsIHRhYmxlID0gW107CiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykgewogICAgICAgICAgYyA9IG47CiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykgewogICAgICAgICAgICBjID0gYyAmIDEgPyAzOTg4MjkyMzg0IF4gYyA+Pj4gMSA6IGMgPj4+IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0YWJsZVtuXSA9IGM7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0YWJsZTsKICAgICAgfQogICAgICB2YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTsKICAgICAgZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7CiAgICAgICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuOwogICAgICAgIGNyYyBePSAtMTsKICAgICAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHsKICAgICAgICAgIGNyYyA9IGNyYyA+Pj4gOCBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAyNTVdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gY3JjIF4gLTE7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gY3JjMzI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcwogIHZhciByZXF1aXJlX21lc3NhZ2VzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gewogICAgICAgIDI6ICJuZWVkIGRpY3Rpb25hcnkiLAogICAgICAgIDE6ICJzdHJlYW0gZW5kIiwKICAgICAgICAwOiAiIiwKICAgICAgICAiLTEiOiAiZmlsZSBlcnJvciIsCiAgICAgICAgIi0yIjogInN0cmVhbSBlcnJvciIsCiAgICAgICAgIi0zIjogImRhdGEgZXJyb3IiLAogICAgICAgICItNCI6ICJpbnN1ZmZpY2llbnQgbWVtb3J5IiwKICAgICAgICAiLTUiOiAiYnVmZmVyIGVycm9yIiwKICAgICAgICAiLTYiOiAiaW5jb21wYXRpYmxlIHZlcnNpb24iCiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfZGVmbGF0ZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIHRyZWVzID0gcmVxdWlyZV90cmVlcygpOwogICAgICB2YXIgYWRsZXIzMiA9IHJlcXVpcmVfYWRsZXIzMigpOwogICAgICB2YXIgY3JjMzIgPSByZXF1aXJlX2NyYzMyKCk7CiAgICAgIHZhciBtc2cgPSByZXF1aXJlX21lc3NhZ2VzKCk7CiAgICAgIHZhciBaX05PX0ZMVVNIID0gMDsKICAgICAgdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7CiAgICAgIHZhciBaX0ZVTExfRkxVU0ggPSAzOwogICAgICB2YXIgWl9GSU5JU0ggPSA0OwogICAgICB2YXIgWl9CTE9DSyA9IDU7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yOwogICAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7CiAgICAgIHZhciBaX0JVRl9FUlJPUiA9IC01OwogICAgICB2YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7CiAgICAgIHZhciBaX0ZJTFRFUkVEID0gMTsKICAgICAgdmFyIFpfSFVGRk1BTl9PTkxZID0gMjsKICAgICAgdmFyIFpfUkxFID0gMzsKICAgICAgdmFyIFpfRklYRUQgPSA0OwogICAgICB2YXIgWl9ERUZBVUxUX1NUUkFURUdZID0gMDsKICAgICAgdmFyIFpfVU5LTk9XTiA9IDI7CiAgICAgIHZhciBaX0RFRkxBVEVEID0gODsKICAgICAgdmFyIE1BWF9NRU1fTEVWRUwgPSA5OwogICAgICB2YXIgTUFYX1dCSVRTID0gMTU7CiAgICAgIHZhciBERUZfTUVNX0xFVkVMID0gODsKICAgICAgdmFyIExFTkdUSF9DT0RFUyA9IDI5OwogICAgICB2YXIgTElURVJBTFMgPSAyNTY7CiAgICAgIHZhciBMX0NPREVTID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTOwogICAgICB2YXIgRF9DT0RFUyA9IDMwOwogICAgICB2YXIgQkxfQ09ERVMgPSAxOTsKICAgICAgdmFyIEhFQVBfU0laRSA9IDIgKiBMX0NPREVTICsgMTsKICAgICAgdmFyIE1BWF9CSVRTID0gMTU7CiAgICAgIHZhciBNSU5fTUFUQ0ggPSAzOwogICAgICB2YXIgTUFYX01BVENIID0gMjU4OwogICAgICB2YXIgTUlOX0xPT0tBSEVBRCA9IE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDE7CiAgICAgIHZhciBQUkVTRVRfRElDVCA9IDMyOwogICAgICB2YXIgSU5JVF9TVEFURSA9IDQyOwogICAgICB2YXIgRVhUUkFfU1RBVEUgPSA2OTsKICAgICAgdmFyIE5BTUVfU1RBVEUgPSA3MzsKICAgICAgdmFyIENPTU1FTlRfU1RBVEUgPSA5MTsKICAgICAgdmFyIEhDUkNfU1RBVEUgPSAxMDM7CiAgICAgIHZhciBCVVNZX1NUQVRFID0gMTEzOwogICAgICB2YXIgRklOSVNIX1NUQVRFID0gNjY2OwogICAgICB2YXIgQlNfTkVFRF9NT1JFID0gMTsKICAgICAgdmFyIEJTX0JMT0NLX0RPTkUgPSAyOwogICAgICB2YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOwogICAgICB2YXIgQlNfRklOSVNIX0RPTkUgPSA0OwogICAgICB2YXIgT1NfQ09ERSA9IDM7CiAgICAgIGZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHsKICAgICAgICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdOwogICAgICAgIHJldHVybiBlcnJvckNvZGU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmFuayhmKSB7CiAgICAgICAgcmV0dXJuIChmIDw8IDEpIC0gKGYgPiA0ID8gOSA6IDApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHplcm8oYnVmKSB7CiAgICAgICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgd2hpbGUgKC0tbGVuID49IDApIHsKICAgICAgICAgIGJ1ZltsZW5dID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7CiAgICAgICAgdmFyIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIHZhciBsZW4gPSBzLnBlbmRpbmc7CiAgICAgICAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7CiAgICAgICAgICBsZW4gPSBzdHJtLmF2YWlsX291dDsKICAgICAgICB9CiAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTsKICAgICAgICBzdHJtLm5leHRfb3V0ICs9IGxlbjsKICAgICAgICBzLnBlbmRpbmdfb3V0ICs9IGxlbjsKICAgICAgICBzdHJtLnRvdGFsX291dCArPSBsZW47CiAgICAgICAgc3RybS5hdmFpbF9vdXQgLT0gbGVuOwogICAgICAgIHMucGVuZGluZyAtPSBsZW47CiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gMCkgewogICAgICAgICAgcy5wZW5kaW5nX291dCA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkgewogICAgICAgIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCBzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEsIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTsKICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDsKICAgICAgICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHV0X2J5dGUocywgYikgewogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjsKICAgICAgfQogICAgICBmdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiID4+PiA4ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDI1NTsKICAgICAgfQogICAgICBmdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7CiAgICAgICAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgaWYgKGxlbiA+IHNpemUpIHsKICAgICAgICAgIGxlbiA9IHNpemU7CiAgICAgICAgfQogICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBzdHJtLmF2YWlsX2luIC09IGxlbjsKICAgICAgICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7CiAgICAgICAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkgewogICAgICAgICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTsKICAgICAgICB9IGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikgewogICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7CiAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9pbiArPSBsZW47CiAgICAgICAgc3RybS50b3RhbF9pbiArPSBsZW47CiAgICAgICAgcmV0dXJuIGxlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkgewogICAgICAgIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7CiAgICAgICAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OwogICAgICAgIHZhciBtYXRjaDsKICAgICAgICB2YXIgbGVuOwogICAgICAgIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7CiAgICAgICAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7CiAgICAgICAgdmFyIGxpbWl0ID0gcy5zdHJzdGFydCA+IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCA/IHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDA7CiAgICAgICAgdmFyIF93aW4gPSBzLndpbmRvdzsKICAgICAgICB2YXIgd21hc2sgPSBzLndfbWFzazsKICAgICAgICB2YXIgcHJldiA9IHMucHJldjsKICAgICAgICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDsKICAgICAgICB2YXIgc2Nhbl9lbmQxID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTsKICAgICAgICB2YXIgc2Nhbl9lbmQgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07CiAgICAgICAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7CiAgICAgICAgICBjaGFpbl9sZW5ndGggPj49IDI7CiAgICAgICAgfQogICAgICAgIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsKICAgICAgICAgIG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsKICAgICAgICB9CiAgICAgICAgZG8gewogICAgICAgICAgbWF0Y2ggPSBjdXJfbWF0Y2g7CiAgICAgICAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAhPT0gc2Nhbl9lbmQgfHwgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fCBfd2luW21hdGNoXSAhPT0gX3dpbltzY2FuXSB8fCBfd2luWysrbWF0Y2hdICE9PSBfd2luW3NjYW4gKyAxXSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHNjYW4gKz0gMjsKICAgICAgICAgIG1hdGNoKys7CiAgICAgICAgICBkbyB7CiAgICAgICAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIHNjYW4gPCBzdHJlbmQpOwogICAgICAgICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pOwogICAgICAgICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDsKICAgICAgICAgIGlmIChsZW4gPiBiZXN0X2xlbikgewogICAgICAgICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoOwogICAgICAgICAgICBiZXN0X2xlbiA9IGxlbjsKICAgICAgICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc2Nhbl9lbmQxID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTsKICAgICAgICAgICAgc2Nhbl9lbmQgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTsKICAgICAgICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHsKICAgICAgICAgIHJldHVybiBiZXN0X2xlbjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMubG9va2FoZWFkOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHsKICAgICAgICB2YXIgX3dfc2l6ZSA9IHMud19zaXplOwogICAgICAgIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7CiAgICAgICAgZG8gewogICAgICAgICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7CiAgICAgICAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgewogICAgICAgICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApOwogICAgICAgICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTsKICAgICAgICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplOwogICAgICAgICAgICBuID0gcy5oYXNoX3NpemU7CiAgICAgICAgICAgIHAgPSBuOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgbSA9IHMuaGVhZFstLXBdOwogICAgICAgICAgICAgIHMuaGVhZFtwXSA9IG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMDsKICAgICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgICAgbiA9IF93X3NpemU7CiAgICAgICAgICAgIHAgPSBuOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgbSA9IHMucHJldlstLXBdOwogICAgICAgICAgICAgIHMucHJldltwXSA9IG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMDsKICAgICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgICAgbW9yZSArPSBfd19zaXplOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpOwogICAgICAgICAgcy5sb29rYWhlYWQgKz0gbjsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7CiAgICAgICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdOwogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIHdoaWxlIChzLmluc2VydCkgewogICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjsKICAgICAgICAgICAgICBzdHIrKzsKICAgICAgICAgICAgICBzLmluc2VydC0tOwogICAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkgewogICAgICAgIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDY1NTM1OwogICAgICAgIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHsKICAgICAgICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTsKICAgICAgICB9CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDsKICAgICAgICAgIHMubG9va2FoZWFkID0gMDsKICAgICAgICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7CiAgICAgICAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkgewogICAgICAgICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGhhc2hfaGVhZDsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGhhc2hfaGVhZCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgfQogICAgICAgICAgaWYgKGhhc2hfaGVhZCAhPT0gMCAmJiBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaCAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOwogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7CiAgICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTsKICAgICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkgewogICAgICAgIHZhciBoYXNoX2hlYWQ7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICB2YXIgbWF4X2luc2VydDsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBoYXNoX2hlYWQgPSAwOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgIH0KICAgICAgICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7CiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICBpZiAoaGFzaF9oZWFkICE9PSAwICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpOwogICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJiAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCBzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5NikpIHsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7CiAgICAgICAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxOwogICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC09IDI7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHsKICAgICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApOwogICAgICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pOwogICAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHsKICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pOwogICAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIHZhciBwcmV2OwogICAgICAgIHZhciBzY2FuLCBzdHJlbmQ7CiAgICAgICAgdmFyIF93aW4gPSBzLndpbmRvdzsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7CiAgICAgICAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTsKICAgICAgICAgICAgcHJldiA9IF93aW5bc2Nhbl07CiAgICAgICAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkgewogICAgICAgICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgc2NhbiA8IHN0cmVuZCk7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7CiAgICAgICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHsKICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7CiAgICAgICAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pOwogICAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgewogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICBzLmxvb2thaGVhZC0tOwogICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7CiAgICAgICAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoOwogICAgICAgIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTsKICAgICAgICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7CiAgICAgICAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47CiAgICAgICAgdGhpcy5mdW5jID0gZnVuYzsKICAgICAgfQogICAgICB2YXIgY29uZmlndXJhdGlvbl90YWJsZTsKICAgICAgY29uZmlndXJhdGlvbl90YWJsZSA9IFsKICAgICAgICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksCiAgICAgICAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykKICAgICAgXTsKICAgICAgZnVuY3Rpb24gbG1faW5pdChzKSB7CiAgICAgICAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTsKICAgICAgICB6ZXJvKHMuaGVhZCk7CiAgICAgICAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7CiAgICAgICAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDsKICAgICAgICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoOwogICAgICAgIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluOwogICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgIHMubG9va2FoZWFkID0gMDsKICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgcy5pbnNfaCA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkgewogICAgICAgIHRoaXMuc3RybSA9IG51bGw7CiAgICAgICAgdGhpcy5zdGF0dXMgPSAwOwogICAgICAgIHRoaXMucGVuZGluZ19idWYgPSBudWxsOwogICAgICAgIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nX291dCA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nID0gMDsKICAgICAgICB0aGlzLndyYXAgPSAwOwogICAgICAgIHRoaXMuZ3poZWFkID0gbnVsbDsKICAgICAgICB0aGlzLmd6aW5kZXggPSAwOwogICAgICAgIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsKICAgICAgICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICB0aGlzLndfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy53X2JpdHMgPSAwOwogICAgICAgIHRoaXMud19tYXNrID0gMDsKICAgICAgICB0aGlzLndpbmRvdyA9IG51bGw7CiAgICAgICAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDsKICAgICAgICB0aGlzLmhlYWQgPSBudWxsOwogICAgICAgIHRoaXMuaW5zX2ggPSAwOwogICAgICAgIHRoaXMuaGFzaF9zaXplID0gMDsKICAgICAgICB0aGlzLmhhc2hfYml0cyA9IDA7CiAgICAgICAgdGhpcy5oYXNoX21hc2sgPSAwOwogICAgICAgIHRoaXMuaGFzaF9zaGlmdCA9IDA7CiAgICAgICAgdGhpcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgIHRoaXMucHJldl9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIHRoaXMuc3Ryc3RhcnQgPSAwOwogICAgICAgIHRoaXMubWF0Y2hfc3RhcnQgPSAwOwogICAgICAgIHRoaXMubG9va2FoZWFkID0gMDsKICAgICAgICB0aGlzLnByZXZfbGVuZ3RoID0gMDsKICAgICAgICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwOwogICAgICAgIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMubGV2ZWwgPSAwOwogICAgICAgIHRoaXMuc3RyYXRlZ3kgPSAwOwogICAgICAgIHRoaXMuZ29vZF9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5uaWNlX21hdGNoID0gMDsKICAgICAgICB0aGlzLmR5bl9sdHJlZSA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTsKICAgICAgICB0aGlzLmR5bl9kdHJlZSA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpOwogICAgICAgIHRoaXMuYmxfdHJlZSA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTsKICAgICAgICB6ZXJvKHRoaXMuZHluX2x0cmVlKTsKICAgICAgICB6ZXJvKHRoaXMuZHluX2R0cmVlKTsKICAgICAgICB6ZXJvKHRoaXMuYmxfdHJlZSk7CiAgICAgICAgdGhpcy5sX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuZF9kZXNjID0gbnVsbDsKICAgICAgICB0aGlzLmJsX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTsKICAgICAgICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsKICAgICAgICB6ZXJvKHRoaXMuaGVhcCk7CiAgICAgICAgdGhpcy5oZWFwX2xlbiA9IDA7CiAgICAgICAgdGhpcy5oZWFwX21heCA9IDA7CiAgICAgICAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOwogICAgICAgIHplcm8odGhpcy5kZXB0aCk7CiAgICAgICAgdGhpcy5sX2J1ZiA9IDA7CiAgICAgICAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5sYXN0X2xpdCA9IDA7CiAgICAgICAgdGhpcy5kX2J1ZiA9IDA7CiAgICAgICAgdGhpcy5vcHRfbGVuID0gMDsKICAgICAgICB0aGlzLnN0YXRpY19sZW4gPSAwOwogICAgICAgIHRoaXMubWF0Y2hlcyA9IDA7CiAgICAgICAgdGhpcy5pbnNlcnQgPSAwOwogICAgICAgIHRoaXMuYmlfYnVmID0gMDsKICAgICAgICB0aGlzLmJpX3ZhbGlkID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHsKICAgICAgICB2YXIgczsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwOwogICAgICAgIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOOwogICAgICAgIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIHMucGVuZGluZyA9IDA7CiAgICAgICAgcy5wZW5kaW5nX291dCA9IDA7CiAgICAgICAgaWYgKHMud3JhcCA8IDApIHsKICAgICAgICAgIHMud3JhcCA9IC1zLndyYXA7CiAgICAgICAgfQogICAgICAgIHMuc3RhdHVzID0gcy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEU7CiAgICAgICAgc3RybS5hZGxlciA9IHMud3JhcCA9PT0gMiA/IDAgOiAxOwogICAgICAgIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7CiAgICAgICAgdHJlZXMuX3RyX2luaXQocyk7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHsKICAgICAgICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTsKICAgICAgICBpZiAocmV0ID09PSBaX09LKSB7CiAgICAgICAgICBsbV9pbml0KHN0cm0uc3RhdGUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkgewogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7CiAgICAgICAgaWYgKCFzdHJtKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHZhciB3cmFwID0gMTsKICAgICAgICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikgewogICAgICAgICAgbGV2ZWwgPSA2OwogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyA8IDApIHsKICAgICAgICAgIHdyYXAgPSAwOwogICAgICAgICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzOwogICAgICAgIH0gZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7CiAgICAgICAgICB3cmFwID0gMjsKICAgICAgICAgIHdpbmRvd0JpdHMgLT0gMTY7CiAgICAgICAgfQogICAgICAgIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fCB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fCBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHsKICAgICAgICAgIHdpbmRvd0JpdHMgPSA5OwogICAgICAgIH0KICAgICAgICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTsKICAgICAgICBzdHJtLnN0YXRlID0gczsKICAgICAgICBzLnN0cm0gPSBzdHJtOwogICAgICAgIHMud3JhcCA9IHdyYXA7CiAgICAgICAgcy5nemhlYWQgPSBudWxsOwogICAgICAgIHMud19iaXRzID0gd2luZG93Qml0czsKICAgICAgICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7CiAgICAgICAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7CiAgICAgICAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7CiAgICAgICAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzOwogICAgICAgIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxOwogICAgICAgIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTsKICAgICAgICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7CiAgICAgICAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTsKICAgICAgICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpOwogICAgICAgIHMubGl0X2J1ZnNpemUgPSAxIDw8IG1lbUxldmVsICsgNjsKICAgICAgICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDsKICAgICAgICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTsKICAgICAgICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7CiAgICAgICAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplOwogICAgICAgIHMubGV2ZWwgPSBsZXZlbDsKICAgICAgICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7CiAgICAgICAgcy5tZXRob2QgPSBtZXRob2Q7CiAgICAgICAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkgewogICAgICAgIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7CiAgICAgICAgdmFyIG9sZF9mbHVzaCwgczsKICAgICAgICB2YXIgYmVnLCB2YWw7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8IGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHsKICAgICAgICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoIXN0cm0ub3V0cHV0IHx8ICFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgc3RybS5hdmFpbF9vdXQgPT09IDAgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgcy5zdHJtID0gc3RybTsKICAgICAgICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7CiAgICAgICAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy53cmFwID09PSAyKSB7CiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSAwOwogICAgICAgICAgICBwdXRfYnl0ZShzLCAzMSk7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDEzOSk7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDgpOwogICAgICAgICAgICBpZiAoIXMuZ3poZWFkKSB7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOiBzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID8gNCA6IDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICsgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNikpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiAxNiAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiAyNCAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOiBzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID8gNCA6IDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMjU1KTsKICAgICAgICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAyNTUpOwogICAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDggJiAyNTUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYykgewogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGhlYWRlciA9IFpfREVGTEFURUQgKyAocy53X2JpdHMgLSA4IDw8IDQpIDw8IDg7CiAgICAgICAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xOwogICAgICAgICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMDsKICAgICAgICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMTsKICAgICAgICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMzsKICAgICAgICAgICAgfQogICAgICAgICAgICBoZWFkZXIgfD0gbGV2ZWxfZmxhZ3MgPDwgNjsKICAgICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsKICAgICAgICAgICAgICBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGVhZGVyICs9IDMxIC0gaGVhZGVyICUgMzE7CiAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTsKICAgICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsKICAgICAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7CiAgICAgICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDY1NTM1KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzdHJtLmFkbGVyID0gMTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhKSB7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiA2NTUzNSkpIHsKICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDI1NSk7CiAgICAgICAgICAgICAgcy5nemluZGV4Kys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHsKICAgICAgICAgICAgICBzLmd6aW5kZXggPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5uYW1lKSB7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICAgIHZhbCA9IDE7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAyNTU7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZhbCA9IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7CiAgICAgICAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7CiAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkgewogICAgICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQpIHsKICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgICAgdmFsID0gMTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkgewogICAgICAgICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDI1NTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFsID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgdmFsKTsKICAgICAgICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTsKICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodmFsID09PSAwKSB7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHsKICAgICAgICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHsKICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiYgZmx1c2ggIT09IFpfRklOSVNIKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7CiAgICAgICAgfQogICAgICAgIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8IGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpIHsKICAgICAgICAgIHZhciBic3RhdGUgPSBzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOiBzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCk7CiAgICAgICAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHsKICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7CiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7CiAgICAgICAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpOwogICAgICAgICAgICB9IGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7CiAgICAgICAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7CiAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHsKICAgICAgICAgICAgICAgIHplcm8ocy5oZWFkKTsKICAgICAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDsKICAgICAgICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgewogICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChzLndyYXAgPD0gMCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VORDsKICAgICAgICB9CiAgICAgICAgaWYgKHMud3JhcCA9PT0gMikgewogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDggJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiAxNiAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDI0ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiA+PiA4ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gPj4gMTYgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiA+PiAyNCAmIDI1NSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTsKICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiA2NTUzNSk7CiAgICAgICAgfQogICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgaWYgKHMud3JhcCA+IDApIHsKICAgICAgICAgIHMud3JhcCA9IC1zLndyYXA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkgewogICAgICAgIHZhciBzdGF0dXM7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzOwogICAgICAgIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiYgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJiBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiYgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJiBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiYgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgICAgICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHsKICAgICAgICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoOwogICAgICAgIHZhciBzOwogICAgICAgIHZhciBzdHIsIG47CiAgICAgICAgdmFyIHdyYXA7CiAgICAgICAgdmFyIGF2YWlsOwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBpbnB1dDsKICAgICAgICB2YXIgdG1wRGljdDsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgd3JhcCA9IHMud3JhcDsKICAgICAgICBpZiAod3JhcCA9PT0gMiB8fCB3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFIHx8IHMubG9va2FoZWFkKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmICh3cmFwID09PSAxKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTsKICAgICAgICB9CiAgICAgICAgcy53cmFwID0gMDsKICAgICAgICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkgewogICAgICAgICAgaWYgKHdyYXAgPT09IDApIHsKICAgICAgICAgICAgemVybyhzLmhlYWQpOwogICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDsKICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7CiAgICAgICAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTsKICAgICAgICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0OwogICAgICAgICAgZGljdExlbmd0aCA9IHMud19zaXplOwogICAgICAgIH0KICAgICAgICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjsKICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7CiAgICAgICAgc3RybS5uZXh0X2luID0gMDsKICAgICAgICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTsKICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICBzdHIgPSBzLnN0cnN0YXJ0OwogICAgICAgICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpOwogICAgICAgICAgZG8gewogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjsKICAgICAgICAgICAgc3RyKys7CiAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgcy5zdHJzdGFydCA9IHN0cjsKICAgICAgICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgIH0KICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0OwogICAgICAgIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7CiAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgc3RybS5pbnB1dCA9IGlucHV0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDsKICAgICAgICBzLndyYXAgPSB3cmFwOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0OwogICAgICBleHBvcnRzMi5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGUgPSBkZWZsYXRlOwogICAgICBleHBvcnRzMi5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTsKICAgICAgZXhwb3J0czIuZGVmbGF0ZUluZm8gPSAicGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcwogIHZhciByZXF1aXJlX3N0cmluZ3MgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgU1RSX0FQUExZX09LID0gdHJ1ZTsKICAgICAgdmFyIFNUUl9BUFBMWV9VSUFfT0sgPSB0cnVlOwogICAgICB0cnkgewogICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWzBdKTsKICAgICAgfSBjYXRjaCAoX18pIHsKICAgICAgICBTVFJfQVBQTFlfT0sgPSBmYWxzZTsKICAgICAgfQogICAgICB0cnkgewogICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOwogICAgICB9IGNhdGNoIChfXykgewogICAgICAgIFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsKICAgICAgfQogICAgICB2YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpOwogICAgICBmb3IgKHEgPSAwOyBxIDwgMjU2OyBxKyspIHsKICAgICAgICBfdXRmOGxlbltxXSA9IHEgPj0gMjUyID8gNiA6IHEgPj0gMjQ4ID8gNSA6IHEgPj0gMjQwID8gNCA6IHEgPj0gMjI0ID8gMyA6IHEgPj0gMTkyID8gMiA6IDE7CiAgICAgIH0KICAgICAgdmFyIHE7CiAgICAgIF91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsKICAgICAgZXhwb3J0czIuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uKHN0cikgewogICAgICAgIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwOwogICAgICAgIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHsKICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7CiAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT09IDU1Mjk2ICYmIG1fcG9zICsgMSA8IHN0cl9sZW4pIHsKICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpOwogICAgICAgICAgICBpZiAoKGMyICYgNjQ1MTIpID09PSA1NjMyMCkgewogICAgICAgICAgICAgIGMgPSA2NTUzNiArIChjIC0gNTUyOTYgPDwgMTApICsgKGMyIC0gNTYzMjApOwogICAgICAgICAgICAgIG1fcG9zKys7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGJ1Zl9sZW4gKz0gYyA8IDEyOCA/IDEgOiBjIDwgMjA0OCA/IDIgOiBjIDwgNjU1MzYgPyAzIDogNDsKICAgICAgICB9CiAgICAgICAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7CiAgICAgICAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykgewogICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTsKICAgICAgICAgIGlmICgoYyAmIDY0NTEyKSA9PT0gNTUyOTYgJiYgbV9wb3MgKyAxIDwgc3RyX2xlbikgewogICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7CiAgICAgICAgICAgIGlmICgoYzIgJiA2NDUxMikgPT09IDU2MzIwKSB7CiAgICAgICAgICAgICAgYyA9IDY1NTM2ICsgKGMgLSA1NTI5NiA8PCAxMCkgKyAoYzIgLSA1NjMyMCk7CiAgICAgICAgICAgICAgbV9wb3MrKzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKGMgPCAxMjgpIHsKICAgICAgICAgICAgYnVmW2krK10gPSBjOwogICAgICAgICAgfSBlbHNlIGlmIChjIDwgMjA0OCkgewogICAgICAgICAgICBidWZbaSsrXSA9IDE5MiB8IGMgPj4+IDY7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyAmIDYzOwogICAgICAgICAgfSBlbHNlIGlmIChjIDwgNjU1MzYpIHsKICAgICAgICAgICAgYnVmW2krK10gPSAyMjQgfCBjID4+PiAxMjsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjID4+PiA2ICYgNjM7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyAmIDYzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYnVmW2krK10gPSAyNDAgfCBjID4+PiAxODsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjID4+PiAxMiAmIDYzOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgPj4+IDYgJiA2MzsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjICYgNjM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJ1ZjJiaW5zdHJpbmcoYnVmLCBsZW4pIHsKICAgICAgICBpZiAobGVuIDwgNjU1MzQpIHsKICAgICAgICAgIGlmIChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSyB8fCAhYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9PSykgewogICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGlscy5zaHJpbmtCdWYoYnVmLCBsZW4pKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdmFyIHJlc3VsdCA9ICIiOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KICAgICAgZXhwb3J0czIuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uKGJ1ZikgewogICAgICAgIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbihzdHIpIHsKICAgICAgICB2YXIgYnVmID0gbmV3IHV0aWxzLkJ1Zjgoc3RyLmxlbmd0aCk7CiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbihidWYsIG1heCkgewogICAgICAgIHZhciBpLCBvdXQsIGMsIGNfbGVuOwogICAgICAgIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDsKICAgICAgICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7CiAgICAgICAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjsgKSB7CiAgICAgICAgICBjID0gYnVmW2krK107CiAgICAgICAgICBpZiAoYyA8IDEyOCkgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGNfbGVuID0gX3V0ZjhsZW5bY107CiAgICAgICAgICBpZiAoY19sZW4gPiA0KSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDY1NTMzOwogICAgICAgICAgICBpICs9IGNfbGVuIC0gMTsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBjICY9IGNfbGVuID09PSAyID8gMzEgOiBjX2xlbiA9PT0gMyA/IDE1IDogNzsKICAgICAgICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikgewogICAgICAgICAgICBjID0gYyA8PCA2IHwgYnVmW2krK10gJiA2MzsKICAgICAgICAgICAgY19sZW4tLTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjX2xlbiA+IDEpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gNjU1MzM7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGMgPCA2NTUzNikgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYyAtPSA2NTUzNjsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gNTUyOTYgfCBjID4+IDEwICYgMTAyMzsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gNTYzMjAgfCBjICYgMTAyMzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLnV0Zjhib3JkZXIgPSBmdW5jdGlvbihidWYsIG1heCkgewogICAgICAgIHZhciBwb3M7CiAgICAgICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7CiAgICAgICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsKICAgICAgICAgIG1heCA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIHBvcyA9IG1heCAtIDE7CiAgICAgICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgcG9zLS07CiAgICAgICAgfQogICAgICAgIGlmIChwb3MgPCAwKSB7CiAgICAgICAgICByZXR1cm4gbWF4OwogICAgICAgIH0KICAgICAgICBpZiAocG9zID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gbWF4OwogICAgICAgIH0KICAgICAgICByZXR1cm4gcG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4ID8gcG9zIDogbWF4OwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcwogIHZhciByZXF1aXJlX3pzdHJlYW0gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIFpTdHJlYW0oKSB7CiAgICAgICAgdGhpcy5pbnB1dCA9IG51bGw7CiAgICAgICAgdGhpcy5uZXh0X2luID0gMDsKICAgICAgICB0aGlzLmF2YWlsX2luID0gMDsKICAgICAgICB0aGlzLnRvdGFsX2luID0gMDsKICAgICAgICB0aGlzLm91dHB1dCA9IG51bGw7CiAgICAgICAgdGhpcy5uZXh0X291dCA9IDA7CiAgICAgICAgdGhpcy5hdmFpbF9vdXQgPSAwOwogICAgICAgIHRoaXMudG90YWxfb3V0ID0gMDsKICAgICAgICB0aGlzLm1zZyA9ICIiOwogICAgICAgIHRoaXMuc3RhdGUgPSBudWxsOwogICAgICAgIHRoaXMuZGF0YV90eXBlID0gMjsKICAgICAgICB0aGlzLmFkbGVyID0gMDsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBaU3RyZWFtOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMKICB2YXIgcmVxdWlyZV9kZWZsYXRlMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlX2RlZmxhdGUoKTsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIHN0cmluZ3MgPSByZXF1aXJlX3N0cmluZ3MoKTsKICAgICAgdmFyIG1zZyA9IHJlcXVpcmVfbWVzc2FnZXMoKTsKICAgICAgdmFyIFpTdHJlYW0gPSByZXF1aXJlX3pzdHJlYW0oKTsKICAgICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzsKICAgICAgdmFyIFpfTk9fRkxVU0ggPSAwOwogICAgICB2YXIgWl9GSU5JU0ggPSA0OwogICAgICB2YXIgWl9PSyA9IDA7CiAgICAgIHZhciBaX1NUUkVBTV9FTkQgPSAxOwogICAgICB2YXIgWl9TWU5DX0ZMVVNIMiA9IDI7CiAgICAgIHZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTsKICAgICAgdmFyIFpfREVGQVVMVF9TVFJBVEVHWSA9IDA7CiAgICAgIHZhciBaX0RFRkxBVEVEID0gODsKICAgICAgZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7CiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKQogICAgICAgICAgcmV0dXJuIG5ldyBEZWZsYXRlKG9wdGlvbnMpOwogICAgICAgIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7CiAgICAgICAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLAogICAgICAgICAgbWV0aG9kOiBaX0RFRkxBVEVELAogICAgICAgICAgY2h1bmtTaXplOiAxNjM4NCwKICAgICAgICAgIHdpbmRvd0JpdHM6IDE1LAogICAgICAgICAgbWVtTGV2ZWw6IDgsCiAgICAgICAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZLAogICAgICAgICAgdG86ICIiCiAgICAgICAgfSwgb3B0aW9ucyB8fCB7fSk7CiAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0aW9uczsKICAgICAgICBpZiAob3B0LnJhdyAmJiBvcHQud2luZG93Qml0cyA+IDApIHsKICAgICAgICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzOwogICAgICAgIH0gZWxzZSBpZiAob3B0Lmd6aXAgJiYgb3B0LndpbmRvd0JpdHMgPiAwICYmIG9wdC53aW5kb3dCaXRzIDwgMTYpIHsKICAgICAgICAgIG9wdC53aW5kb3dCaXRzICs9IDE2OwogICAgICAgIH0KICAgICAgICB0aGlzLmVyciA9IDA7CiAgICAgICAgdGhpcy5tc2cgPSAiIjsKICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7CiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpOwogICAgICAgIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKHRoaXMuc3RybSwgb3B0LmxldmVsLCBvcHQubWV0aG9kLCBvcHQud2luZG93Qml0cywgb3B0Lm1lbUxldmVsLCBvcHQuc3RyYXRlZ3kpOwogICAgICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7CiAgICAgICAgfQogICAgICAgIGlmIChvcHQuaGVhZGVyKSB7CiAgICAgICAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpOwogICAgICAgIH0KICAgICAgICBpZiAob3B0LmRpY3Rpb25hcnkpIHsKICAgICAgICAgIHZhciBkaWN0OwogICAgICAgICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTsKICAgICAgICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGRhdGEsIG1vZGUpIHsKICAgICAgICB2YXIgc3RybSA9IHRoaXMuc3RybTsKICAgICAgICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTsKICAgICAgICB2YXIgc3RhdHVzLCBfbW9kZTsKICAgICAgICBpZiAodGhpcy5lbmRlZCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBfbW9kZSA9IG1vZGUgPT09IH5+bW9kZSA/IG1vZGUgOiBtb2RlID09PSB0cnVlID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIOwogICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7CiAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBkYXRhOwogICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfaW4gPSAwOwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDsKICAgICAgICBkbyB7CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpOwogICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gMDsKICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7CiAgICAgICAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7CiAgICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSDIpKSB7CiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgdGhpcy5vbkRhdGEoc3RyaW5ncy5idWYyYmluc3RyaW5nKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpOwogICAgICAgIGlmIChfbW9kZSA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7CiAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIMikgewogICAgICAgICAgdGhpcy5vbkVuZChaX09LKTsKICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfTsKICAgICAgRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oY2h1bmspIHsKICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTsKICAgICAgfTsKICAgICAgRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzdGF0dXMpIHsKICAgICAgICBpZiAoc3RhdHVzID09PSBaX09LKSB7CiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oIiIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB0aGlzLmVyciA9IHN0YXR1czsKICAgICAgICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTsKICAgICAgICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTsKICAgICAgICBpZiAoZGVmbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTsKICAgICAgICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMuZ3ppcCA9IHRydWU7CiAgICAgICAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLkRlZmxhdGUgPSBEZWZsYXRlOwogICAgICBleHBvcnRzMi5kZWZsYXRlID0gZGVmbGF0ZTsKICAgICAgZXhwb3J0czIuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7CiAgICAgIGV4cG9ydHMyLmd6aXAgPSBnemlwOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcwogIHZhciByZXF1aXJlX2luZmZhc3QgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBCQUQgPSAzMDsKICAgICAgdmFyIFRZUEUgPSAxMjsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIHZhciBfaW47CiAgICAgICAgdmFyIGxhc3Q7CiAgICAgICAgdmFyIF9vdXQ7CiAgICAgICAgdmFyIGJlZzsKICAgICAgICB2YXIgZW5kOwogICAgICAgIHZhciBkbWF4OwogICAgICAgIHZhciB3c2l6ZTsKICAgICAgICB2YXIgd2hhdmU7CiAgICAgICAgdmFyIHduZXh0OwogICAgICAgIHZhciBzX3dpbmRvdzsKICAgICAgICB2YXIgaG9sZDsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgbGNvZGU7CiAgICAgICAgdmFyIGRjb2RlOwogICAgICAgIHZhciBsbWFzazsKICAgICAgICB2YXIgZG1hc2s7CiAgICAgICAgdmFyIGhlcmU7CiAgICAgICAgdmFyIG9wOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIGZyb207CiAgICAgICAgdmFyIGZyb21fc291cmNlOwogICAgICAgIHZhciBpbnB1dCwgb3V0cHV0OwogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBfaW4gPSBzdHJtLm5leHRfaW47CiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpOwogICAgICAgIF9vdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7CiAgICAgICAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7CiAgICAgICAgZG1heCA9IHN0YXRlLmRtYXg7CiAgICAgICAgd3NpemUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICB3aGF2ZSA9IHN0YXRlLndoYXZlOwogICAgICAgIHduZXh0ID0gc3RhdGUud25leHQ7CiAgICAgICAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7CiAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7CiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlOwogICAgICAgIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7CiAgICAgICAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7CiAgICAgICAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxOwogICAgICAgIHRvcDoKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgaWYgKGJpdHMgPCAxNSkgewogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdOwogICAgICAgICAgICBkb2xlbjoKICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AgJiAxNikgewogICAgICAgICAgICAgICAgICBsZW4gPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgIG9wICY9IDE1OwogICAgICAgICAgICAgICAgICBpZiAob3ApIHsKICAgICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBsZW4gKz0gaG9sZCAmICgxIDw8IG9wKSAtIDE7CiAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCAxNSkgewogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdOwogICAgICAgICAgICAgICAgICBkb2Rpc3Q6CiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgJiAxNikgewogICAgICAgICAgICAgICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgICAgICBvcCAmPSAxNTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgxIDw8IG9wKSAtIDE7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIjsKICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdzsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod25leHQgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSAzOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gMzsKICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDY1NTM1KSArIChob2xkICYgKDEgPDwgb3ApIC0gMSldOwogICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiOwogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiA2NTUzNSkgKyAoaG9sZCAmICgxIDw8IG9wKSAtIDEpXTsKICAgICAgICAgICAgICAgICAgY29udGludWUgZG9sZW47CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wICYgMzIpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7CiAgICAgICAgbGVuID0gYml0cyA+PiAzOwogICAgICAgIF9pbiAtPSBsZW47CiAgICAgICAgYml0cyAtPSBsZW4gPDwgMzsKICAgICAgICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTsKICAgICAgICBzdHJtLm5leHRfaW4gPSBfaW47CiAgICAgICAgc3RybS5uZXh0X291dCA9IF9vdXQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KTsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCk7CiAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgcmV0dXJuOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMKICB2YXIgcmVxdWlyZV9pbmZ0cmVlcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBNQVhCSVRTID0gMTU7CiAgICAgIHZhciBFTk9VR0hfTEVOUyA9IDg1MjsKICAgICAgdmFyIEVOT1VHSF9ESVNUUyA9IDU5MjsKICAgICAgdmFyIENPREVTID0gMDsKICAgICAgdmFyIExFTlMgPSAxOwogICAgICB2YXIgRElTVFMgPSAyOwogICAgICB2YXIgbGJhc2UgPSBbCiAgICAgICAgMywKICAgICAgICA0LAogICAgICAgIDUsCiAgICAgICAgNiwKICAgICAgICA3LAogICAgICAgIDgsCiAgICAgICAgOSwKICAgICAgICAxMCwKICAgICAgICAxMSwKICAgICAgICAxMywKICAgICAgICAxNSwKICAgICAgICAxNywKICAgICAgICAxOSwKICAgICAgICAyMywKICAgICAgICAyNywKICAgICAgICAzMSwKICAgICAgICAzNSwKICAgICAgICA0MywKICAgICAgICA1MSwKICAgICAgICA1OSwKICAgICAgICA2NywKICAgICAgICA4MywKICAgICAgICA5OSwKICAgICAgICAxMTUsCiAgICAgICAgMTMxLAogICAgICAgIDE2MywKICAgICAgICAxOTUsCiAgICAgICAgMjI3LAogICAgICAgIDI1OCwKICAgICAgICAwLAogICAgICAgIDAKICAgICAgXTsKICAgICAgdmFyIGxleHQgPSBbCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMTYsCiAgICAgICAgNzIsCiAgICAgICAgNzgKICAgICAgXTsKICAgICAgdmFyIGRiYXNlID0gWwogICAgICAgIDEsCiAgICAgICAgMiwKICAgICAgICAzLAogICAgICAgIDQsCiAgICAgICAgNSwKICAgICAgICA3LAogICAgICAgIDksCiAgICAgICAgMTMsCiAgICAgICAgMTcsCiAgICAgICAgMjUsCiAgICAgICAgMzMsCiAgICAgICAgNDksCiAgICAgICAgNjUsCiAgICAgICAgOTcsCiAgICAgICAgMTI5LAogICAgICAgIDE5MywKICAgICAgICAyNTcsCiAgICAgICAgMzg1LAogICAgICAgIDUxMywKICAgICAgICA3NjksCiAgICAgICAgMTAyNSwKICAgICAgICAxNTM3LAogICAgICAgIDIwNDksCiAgICAgICAgMzA3MywKICAgICAgICA0MDk3LAogICAgICAgIDYxNDUsCiAgICAgICAgODE5MywKICAgICAgICAxMjI4OSwKICAgICAgICAxNjM4NSwKICAgICAgICAyNDU3NywKICAgICAgICAwLAogICAgICAgIDAKICAgICAgXTsKICAgICAgdmFyIGRleHQgPSBbCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjIsCiAgICAgICAgMjIsCiAgICAgICAgMjMsCiAgICAgICAgMjMsCiAgICAgICAgMjQsCiAgICAgICAgMjQsCiAgICAgICAgMjUsCiAgICAgICAgMjUsCiAgICAgICAgMjYsCiAgICAgICAgMjYsCiAgICAgICAgMjcsCiAgICAgICAgMjcsCiAgICAgICAgMjgsCiAgICAgICAgMjgsCiAgICAgICAgMjksCiAgICAgICAgMjksCiAgICAgICAgNjQsCiAgICAgICAgNjQKICAgICAgXTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKSB7CiAgICAgICAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgdmFyIGxlbiA9IDA7CiAgICAgICAgdmFyIHN5bSA9IDA7CiAgICAgICAgdmFyIG1pbiA9IDAsIG1heCA9IDA7CiAgICAgICAgdmFyIHJvb3QyID0gMDsKICAgICAgICB2YXIgY3VyciA9IDA7CiAgICAgICAgdmFyIGRyb3AgPSAwOwogICAgICAgIHZhciBsZWZ0ID0gMDsKICAgICAgICB2YXIgdXNlZCA9IDA7CiAgICAgICAgdmFyIGh1ZmYgPSAwOwogICAgICAgIHZhciBpbmNyOwogICAgICAgIHZhciBmaWxsOwogICAgICAgIHZhciBsb3c7CiAgICAgICAgdmFyIG1hc2s7CiAgICAgICAgdmFyIG5leHQ7CiAgICAgICAgdmFyIGJhc2UgPSBudWxsOwogICAgICAgIHZhciBiYXNlX2luZGV4ID0gMDsKICAgICAgICB2YXIgZW5kOwogICAgICAgIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7CiAgICAgICAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOwogICAgICAgIHZhciBleHRyYSA9IG51bGw7CiAgICAgICAgdmFyIGV4dHJhX2luZGV4ID0gMDsKICAgICAgICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsKICAgICAgICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykgewogICAgICAgICAgY291bnRbbGVuXSA9IDA7CiAgICAgICAgfQogICAgICAgIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7CiAgICAgICAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrOwogICAgICAgIH0KICAgICAgICByb290MiA9IGJpdHM7CiAgICAgICAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHsKICAgICAgICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocm9vdDIgPiBtYXgpIHsKICAgICAgICAgIHJvb3QyID0gbWF4OwogICAgICAgIH0KICAgICAgICBpZiAobWF4ID09PSAwKSB7CiAgICAgICAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9IDEgPDwgMjQgfCA2NCA8PCAxNiB8IDA7CiAgICAgICAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9IDEgPDwgMjQgfCA2NCA8PCAxNiB8IDA7CiAgICAgICAgICBvcHRzLmJpdHMgPSAxOwogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykgewogICAgICAgICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChyb290MiA8IG1pbikgewogICAgICAgICAgcm9vdDIgPSBtaW47CiAgICAgICAgfQogICAgICAgIGxlZnQgPSAxOwogICAgICAgIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7CiAgICAgICAgICBsZWZ0IDw8PSAxOwogICAgICAgICAgbGVmdCAtPSBjb3VudFtsZW5dOwogICAgICAgICAgaWYgKGxlZnQgPCAwKSB7CiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7CiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgfQogICAgICAgIG9mZnNbMV0gPSAwOwogICAgICAgIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dOwogICAgICAgIH0KICAgICAgICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykgewogICAgICAgICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHsKICAgICAgICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAodHlwZSA9PT0gQ09ERVMpIHsKICAgICAgICAgIGJhc2UgPSBleHRyYSA9IHdvcms7CiAgICAgICAgICBlbmQgPSAxOTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHsKICAgICAgICAgIGJhc2UgPSBsYmFzZTsKICAgICAgICAgIGJhc2VfaW5kZXggLT0gMjU3OwogICAgICAgICAgZXh0cmEgPSBsZXh0OwogICAgICAgICAgZXh0cmFfaW5kZXggLT0gMjU3OwogICAgICAgICAgZW5kID0gMjU2OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBiYXNlID0gZGJhc2U7CiAgICAgICAgICBleHRyYSA9IGRleHQ7CiAgICAgICAgICBlbmQgPSAtMTsKICAgICAgICB9CiAgICAgICAgaHVmZiA9IDA7CiAgICAgICAgc3ltID0gMDsKICAgICAgICBsZW4gPSBtaW47CiAgICAgICAgbmV4dCA9IHRhYmxlX2luZGV4OwogICAgICAgIGN1cnIgPSByb290MjsKICAgICAgICBkcm9wID0gMDsKICAgICAgICBsb3cgPSAtMTsKICAgICAgICB1c2VkID0gMSA8PCByb290MjsKICAgICAgICBtYXNrID0gdXNlZCAtIDE7CiAgICAgICAgaWYgKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TIHx8IHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpIHsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7CiAgICAgICAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSAwOwogICAgICAgICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTsKICAgICAgICAgIH0gZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07CiAgICAgICAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSAzMiArIDY0OwogICAgICAgICAgICBoZXJlX3ZhbCA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBpbmNyID0gMSA8PCBsZW4gLSBkcm9wOwogICAgICAgICAgZmlsbCA9IDEgPDwgY3VycjsKICAgICAgICAgIG1pbiA9IGZpbGw7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGZpbGwgLT0gaW5jcjsKICAgICAgICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSBoZXJlX2JpdHMgPDwgMjQgfCBoZXJlX29wIDw8IDE2IHwgaGVyZV92YWwgfCAwOwogICAgICAgICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7CiAgICAgICAgICBpbmNyID0gMSA8PCBsZW4gLSAxOwogICAgICAgICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7CiAgICAgICAgICAgIGluY3IgPj49IDE7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5jciAhPT0gMCkgewogICAgICAgICAgICBodWZmICY9IGluY3IgLSAxOwogICAgICAgICAgICBodWZmICs9IGluY3I7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBodWZmID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHN5bSsrOwogICAgICAgICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkgewogICAgICAgICAgICBpZiAobGVuID09PSBtYXgpIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGxlbiA+IHJvb3QyICYmIChodWZmICYgbWFzaykgIT09IGxvdykgewogICAgICAgICAgICBpZiAoZHJvcCA9PT0gMCkgewogICAgICAgICAgICAgIGRyb3AgPSByb290MjsKICAgICAgICAgICAgfQogICAgICAgICAgICBuZXh0ICs9IG1pbjsKICAgICAgICAgICAgY3VyciA9IGxlbiAtIGRyb3A7CiAgICAgICAgICAgIGxlZnQgPSAxIDw8IGN1cnI7CiAgICAgICAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkgewogICAgICAgICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdOwogICAgICAgICAgICAgIGlmIChsZWZ0IDw9IDApIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjdXJyKys7CiAgICAgICAgICAgICAgbGVmdCA8PD0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgICB1c2VkICs9IDEgPDwgY3VycjsKICAgICAgICAgICAgaWYgKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TIHx8IHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpIHsKICAgICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgICAgfQogICAgICAgICAgICBsb3cgPSBodWZmICYgbWFzazsKICAgICAgICAgICAgdGFibGVbbG93XSA9IHJvb3QyIDw8IDI0IHwgY3VyciA8PCAxNiB8IG5leHQgLSB0YWJsZV9pbmRleCB8IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChodWZmICE9PSAwKSB7CiAgICAgICAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgIH0KICAgICAgICBvcHRzLmJpdHMgPSByb290MjsKICAgICAgICByZXR1cm4gMDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMKICB2YXIgcmVxdWlyZV9pbmZsYXRlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgYWRsZXIzMiA9IHJlcXVpcmVfYWRsZXIzMigpOwogICAgICB2YXIgY3JjMzIgPSByZXF1aXJlX2NyYzMyKCk7CiAgICAgIHZhciBpbmZsYXRlX2Zhc3QgPSByZXF1aXJlX2luZmZhc3QoKTsKICAgICAgdmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlX2luZnRyZWVzKCk7CiAgICAgIHZhciBDT0RFUyA9IDA7CiAgICAgIHZhciBMRU5TID0gMTsKICAgICAgdmFyIERJU1RTID0gMjsKICAgICAgdmFyIFpfRklOSVNIID0gNDsKICAgICAgdmFyIFpfQkxPQ0sgPSA1OwogICAgICB2YXIgWl9UUkVFUyA9IDY7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX05FRURfRElDVCA9IDI7CiAgICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yOwogICAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7CiAgICAgIHZhciBaX01FTV9FUlJPUiA9IC00OwogICAgICB2YXIgWl9CVUZfRVJST1IgPSAtNTsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICB2YXIgSEVBRCA9IDE7CiAgICAgIHZhciBGTEFHUyA9IDI7CiAgICAgIHZhciBUSU1FID0gMzsKICAgICAgdmFyIE9TID0gNDsKICAgICAgdmFyIEVYTEVOID0gNTsKICAgICAgdmFyIEVYVFJBID0gNjsKICAgICAgdmFyIE5BTUUgPSA3OwogICAgICB2YXIgQ09NTUVOVCA9IDg7CiAgICAgIHZhciBIQ1JDID0gOTsKICAgICAgdmFyIERJQ1RJRCA9IDEwOwogICAgICB2YXIgRElDVCA9IDExOwogICAgICB2YXIgVFlQRSA9IDEyOwogICAgICB2YXIgVFlQRURPID0gMTM7CiAgICAgIHZhciBTVE9SRUQgPSAxNDsKICAgICAgdmFyIENPUFlfID0gMTU7CiAgICAgIHZhciBDT1BZID0gMTY7CiAgICAgIHZhciBUQUJMRSA9IDE3OwogICAgICB2YXIgTEVOTEVOUyA9IDE4OwogICAgICB2YXIgQ09ERUxFTlMgPSAxOTsKICAgICAgdmFyIExFTl8gPSAyMDsKICAgICAgdmFyIExFTiA9IDIxOwogICAgICB2YXIgTEVORVhUID0gMjI7CiAgICAgIHZhciBESVNUID0gMjM7CiAgICAgIHZhciBESVNURVhUID0gMjQ7CiAgICAgIHZhciBNQVRDSCA9IDI1OwogICAgICB2YXIgTElUID0gMjY7CiAgICAgIHZhciBDSEVDSyA9IDI3OwogICAgICB2YXIgTEVOR1RIID0gMjg7CiAgICAgIHZhciBET05FID0gMjk7CiAgICAgIHZhciBCQUQgPSAzMDsKICAgICAgdmFyIE1FTSA9IDMxOwogICAgICB2YXIgU1lOQyA9IDMyOwogICAgICB2YXIgRU5PVUdIX0xFTlMgPSA4NTI7CiAgICAgIHZhciBFTk9VR0hfRElTVFMgPSA1OTI7CiAgICAgIHZhciBNQVhfV0JJVFMgPSAxNTsKICAgICAgdmFyIERFRl9XQklUUyA9IE1BWF9XQklUUzsKICAgICAgZnVuY3Rpb24genN3YXAzMihxKSB7CiAgICAgICAgcmV0dXJuIChxID4+PiAyNCAmIDI1NSkgKyAocSA+Pj4gOCAmIDY1MjgwKSArICgocSAmIDY1MjgwKSA8PCA4KSArICgocSAmIDI1NSkgPDwgMjQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHsKICAgICAgICB0aGlzLm1vZGUgPSAwOwogICAgICAgIHRoaXMubGFzdCA9IGZhbHNlOwogICAgICAgIHRoaXMud3JhcCA9IDA7CiAgICAgICAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOwogICAgICAgIHRoaXMuZmxhZ3MgPSAwOwogICAgICAgIHRoaXMuZG1heCA9IDA7CiAgICAgICAgdGhpcy5jaGVjayA9IDA7CiAgICAgICAgdGhpcy50b3RhbCA9IDA7CiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDsKICAgICAgICB0aGlzLndiaXRzID0gMDsKICAgICAgICB0aGlzLndzaXplID0gMDsKICAgICAgICB0aGlzLndoYXZlID0gMDsKICAgICAgICB0aGlzLnduZXh0ID0gMDsKICAgICAgICB0aGlzLndpbmRvdyA9IG51bGw7CiAgICAgICAgdGhpcy5ob2xkID0gMDsKICAgICAgICB0aGlzLmJpdHMgPSAwOwogICAgICAgIHRoaXMubGVuZ3RoID0gMDsKICAgICAgICB0aGlzLm9mZnNldCA9IDA7CiAgICAgICAgdGhpcy5leHRyYSA9IDA7CiAgICAgICAgdGhpcy5sZW5jb2RlID0gbnVsbDsKICAgICAgICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsKICAgICAgICB0aGlzLmxlbmJpdHMgPSAwOwogICAgICAgIHRoaXMuZGlzdGJpdHMgPSAwOwogICAgICAgIHRoaXMubmNvZGUgPSAwOwogICAgICAgIHRoaXMubmxlbiA9IDA7CiAgICAgICAgdGhpcy5uZGlzdCA9IDA7CiAgICAgICAgdGhpcy5oYXZlID0gMDsKICAgICAgICB0aGlzLm5leHQgPSBudWxsOwogICAgICAgIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOwogICAgICAgIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOwogICAgICAgIHRoaXMubGVuZHluID0gbnVsbDsKICAgICAgICB0aGlzLmRpc3RkeW4gPSBudWxsOwogICAgICAgIHRoaXMuc2FuZSA9IDA7CiAgICAgICAgdGhpcy5iYWNrID0gMDsKICAgICAgICB0aGlzLndhcyA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwOwogICAgICAgIHN0cm0ubXNnID0gIiI7CiAgICAgICAgaWYgKHN0YXRlLndyYXApIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTsKICAgICAgICB9CiAgICAgICAgc3RhdGUubW9kZSA9IEhFQUQ7CiAgICAgICAgc3RhdGUubGFzdCA9IDA7CiAgICAgICAgc3RhdGUuaGF2ZWRpY3QgPSAwOwogICAgICAgIHN0YXRlLmRtYXggPSAzMjc2ODsKICAgICAgICBzdGF0ZS5oZWFkID0gbnVsbDsKICAgICAgICBzdGF0ZS5ob2xkID0gMDsKICAgICAgICBzdGF0ZS5iaXRzID0gMDsKICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTsKICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTsKICAgICAgICBzdGF0ZS5zYW5lID0gMTsKICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBzdGF0ZS53c2l6ZSA9IDA7CiAgICAgICAgc3RhdGUud2hhdmUgPSAwOwogICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHsKICAgICAgICB2YXIgd3JhcDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAod2luZG93Qml0cyA8IDApIHsKICAgICAgICAgIHdyYXAgPSAwOwogICAgICAgICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxOwogICAgICAgICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkgewogICAgICAgICAgICB3aW5kb3dCaXRzICY9IDE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7CiAgICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIH0KICAgICAgICBzdGF0ZS53cmFwID0gd3JhcDsKICAgICAgICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7CiAgICAgICAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykgewogICAgICAgIHZhciByZXQ7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTsKICAgICAgICBzdHJtLnN0YXRlID0gc3RhdGU7CiAgICAgICAgc3RhdGUud2luZG93ID0gbnVsbDsKICAgICAgICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpOwogICAgICAgIGlmIChyZXQgIT09IFpfT0spIHsKICAgICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHsKICAgICAgICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7CiAgICAgIH0KICAgICAgdmFyIHZpcmdpbiA9IHRydWU7CiAgICAgIHZhciBsZW5maXg7CiAgICAgIHZhciBkaXN0Zml4OwogICAgICBmdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkgewogICAgICAgIGlmICh2aXJnaW4pIHsKICAgICAgICAgIHZhciBzeW07CiAgICAgICAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTsKICAgICAgICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpOwogICAgICAgICAgc3ltID0gMDsKICAgICAgICAgIHdoaWxlIChzeW0gPCAxNDQpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA4OwogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKHN5bSA8IDI1NikgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMjgwKSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gNzsKICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzeW0gPCAyODgpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA4OwogICAgICAgICAgfQogICAgICAgICAgaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pOwogICAgICAgICAgc3ltID0gMDsKICAgICAgICAgIHdoaWxlIChzeW0gPCAzMikgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7CiAgICAgICAgICB9CiAgICAgICAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pOwogICAgICAgICAgdmlyZ2luID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7CiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7CiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4OwogICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHsKICAgICAgICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0czsKICAgICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICAgIHN0YXRlLndoYXZlID0gMDsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTsKICAgICAgICB9CiAgICAgICAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHsKICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApOwogICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7CiAgICAgICAgICBpZiAoZGlzdCA+IGNvcHkpIHsKICAgICAgICAgICAgZGlzdCA9IGNvcHk7CiAgICAgICAgICB9CiAgICAgICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpOwogICAgICAgICAgY29weSAtPSBkaXN0OwogICAgICAgICAgaWYgKGNvcHkpIHsKICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApOwogICAgICAgICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7CiAgICAgICAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGF0ZS53bmV4dCArPSBkaXN0OwogICAgICAgICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7CiAgICAgICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7CiAgICAgICAgICAgICAgc3RhdGUud2hhdmUgKz0gZGlzdDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIHZhciBpbnB1dCwgb3V0cHV0OwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBwdXQ7CiAgICAgICAgdmFyIGhhdmUsIGxlZnQ7CiAgICAgICAgdmFyIGhvbGQ7CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIF9pbiwgX291dDsKICAgICAgICB2YXIgY29weTsKICAgICAgICB2YXIgZnJvbTsKICAgICAgICB2YXIgZnJvbV9zb3VyY2U7CiAgICAgICAgdmFyIGhlcmUgPSAwOwogICAgICAgIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOwogICAgICAgIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIHJldDsKICAgICAgICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOwogICAgICAgIHZhciBvcHRzOwogICAgICAgIHZhciBuOwogICAgICAgIHZhciBvcmRlciA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8ICFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPOwogICAgICAgIH0KICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDsKICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICBfaW4gPSBoYXZlOwogICAgICAgIF9vdXQgPSBsZWZ0OwogICAgICAgIHJldCA9IFpfT0s7CiAgICAgICAgaW5mX2xlYXZlOgogICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUubW9kZSkgewogICAgICAgICAgICAgIGNhc2UgSEVBRDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCAmIDIgJiYgaG9sZCA9PT0gMzU2MTUpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSAwOwogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5mbGFncyA9IDA7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAoKChob2xkICYgMjU1KSA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImluY29ycmVjdCBoZWFkZXIgY2hlY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICgoaG9sZCAmIDE1KSAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDQ7CiAgICAgICAgICAgICAgICBiaXRzIC09IDQ7CiAgICAgICAgICAgICAgICBsZW4gPSAoaG9sZCAmIDE1KSArIDg7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgd2luZG93IHNpemUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjsKICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDE7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDUxMiA/IERJQ1RJRCA6IFRZUEU7CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBGTEFHUzoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkOwogICAgICAgICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDI1NSkgIT09IFpfREVGTEFURUQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDU3MzQ0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInVua25vd24gaGVhZGVyIGZsYWdzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gaG9sZCA+PiA4ICYgMTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FOwogICAgICAgICAgICAgIGNhc2UgVElNRToKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMl0gPSBob2xkID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlszXSA9IGhvbGQgPj4+IDI0ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gT1M7CiAgICAgICAgICAgICAgY2FzZSBPUzoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gaG9sZCA+PiA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOOwogICAgICAgICAgICAgIGNhc2UgRVhMRU46CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAxMDI0KSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTsKICAgICAgICAgICAgICBjYXNlIEVYVFJBOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMTAyNCkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkgewogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLmhlYWQuZXh0cmEsIGlucHV0LCBuZXh0LCBjb3B5LCBsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7CiAgICAgICAgICAgICAgY2FzZSBOQU1FOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMjA0OCkgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjb3B5ID0gMDsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdOwogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJiBzdGF0ZS5sZW5ndGggPCA2NTUzNikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7CiAgICAgICAgICAgICAgY2FzZSBDT01NRU5UOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNDA5NikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjb3B5ID0gMDsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdOwogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJiBzdGF0ZS5sZW5ndGggPCA2NTUzNikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gSENSQzsKICAgICAgICAgICAgICBjYXNlIEhDUkM6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDY1NTM1KSkgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImhlYWRlciBjcmMgbWlzbWF0Y2giOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gc3RhdGUuZmxhZ3MgPj4gOSAmIDE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIERJQ1RJRDoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTsKICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDsKICAgICAgICAgICAgICBjYXNlIERJQ1Q6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0OwogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgICAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgY2FzZSBUWVBFOgogICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjYXNlIFRZUEVETzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNzsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sYXN0ID0gaG9sZCAmIDE7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMTsKICAgICAgICAgICAgICAgIHN3aXRjaCAoaG9sZCAmIDMpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87CiAgICAgICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJsb2NrIHR5cGUiOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgU1RPUkVEOgogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChob2xkICYgNjU1MzUpICE9PSAoaG9sZCA+Pj4gMTYgXiA2NTUzNSkpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3RocyI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDY1NTM1OwogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXzsKICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY2FzZSBDT1BZXzoKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZOwogICAgICAgICAgICAgIGNhc2UgQ09QWToKICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpOwogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgbGVmdCAtPSBjb3B5OwogICAgICAgICAgICAgICAgICBwdXQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIFRBQkxFOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAzMSkgKyAyNTc7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNTsKICAgICAgICAgICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAzMSkgKyAxOwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDU7CiAgICAgICAgICAgICAgICBiaXRzIC09IDU7CiAgICAgICAgICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMTUpICsgNDsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA0OwogICAgICAgICAgICAgICAgYml0cyAtPSA0OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuaGF2ZSA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUzsKICAgICAgICAgICAgICBjYXNlIExFTkxFTlM6CiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IGhvbGQgJiA3OwogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMzsKICAgICAgICAgICAgICAgICAgYml0cyAtPSAzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNzsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgY29kZSBsZW5ndGhzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuaGF2ZSA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7CiAgICAgICAgICAgICAgY2FzZSBDT0RFTEVOUzoKICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7CiAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDFdOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IjsKICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTsKICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAzKTsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7CiAgICAgICAgICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMzsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDcpOwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IDM7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3OwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDEyNyk7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gNzsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gNzsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IjsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgewogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzOwogICAgICAgICAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjsKICAgICAgICAgICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07CiAgICAgICAgICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2VzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87CiAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhc2UgTEVOXzoKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU47CiAgICAgICAgICAgICAgY2FzZSBMRU46CiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7CiAgICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICAgICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpOwogICAgICAgICAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgICAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgICAgICAgICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgICAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgICAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luOwogICAgICAgICAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICAgICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IDA7CiAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDI0MCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDsKICAgICAgICAgICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgKyAoKGhvbGQgJiAoMSA8PCBsYXN0X2JpdHMgKyBsYXN0X29wKSAtIDEpID4+IGxhc3RfYml0cyldOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9iaXRzICsgaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYgMzIpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUOwogICAgICAgICAgICAgIGNhc2UgTEVORVhUOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7CiAgICAgICAgICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgxIDw8IHN0YXRlLmV4dHJhKSAtIDE7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESVNUOwogICAgICAgICAgICAgIGNhc2UgRElTVDoKICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDFdOwogICAgICAgICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChoZXJlX29wICYgMjQwKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wOwogICAgICAgICAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgKyAoKGhvbGQgJiAoMSA8PCBsYXN0X2JpdHMgKyBsYXN0X29wKSAtIDEpID4+IGxhc3RfYml0cyldOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9iaXRzICsgaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDsKICAgICAgICAgICAgICBjYXNlIERJU1RFWFQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgbiA9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKDEgPDwgc3RhdGUuZXh0cmEpIC0gMTsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDsKICAgICAgICAgICAgICBjYXNlIE1BVENIOgogICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsKICAgICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkgewogICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDsKICAgICAgICAgICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5OwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93OwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7CiAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsKICAgICAgICAgICAgICAgICAgY29weSA9IGxlZnQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBsZWZ0IC09IGNvcHk7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpOwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBMSVQ6CiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgbGVmdC0tOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgQ0hFQ0s6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCkgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBfb3V0IC09IGxlZnQ7CiAgICAgICAgICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7CiAgICAgICAgICAgICAgICAgIGlmIChfb3V0KSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgX291dCA9IGxlZnQ7CiAgICAgICAgICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGRhdGEgY2hlY2siOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDsKICAgICAgICAgICAgICBjYXNlIExFTkdUSDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiA0Mjk0OTY3Mjk1KSkgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImluY29ycmVjdCBsZW5ndGggY2hlY2siOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7CiAgICAgICAgICAgICAgY2FzZSBET05FOgogICAgICAgICAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EOwogICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgIGNhc2UgQkFEOgogICAgICAgICAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SOwogICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgIGNhc2UgTUVNOgogICAgICAgICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgICAgICAgIGNhc2UgU1lOQzoKICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICBpZiAoc3RhdGUud3NpemUgfHwgX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJiAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpIHsKICAgICAgICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IE1FTTsKICAgICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBfaW4gLT0gc3RybS5hdmFpbF9pbjsKICAgICAgICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIHN0cm0udG90YWxfaW4gKz0gX2luOwogICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7CiAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDsKICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSBzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpOwogICAgICAgIH0KICAgICAgICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgKyAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICsgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTsKICAgICAgICBpZiAoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7CiAgICAgICAgICByZXQgPSBaX0JVRl9FUlJPUjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUud2luZG93KSB7CiAgICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIH0KICAgICAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5oZWFkID0gaGVhZDsKICAgICAgICBoZWFkLmRvbmUgPSBmYWxzZTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7CiAgICAgICAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgdmFyIGRpY3RpZDsKICAgICAgICB2YXIgcmV0OwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkgewogICAgICAgICAgZGljdGlkID0gMTsKICAgICAgICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTsKICAgICAgICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7CiAgICAgICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTsKICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gTUVNOwogICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5oYXZlZGljdCA9IDE7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZXhwb3J0czIuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0OwogICAgICBleHBvcnRzMi5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjsKICAgICAgZXhwb3J0czIuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjsKICAgICAgZXhwb3J0czIuaW5mbGF0ZSA9IGluZmxhdGU7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kOwogICAgICBleHBvcnRzMi5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjsKICAgICAgZXhwb3J0czIuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUluZm8gPSAicGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMKICB2YXIgcmVxdWlyZV9jb25zdGFudHMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gewogICAgICAgIFpfTk9fRkxVU0g6IDAsCiAgICAgICAgWl9QQVJUSUFMX0ZMVVNIOiAxLAogICAgICAgIFpfU1lOQ19GTFVTSDogMiwKICAgICAgICBaX0ZVTExfRkxVU0g6IDMsCiAgICAgICAgWl9GSU5JU0g6IDQsCiAgICAgICAgWl9CTE9DSzogNSwKICAgICAgICBaX1RSRUVTOiA2LAogICAgICAgIFpfT0s6IDAsCiAgICAgICAgWl9TVFJFQU1fRU5EOiAxLAogICAgICAgIFpfTkVFRF9ESUNUOiAyLAogICAgICAgIFpfRVJSTk86IC0xLAogICAgICAgIFpfU1RSRUFNX0VSUk9SOiAtMiwKICAgICAgICBaX0RBVEFfRVJST1I6IC0zLAogICAgICAgIFpfQlVGX0VSUk9SOiAtNSwKICAgICAgICBaX05PX0NPTVBSRVNTSU9OOiAwLAogICAgICAgIFpfQkVTVF9TUEVFRDogMSwKICAgICAgICBaX0JFU1RfQ09NUFJFU1NJT046IDksCiAgICAgICAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAtMSwKICAgICAgICBaX0ZJTFRFUkVEOiAxLAogICAgICAgIFpfSFVGRk1BTl9PTkxZOiAyLAogICAgICAgIFpfUkxFOiAzLAogICAgICAgIFpfRklYRUQ6IDQsCiAgICAgICAgWl9ERUZBVUxUX1NUUkFURUdZOiAwLAogICAgICAgIFpfQklOQVJZOiAwLAogICAgICAgIFpfVEVYVDogMSwKICAgICAgICBaX1VOS05PV046IDIsCiAgICAgICAgWl9ERUZMQVRFRDogOAogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMKICB2YXIgcmVxdWlyZV9nemhlYWRlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIEdaaGVhZGVyKCkgewogICAgICAgIHRoaXMudGV4dCA9IDA7CiAgICAgICAgdGhpcy50aW1lID0gMDsKICAgICAgICB0aGlzLnhmbGFncyA9IDA7CiAgICAgICAgdGhpcy5vcyA9IDA7CiAgICAgICAgdGhpcy5leHRyYSA9IG51bGw7CiAgICAgICAgdGhpcy5leHRyYV9sZW4gPSAwOwogICAgICAgIHRoaXMubmFtZSA9ICIiOwogICAgICAgIHRoaXMuY29tbWVudCA9ICIiOwogICAgICAgIHRoaXMuaGNyYyA9IDA7CiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gR1poZWFkZXI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcwogIHZhciByZXF1aXJlX2luZmxhdGUyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmVfaW5mbGF0ZSgpOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgc3RyaW5ncyA9IHJlcXVpcmVfc3RyaW5ncygpOwogICAgICB2YXIgYyA9IHJlcXVpcmVfY29uc3RhbnRzKCk7CiAgICAgIHZhciBtc2cgPSByZXF1aXJlX21lc3NhZ2VzKCk7CiAgICAgIHZhciBaU3RyZWFtID0gcmVxdWlyZV96c3RyZWFtKCk7CiAgICAgIHZhciBHWmhlYWRlciA9IHJlcXVpcmVfZ3poZWFkZXIoKTsKICAgICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzsKICAgICAgZnVuY3Rpb24gSW5mbGF0ZTIob3B0aW9ucykgewogICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlMikpCiAgICAgICAgICByZXR1cm4gbmV3IEluZmxhdGUyKG9wdGlvbnMpOwogICAgICAgIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7CiAgICAgICAgICBjaHVua1NpemU6IDE2Mzg0LAogICAgICAgICAgd2luZG93Qml0czogMCwKICAgICAgICAgIHRvOiAiIgogICAgICAgIH0sIG9wdGlvbnMgfHwge30pOwogICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7CiAgICAgICAgaWYgKG9wdC5yYXcgJiYgb3B0LndpbmRvd0JpdHMgPj0gMCAmJiBvcHQud2luZG93Qml0cyA8IDE2KSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0czsKICAgICAgICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgewogICAgICAgICAgICBvcHQud2luZG93Qml0cyA9IC0xNTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID49IDAgJiYgb3B0LndpbmRvd0JpdHMgPCAxNiAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7CiAgICAgICAgfQogICAgICAgIGlmIChvcHQud2luZG93Qml0cyA+IDE1ICYmIG9wdC53aW5kb3dCaXRzIDwgNDgpIHsKICAgICAgICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHsKICAgICAgICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuZXJyID0gMDsKICAgICAgICB0aGlzLm1zZyA9ICIiOwogICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7CiAgICAgICAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIodGhpcy5zdHJtLCBvcHQud2luZG93Qml0cyk7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgIH0KICAgICAgICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpOwogICAgICAgIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpOwogICAgICAgIGlmIChvcHQuZGljdGlvbmFyeSkgewogICAgICAgICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gIltvYmplY3QgQXJyYXlCdWZmZXJdIikgewogICAgICAgICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChvcHQucmF3KSB7CiAgICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBJbmZsYXRlMi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGRhdGEsIG1vZGUpIHsKICAgICAgICB2YXIgc3RybSA9IHRoaXMuc3RybTsKICAgICAgICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTsKICAgICAgICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5OwogICAgICAgIHZhciBzdGF0dXMsIF9tb2RlOwogICAgICAgIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyOwogICAgICAgIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7CiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgX21vZGUgPSBtb2RlID09PSB+fm1vZGUgPyBtb2RlIDogbW9kZSA9PT0gdHJ1ZSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0g7CiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAic3RyaW5nIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IHN0cmluZ3MuYmluc3RyaW5nMmJ1ZihkYXRhKTsKICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RybS5pbnB1dCA9IGRhdGE7CiAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9pbiA9IDA7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoOwogICAgICAgIGRvIHsKICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7CiAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSAwOwogICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7CiAgICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHsKICAgICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdGlvbmFyeSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfQlVGX0VSUk9SICYmIGFsbG93QnVmRXJyb3IgPT09IHRydWUpIHsKICAgICAgICAgICAgc3RhdHVzID0gYy5aX09LOwogICAgICAgICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykgewogICAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RybS5uZXh0X291dCkgewogICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCBzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSB7CiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpOwogICAgICAgICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4OwogICAgICAgICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7CiAgICAgICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDsKICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDsKICAgICAgICAgICAgICAgIGlmICh0YWlsKSB7CiAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpOwogICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7CiAgICAgICAgICBfbW9kZSA9IGMuWl9GSU5JU0g7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkgewogICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTsKICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gYy5aX09LOwogICAgICAgIH0KICAgICAgICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7CiAgICAgICAgICB0aGlzLm9uRW5kKGMuWl9PSyk7CiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH07CiAgICAgIEluZmxhdGUyLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihjaHVuaykgewogICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspOwogICAgICB9OwogICAgICBJbmZsYXRlMi5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzdGF0dXMpIHsKICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHsKICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbigiIik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuZXJyID0gc3RhdHVzOwogICAgICAgIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZzsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykgewogICAgICAgIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlMihvcHRpb25zKTsKICAgICAgICBpbmZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTsKICAgICAgICBpZiAoaW5mbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07CiAgICAgICAgfQogICAgICAgIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTsKICAgICAgICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuSW5mbGF0ZSA9IEluZmxhdGUyOwogICAgICBleHBvcnRzMi5pbmZsYXRlID0gaW5mbGF0ZTsKICAgICAgZXhwb3J0czIuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7CiAgICAgIGV4cG9ydHMyLnVuZ3ppcCA9IGluZmxhdGU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcwogIHZhciByZXF1aXJlX3Bha28gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgYXNzaWduID0gcmVxdWlyZV9jb21tb24oKS5hc3NpZ247CiAgICAgIHZhciBkZWZsYXRlID0gcmVxdWlyZV9kZWZsYXRlMigpOwogICAgICB2YXIgaW5mbGF0ZSA9IHJlcXVpcmVfaW5mbGF0ZTIoKTsKICAgICAgdmFyIGNvbnN0YW50cyA9IHJlcXVpcmVfY29uc3RhbnRzKCk7CiAgICAgIHZhciBwYWtvID0ge307CiAgICAgIGFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBwYWtvOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9uZ0A0LjAuMC9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcwogIHZhciByZXF1aXJlX2xvbmcgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vbG9uZ0A0LjAuMC9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBMb25nNDsKICAgICAgdmFyIHdhc20gPSBudWxsOwogICAgICB0cnkgewogICAgICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbCiAgICAgICAgICAwLAogICAgICAgICAgOTcsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxLAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDEzLAogICAgICAgICAgMiwKICAgICAgICAgIDk2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjcsCiAgICAgICAgICA5NiwKICAgICAgICAgIDQsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMywKICAgICAgICAgIDcsCiAgICAgICAgICA2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgNiwKICAgICAgICAgIDYsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMSwKICAgICAgICAgIDY1LAogICAgICAgICAgMCwKICAgICAgICAgIDExLAogICAgICAgICAgNywKICAgICAgICAgIDUwLAogICAgICAgICAgNiwKICAgICAgICAgIDMsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxMTcsCiAgICAgICAgICAxMDgsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDUsCiAgICAgICAgICAxMDAsCiAgICAgICAgICAxMDUsCiAgICAgICAgICAxMTgsCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNSwKICAgICAgICAgIDAsCiAgICAgICAgICAyLAogICAgICAgICAgNSwKICAgICAgICAgIDEwMCwKICAgICAgICAgIDEwNSwKICAgICAgICAgIDExOCwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE3LAogICAgICAgICAgMCwKICAgICAgICAgIDMsCiAgICAgICAgICA1LAogICAgICAgICAgMTE0LAogICAgICAgICAgMTAxLAogICAgICAgICAgMTA5LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAwLAogICAgICAgICAgNCwKICAgICAgICAgIDUsCiAgICAgICAgICAxMTQsCiAgICAgICAgICAxMDEsCiAgICAgICAgICAxMDksCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNywKICAgICAgICAgIDAsCiAgICAgICAgICA1LAogICAgICAgICAgOCwKICAgICAgICAgIDEwMywKICAgICAgICAgIDEwMSwKICAgICAgICAgIDExNiwKICAgICAgICAgIDk1LAogICAgICAgICAgMTA0LAogICAgICAgICAgMTA1LAogICAgICAgICAgMTAzLAogICAgICAgICAgMTA0LAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAxMCwKICAgICAgICAgIDE5MSwKICAgICAgICAgIDEsCiAgICAgICAgICA2LAogICAgICAgICAgNCwKICAgICAgICAgIDAsCiAgICAgICAgICAzNSwKICAgICAgICAgIDAsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNywKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOSwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEzMCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMQogICAgICAgIF0pKSwge30pLmV4cG9ydHM7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgfQogICAgICBmdW5jdGlvbiBMb25nNChsb3csIGhpZ2gsIHVuc2lnbmVkKSB7CiAgICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwOwogICAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwOwogICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgICB9CiAgICAgIExvbmc0LnByb3RvdHlwZS5fX2lzTG9uZ19fOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZzQucHJvdG90eXBlLCAiX19pc0xvbmdfXyIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGZ1bmN0aW9uIGlzTG9uZyhvYmopIHsKICAgICAgICByZXR1cm4gKG9iaiAmJiBvYmpbIl9faXNMb25nX18iXSkgPT09IHRydWU7CiAgICAgIH0KICAgICAgTG9uZzQuaXNMb25nID0gaXNMb25nOwogICAgICB2YXIgSU5UX0NBQ0hFID0ge307CiAgICAgIHZhciBVSU5UX0NBQ0hFID0ge307CiAgICAgIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7CiAgICAgICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTsKICAgICAgICBpZiAodW5zaWduZWQpIHsKICAgICAgICAgIHZhbHVlID4+Pj0gMDsKICAgICAgICAgIGlmIChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpIHsKICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpOwogICAgICAgICAgaWYgKGNhY2hlKQogICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajsKICAgICAgICAgIHJldHVybiBvYmo7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhbHVlIHw9IDA7CiAgICAgICAgICBpZiAoY2FjaGUgPSAtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSB7CiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTsKICAgICAgICAgIGlmIChjYWNoZSkKICAgICAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajsKICAgICAgICAgIHJldHVybiBvYmo7CiAgICAgICAgfQogICAgICB9CiAgICAgIExvbmc0LmZyb21JbnQgPSBmcm9tSW50OwogICAgICBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkgewogICAgICAgIGlmIChpc05hTih2YWx1ZSkpCiAgICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICAgICAgaWYgKHVuc2lnbmVkKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgICByZXR1cm4gVVpFUk87CiAgICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpCiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpCiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKQogICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFOwogICAgICAgIH0KICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCB2YWx1ZSAvIFRXT19QV1JfMzJfREJMIHwgMCwgdW5zaWduZWQpOwogICAgICB9CiAgICAgIExvbmc0LmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyOwogICAgICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmc0KGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbUJpdHMgPSBmcm9tQml0czsKICAgICAgdmFyIHBvd19kYmwgPSBNYXRoLnBvdzsKICAgICAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkgewogICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKQogICAgICAgICAgdGhyb3cgRXJyb3IoImVtcHR5IHN0cmluZyIpOwogICAgICAgIGlmIChzdHIgPT09ICJOYU4iIHx8IHN0ciA9PT0gIkluZmluaXR5IiB8fCBzdHIgPT09ICIrSW5maW5pdHkiIHx8IHN0ciA9PT0gIi1JbmZpbml0eSIpCiAgICAgICAgICByZXR1cm4gWkVSTzsKICAgICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAibnVtYmVyIikgewogICAgICAgICAgcmFkaXggPSB1bnNpZ25lZCwgdW5zaWduZWQgPSBmYWxzZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgICAgIH0KICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwOwogICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkKICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoInJhZGl4Iik7CiAgICAgICAgdmFyIHA7CiAgICAgICAgaWYgKChwID0gc3RyLmluZGV4T2YoIi0iKSkgPiAwKQogICAgICAgICAgdGhyb3cgRXJyb3IoImludGVyaW9yIGh5cGhlbiIpOwogICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHsKICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7CiAgICAgICAgfQogICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTsKICAgICAgICB2YXIgcmVzdWx0ID0gWkVSTzsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkgewogICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTsKICAgICAgICAgIGlmIChzaXplIDwgOCkgewogICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkOwogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7CiAgICAgIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKQogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICJib29sZWFuIiA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nNC5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7CiAgICAgIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7CiAgICAgIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7CiAgICAgIHZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7CiAgICAgIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7CiAgICAgIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjsKICAgICAgdmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTsKICAgICAgdmFyIFpFUk8gPSBmcm9tSW50KDApOwogICAgICBMb25nNC5aRVJPID0gWkVSTzsKICAgICAgdmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTsKICAgICAgTG9uZzQuVVpFUk8gPSBVWkVSTzsKICAgICAgdmFyIE9ORSA9IGZyb21JbnQoMSk7CiAgICAgIExvbmc0Lk9ORSA9IE9ORTsKICAgICAgdmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpOwogICAgICBMb25nNC5VT05FID0gVU9ORTsKICAgICAgdmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTsKICAgICAgTG9uZzQuTkVHX09ORSA9IE5FR19PTkU7CiAgICAgIHZhciBNQVhfVkFMVUUgPSBmcm9tQml0cyg0Mjk0OTY3Mjk1IHwgMCwgMjE0NzQ4MzY0NyB8IDAsIGZhbHNlKTsKICAgICAgTG9uZzQuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFOwogICAgICB2YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoNDI5NDk2NzI5NSB8IDAsIDQyOTQ5NjcyOTUgfCAwLCB0cnVlKTsKICAgICAgTG9uZzQuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFOwogICAgICB2YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMjE0NzQ4MzY0OCB8IDAsIGZhbHNlKTsKICAgICAgTG9uZzQuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFOwogICAgICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmc0LnByb3RvdHlwZTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkgewogICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyMigpIHsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHsKICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwOwogICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkKICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoInJhZGl4Iik7CiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpCiAgICAgICAgICByZXR1cm4gIjAiOwogICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkgewogICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpOwogICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgcmV0dXJuICItIiArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpOwogICAgICAgIH0KICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksIHJlbSA9IHRoaXM7CiAgICAgICAgdmFyIHJlc3VsdCA9ICIiOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLCBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCwgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTsKICAgICAgICAgIHJlbSA9IHJlbURpdjsKICAgICAgICAgIGlmIChyZW0uaXNaZXJvKCkpCiAgICAgICAgICAgIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7CiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KQogICAgICAgICAgICAgIGRpZ2l0cyA9ICIwIiArIGRpZ2l0czsKICAgICAgICAgICAgcmVzdWx0ID0gIiIgKyBkaWdpdHMgKyByZXN1bHQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkgewogICAgICAgIHJldHVybiB0aGlzLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubG93ID4+PiAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkgewogICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpOwogICAgICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93OwogICAgICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSkKICAgICAgICAgIGlmICgodmFsICYgMSA8PCBiaXQpICE9IDApCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybzsKICAgICAgTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHsKICAgICAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHsKICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkgewogICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7CiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikgewogICAgICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgdGhpcy5oaWdoID4+PiAzMSA9PT0gMSAmJiBvdGhlci5oaWdoID4+PiAzMSA9PT0gMSkKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFsczsKICAgICAgTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHsKICAgICAgICByZXR1cm4gIXRoaXMuZXEob3RoZXIpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzOwogICAgICBMb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDwgMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47CiAgICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPD0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHsKICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuOwogICAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID49IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUuZ2UgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikgewogICAgICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLCBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTsKICAgICAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKQogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKQogICAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7CiAgICAgICAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHwgb3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwID8gLTEgOiAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7CiAgICAgIExvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkgewogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpCiAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOwogICAgICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlOwogICAgICBMb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHsKICAgICAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKQogICAgICAgICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7CiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiA2NTUzNTsKICAgICAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDsKICAgICAgICBjMDAgKz0gYTAwICsgYjAwOwogICAgICAgIGMxNiArPSBjMDAgPj4+IDE2OwogICAgICAgIGMwMCAmPSA2NTUzNTsKICAgICAgICBjMTYgKz0gYTE2ICsgYjE2OwogICAgICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgICAgIGMxNiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTMyICsgYjMyOwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjNDggKz0gYTQ4ICsgYjQ4OwogICAgICAgIGM0OCAmPSA2NTUzNTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkgewogICAgICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKQogICAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTsKICAgICAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDsKICAgICAgTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHsKICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiBaRVJPOwogICAgICAgIGlmICghaXNMb25nKG11bHRpcGxpZXIpKQogICAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTsKICAgICAgICBpZiAod2FzbSkgewogICAgICAgICAgdmFyIGxvdyA9IHdhc20ubXVsKHRoaXMubG93LCB0aGlzLmhpZ2gsIG11bHRpcGxpZXIubG93LCBtdWx0aXBsaWVyLmhpZ2gpOwogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpCiAgICAgICAgICByZXR1cm4gWkVSTzsKICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKQogICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87CiAgICAgICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSkKICAgICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPOwogICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTsKICAgICAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpOwogICAgICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpCiAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2OwogICAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiA2NTUzNTsKICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2OwogICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDY1NTM1OwogICAgICAgIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2OwogICAgICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiA2NTUzNTsKICAgICAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2OwogICAgICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDY1NTM1OwogICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgICAgIGMwMCArPSBhMDAgKiBiMDA7CiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7CiAgICAgICAgYzAwICY9IDY1NTM1OwogICAgICAgIGMxNiArPSBhMTYgKiBiMDA7CiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICAgICAgYzE2ICY9IDY1NTM1OwogICAgICAgIGMxNiArPSBhMDAgKiBiMTY7CiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICAgICAgYzE2ICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMzIgKiBiMDA7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMTYgKiBiMTY7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMDAgKiBiMzI7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7CiAgICAgICAgYzQ4ICY9IDY1NTM1OwogICAgICAgIHJldHVybiBmcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTsKICAgICAgTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikgewogICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKQogICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTsKICAgICAgICBpZiAoZGl2aXNvci5pc1plcm8oKSkKICAgICAgICAgIHRocm93IEVycm9yKCJkaXZpc2lvbiBieSB6ZXJvIik7CiAgICAgICAgaWYgKHdhc20pIHsKICAgICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPT09IC0yMTQ3NDgzNjQ4ICYmIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5kaXZfdSA6IHdhc20uZGl2X3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpCiAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTzsKICAgICAgICB2YXIgYXBwcm94LCByZW0sIHJlczsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpIHsKICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHsKICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKQogICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkKICAgICAgICAgICAgICByZXR1cm4gT05FOwogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTsKICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpOwogICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHsKICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpOwogICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTsKICAgICAgICAgICAgICAgIHJldHVybiByZXM7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpOwogICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpOwogICAgICAgICAgcmVzID0gWkVSTzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKQogICAgICAgICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7CiAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSkKICAgICAgICAgICAgcmV0dXJuIFVaRVJPOwogICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkKICAgICAgICAgICAgcmV0dXJuIFVPTkU7CiAgICAgICAgICByZXMgPSBVWkVSTzsKICAgICAgICB9CiAgICAgICAgcmVtID0gdGhpczsKICAgICAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkgewogICAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpOwogICAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSwgZGVsdGEgPSBsb2cyIDw9IDQ4ID8gMSA6IHBvd19kYmwoMiwgbG9nMiAtIDQ4KSwgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLCBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpOwogICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHsKICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhOwogICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKQogICAgICAgICAgICBhcHByb3hSZXMgPSBPTkU7CiAgICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7CiAgICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7CiAgICAgIExvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHsKICAgICAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSkKICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7CiAgICAgICAgaWYgKHdhc20pIHsKICAgICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20ucmVtX3UgOiB3YXNtLnJlbV9zKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTsKICAgICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvOwogICAgICBMb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvOwogICAgICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHsKICAgICAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHsKICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IDMyIC0gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgZWxzZQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IG51bUJpdHMgLSAzMiwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7CiAgICAgIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykgewogICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPj4+IG51bUJpdHMgfCB0aGlzLmhpZ2ggPDwgMzIgLSBudW1CaXRzLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgZWxzZQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiBudW1CaXRzIC0gMzIsIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7CiAgICAgIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHsKICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgICAgICBudW1CaXRzICY9IDYzOwogICAgICAgIGlmIChudW1CaXRzID09PSAwKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgZWxzZSB7CiAgICAgICAgICB2YXIgaGlnaCA9IHRoaXMuaGlnaDsKICAgICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHsKICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93OwogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93ID4+PiBudW1CaXRzIHwgaGlnaCA8PCAzMiAtIG51bUJpdHMsIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09PSAzMikKICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCA+Pj4gbnVtQml0cyAtIDMyLCAwLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkOwogICAgICBMb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7CiAgICAgIExvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkgewogICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7CiAgICAgICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFKCkgewogICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgbG8gJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGxvID4+PiAyNCwKICAgICAgICAgIGhpICYgMjU1LAogICAgICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gMTYgJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gMjQKICAgICAgICBdOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHsKICAgICAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7CiAgICAgICAgcmV0dXJuIFsKICAgICAgICAgIGhpID4+PiAyNCwKICAgICAgICAgIGhpID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGhpID4+PiA4ICYgMjU1LAogICAgICAgICAgaGkgJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gMjQsCiAgICAgICAgICBsbyA+Pj4gMTYgJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGxvICYgMjU1CiAgICAgICAgXTsKICAgICAgfTsKICAgICAgTG9uZzQuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzMihieXRlcywgdW5zaWduZWQsIGxlKSB7CiAgICAgICAgcmV0dXJuIGxlID8gTG9uZzQuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmc0LmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmc0LmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBMb25nNChieXRlc1swXSB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzNdIDw8IDI0LCBieXRlc1s0XSB8IGJ5dGVzWzVdIDw8IDggfCBieXRlc1s2XSA8PCAxNiB8IGJ5dGVzWzddIDw8IDI0LCB1bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmc0LmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBMb25nNChieXRlc1s0XSA8PCAyNCB8IGJ5dGVzWzVdIDw8IDE2IHwgYnl0ZXNbNl0gPDwgOCB8IGJ5dGVzWzddLCBieXRlc1swXSA8PCAyNCB8IGJ5dGVzWzFdIDw8IDE2IHwgYnl0ZXNbMl0gPDwgOCB8IGJ5dGVzWzNdLCB1bnNpZ25lZCk7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9pcy1vYnNlcnZhYmxlQDIuMS4wL25vZGVfbW9kdWxlcy9pcy1vYnNlcnZhYmxlL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfaXNfb2JzZXJ2YWJsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9pcy1vYnNlcnZhYmxlQDIuMS4wL25vZGVfbW9kdWxlcy9pcy1vYnNlcnZhYmxlL2luZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gKHZhbHVlKSA9PiB7CiAgICAgICAgaWYgKCF2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIFN5bWJvbC5vYnNlcnZhYmxlID09PSAic3ltYm9sIiAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLm9ic2VydmFibGVdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlW1N5bWJvbC5vYnNlcnZhYmxlXSgpOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHZhbHVlWyJAQG9ic2VydmFibGUiXSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVsiQEBvYnNlcnZhYmxlIl0oKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3NlcmlhbGl6ZXJzLmpzCiAgdmFyIHJlcXVpcmVfc2VyaWFsaXplcnMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3NlcmlhbGl6ZXJzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLkRlZmF1bHRTZXJpYWxpemVyID0gZXhwb3J0czIuZXh0ZW5kU2VyaWFsaXplciA9IHZvaWQgMDsKICAgICAgZnVuY3Rpb24gZXh0ZW5kU2VyaWFsaXplcihleHRlbmQsIGltcGxlbWVudGF0aW9uKSB7CiAgICAgICAgY29uc3QgZmFsbGJhY2tEZXNlcmlhbGl6ZXIgPSBleHRlbmQuZGVzZXJpYWxpemUuYmluZChleHRlbmQpOwogICAgICAgIGNvbnN0IGZhbGxiYWNrU2VyaWFsaXplciA9IGV4dGVuZC5zZXJpYWxpemUuYmluZChleHRlbmQpOwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICAgIHJldHVybiBpbXBsZW1lbnRhdGlvbi5kZXNlcmlhbGl6ZShtZXNzYWdlLCBmYWxsYmFja0Rlc2VyaWFsaXplcik7CiAgICAgICAgICB9LAogICAgICAgICAgc2VyaWFsaXplKGlucHV0KSB7CiAgICAgICAgICAgIHJldHVybiBpbXBsZW1lbnRhdGlvbi5zZXJpYWxpemUoaW5wdXQsIGZhbGxiYWNrU2VyaWFsaXplcik7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgfQogICAgICBleHBvcnRzMi5leHRlbmRTZXJpYWxpemVyID0gZXh0ZW5kU2VyaWFsaXplcjsKICAgICAgdmFyIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIgPSB7CiAgICAgICAgZGVzZXJpYWxpemUobWVzc2FnZSkgewogICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oRXJyb3IobWVzc2FnZS5tZXNzYWdlKSwgewogICAgICAgICAgICBuYW1lOiBtZXNzYWdlLm5hbWUsCiAgICAgICAgICAgIHN0YWNrOiBtZXNzYWdlLnN0YWNrCiAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICAgIHNlcmlhbGl6ZShlcnJvcikgewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgX19lcnJvcl9tYXJrZXI6ICIkJGVycm9yIiwKICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSwKICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSwKICAgICAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrCiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgfTsKICAgICAgdmFyIGlzU2VyaWFsaXplZEVycm9yID0gKHRoaW5nKSA9PiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICJvYmplY3QiICYmICJfX2Vycm9yX21hcmtlciIgaW4gdGhpbmcgJiYgdGhpbmcuX19lcnJvcl9tYXJrZXIgPT09ICIkJGVycm9yIjsKICAgICAgZXhwb3J0czIuRGVmYXVsdFNlcmlhbGl6ZXIgPSB7CiAgICAgICAgZGVzZXJpYWxpemUobWVzc2FnZSkgewogICAgICAgICAgaWYgKGlzU2VyaWFsaXplZEVycm9yKG1lc3NhZ2UpKSB7CiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0RXJyb3JTZXJpYWxpemVyLmRlc2VyaWFsaXplKG1lc3NhZ2UpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBzZXJpYWxpemUoaW5wdXQpIHsKICAgICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEVycm9yKSB7CiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0RXJyb3JTZXJpYWxpemVyLnNlcmlhbGl6ZShpbnB1dCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gaW5wdXQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L2NvbW1vbi5qcwogIHZhciByZXF1aXJlX2NvbW1vbjIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L2NvbW1vbi5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5zZXJpYWxpemUgPSBleHBvcnRzMi5kZXNlcmlhbGl6ZSA9IGV4cG9ydHMyLnJlZ2lzdGVyU2VyaWFsaXplciA9IHZvaWQgMDsKICAgICAgdmFyIHNlcmlhbGl6ZXJzXzEgPSByZXF1aXJlX3NlcmlhbGl6ZXJzKCk7CiAgICAgIHZhciByZWdpc3RlcmVkU2VyaWFsaXplciA9IHNlcmlhbGl6ZXJzXzEuRGVmYXVsdFNlcmlhbGl6ZXI7CiAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyU2VyaWFsaXplcjIoc2VyaWFsaXplcikgewogICAgICAgIHJlZ2lzdGVyZWRTZXJpYWxpemVyID0gc2VyaWFsaXplcnNfMS5leHRlbmRTZXJpYWxpemVyKHJlZ2lzdGVyZWRTZXJpYWxpemVyLCBzZXJpYWxpemVyKTsKICAgICAgfQogICAgICBleHBvcnRzMi5yZWdpc3RlclNlcmlhbGl6ZXIgPSByZWdpc3RlclNlcmlhbGl6ZXIyOwogICAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRTZXJpYWxpemVyLmRlc2VyaWFsaXplKG1lc3NhZ2UpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7CiAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZShpbnB1dCkgewogICAgICAgIHJldHVybiByZWdpc3RlcmVkU2VyaWFsaXplci5zZXJpYWxpemUoaW5wdXQpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zeW1ib2xzLmpzCiAgdmFyIHJlcXVpcmVfc3ltYm9scyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc3ltYm9scy5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi4kd29ya2VyID0gZXhwb3J0czIuJHRyYW5zZmVyYWJsZSA9IGV4cG9ydHMyLiR0ZXJtaW5hdGUgPSBleHBvcnRzMi4kZXZlbnRzID0gZXhwb3J0czIuJGVycm9ycyA9IHZvaWQgMDsKICAgICAgZXhwb3J0czIuJGVycm9ycyA9IFN5bWJvbCgidGhyZWFkLmVycm9ycyIpOwogICAgICBleHBvcnRzMi4kZXZlbnRzID0gU3ltYm9sKCJ0aHJlYWQuZXZlbnRzIik7CiAgICAgIGV4cG9ydHMyLiR0ZXJtaW5hdGUgPSBTeW1ib2woInRocmVhZC50ZXJtaW5hdGUiKTsKICAgICAgZXhwb3J0czIuJHRyYW5zZmVyYWJsZSA9IFN5bWJvbCgidGhyZWFkLnRyYW5zZmVyYWJsZSIpOwogICAgICBleHBvcnRzMi4kd29ya2VyID0gU3ltYm9sKCJ0aHJlYWQud29ya2VyIik7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHJhbnNmZXJhYmxlLmpzCiAgdmFyIHJlcXVpcmVfdHJhbnNmZXJhYmxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90cmFuc2ZlcmFibGUuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuVHJhbnNmZXIgPSBleHBvcnRzMi5pc1RyYW5zZmVyRGVzY3JpcHRvciA9IHZvaWQgMDsKICAgICAgdmFyIHN5bWJvbHNfMSA9IHJlcXVpcmVfc3ltYm9scygpOwogICAgICBmdW5jdGlvbiBpc1RyYW5zZmVyYWJsZSh0aGluZykgewogICAgICAgIGlmICghdGhpbmcgfHwgdHlwZW9mIHRoaW5nICE9PSAib2JqZWN0IikKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpc1RyYW5zZmVyRGVzY3JpcHRvcih0aGluZykgewogICAgICAgIHJldHVybiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICJvYmplY3QiICYmIHRoaW5nW3N5bWJvbHNfMS4kdHJhbnNmZXJhYmxlXTsKICAgICAgfQogICAgICBleHBvcnRzMi5pc1RyYW5zZmVyRGVzY3JpcHRvciA9IGlzVHJhbnNmZXJEZXNjcmlwdG9yOwogICAgICBmdW5jdGlvbiBUcmFuc2ZlcjIocGF5bG9hZCwgdHJhbnNmZXJhYmxlcykgewogICAgICAgIGlmICghdHJhbnNmZXJhYmxlcykgewogICAgICAgICAgaWYgKCFpc1RyYW5zZmVyYWJsZShwYXlsb2FkKSkKICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTsKICAgICAgICAgIHRyYW5zZmVyYWJsZXMgPSBbcGF5bG9hZF07CiAgICAgICAgfQogICAgICAgIHJldHVybiB7CiAgICAgICAgICBbc3ltYm9sc18xLiR0cmFuc2ZlcmFibGVdOiB0cnVlLAogICAgICAgICAgc2VuZDogcGF5bG9hZCwKICAgICAgICAgIHRyYW5zZmVyYWJsZXMKICAgICAgICB9OwogICAgICB9CiAgICAgIGV4cG9ydHMyLlRyYW5zZmVyID0gVHJhbnNmZXIyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3R5cGVzL21lc3NhZ2VzLmpzCiAgdmFyIHJlcXVpcmVfbWVzc2FnZXMyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90eXBlcy9tZXNzYWdlcy5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5Xb3JrZXJNZXNzYWdlVHlwZSA9IGV4cG9ydHMyLk1hc3Rlck1lc3NhZ2VUeXBlID0gdm9pZCAwOwogICAgICB2YXIgTWFzdGVyTWVzc2FnZVR5cGU7CiAgICAgIChmdW5jdGlvbihNYXN0ZXJNZXNzYWdlVHlwZTIpIHsKICAgICAgICBNYXN0ZXJNZXNzYWdlVHlwZTJbImNhbmNlbCJdID0gImNhbmNlbCI7CiAgICAgICAgTWFzdGVyTWVzc2FnZVR5cGUyWyJydW4iXSA9ICJydW4iOwogICAgICB9KShNYXN0ZXJNZXNzYWdlVHlwZSA9IGV4cG9ydHMyLk1hc3Rlck1lc3NhZ2VUeXBlIHx8IChleHBvcnRzMi5NYXN0ZXJNZXNzYWdlVHlwZSA9IHt9KSk7CiAgICAgIHZhciBXb3JrZXJNZXNzYWdlVHlwZTsKICAgICAgKGZ1bmN0aW9uKFdvcmtlck1lc3NhZ2VUeXBlMikgewogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsiZXJyb3IiXSA9ICJlcnJvciI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJpbml0Il0gPSAiaW5pdCI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJyZXN1bHQiXSA9ICJyZXN1bHQiOwogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsicnVubmluZyJdID0gInJ1bm5pbmciOwogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsidW5jYXVnaHRFcnJvciJdID0gInVuY2F1Z2h0RXJyb3IiOwogICAgICB9KShXb3JrZXJNZXNzYWdlVHlwZSA9IGV4cG9ydHMyLldvcmtlck1lc3NhZ2VUeXBlIHx8IChleHBvcnRzMi5Xb3JrZXJNZXNzYWdlVHlwZSA9IHt9KSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2ltcGxlbWVudGF0aW9uLmJyb3dzZXIuanMKICB2YXIgcmVxdWlyZV9pbXBsZW1lbnRhdGlvbl9icm93c2VyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW1wbGVtZW50YXRpb24uYnJvd3Nlci5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgaXNXb3JrZXJSdW50aW1lID0gZnVuY3Rpb24gaXNXb3JrZXJSdW50aW1lMigpIHsKICAgICAgICBjb25zdCBpc1dpbmRvd0NvbnRleHQgPSB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIFdpbmRvdyAhPT0gInVuZGVmaW5lZCIgJiYgc2VsZiBpbnN0YW5jZW9mIFdpbmRvdzsKICAgICAgICByZXR1cm4gdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiICYmIHNlbGYucG9zdE1lc3NhZ2UgJiYgIWlzV2luZG93Q29udGV4dCA/IHRydWUgOiBmYWxzZTsKICAgICAgfTsKICAgICAgdmFyIHBvc3RNZXNzYWdlVG9NYXN0ZXIgPSBmdW5jdGlvbiBwb3N0TWVzc2FnZVRvTWFzdGVyMihkYXRhLCB0cmFuc2Zlckxpc3QpIHsKICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCk7CiAgICAgIH07CiAgICAgIHZhciBzdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzID0gZnVuY3Rpb24gc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlczIob25NZXNzYWdlKSB7CiAgICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSAobWVzc2FnZUV2ZW50KSA9PiB7CiAgICAgICAgICBvbk1lc3NhZ2UobWVzc2FnZUV2ZW50LmRhdGEpOwogICAgICAgIH07CiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7CiAgICAgICAgICBzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLCBtZXNzYWdlSGFuZGxlcik7CiAgICAgICAgfTsKICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLCBtZXNzYWdlSGFuZGxlcik7CiAgICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlOwogICAgICB9OwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gewogICAgICAgIGlzV29ya2VyUnVudGltZSwKICAgICAgICBwb3N0TWVzc2FnZVRvTWFzdGVyLAogICAgICAgIHN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW5kZXguanMKICB2YXIgcmVxdWlyZV93b3JrZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbmRleC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfX2F3YWl0ZXIgPSBleHBvcnRzMiAmJiBleHBvcnRzMi5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7CiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsKICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpIHsKICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIHJlamVjdChlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvclsidGhyb3ciXSh2YWx1ZSkpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgcmVqZWN0KGUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgewogICAgICAgICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsKICAgICAgICAgIH0KICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTsKICAgICAgICB9KTsKICAgICAgfTsKICAgICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IGV4cG9ydHMyICYmIGV4cG9ydHMyLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbihtb2QpIHsKICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyAiZGVmYXVsdCI6IG1vZCB9OwogICAgICB9OwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuZXhwb3NlID0gZXhwb3J0czIuaXNXb3JrZXJSdW50aW1lID0gZXhwb3J0czIuVHJhbnNmZXIgPSBleHBvcnRzMi5yZWdpc3RlclNlcmlhbGl6ZXIgPSB2b2lkIDA7CiAgICAgIHZhciBpc19vYnNlcnZhYmxlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9pc19vYnNlcnZhYmxlKCkpOwogICAgICB2YXIgY29tbW9uXzEgPSByZXF1aXJlX2NvbW1vbjIoKTsKICAgICAgdmFyIHRyYW5zZmVyYWJsZV8xID0gcmVxdWlyZV90cmFuc2ZlcmFibGUoKTsKICAgICAgdmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlX21lc3NhZ2VzMigpOwogICAgICB2YXIgaW1wbGVtZW50YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX2ltcGxlbWVudGF0aW9uX2Jyb3dzZXIoKSk7CiAgICAgIHZhciBjb21tb25fMiA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJyZWdpc3RlclNlcmlhbGl6ZXIiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIGNvbW1vbl8yLnJlZ2lzdGVyU2VyaWFsaXplcjsKICAgICAgfSB9KTsKICAgICAgdmFyIHRyYW5zZmVyYWJsZV8yID0gcmVxdWlyZV90cmFuc2ZlcmFibGUoKTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiVHJhbnNmZXIiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRyYW5zZmVyYWJsZV8yLlRyYW5zZmVyOwogICAgICB9IH0pOwogICAgICBleHBvcnRzMi5pc1dvcmtlclJ1bnRpbWUgPSBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lOwogICAgICB2YXIgZXhwb3NlQ2FsbGVkID0gZmFsc2U7CiAgICAgIHZhciBhY3RpdmVTdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpOwogICAgICB2YXIgaXNNYXN0ZXJKb2JDYW5jZWxNZXNzYWdlID0gKHRoaW5nKSA9PiB0aGluZyAmJiB0aGluZy50eXBlID09PSBtZXNzYWdlc18xLk1hc3Rlck1lc3NhZ2VUeXBlLmNhbmNlbDsKICAgICAgdmFyIGlzTWFzdGVySm9iUnVuTWVzc2FnZSA9ICh0aGluZykgPT4gdGhpbmcgJiYgdGhpbmcudHlwZSA9PT0gbWVzc2FnZXNfMS5NYXN0ZXJNZXNzYWdlVHlwZS5ydW47CiAgICAgIHZhciBpc09ic2VydmFibGUgPSAodGhpbmcpID0+IGlzX29ic2VydmFibGVfMS5kZWZhdWx0KHRoaW5nKSB8fCBpc1plbk9ic2VydmFibGUodGhpbmcpOwogICAgICBmdW5jdGlvbiBpc1plbk9ic2VydmFibGUodGhpbmcpIHsKICAgICAgICByZXR1cm4gdGhpbmcgJiYgdHlwZW9mIHRoaW5nID09PSAib2JqZWN0IiAmJiB0eXBlb2YgdGhpbmcuc3Vic2NyaWJlID09PSAiZnVuY3Rpb24iOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlY29uc3RydWN0VHJhbnNmZXIodGhpbmcpIHsKICAgICAgICByZXR1cm4gdHJhbnNmZXJhYmxlXzEuaXNUcmFuc2ZlckRlc2NyaXB0b3IodGhpbmcpID8geyBwYXlsb2FkOiB0aGluZy5zZW5kLCB0cmFuc2ZlcmFibGVzOiB0aGluZy50cmFuc2ZlcmFibGVzIH0gOiB7IHBheWxvYWQ6IHRoaW5nLCB0cmFuc2ZlcmFibGVzOiB2b2lkIDAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0RnVuY3Rpb25Jbml0TWVzc2FnZSgpIHsKICAgICAgICBjb25zdCBpbml0TWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUuaW5pdCwKICAgICAgICAgIGV4cG9zZWQ6IHsKICAgICAgICAgICAgdHlwZTogImZ1bmN0aW9uIgogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoaW5pdE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RNb2R1bGVJbml0TWVzc2FnZShtZXRob2ROYW1lcykgewogICAgICAgIGNvbnN0IGluaXRNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5pbml0LAogICAgICAgICAgZXhwb3NlZDogewogICAgICAgICAgICB0eXBlOiAibW9kdWxlIiwKICAgICAgICAgICAgbWV0aG9kczogbWV0aG9kTmFtZXMKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKGluaXRNZXNzYWdlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0Sm9iRXJyb3JNZXNzYWdlKHVpZCwgcmF3RXJyb3IpIHsKICAgICAgICBjb25zdCB7IHBheWxvYWQ6IGVycm9yLCB0cmFuc2ZlcmFibGVzIH0gPSBkZWNvbnN0cnVjdFRyYW5zZmVyKHJhd0Vycm9yKTsKICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLmVycm9yLAogICAgICAgICAgdWlkLAogICAgICAgICAgZXJyb3I6IGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikKICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKGVycm9yTWVzc2FnZSwgdHJhbnNmZXJhYmxlcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEpvYlJlc3VsdE1lc3NhZ2UodWlkLCBjb21wbGV0ZWQsIHJlc3VsdFZhbHVlKSB7CiAgICAgICAgY29uc3QgeyBwYXlsb2FkLCB0cmFuc2ZlcmFibGVzIH0gPSBkZWNvbnN0cnVjdFRyYW5zZmVyKHJlc3VsdFZhbHVlKTsKICAgICAgICBjb25zdCByZXN1bHRNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5yZXN1bHQsCiAgICAgICAgICB1aWQsCiAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGVkID8gdHJ1ZSA6IHZvaWQgMCwKICAgICAgICAgIHBheWxvYWQKICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKHJlc3VsdE1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RKb2JTdGFydE1lc3NhZ2UodWlkLCByZXN1bHRUeXBlKSB7CiAgICAgICAgY29uc3Qgc3RhcnRNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5ydW5uaW5nLAogICAgICAgICAgdWlkLAogICAgICAgICAgcmVzdWx0VHlwZQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoc3RhcnRNZXNzYWdlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXJyb3IpIHsKICAgICAgICB0cnkgewogICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gewogICAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnVuY2F1Z2h0RXJyb3IsCiAgICAgICAgICAgIGVycm9yOiBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpCiAgICAgICAgICB9OwogICAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoZXJyb3JNZXNzYWdlKTsKICAgICAgICB9IGNhdGNoIChzdWJFcnJvcikgewogICAgICAgICAgY29uc29sZS5lcnJvcigiTm90IHJlcG9ydGluZyB1bmNhdWdodCBlcnJvciBiYWNrIHRvIG1hc3RlciB0aHJlYWQgYXMgaXQgb2NjdXJlZCB3aGlsZSByZXBvcnRpbmcgYW4gdW5jYXVnaHQgZXJyb3IgYWxyZWFkeS5cbkxhdGVzdCBlcnJvcjoiLCBzdWJFcnJvciwgIlxuT3JpZ2luYWwgZXJyb3I6IiwgZXJyb3IpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBydW5GdW5jdGlvbihqb2JVSUQsIGZuLCBhcmdzKSB7CiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsKICAgICAgICAgIGxldCBzeW5jUmVzdWx0OwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgc3luY1Jlc3VsdCA9IGZuKC4uLmFyZ3MpOwogICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgcmV0dXJuIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBlcnJvcik7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCByZXN1bHRUeXBlID0gaXNPYnNlcnZhYmxlKHN5bmNSZXN1bHQpID8gIm9ic2VydmFibGUiIDogInByb21pc2UiOwogICAgICAgICAgcG9zdEpvYlN0YXJ0TWVzc2FnZShqb2JVSUQsIHJlc3VsdFR5cGUpOwogICAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZShzeW5jUmVzdWx0KSkgewogICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzeW5jUmVzdWx0LnN1YnNjcmliZSgodmFsdWUpID0+IHBvc3RKb2JSZXN1bHRNZXNzYWdlKGpvYlVJRCwgZmFsc2UsIGNvbW1vbl8xLnNlcmlhbGl6ZSh2YWx1ZSkpLCAoZXJyb3IpID0+IHsKICAgICAgICAgICAgICBwb3N0Sm9iRXJyb3JNZXNzYWdlKGpvYlVJRCwgY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKSk7CiAgICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5kZWxldGUoam9iVUlEKTsKICAgICAgICAgICAgfSwgKCkgPT4gewogICAgICAgICAgICAgIHBvc3RKb2JSZXN1bHRNZXNzYWdlKGpvYlVJRCwgdHJ1ZSk7CiAgICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5kZWxldGUoam9iVUlEKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuc2V0KGpvYlVJRCwgc3Vic2NyaXB0aW9uKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc3luY1Jlc3VsdDsKICAgICAgICAgICAgICBwb3N0Sm9iUmVzdWx0TWVzc2FnZShqb2JVSUQsIHRydWUsIGNvbW1vbl8xLnNlcmlhbGl6ZShyZXN1bHQpKTsKICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgICBwb3N0Sm9iRXJyb3JNZXNzYWdlKGpvYlVJRCwgY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBleHBvc2UyKGV4cG9zZWQpIHsKICAgICAgICBpZiAoIWltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWUoKSkgewogICAgICAgICAgdGhyb3cgRXJyb3IoImV4cG9zZSgpIGNhbGxlZCBpbiB0aGUgbWFzdGVyIHRocmVhZC4iKTsKICAgICAgICB9CiAgICAgICAgaWYgKGV4cG9zZUNhbGxlZCkgewogICAgICAgICAgdGhyb3cgRXJyb3IoImV4cG9zZSgpIGNhbGxlZCBtb3JlIHRoYW4gb25jZS4gVGhpcyBpcyBub3QgcG9zc2libGUuIFBhc3MgYW4gb2JqZWN0IHRvIGV4cG9zZSgpIGlmIHlvdSB3YW50IHRvIGV4cG9zZSBtdWx0aXBsZSBmdW5jdGlvbnMuIik7CiAgICAgICAgfQogICAgICAgIGV4cG9zZUNhbGxlZCA9IHRydWU7CiAgICAgICAgaWYgKHR5cGVvZiBleHBvc2VkID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcygobWVzc2FnZURhdGEpID0+IHsKICAgICAgICAgICAgaWYgKGlzTWFzdGVySm9iUnVuTWVzc2FnZShtZXNzYWdlRGF0YSkgJiYgIW1lc3NhZ2VEYXRhLm1ldGhvZCkgewogICAgICAgICAgICAgIHJ1bkZ1bmN0aW9uKG1lc3NhZ2VEYXRhLnVpZCwgZXhwb3NlZCwgbWVzc2FnZURhdGEuYXJncy5tYXAoY29tbW9uXzEuZGVzZXJpYWxpemUpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBwb3N0RnVuY3Rpb25Jbml0TWVzc2FnZSgpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9zZWQgPT09ICJvYmplY3QiICYmIGV4cG9zZWQpIHsKICAgICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgICBpZiAoaXNNYXN0ZXJKb2JSdW5NZXNzYWdlKG1lc3NhZ2VEYXRhKSAmJiBtZXNzYWdlRGF0YS5tZXRob2QpIHsKICAgICAgICAgICAgICBydW5GdW5jdGlvbihtZXNzYWdlRGF0YS51aWQsIGV4cG9zZWRbbWVzc2FnZURhdGEubWV0aG9kXSwgbWVzc2FnZURhdGEuYXJncy5tYXAoY29tbW9uXzEuZGVzZXJpYWxpemUpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBjb25zdCBtZXRob2ROYW1lcyA9IE9iamVjdC5rZXlzKGV4cG9zZWQpLmZpbHRlcigoa2V5KSA9PiB0eXBlb2YgZXhwb3NlZFtrZXldID09PSAiZnVuY3Rpb24iKTsKICAgICAgICAgIHBvc3RNb2R1bGVJbml0TWVzc2FnZShtZXRob2ROYW1lcyk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBleHBvc2UoKS4gRXhwZWN0ZWQgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QsIGdvdDogJHtleHBvc2VkfWApOwogICAgICAgIH0KICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcygobWVzc2FnZURhdGEpID0+IHsKICAgICAgICAgIGlmIChpc01hc3RlckpvYkNhbmNlbE1lc3NhZ2UobWVzc2FnZURhdGEpKSB7CiAgICAgICAgICAgIGNvbnN0IGpvYlVJRCA9IG1lc3NhZ2VEYXRhLnVpZDsKICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYWN0aXZlU3Vic2NyaXB0aW9ucy5nZXQoam9iVUlEKTsKICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikgewogICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOwogICAgICAgICAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGpvYlVJRCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgICBleHBvcnRzMi5leHBvc2UgPSBleHBvc2UyOwogICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBzZWxmLmFkZEV2ZW50TGlzdGVuZXIgPT09ICJmdW5jdGlvbiIgJiYgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZSgpKSB7CiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCJlcnJvciIsIChldmVudCkgPT4gewogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXZlbnQuZXJyb3IgfHwgZXZlbnQpLCAyNTApOwogICAgICAgIH0pOwogICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigidW5oYW5kbGVkcmVqZWN0aW9uIiwgKGV2ZW50KSA9PiB7CiAgICAgICAgICBjb25zdCBlcnJvciA9IGV2ZW50LnJlYXNvbjsKICAgICAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXJyb3IpLCAyNTApOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIHByb2Nlc3Mub24gPT09ICJmdW5jdGlvbiIgJiYgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZSgpKSB7CiAgICAgICAgcHJvY2Vzcy5vbigidW5jYXVnaHRFeGNlcHRpb24iLCAoZXJyb3IpID0+IHsKICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGVycm9yKSwgMjUwKTsKICAgICAgICB9KTsKICAgICAgICBwcm9jZXNzLm9uKCJ1bmhhbmRsZWRSZWplY3Rpb24iLCAoZXJyb3IpID0+IHsKICAgICAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXJyb3IpLCAyNTApOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL3ZjZi92Y2Ytd29ya2VyLnRzP3dvcmtlciZpbmxpbmU/d29ya2VyX2ZpbGUKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCt0YWJpeEAxLjUuMTEvbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK3RhYml4QDEuNS4xMS9ub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3RhYml4SW5kZXhlZEZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9hYm9ydGFibGVfcHJvbWlzZV9jYWNoZSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9lc20oKSk7CiAgdmFyIGltcG9ydF9xdWlja19scnUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfcXVpY2tfbHJ1KCkpOwogIHZhciBpbXBvcnRfYnVmZmVyNyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9nZW5lcmljLWZpbGVoYW5kbGVAMy4xLjEvbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vaW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb2NhbEZpbGUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbG9jYWxGaWxlKCkpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vZ2VuZXJpYy1maWxlaGFuZGxlQDMuMS4xL25vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL3JlbW90ZUZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXIyID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKICB2YXIgUmVtb3RlRmlsZSA9IGNsYXNzIHsKICAgIGFzeW5jIGdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSkgewogICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmJ1ZmZlciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIHJldHVybiByZXNwb25zZS5idWZmZXIoKTsKICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UuYXJyYXlCdWZmZXIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTsKICAgICAgICByZXR1cm4gaW1wb3J0X2J1ZmZlcjIuQnVmZmVyLmZyb20ocmVzcCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiaW52YWxpZCBIVFRQIHJlc3BvbnNlIG9iamVjdCwgaGFzIG5vIGJ1ZmZlciBtZXRob2QsIGFuZCBubyBhcnJheUJ1ZmZlciBtZXRob2QiKTsKICAgICAgfQogICAgfQogICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRzID0ge30pIHsKICAgICAgdGhpcy5iYXNlT3ZlcnJpZGVzID0ge307CiAgICAgIHRoaXMudXJsID0gc291cmNlOwogICAgICBjb25zdCBmZXRjaCA9IG9wdHMuZmV0Y2ggfHwgZ2xvYmFsVGhpcy5mZXRjaC5iaW5kKGdsb2JhbFRoaXMpOwogICAgICBpZiAoIWZldGNoKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbm8gZmV0Y2ggZnVuY3Rpb24gc3VwcGxpZWQsIGFuZCBub25lIGZvdW5kIGluIGdsb2JhbCBlbnZpcm9ubWVudGApOwogICAgICB9CiAgICAgIGlmIChvcHRzLm92ZXJyaWRlcykgewogICAgICAgIHRoaXMuYmFzZU92ZXJyaWRlcyA9IG9wdHMub3ZlcnJpZGVzOwogICAgICB9CiAgICAgIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGZldGNoOwogICAgfQogICAgYXN5bmMgZmV0Y2goaW5wdXQsIGluaXQyKSB7CiAgICAgIGxldCByZXNwb25zZTsKICAgICAgdHJ5IHsKICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbihpbnB1dCwgaW5pdDIpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKGAke2V9YC5pbmNsdWRlcygiRmFpbGVkIHRvIGZldGNoIikpIHsKICAgICAgICAgIGNvbnNvbGUud2FybihgZ2VuZXJpYy1maWxlaGFuZGxlOiByZWZldGNoaW5nICR7aW5wdXR9IHRvIGF0dGVtcHQgdG8gd29yayBhcm91bmQgY2hyb21lIENPUlMgaGVhZGVyIGNhY2hpbmcgYnVnYCk7CiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbihpbnB1dCwgewogICAgICAgICAgICAuLi5pbml0MiwKICAgICAgICAgICAgY2FjaGU6ICJyZWxvYWQiCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHJlc3BvbnNlOwogICAgfQogICAgYXN5bmMgcmVhZChidWZmZXIsIG9mZnNldCA9IDAsIGxlbmd0aCwgcG9zaXRpb24gPSAwLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgIGlmIChsZW5ndGggPCBJbmZpbml0eSkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tJHtwb3NpdGlvbiArIGxlbmd0aH1gOwogICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gSW5maW5pdHkgJiYgcG9zaXRpb24gIT09IDApIHsKICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LWA7CiAgICAgIH0KICAgICAgY29uc3QgYXJncyA9IHsKICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsCiAgICAgICAgLi4ub3ZlcnJpZGVzLAogICAgICAgIGhlYWRlcnM6IHsKICAgICAgICAgIC4uLmhlYWRlcnMsCiAgICAgICAgICAuLi5vdmVycmlkZXMuaGVhZGVycywKICAgICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcy5oZWFkZXJzCiAgICAgICAgfSwKICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgIHJlZGlyZWN0OiAiZm9sbG93IiwKICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgc2lnbmFsCiAgICAgIH07CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncyk7CiAgICAgIGlmICghcmVzcG9uc2Uub2spIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gJHt0aGlzLnVybH1gKTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgJiYgcG9zaXRpb24gPT09IDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHsKICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICAgICAgY29uc3QgYnl0ZXNDb3BpZWQgPSByZXNwb25zZURhdGEuY29weShidWZmZXIsIG9mZnNldCwgMCwgTWF0aC5taW4obGVuZ3RoLCByZXNwb25zZURhdGEubGVuZ3RoKSk7CiAgICAgICAgY29uc3QgcmVzID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoImNvbnRlbnQtcmFuZ2UiKTsKICAgICAgICBjb25zdCBzaXplTWF0Y2ggPSAvXC8oXGQrKSQvLmV4ZWMocmVzIHx8ICIiKTsKICAgICAgICBpZiAoc2l6ZU1hdGNoICYmIHNpemVNYXRjaFsxXSkgewogICAgICAgICAgdGhpcy5fc3RhdCA9IHsgc2l6ZTogcGFyc2VJbnQoc2l6ZU1hdGNoWzFdLCAxMCkgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYnl0ZXNSZWFkOiBieXRlc0NvcGllZCwgYnVmZmVyIH07CiAgICAgIH0KICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCIke3RoaXMudXJsfSBmZXRjaCByZXR1cm5lZCBzdGF0dXMgMjAwLCBleHBlY3RlZCAyMDYiKTsKICAgICAgfQogICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9IGZldGNoaW5nICR7dGhpcy51cmx9YCk7CiAgICB9CiAgICBhc3luYyByZWFkRmlsZShvcHRpb25zID0ge30pIHsKICAgICAgbGV0IGVuY29kaW5nOwogICAgICBsZXQgb3B0czsKICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAic3RyaW5nIikgewogICAgICAgIGVuY29kaW5nID0gb3B0aW9uczsKICAgICAgICBvcHRzID0ge307CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nOwogICAgICAgIG9wdHMgPSBvcHRpb25zOwogICAgICAgIGRlbGV0ZSBvcHRzLmVuY29kaW5nOwogICAgICB9CiAgICAgIGNvbnN0IHsgaGVhZGVycyA9IHt9LCBzaWduYWwsIG92ZXJyaWRlcyA9IHt9IH0gPSBvcHRzOwogICAgICBjb25zdCBhcmdzID0gewogICAgICAgIGhlYWRlcnMsCiAgICAgICAgbWV0aG9kOiAiR0VUIiwKICAgICAgICByZWRpcmVjdDogImZvbGxvdyIsCiAgICAgICAgbW9kZTogImNvcnMiLAogICAgICAgIHNpZ25hbCwKICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsCiAgICAgICAgLi4ub3ZlcnJpZGVzCiAgICAgIH07CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncyk7CiAgICAgIGlmICghcmVzcG9uc2UpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImdlbmVyaWMtZmlsZWhhbmRsZSBmYWlsZWQgdG8gZmV0Y2giKTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHsKICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKSwgewogICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMKICAgICAgICB9KTsKICAgICAgfQogICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1dGY4IikgewogICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7CiAgICAgIH0KICAgICAgaWYgKGVuY29kaW5nKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJGcm9tUmVzcG9uc2UocmVzcG9uc2UpOwogICAgfQogICAgYXN5bmMgc3RhdCgpIHsKICAgICAgaWYgKCF0aGlzLl9zdGF0KSB7CiAgICAgICAgY29uc3QgYnVmID0gaW1wb3J0X2J1ZmZlcjIuQnVmZmVyLmFsbG9jVW5zYWZlKDEwKTsKICAgICAgICBhd2FpdCB0aGlzLnJlYWQoYnVmLCAwLCAxMCwgMCk7CiAgICAgICAgaWYgKCF0aGlzLl9zdGF0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBkZXRlcm1pbmUgc2l6ZSBvZiBmaWxlIGF0ICR7dGhpcy51cmx9YCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB0aGlzLl9zdGF0OwogICAgfQogICAgYXN5bmMgY2xvc2UoKSB7CiAgICAgIHJldHVybjsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vZ2VuZXJpYy1maWxlaGFuZGxlQDMuMS4xL25vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2Jsb2JGaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyMyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9nZW5lcmljLWZpbGVoYW5kbGVAMy4xLjEvbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vZmlsZWhhbmRsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JnemYtZmlsZWhhbmRsZUAxLjQuNy9ub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JnemYtZmlsZWhhbmRsZUAxLjQuNy9ub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS9iZ3pGaWxlaGFuZGxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyNiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCtiZ3pmLWZpbGVoYW5kbGVAMS40Ljcvbm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9lc20vdW56aXAtcGFrby5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2J1ZmZlcjQgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwogIHZhciBpbXBvcnRfcGFrbyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9wYWtvKCkpOwogIGFzeW5jIGZ1bmN0aW9uIHVuemlwKGlucHV0RGF0YSkgewogICAgdHJ5IHsKICAgICAgbGV0IHN0cm07CiAgICAgIGxldCBwb3MgPSAwOwogICAgICBsZXQgaSA9IDA7CiAgICAgIGNvbnN0IGNodW5rcyA9IFtdOwogICAgICBsZXQgdG90YWxTaXplID0gMDsKICAgICAgbGV0IGluZmxhdG9yOwogICAgICBkbyB7CiAgICAgICAgY29uc3QgcmVtYWluaW5nSW5wdXQgPSBpbnB1dERhdGEuc3ViYXJyYXkocG9zKTsKICAgICAgICBpbmZsYXRvciA9IG5ldyBpbXBvcnRfcGFrby5JbmZsYXRlKCk7CiAgICAgICAgKHsgc3RybSB9ID0gaW5mbGF0b3IpOwogICAgICAgIGluZmxhdG9yLnB1c2gocmVtYWluaW5nSW5wdXQsIGltcG9ydF9wYWtvLlpfU1lOQ19GTFVTSCk7CiAgICAgICAgaWYgKGluZmxhdG9yLmVycikgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluZmxhdG9yLm1zZyk7CiAgICAgICAgfQogICAgICAgIHBvcyArPSBzdHJtLm5leHRfaW47CiAgICAgICAgY2h1bmtzW2ldID0gaW5mbGF0b3IucmVzdWx0OwogICAgICAgIHRvdGFsU2l6ZSArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgIGkgKz0gMTsKICAgICAgfSB3aGlsZSAoc3RybS5hdmFpbF9pbik7CiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsU2l6ZSk7CiAgICAgIGZvciAobGV0IGkyID0gMCwgb2Zmc2V0ID0gMDsgaTIgPCBjaHVua3MubGVuZ3RoOyBpMisrKSB7CiAgICAgICAgcmVzdWx0LnNldChjaHVua3NbaTJdLCBvZmZzZXQpOwogICAgICAgIG9mZnNldCArPSBjaHVua3NbaTJdLmxlbmd0aDsKICAgICAgfQogICAgICByZXR1cm4gaW1wb3J0X2J1ZmZlcjQuQnVmZmVyLmZyb20ocmVzdWx0KTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgaWYgKGAke2V9YC5tYXRjaCgvaW5jb3JyZWN0IGhlYWRlciBjaGVjay8pKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJwcm9ibGVtIGRlY29tcHJlc3NpbmcgYmxvY2s6IGluY29ycmVjdCBnemlwIGhlYWRlciBjaGVjayIpOwogICAgICB9CiAgICAgIHRocm93IGU7CiAgICB9CiAgfQogIGFzeW5jIGZ1bmN0aW9uIHVuemlwQ2h1bmtTbGljZShpbnB1dERhdGEsIGNodW5rKSB7CiAgICB0cnkgewogICAgICBsZXQgc3RybTsKICAgICAgY29uc3QgeyBtaW52LCBtYXh2IH0gPSBjaHVuazsKICAgICAgbGV0IGNwb3MgPSBtaW52LmJsb2NrUG9zaXRpb247CiAgICAgIGxldCBkcG9zID0gbWludi5kYXRhUG9zaXRpb247CiAgICAgIGNvbnN0IGNodW5rcyA9IFtdOwogICAgICBjb25zdCBjcG9zaXRpb25zID0gW107CiAgICAgIGNvbnN0IGRwb3NpdGlvbnMgPSBbXTsKICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7CiAgICAgIGxldCBpID0gMDsKICAgICAgZG8gewogICAgICAgIGNvbnN0IHJlbWFpbmluZ0lucHV0ID0gaW5wdXREYXRhLnN1YmFycmF5KGNwb3MgLSBtaW52LmJsb2NrUG9zaXRpb24pOwogICAgICAgIGNvbnN0IGluZmxhdG9yID0gbmV3IGltcG9ydF9wYWtvLkluZmxhdGUoKTsKICAgICAgICAoeyBzdHJtIH0gPSBpbmZsYXRvcik7CiAgICAgICAgaW5mbGF0b3IucHVzaChyZW1haW5pbmdJbnB1dCwgaW1wb3J0X3Bha28uWl9TWU5DX0ZMVVNIKTsKICAgICAgICBpZiAoaW5mbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0b3IubXNnKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgYnVmZmVyMiA9IGluZmxhdG9yLnJlc3VsdDsKICAgICAgICBjaHVua3MucHVzaChidWZmZXIyKTsKICAgICAgICBsZXQgbGVuID0gYnVmZmVyMi5sZW5ndGg7CiAgICAgICAgY3Bvc2l0aW9ucy5wdXNoKGNwb3MpOwogICAgICAgIGRwb3NpdGlvbnMucHVzaChkcG9zKTsKICAgICAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSAmJiBtaW52LmRhdGFQb3NpdGlvbikgewogICAgICAgICAgY2h1bmtzWzBdID0gY2h1bmtzWzBdLnN1YmFycmF5KG1pbnYuZGF0YVBvc2l0aW9uKTsKICAgICAgICAgIGxlbiA9IGNodW5rc1swXS5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGNvbnN0IG9yaWdDcG9zID0gY3BvczsKICAgICAgICBjcG9zICs9IHN0cm0ubmV4dF9pbjsKICAgICAgICBkcG9zICs9IGxlbjsKICAgICAgICBpZiAob3JpZ0Nwb3MgPj0gbWF4di5ibG9ja1Bvc2l0aW9uKSB7CiAgICAgICAgICBjaHVua3NbaV0gPSBjaHVua3NbaV0uc3ViYXJyYXkoMCwgbWF4di5ibG9ja1Bvc2l0aW9uID09PSBtaW52LmJsb2NrUG9zaXRpb24gPyBtYXh2LmRhdGFQb3NpdGlvbiAtIG1pbnYuZGF0YVBvc2l0aW9uICsgMSA6IG1heHYuZGF0YVBvc2l0aW9uICsgMSk7CiAgICAgICAgICBjcG9zaXRpb25zLnB1c2goY3Bvcyk7CiAgICAgICAgICBkcG9zaXRpb25zLnB1c2goZHBvcyk7CiAgICAgICAgICB0b3RhbFNpemUgKz0gY2h1bmtzW2ldLmxlbmd0aDsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICB0b3RhbFNpemUgKz0gY2h1bmtzW2ldLmxlbmd0aDsKICAgICAgICBpKys7CiAgICAgIH0gd2hpbGUgKHN0cm0uYXZhaWxfaW4pOwogICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpOwogICAgICBmb3IgKGxldCBpMiA9IDAsIG9mZnNldCA9IDA7IGkyIDwgY2h1bmtzLmxlbmd0aDsgaTIrKykgewogICAgICAgIHJlc3VsdC5zZXQoY2h1bmtzW2kyXSwgb2Zmc2V0KTsKICAgICAgICBvZmZzZXQgKz0gY2h1bmtzW2kyXS5sZW5ndGg7CiAgICAgIH0KICAgICAgY29uc3QgYnVmZmVyID0gaW1wb3J0X2J1ZmZlcjQuQnVmZmVyLmZyb20ocmVzdWx0KTsKICAgICAgcmV0dXJuIHsgYnVmZmVyLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zIH07CiAgICB9IGNhdGNoIChlKSB7CiAgICAgIGlmIChgJHtlfWAubWF0Y2goL2luY29ycmVjdCBoZWFkZXIgY2hlY2svKSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigicHJvYmxlbSBkZWNvbXByZXNzaW5nIGJsb2NrOiBpbmNvcnJlY3QgZ3ppcCBoZWFkZXIgY2hlY2siKTsKICAgICAgfQogICAgICB0aHJvdyBlOwogICAgfQogIH0KCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JnemYtZmlsZWhhbmRsZUAxLjQuNy9ub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS9nemlJbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2xvbmcgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbG9uZygpKTsKICB2YXIgaW1wb3J0X2J1ZmZlcjUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdXRpbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBsb25nVG9OdW1iZXIobG9uZykgewogICAgaWYgKGxvbmcuZ3JlYXRlclRoYW4oTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHx8IGxvbmcubGVzc1RoYW4oTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiaW50ZWdlciBvdmVyZmxvdyIpOwogICAgfQogICAgcmV0dXJuIGxvbmcudG9OdW1iZXIoKTsKICB9CiAgdmFyIEFib3J0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHsKICB9OwogIGZ1bmN0aW9uIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKSB7CiAgICBpZiAoIXNpZ25hbCkgewogICAgICByZXR1cm47CiAgICB9CiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgaWYgKHR5cGVvZiBET01FeGNlcHRpb24gIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbigiYWJvcnRlZCIsICJBYm9ydEVycm9yIik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgZSA9IG5ldyBBYm9ydEVycm9yKCJhYm9ydGVkIik7CiAgICAgICAgZS5jb2RlID0gIkVSUl9BQk9SVEVEIjsKICAgICAgICB0aHJvdyBlOwogICAgICB9CiAgICB9CiAgfQogIGZ1bmN0aW9uIGNhbk1lcmdlQmxvY2tzKGNodW5rMSwgY2h1bmsyKSB7CiAgICByZXR1cm4gY2h1bmsyLm1pbnYuYmxvY2tQb3NpdGlvbiAtIGNodW5rMS5tYXh2LmJsb2NrUG9zaXRpb24gPCA2NWUzICYmIGNodW5rMi5tYXh2LmJsb2NrUG9zaXRpb24gLSBjaHVuazEubWludi5ibG9ja1Bvc2l0aW9uIDwgNWU2OwogIH0KICBmdW5jdGlvbiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIGxvd2VzdCkgewogICAgY29uc3QgbWVyZ2VkQ2h1bmtzID0gW107CiAgICBsZXQgbGFzdENodW5rID0gbnVsbDsKICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiBjaHVua3M7CiAgICB9CiAgICBjaHVua3Muc29ydChmdW5jdGlvbihjMCwgYzEpIHsKICAgICAgY29uc3QgZGlmID0gYzAubWludi5ibG9ja1Bvc2l0aW9uIC0gYzEubWludi5ibG9ja1Bvc2l0aW9uOwogICAgICBpZiAoZGlmICE9PSAwKSB7CiAgICAgICAgcmV0dXJuIGRpZjsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gYzAubWludi5kYXRhUG9zaXRpb24gLSBjMS5taW52LmRhdGFQb3NpdGlvbjsKICAgICAgfQogICAgfSk7CiAgICBjaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IHsKICAgICAgaWYgKCFsb3dlc3QgfHwgY2h1bmsubWF4di5jb21wYXJlVG8obG93ZXN0KSA+IDApIHsKICAgICAgICBpZiAobGFzdENodW5rID09PSBudWxsKSB7CiAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7CiAgICAgICAgICBsYXN0Q2h1bmsgPSBjaHVuazsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKGNhbk1lcmdlQmxvY2tzKGxhc3RDaHVuaywgY2h1bmspKSB7CiAgICAgICAgICAgIGlmIChjaHVuay5tYXh2LmNvbXBhcmVUbyhsYXN0Q2h1bmsubWF4dikgPiAwKSB7CiAgICAgICAgICAgICAgbGFzdENodW5rLm1heHYgPSBjaHVuay5tYXh2OwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7CiAgICAgICAgICAgIGxhc3RDaHVuayA9IGNodW5rOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSk7CiAgICByZXR1cm4gbWVyZ2VkQ2h1bmtzOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK3RhYml4QDEuNS4xMS9ub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3RiaS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2xvbmcyID0gX190b01vZHVsZShyZXF1aXJlX2xvbmcoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCt0YWJpeEAxLjUuMTEvbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS92aXJ0dWFsT2Zmc2V0LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBWaXJ0dWFsT2Zmc2V0ID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoYmxvY2tQb3NpdGlvbiwgZGF0YVBvc2l0aW9uKSB7CiAgICAgIHRoaXMuYmxvY2tQb3NpdGlvbiA9IGJsb2NrUG9zaXRpb247CiAgICAgIHRoaXMuZGF0YVBvc2l0aW9uID0gZGF0YVBvc2l0aW9uOwogICAgfQogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLmJsb2NrUG9zaXRpb259OiR7dGhpcy5kYXRhUG9zaXRpb259YDsKICAgIH0KICAgIGNvbXBhcmVUbyhiKSB7CiAgICAgIHJldHVybiB0aGlzLmJsb2NrUG9zaXRpb24gLSBiLmJsb2NrUG9zaXRpb24gfHwgdGhpcy5kYXRhUG9zaXRpb24gLSBiLmRhdGFQb3NpdGlvbjsKICAgIH0KICAgIHN0YXRpYyBtaW4oLi4uYXJncykgewogICAgICBsZXQgbWluOwogICAgICBsZXQgaSA9IDA7CiAgICAgIGZvciAoOyAhbWluOyBpICs9IDEpIHsKICAgICAgICBtaW4gPSBhcmdzW2ldOwogICAgICB9CiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgIGlmIChtaW4uY29tcGFyZVRvKGFyZ3NbaV0pID4gMCkgewogICAgICAgICAgbWluID0gYXJnc1tpXTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG1pbjsKICAgIH0KICB9OwogIGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgb2Zmc2V0ID0gMCwgYmlnZW5kaWFuID0gZmFsc2UpIHsKICAgIGlmIChiaWdlbmRpYW4pIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJiaWctZW5kaWFuIHZpcnR1YWwgZmlsZSBvZmZzZXRzIG5vdCBpbXBsZW1lbnRlZCIpOwogICAgfQogICAgcmV0dXJuIG5ldyBWaXJ0dWFsT2Zmc2V0KGJ5dGVzW29mZnNldCArIDddICogMTA5OTUxMTYyNzc3NiArIGJ5dGVzW29mZnNldCArIDZdICogNDI5NDk2NzI5NiArIGJ5dGVzW29mZnNldCArIDVdICogMTY3NzcyMTYgKyBieXRlc1tvZmZzZXQgKyA0XSAqIDY1NTM2ICsgYnl0ZXNbb2Zmc2V0ICsgM10gKiAyNTYgKyBieXRlc1tvZmZzZXQgKyAyXSwgYnl0ZXNbb2Zmc2V0ICsgMV0gPDwgOCB8IGJ5dGVzW29mZnNldF0pOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK3RhYml4QDEuNS4xMS9ub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL2NodW5rLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBDaHVuayA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKG1pbnYsIG1heHYsIGJpbiwgZmV0Y2hlZFNpemUgPSB2b2lkIDApIHsKICAgICAgdGhpcy5taW52ID0gbWludjsKICAgICAgdGhpcy5tYXh2ID0gbWF4djsKICAgICAgdGhpcy5iaW4gPSBiaW47CiAgICAgIHRoaXMuX2ZldGNoZWRTaXplID0gZmV0Y2hlZFNpemU7CiAgICB9CiAgICB0b1VuaXF1ZVN0cmluZygpIHsKICAgICAgcmV0dXJuIGAke3RoaXMubWludn0uLiR7dGhpcy5tYXh2fSAoYmluICR7dGhpcy5iaW59LCBmZXRjaGVkU2l6ZSAke3RoaXMuZmV0Y2hlZFNpemUoKX0pYDsKICAgIH0KICAgIHRvU3RyaW5nKCkgewogICAgICByZXR1cm4gdGhpcy50b1VuaXF1ZVN0cmluZygpOwogICAgfQogICAgY29tcGFyZVRvKGIpIHsKICAgICAgcmV0dXJuIHRoaXMubWludi5jb21wYXJlVG8oYi5taW52KSB8fCB0aGlzLm1heHYuY29tcGFyZVRvKGIubWF4dikgfHwgdGhpcy5iaW4gLSBiLmJpbjsKICAgIH0KICAgIGZldGNoZWRTaXplKCkgewogICAgICBpZiAodGhpcy5fZmV0Y2hlZFNpemUgIT09IHZvaWQgMCkgewogICAgICAgIHJldHVybiB0aGlzLl9mZXRjaGVkU2l6ZTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5tYXh2LmJsb2NrUG9zaXRpb24gKyAoMSA8PCAxNikgLSB0aGlzLm1pbnYuYmxvY2tQb3NpdGlvbjsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vaW5kZXhGaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBJbmRleEZpbGUgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3Rvcih7IGZpbGVoYW5kbGUsIHJlbmFtZVJlZlNlcXMgPSAobikgPT4gbiB9KSB7CiAgICAgIHRoaXMuZmlsZWhhbmRsZSA9IGZpbGVoYW5kbGU7CiAgICAgIHRoaXMucmVuYW1lUmVmU2VxID0gcmVuYW1lUmVmU2VxczsKICAgIH0KICAgIGFzeW5jIGdldE1ldGFkYXRhKG9wdHMgPSB7fSkgewogICAgICBjb25zdCB7IGluZGljZXMsIC4uLnJlc3QgfSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIHJldHVybiByZXN0OwogICAgfQogICAgX2ZpbmRGaXJzdERhdGEoY3VycmVudEZkbCwgdmlydHVhbE9mZnNldCkgewogICAgICBpZiAoY3VycmVudEZkbCkgewogICAgICAgIHJldHVybiBjdXJyZW50RmRsLmNvbXBhcmVUbyh2aXJ0dWFsT2Zmc2V0KSA+IDAgPyB2aXJ0dWFsT2Zmc2V0IDogY3VycmVudEZkbDsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gdmlydHVhbE9mZnNldDsKICAgICAgfQogICAgfQogICAgYXN5bmMgcGFyc2Uob3B0cyA9IHt9KSB7CiAgICAgIGlmICghdGhpcy5wYXJzZVApIHsKICAgICAgICB0aGlzLnBhcnNlUCA9IHRoaXMuX3BhcnNlKG9wdHMpLmNhdGNoKChlKSA9PiB7CiAgICAgICAgICB0aGlzLnBhcnNlUCA9IHZvaWQgMDsKICAgICAgICAgIHRocm93IGU7CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMucGFyc2VQOwogICAgfQogICAgYXN5bmMgaGFzUmVmU2VxKHNlcUlkLCBvcHRzID0ge30pIHsKICAgICAgcmV0dXJuICEhKChhd2FpdCB0aGlzLnBhcnNlKG9wdHMpKS5pbmRpY2VzW3NlcUlkXSB8fCB7fSkuYmluSW5kZXg7CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK3RhYml4QDEuNS4xMS9ub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3RiaS5qcwogIHZhciBUQklfTUFHSUMgPSAyMTU3ODMyNDsKICB2YXIgVEFEX0xJRFhfU0hJRlQgPSAxNDsKICBmdW5jdGlvbiByZWcyYmlucyhiZWcsIGVuZCkgewogICAgYmVnICs9IDE7CiAgICBlbmQgLT0gMTsKICAgIHJldHVybiBbCiAgICAgIFswLCAwXSwKICAgICAgWzEgKyAoYmVnID4+IDI2KSwgMSArIChlbmQgPj4gMjYpXSwKICAgICAgWzkgKyAoYmVnID4+IDIzKSwgOSArIChlbmQgPj4gMjMpXSwKICAgICAgWzczICsgKGJlZyA+PiAyMCksIDczICsgKGVuZCA+PiAyMCldLAogICAgICBbNTg1ICsgKGJlZyA+PiAxNyksIDU4NSArIChlbmQgPj4gMTcpXSwKICAgICAgWzQ2ODEgKyAoYmVnID4+IDE0KSwgNDY4MSArIChlbmQgPj4gMTQpXQogICAgXTsKICB9CiAgdmFyIFRhYml4SW5kZXggPSBjbGFzcyBleHRlbmRzIEluZGV4RmlsZSB7CiAgICBhc3luYyBsaW5lQ291bnQocmVmTmFtZSwgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBpZHggPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghaWR4KSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHsgc3RhdHMgfSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKHN0YXRzKSB7CiAgICAgICAgcmV0dXJuIHN0YXRzLmxpbmVDb3VudDsKICAgICAgfQogICAgICByZXR1cm4gLTE7CiAgICB9CiAgICBhc3luYyBfcGFyc2Uob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHRoaXMuZmlsZWhhbmRsZS5yZWFkRmlsZShvcHRzKTsKICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB1bnppcChidWYpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKTsKICAgICAgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSAhPT0gVEJJX01BR0lDKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJOb3QgYSBUQkkgZmlsZSIpOwogICAgICB9CiAgICAgIGNvbnN0IHJlZkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoNCk7CiAgICAgIGNvbnN0IGZvcm1hdEZsYWdzID0gYnl0ZXMucmVhZEludDMyTEUoOCk7CiAgICAgIGNvbnN0IGNvb3JkaW5hdGVUeXBlID0gZm9ybWF0RmxhZ3MgJiA2NTUzNiA/ICJ6ZXJvLWJhc2VkLWhhbGYtb3BlbiIgOiAiMS1iYXNlZC1jbG9zZWQiOwogICAgICBjb25zdCBmb3JtYXRPcHRzID0gewogICAgICAgIDA6ICJnZW5lcmljIiwKICAgICAgICAxOiAiU0FNIiwKICAgICAgICAyOiAiVkNGIgogICAgICB9OwogICAgICBjb25zdCBmb3JtYXQgPSBmb3JtYXRPcHRzW2Zvcm1hdEZsYWdzICYgMTVdOwogICAgICBpZiAoIWZvcm1hdCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBUYWJpeCBwcmVzZXQgZm9ybWF0IGZsYWdzICR7Zm9ybWF0RmxhZ3N9YCk7CiAgICAgIH0KICAgICAgY29uc3QgY29sdW1uTnVtYmVycyA9IHsKICAgICAgICByZWY6IGJ5dGVzLnJlYWRJbnQzMkxFKDEyKSwKICAgICAgICBzdGFydDogYnl0ZXMucmVhZEludDMyTEUoMTYpLAogICAgICAgIGVuZDogYnl0ZXMucmVhZEludDMyTEUoMjApCiAgICAgIH07CiAgICAgIGNvbnN0IG1ldGFWYWx1ZSA9IGJ5dGVzLnJlYWRJbnQzMkxFKDI0KTsKICAgICAgY29uc3QgZGVwdGggPSA1OwogICAgICBjb25zdCBtYXhCaW5OdW1iZXIgPSAoKDEgPDwgKGRlcHRoICsgMSkgKiAzKSAtIDEpIC8gNzsKICAgICAgY29uc3QgbWF4UmVmTGVuZ3RoID0gMiAqKiAoMTQgKyBkZXB0aCAqIDMpOwogICAgICBjb25zdCBtZXRhQ2hhciA9IG1ldGFWYWx1ZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUobWV0YVZhbHVlKSA6IG51bGw7CiAgICAgIGNvbnN0IHNraXBMaW5lcyA9IGJ5dGVzLnJlYWRJbnQzMkxFKDI4KTsKICAgICAgY29uc3QgbmFtZVNlY3Rpb25MZW5ndGggPSBieXRlcy5yZWFkSW50MzJMRSgzMik7CiAgICAgIGNvbnN0IHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH0gPSB0aGlzLl9wYXJzZU5hbWVCeXRlcyhieXRlcy5zbGljZSgzNiwgMzYgKyBuYW1lU2VjdGlvbkxlbmd0aCkpOwogICAgICBsZXQgY3Vyck9mZnNldCA9IDM2ICsgbmFtZVNlY3Rpb25MZW5ndGg7CiAgICAgIGxldCBmaXJzdERhdGFMaW5lOwogICAgICBjb25zdCBpbmRpY2VzID0gbmV3IEFycmF5KHJlZkNvdW50KS5maWxsKDApLm1hcCgoKSA9PiB7CiAgICAgICAgY29uc3QgYmluQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgYmluSW5kZXggPSB7fTsKICAgICAgICBsZXQgc3RhdHM7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiaW5Db3VudDsgaiArPSAxKSB7CiAgICAgICAgICBjb25zdCBiaW4gPSBieXRlcy5yZWFkVUludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICBpZiAoYmluID4gbWF4QmluTnVtYmVyICsgMSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInRhYml4IGluZGV4IGNvbnRhaW5zIHRvbyBtYW55IGJpbnMsIHBsZWFzZSB1c2UgYSBDU0kgaW5kZXgiKTsKICAgICAgICAgIH0gZWxzZSBpZiAoYmluID09PSBtYXhCaW5OdW1iZXIgKyAxKSB7CiAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgICAgICBpZiAoY2h1bmtDb3VudCA9PT0gMikgewogICAgICAgICAgICAgIHN0YXRzID0gdGhpcy5wYXJzZVBzZXVkb0JpbihieXRlcywgY3Vyck9mZnNldCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNiAqIGNodW5rQ291bnQ7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ291bnQpOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNodW5rQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgICAgIGNvbnN0IHUgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgICAgIGNvbnN0IHYgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQgKyA4KTsKICAgICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDE2OwogICAgICAgICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIHUpOwogICAgICAgICAgICAgIGNodW5rc1trXSA9IG5ldyBDaHVuayh1LCB2LCBiaW4pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJpbkluZGV4W2Jpbl0gPSBjaHVua3M7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxpbmVhckNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgIGNvbnN0IGxpbmVhckluZGV4ID0gbmV3IEFycmF5KGxpbmVhckNvdW50KTsKICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGxpbmVhckNvdW50OyBrICs9IDEpIHsKICAgICAgICAgIGxpbmVhckluZGV4W2tdID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgIGN1cnJPZmZzZXQgKz0gODsKICAgICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIGxpbmVhckluZGV4W2tdKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYmluSW5kZXgsIGxpbmVhckluZGV4LCBzdGF0cyB9OwogICAgICB9KTsKICAgICAgcmV0dXJuIHsKICAgICAgICBpbmRpY2VzLAogICAgICAgIG1ldGFDaGFyLAogICAgICAgIG1heEJpbk51bWJlciwKICAgICAgICBtYXhSZWZMZW5ndGgsCiAgICAgICAgc2tpcExpbmVzLAogICAgICAgIGZpcnN0RGF0YUxpbmUsCiAgICAgICAgY29sdW1uTnVtYmVycywKICAgICAgICBjb29yZGluYXRlVHlwZSwKICAgICAgICBmb3JtYXQsCiAgICAgICAgcmVmSWRUb05hbWUsCiAgICAgICAgcmVmTmFtZVRvSWQsCiAgICAgICAgbWF4QmxvY2tTaXplOiAxIDw8IDE2CiAgICAgIH07CiAgICB9CiAgICBwYXJzZVBzZXVkb0JpbihieXRlcywgb2Zmc2V0KSB7CiAgICAgIGNvbnN0IGxpbmVDb3VudCA9IGxvbmdUb051bWJlcihpbXBvcnRfbG9uZzIuZGVmYXVsdC5mcm9tQnl0ZXNMRShieXRlcy5zbGljZShvZmZzZXQgKyAxNiwgb2Zmc2V0ICsgMjQpLCB0cnVlKSk7CiAgICAgIHJldHVybiB7IGxpbmVDb3VudCB9OwogICAgfQogICAgX3BhcnNlTmFtZUJ5dGVzKG5hbWVzQnl0ZXMpIHsKICAgICAgbGV0IGN1cnJSZWZJZCA9IDA7CiAgICAgIGxldCBjdXJyTmFtZVN0YXJ0ID0gMDsKICAgICAgY29uc3QgcmVmSWRUb05hbWUgPSBbXTsKICAgICAgY29uc3QgcmVmTmFtZVRvSWQgPSB7fTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc0J5dGVzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgaWYgKCFuYW1lc0J5dGVzW2ldKSB7CiAgICAgICAgICBpZiAoY3Vyck5hbWVTdGFydCA8IGkpIHsKICAgICAgICAgICAgbGV0IHJlZk5hbWUgPSBuYW1lc0J5dGVzLnRvU3RyaW5nKCJ1dGY4IiwgY3Vyck5hbWVTdGFydCwgaSk7CiAgICAgICAgICAgIHJlZk5hbWUgPSB0aGlzLnJlbmFtZVJlZlNlcShyZWZOYW1lKTsKICAgICAgICAgICAgcmVmSWRUb05hbWVbY3VyclJlZklkXSA9IHJlZk5hbWU7CiAgICAgICAgICAgIHJlZk5hbWVUb0lkW3JlZk5hbWVdID0gY3VyclJlZklkOwogICAgICAgICAgfQogICAgICAgICAgY3Vyck5hbWVTdGFydCA9IGkgKyAxOwogICAgICAgICAgY3VyclJlZklkICs9IDE7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB7IHJlZk5hbWVUb0lkLCByZWZJZFRvTmFtZSB9OwogICAgfQogICAgYXN5bmMgYmxvY2tzRm9yUmFuZ2UocmVmTmFtZSwgbWluLCBtYXgsIG9wdHMgPSB7fSkgewogICAgICBpZiAobWluIDwgMCkgewogICAgICAgIG1pbiA9IDA7CiAgICAgIH0KICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV07CiAgICAgIGNvbnN0IGJhID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoIWJhKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IG1pbk9mZnNldCA9IGJhLmxpbmVhckluZGV4Lmxlbmd0aCA/IGJhLmxpbmVhckluZGV4W21pbiA+PiBUQURfTElEWF9TSElGVCA+PSBiYS5saW5lYXJJbmRleC5sZW5ndGggPyBiYS5saW5lYXJJbmRleC5sZW5ndGggLSAxIDogbWluID4+IFRBRF9MSURYX1NISUZUXSA6IG5ldyBWaXJ0dWFsT2Zmc2V0KDAsIDApOwogICAgICBpZiAoIW1pbk9mZnNldCkgewogICAgICAgIGNvbnNvbGUud2FybigicXVlcnlpbmcgb3V0c2lkZSBvZiBwb3NzaWJsZSB0YWJpeCByYW5nZSIpOwogICAgICB9CiAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQmlucyA9IHJlZzJiaW5zKG1pbiwgbWF4KTsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIG92ZXJsYXBwaW5nQmlucykgewogICAgICAgIGZvciAobGV0IGJpbiA9IHN0YXJ0OyBiaW4gPD0gZW5kOyBiaW4rKykgewogICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHsKICAgICAgICAgICAgY29uc3QgYmluQ2h1bmtzID0gYmEuYmluSW5kZXhbYmluXTsKICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBiaW5DaHVua3MubGVuZ3RoOyArK2MpIHsKICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQ2h1bmsoYmluQ2h1bmtzW2NdLm1pbnYsIGJpbkNodW5rc1tjXS5tYXh2LCBiaW4pKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBjb25zdCBuaW50diA9IGJhLmxpbmVhckluZGV4Lmxlbmd0aDsKICAgICAgbGV0IGxvd2VzdCA9IG51bGw7CiAgICAgIGNvbnN0IG1pbkxpbiA9IE1hdGgubWluKG1pbiA+PiAxNCwgbmludHYgLSAxKTsKICAgICAgY29uc3QgbWF4TGluID0gTWF0aC5taW4obWF4ID4+IDE0LCBuaW50diAtIDEpOwogICAgICBmb3IgKGxldCBpID0gbWluTGluOyBpIDw9IG1heExpbjsgKytpKSB7CiAgICAgICAgY29uc3QgdnAgPSBiYS5saW5lYXJJbmRleFtpXTsKICAgICAgICBpZiAodnApIHsKICAgICAgICAgIGlmICghbG93ZXN0IHx8IHZwLmNvbXBhcmVUbyhsb3dlc3QpIDwgMCkgewogICAgICAgICAgICBsb3dlc3QgPSB2cDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbG93ZXN0KTsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vY3NpLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfbG9uZzMgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbG9uZygpKTsKICB2YXIgQ1NJMV9NQUdJQyA9IDIxNTgyNjU5OwogIHZhciBDU0kyX01BR0lDID0gMzgzNTk4NzU7CiAgZnVuY3Rpb24gbHNoaWZ0KG51bSwgYml0cykgewogICAgcmV0dXJuIG51bSAqIDIgKiogYml0czsKICB9CiAgZnVuY3Rpb24gcnNoaWZ0KG51bSwgYml0cykgewogICAgcmV0dXJuIE1hdGguZmxvb3IobnVtIC8gMiAqKiBiaXRzKTsKICB9CiAgdmFyIENTSSA9IGNsYXNzIGV4dGVuZHMgSW5kZXhGaWxlIHsKICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHsKICAgICAgc3VwZXIoYXJncyk7CiAgICAgIHRoaXMubWF4QmluTnVtYmVyID0gMDsKICAgICAgdGhpcy5kZXB0aCA9IDA7CiAgICAgIHRoaXMubWluU2hpZnQgPSAwOwogICAgfQogICAgYXN5bmMgbGluZUNvdW50KHJlZk5hbWUsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpOwogICAgICBpZiAoIWluZGV4RGF0YSkgewogICAgICAgIHJldHVybiAtMTsKICAgICAgfQogICAgICBjb25zdCByZWZJZCA9IGluZGV4RGF0YS5yZWZOYW1lVG9JZFtyZWZOYW1lXTsKICAgICAgY29uc3QgaWR4ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoIWlkeCkgewogICAgICAgIHJldHVybiAtMTsKICAgICAgfQogICAgICBjb25zdCB7IHN0YXRzIH0gPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmIChzdGF0cykgewogICAgICAgIHJldHVybiBzdGF0cy5saW5lQ291bnQ7CiAgICAgIH0KICAgICAgcmV0dXJuIC0xOwogICAgfQogICAgYXN5bmMgaW5kZXhDb3YoKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiQ1NJIGluZGV4ZXMgZG8gbm90IHN1cHBvcnQgaW5kZXhjb3YiKTsKICAgIH0KICAgIHBhcnNlQXV4RGF0YShieXRlcywgb2Zmc2V0KSB7CiAgICAgIGNvbnN0IGZvcm1hdEZsYWdzID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0KTsKICAgICAgY29uc3QgY29vcmRpbmF0ZVR5cGUgPSBmb3JtYXRGbGFncyAmIDY1NTM2ID8gInplcm8tYmFzZWQtaGFsZi1vcGVuIiA6ICIxLWJhc2VkLWNsb3NlZCI7CiAgICAgIGNvbnN0IGZvcm1hdCA9IHsgMDogImdlbmVyaWMiLCAxOiAiU0FNIiwgMjogIlZDRiIgfVtmb3JtYXRGbGFncyAmIDE1XTsKICAgICAgaWYgKCFmb3JtYXQpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgVGFiaXggcHJlc2V0IGZvcm1hdCBmbGFncyAke2Zvcm1hdEZsYWdzfWApOwogICAgICB9CiAgICAgIGNvbnN0IGNvbHVtbk51bWJlcnMgPSB7CiAgICAgICAgcmVmOiBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyA0KSwKICAgICAgICBzdGFydDogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgOCksCiAgICAgICAgZW5kOiBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAxMikKICAgICAgfTsKICAgICAgY29uc3QgbWV0YVZhbHVlID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMTYpOwogICAgICBjb25zdCBtZXRhQ2hhciA9IG1ldGFWYWx1ZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUobWV0YVZhbHVlKSA6IG51bGw7CiAgICAgIGNvbnN0IHNraXBMaW5lcyA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDIwKTsKICAgICAgY29uc3QgbmFtZVNlY3Rpb25MZW5ndGggPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAyNCk7CiAgICAgIGNvbnN0IHsgcmVmSWRUb05hbWUsIHJlZk5hbWVUb0lkIH0gPSB0aGlzLl9wYXJzZU5hbWVCeXRlcyhieXRlcy5zbGljZShvZmZzZXQgKyAyOCwgb2Zmc2V0ICsgMjggKyBuYW1lU2VjdGlvbkxlbmd0aCkpOwogICAgICByZXR1cm4gewogICAgICAgIHJlZklkVG9OYW1lLAogICAgICAgIHJlZk5hbWVUb0lkLAogICAgICAgIHNraXBMaW5lcywKICAgICAgICBtZXRhQ2hhciwKICAgICAgICBjb2x1bW5OdW1iZXJzLAogICAgICAgIGZvcm1hdCwKICAgICAgICBjb29yZGluYXRlVHlwZQogICAgICB9OwogICAgfQogICAgX3BhcnNlTmFtZUJ5dGVzKG5hbWVzQnl0ZXMpIHsKICAgICAgbGV0IGN1cnJSZWZJZCA9IDA7CiAgICAgIGxldCBjdXJyTmFtZVN0YXJ0ID0gMDsKICAgICAgY29uc3QgcmVmSWRUb05hbWUgPSBbXTsKICAgICAgY29uc3QgcmVmTmFtZVRvSWQgPSB7fTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc0J5dGVzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgaWYgKCFuYW1lc0J5dGVzW2ldKSB7CiAgICAgICAgICBpZiAoY3Vyck5hbWVTdGFydCA8IGkpIHsKICAgICAgICAgICAgbGV0IHJlZk5hbWUgPSBuYW1lc0J5dGVzLnRvU3RyaW5nKCJ1dGY4IiwgY3Vyck5hbWVTdGFydCwgaSk7CiAgICAgICAgICAgIHJlZk5hbWUgPSB0aGlzLnJlbmFtZVJlZlNlcShyZWZOYW1lKTsKICAgICAgICAgICAgcmVmSWRUb05hbWVbY3VyclJlZklkXSA9IHJlZk5hbWU7CiAgICAgICAgICAgIHJlZk5hbWVUb0lkW3JlZk5hbWVdID0gY3VyclJlZklkOwogICAgICAgICAgfQogICAgICAgICAgY3Vyck5hbWVTdGFydCA9IGkgKyAxOwogICAgICAgICAgY3VyclJlZklkICs9IDE7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB7IHJlZk5hbWVUb0lkLCByZWZJZFRvTmFtZSB9OwogICAgfQogICAgYXN5bmMgX3BhcnNlKG9wdHMgPSB7fSkgewogICAgICBjb25zdCBieXRlcyA9IGF3YWl0IHVuemlwKGF3YWl0IHRoaXMuZmlsZWhhbmRsZS5yZWFkRmlsZShvcHRzKSk7CiAgICAgIGxldCBjc2lWZXJzaW9uOwogICAgICBpZiAoYnl0ZXMucmVhZFVJbnQzMkxFKDApID09PSBDU0kxX01BR0lDKSB7CiAgICAgICAgY3NpVmVyc2lvbiA9IDE7CiAgICAgIH0gZWxzZSBpZiAoYnl0ZXMucmVhZFVJbnQzMkxFKDApID09PSBDU0kyX01BR0lDKSB7CiAgICAgICAgY3NpVmVyc2lvbiA9IDI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJOb3QgYSBDU0kgZmlsZSIpOwogICAgICB9CiAgICAgIHRoaXMubWluU2hpZnQgPSBieXRlcy5yZWFkSW50MzJMRSg0KTsKICAgICAgdGhpcy5kZXB0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDgpOwogICAgICB0aGlzLm1heEJpbk51bWJlciA9ICgoMSA8PCAodGhpcy5kZXB0aCArIDEpICogMykgLSAxKSAvIDc7CiAgICAgIGNvbnN0IG1heFJlZkxlbmd0aCA9IDIgKiogKHRoaXMubWluU2hpZnQgKyB0aGlzLmRlcHRoICogMyk7CiAgICAgIGNvbnN0IGF1eExlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDEyKTsKICAgICAgY29uc3QgYXV4ID0gYXV4TGVuZ3RoICYmIGF1eExlbmd0aCA+PSAzMCA/IHRoaXMucGFyc2VBdXhEYXRhKGJ5dGVzLCAxNikgOiB7CiAgICAgICAgcmVmSWRUb05hbWU6IFtdLAogICAgICAgIHJlZk5hbWVUb0lkOiB7fSwKICAgICAgICBtZXRhQ2hhcjogbnVsbCwKICAgICAgICBjb2x1bW5OdW1iZXJzOiB7IHJlZjogMCwgc3RhcnQ6IDEsIGVuZDogMiB9LAogICAgICAgIGNvb3JkaW5hdGVUeXBlOiAiemVyby1iYXNlZC1oYWxmLW9wZW4iLAogICAgICAgIGZvcm1hdDogImdlbmVyaWMiCiAgICAgIH07CiAgICAgIGNvbnN0IHJlZkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoMTYgKyBhdXhMZW5ndGgpOwogICAgICBsZXQgZmlyc3REYXRhTGluZTsKICAgICAgbGV0IGN1cnJPZmZzZXQgPSAxNiArIGF1eExlbmd0aCArIDQ7CiAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgQXJyYXkocmVmQ291bnQpLmZpbGwoMCkubWFwKCgpID0+IHsKICAgICAgICBjb25zdCBiaW5Db3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICBjb25zdCBiaW5JbmRleCA9IHt9OwogICAgICAgIGxldCBzdGF0czsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJpbkNvdW50OyBqICs9IDEpIHsKICAgICAgICAgIGNvbnN0IGJpbiA9IGJ5dGVzLnJlYWRVSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgIGlmIChiaW4gPiB0aGlzLm1heEJpbk51bWJlcikgewogICAgICAgICAgICBzdGF0cyA9IHRoaXMucGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIGN1cnJPZmZzZXQgKyA0KTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSA0ICsgOCArIDQgKyAxNiArIDE2OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29uc3QgbG9mZnNldCA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldCArIDQpOwogICAgICAgICAgICBmaXJzdERhdGFMaW5lID0gdGhpcy5fZmluZEZpcnN0RGF0YShmaXJzdERhdGFMaW5lLCBsb2Zmc2V0KTsKICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQgKyAxMik7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IG5ldyBBcnJheShjaHVua0NvdW50KTsKICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjaHVua0NvdW50OyBrICs9IDEpIHsKICAgICAgICAgICAgICBjb25zdCB1ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICBjb25zdCB2ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgOCk7CiAgICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNjsKICAgICAgICAgICAgICBjaHVua3Nba10gPSBuZXcgQ2h1bmsodSwgdiwgYmluKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBiaW5JbmRleFtiaW5dID0gY2h1bmtzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4geyBiaW5JbmRleCwgc3RhdHMgfTsKICAgICAgfSk7CiAgICAgIHJldHVybiB7CiAgICAgICAgLi4uYXV4LAogICAgICAgIGNzaTogdHJ1ZSwKICAgICAgICByZWZDb3VudCwKICAgICAgICBtYXhCbG9ja1NpemU6IDEgPDwgMTYsCiAgICAgICAgZmlyc3REYXRhTGluZSwKICAgICAgICBjc2lWZXJzaW9uLAogICAgICAgIGluZGljZXMsCiAgICAgICAgZGVwdGg6IHRoaXMuZGVwdGgsCiAgICAgICAgbWF4QmluTnVtYmVyOiB0aGlzLm1heEJpbk51bWJlciwKICAgICAgICBtYXhSZWZMZW5ndGgKICAgICAgfTsKICAgIH0KICAgIHBhcnNlUHNldWRvQmluKGJ5dGVzLCBvZmZzZXQpIHsKICAgICAgY29uc3QgbGluZUNvdW50ID0gbG9uZ1RvTnVtYmVyKGltcG9ydF9sb25nMy5kZWZhdWx0LmZyb21CeXRlc0xFKGJ5dGVzLnNsaWNlKG9mZnNldCArIDI4LCBvZmZzZXQgKyAzNiksIHRydWUpKTsKICAgICAgcmV0dXJuIHsgbGluZUNvdW50IH07CiAgICB9CiAgICBhc3luYyBibG9ja3NGb3JSYW5nZShyZWZOYW1lLCBtaW4sIG1heCwgb3B0cyA9IHt9KSB7CiAgICAgIGlmIChtaW4gPCAwKSB7CiAgICAgICAgbWluID0gMDsKICAgICAgfQogICAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpOwogICAgICBpZiAoIWluZGV4RGF0YSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCByZWZJZCA9IGluZGV4RGF0YS5yZWZOYW1lVG9JZFtyZWZOYW1lXTsKICAgICAgY29uc3QgYmEgPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghYmEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdCaW5zID0gdGhpcy5yZWcyYmlucyhtaW4sIG1heCk7CiAgICAgIGNvbnN0IGNodW5rcyA9IFtdOwogICAgICBmb3IgKGNvbnN0IFtzdGFydCwgZW5kXSBvZiBvdmVybGFwcGluZ0JpbnMpIHsKICAgICAgICBmb3IgKGxldCBiaW4gPSBzdGFydDsgYmluIDw9IGVuZDsgYmluKyspIHsKICAgICAgICAgIGlmIChiYS5iaW5JbmRleFtiaW5dKSB7CiAgICAgICAgICAgIGNvbnN0IGJpbkNodW5rcyA9IGJhLmJpbkluZGV4W2Jpbl07CiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgYmluQ2h1bmtzLmxlbmd0aDsgKytjKSB7CiAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IENodW5rKGJpbkNodW5rc1tjXS5taW52LCBiaW5DaHVua3NbY10ubWF4diwgYmluKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbmV3IFZpcnR1YWxPZmZzZXQoMCwgMCkpOwogICAgfQogICAgcmVnMmJpbnMoYmVnLCBlbmQpIHsKICAgICAgYmVnIC09IDE7CiAgICAgIGlmIChiZWcgPCAxKSB7CiAgICAgICAgYmVnID0gMTsKICAgICAgfQogICAgICBpZiAoZW5kID4gMiAqKiA1MCkgewogICAgICAgIGVuZCA9IDIgKiogMzQ7CiAgICAgIH0KICAgICAgZW5kIC09IDE7CiAgICAgIGxldCBsID0gMDsKICAgICAgbGV0IHQgPSAwOwogICAgICBsZXQgcyA9IHRoaXMubWluU2hpZnQgKyB0aGlzLmRlcHRoICogMzsKICAgICAgY29uc3QgYmlucyA9IFtdOwogICAgICBmb3IgKDsgbCA8PSB0aGlzLmRlcHRoOyBzIC09IDMsIHQgKz0gbHNoaWZ0KDEsIGwgKiAzKSwgbCArPSAxKSB7CiAgICAgICAgY29uc3QgYiA9IHQgKyByc2hpZnQoYmVnLCBzKTsKICAgICAgICBjb25zdCBlID0gdCArIHJzaGlmdChlbmQsIHMpOwogICAgICAgIGlmIChlIC0gYiArIGJpbnMubGVuZ3RoID4gdGhpcy5tYXhCaW5OdW1iZXIpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcXVlcnkgJHtiZWd9LSR7ZW5kfSBpcyB0b28gbGFyZ2UgZm9yIGN1cnJlbnQgYmlubmluZyBzY2hlbWUgKHNoaWZ0ICR7dGhpcy5taW5TaGlmdH0sIGRlcHRoICR7dGhpcy5kZXB0aH0pLCB0cnkgYSBzbWFsbGVyIHF1ZXJ5IG9yIGEgY29hcnNlciBpbmRleCBiaW5uaW5nIHNjaGVtZWApOwogICAgICAgIH0KICAgICAgICBiaW5zLnB1c2goW2IsIGVdKTsKICAgICAgfQogICAgICByZXR1cm4gYmluczsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdGFiaXhJbmRleGVkRmlsZS5qcwogIHZhciBkZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSAidW5kZWZpbmVkIiA/IG5ldyBUZXh0RGVjb2RlcigidXRmLTgiKSA6IHZvaWQgMDsKICBmdW5jdGlvbiB0aW1lb3V0KHRpbWUpIHsKICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lKSk7CiAgfQogIHZhciBUYWJpeEluZGV4ZWRGaWxlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoeyBwYXRoLCBmaWxlaGFuZGxlLCB0YmlQYXRoLCB0YmlGaWxlaGFuZGxlLCBjc2lQYXRoLCBjc2lGaWxlaGFuZGxlLCB5aWVsZFRpbWUgPSA1MDAsIGNodW5rU2l6ZUxpbWl0ID0gNWU3LCByZW5hbWVSZWZTZXFzID0gKG4pID0+IG4sIGNodW5rQ2FjaGVTaXplID0gNSAqIDIgKiogMjAgfSkgewogICAgICBpZiAoZmlsZWhhbmRsZSkgewogICAgICAgIHRoaXMuZmlsZWhhbmRsZSA9IGZpbGVoYW5kbGU7CiAgICAgIH0gZWxzZSBpZiAocGF0aCkgewogICAgICAgIHRoaXMuZmlsZWhhbmRsZSA9IG5ldyBpbXBvcnRfbG9jYWxGaWxlLmRlZmF1bHQocGF0aCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwcm92aWRlIGVpdGhlciBmaWxlaGFuZGxlIG9yIHBhdGgiKTsKICAgICAgfQogICAgICBpZiAodGJpRmlsZWhhbmRsZSkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgVGFiaXhJbmRleCh7CiAgICAgICAgICBmaWxlaGFuZGxlOiB0YmlGaWxlaGFuZGxlLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKGNzaUZpbGVoYW5kbGUpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IENTSSh7CiAgICAgICAgICBmaWxlaGFuZGxlOiBjc2lGaWxlaGFuZGxlLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKHRiaVBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IFRhYml4SW5kZXgoewogICAgICAgICAgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdCh0YmlQYXRoKSwKICAgICAgICAgIHJlbmFtZVJlZlNlcXMKICAgICAgICB9KTsKICAgICAgfSBlbHNlIGlmIChjc2lQYXRoKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBDU0koewogICAgICAgICAgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChjc2lQYXRoKSwKICAgICAgICAgIHJlbmFtZVJlZlNlcXMKICAgICAgICB9KTsKICAgICAgfSBlbHNlIGlmIChwYXRoKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBUYWJpeEluZGV4KHsKICAgICAgICAgIGZpbGVoYW5kbGU6IG5ldyBpbXBvcnRfbG9jYWxGaWxlLmRlZmF1bHQoYCR7cGF0aH0udGJpYCksCiAgICAgICAgICByZW5hbWVSZWZTZXFzCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwcm92aWRlIG9uZSBvZiB0YmlGaWxlaGFuZGxlLCB0YmlQYXRoLCBjc2lGaWxlaGFuZGxlLCBvciBjc2lQYXRoIik7CiAgICAgIH0KICAgICAgdGhpcy5jaHVua1NpemVMaW1pdCA9IGNodW5rU2l6ZUxpbWl0OwogICAgICB0aGlzLnJlbmFtZVJlZlNlcSA9IHJlbmFtZVJlZlNlcXM7CiAgICAgIHRoaXMueWllbGRUaW1lID0geWllbGRUaW1lOwogICAgICB0aGlzLmNodW5rQ2FjaGUgPSBuZXcgaW1wb3J0X2Fib3J0YWJsZV9wcm9taXNlX2NhY2hlLmRlZmF1bHQoewogICAgICAgIGNhY2hlOiBuZXcgaW1wb3J0X3F1aWNrX2xydS5kZWZhdWx0KHsgbWF4U2l6ZTogTWF0aC5mbG9vcihjaHVua0NhY2hlU2l6ZSAvICgxIDw8IDE2KSkgfSksCiAgICAgICAgZmlsbDogKGFyZ3MsIHNpZ25hbCkgPT4gdGhpcy5yZWFkQ2h1bmsoYXJncywgeyBzaWduYWwgfSkKICAgICAgfSk7CiAgICB9CiAgICBhc3luYyBnZXRMaW5lcyhyZWZOYW1lLCBzdGFydCwgZW5kLCBvcHRzKSB7CiAgICAgIGxldCBzaWduYWw7CiAgICAgIGxldCBvcHRpb25zID0ge307CiAgICAgIGxldCBjYWxsYmFjazsKICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAidW5kZWZpbmVkIikgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImxpbmUgY2FsbGJhY2sgbXVzdCBiZSBwcm92aWRlZCIpOwogICAgICB9CiAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIGNhbGxiYWNrID0gb3B0czsKICAgICAgfSBlbHNlIHsKICAgICAgICBvcHRpb25zID0gb3B0czsKICAgICAgICBjYWxsYmFjayA9IG9wdHMubGluZUNhbGxiYWNrOwogICAgICB9CiAgICAgIGlmIChyZWZOYW1lID09PSB2b2lkIDApIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHByb3ZpZGUgYSByZWZlcmVuY2Ugc2VxdWVuY2UgbmFtZSIpOwogICAgICB9CiAgICAgIGlmICghY2FsbGJhY2spIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJsaW5lIGNhbGxiYWNrIG11c3QgYmUgcHJvdmlkZWQiKTsKICAgICAgfQogICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuaW5kZXguZ2V0TWV0YWRhdGEob3B0aW9ucyk7CiAgICAgIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKTsKICAgICAgaWYgKCFzdGFydCkgewogICAgICAgIHN0YXJ0ID0gMDsKICAgICAgfQogICAgICBpZiAoIWVuZCkgewogICAgICAgIGVuZCA9IG1ldGFkYXRhLm1heFJlZkxlbmd0aDsKICAgICAgfQogICAgICBpZiAoIShzdGFydCA8PSBlbmQpKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiaW52YWxpZCBzdGFydCBhbmQgZW5kIGNvb3JkaW5hdGVzLiBzdGFydCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBlbmQiKTsKICAgICAgfQogICAgICBpZiAoc3RhcnQgPT09IGVuZCkgewogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBjb25zdCBjaHVua3MgPSBhd2FpdCB0aGlzLmluZGV4LmJsb2Nrc0ZvclJhbmdlKHJlZk5hbWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgY29uc3Qgc2l6ZSA9IGNodW5rc1tpXS5mZXRjaGVkU2l6ZSgpOwogICAgICAgIGlmIChzaXplID4gdGhpcy5jaHVua1NpemVMaW1pdCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb28gbXVjaCBkYXRhLiBDaHVuayBzaXplICR7c2l6ZS50b0xvY2FsZVN0cmluZygpfSBieXRlcyBleGNlZWRzIGNodW5rU2l6ZUxpbWl0IG9mICR7dGhpcy5jaHVua1NpemVMaW1pdC50b0xvY2FsZVN0cmluZygpfS5gKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgbGV0IGxhc3QgPSBEYXRlLm5vdygpOwogICAgICBmb3IgKGxldCBjaHVua051bSA9IDA7IGNodW5rTnVtIDwgY2h1bmtzLmxlbmd0aDsgY2h1bmtOdW0gKz0gMSkgewogICAgICAgIGxldCBwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZTsKICAgICAgICBjb25zdCBjID0gY2h1bmtzW2NodW5rTnVtXTsKICAgICAgICBjb25zdCB7IGJ1ZmZlciwgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucyB9ID0gYXdhaXQgdGhpcy5jaHVua0NhY2hlLmdldChjLnRvU3RyaW5nKCksIGMpOwogICAgICAgIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKTsKICAgICAgICBsZXQgYmxvY2tTdGFydCA9IDA7CiAgICAgICAgbGV0IHBvcyA9IDA7CiAgICAgICAgd2hpbGUgKGJsb2NrU3RhcnQgPCBidWZmZXIubGVuZ3RoKSB7CiAgICAgICAgICBjb25zdCBuID0gYnVmZmVyLmluZGV4T2YoIlxuIiwgYmxvY2tTdGFydCk7CiAgICAgICAgICBpZiAobiA9PT0gLTEpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBiID0gYnVmZmVyLnNsaWNlKGJsb2NrU3RhcnQsIG4pOwogICAgICAgICAgY29uc3QgbGluZSA9IChkZWNvZGVyID09PSBudWxsIHx8IGRlY29kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29kZXIuZGVjb2RlKGIpKSB8fCBiLnRvU3RyaW5nKCk7CiAgICAgICAgICBpZiAoZHBvc2l0aW9ucykgewogICAgICAgICAgICB3aGlsZSAoYmxvY2tTdGFydCArIGMubWludi5kYXRhUG9zaXRpb24gPj0gZHBvc2l0aW9uc1twb3MrK10pIHsKICAgICAgICAgICAgfQogICAgICAgICAgICBwb3MtLTsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwcyB9ID0gdGhpcy5jaGVja0xpbmUobWV0YWRhdGEsIHJlZk5hbWUsIHN0YXJ0LCBlbmQsIGxpbmUpOwogICAgICAgICAgaWYgKHByZXZpb3VzU3RhcnRDb29yZGluYXRlICE9PSB2b2lkIDAgJiYgc3RhcnRDb29yZGluYXRlICE9PSB2b2lkIDAgJiYgcHJldmlvdXNTdGFydENvb3JkaW5hdGUgPiBzdGFydENvb3JkaW5hdGUpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5lcyBub3Qgc29ydGVkIGJ5IHN0YXJ0IGNvb3JkaW5hdGUgKCR7cHJldmlvdXNTdGFydENvb3JkaW5hdGV9ID4gJHtzdGFydENvb3JkaW5hdGV9KSwgdGhpcyBmaWxlIGlzIG5vdCB1c2FibGUgd2l0aCBUYWJpeC5gKTsKICAgICAgICAgIH0KICAgICAgICAgIHByZXZpb3VzU3RhcnRDb29yZGluYXRlID0gc3RhcnRDb29yZGluYXRlOwogICAgICAgICAgaWYgKG92ZXJsYXBzKSB7CiAgICAgICAgICAgIGNhbGxiYWNrKGxpbmUudHJpbSgpLCBjcG9zaXRpb25zW3Bvc10gKiAoMSA8PCA4KSArIChibG9ja1N0YXJ0IC0gZHBvc2l0aW9uc1twb3NdKSArIGMubWludi5kYXRhUG9zaXRpb24gKyAxKTsKICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRDb29yZGluYXRlICE9PSB2b2lkIDAgJiYgc3RhcnRDb29yZGluYXRlID49IGVuZCkgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpcy55aWVsZFRpbWUgJiYgbGFzdCAtIERhdGUubm93KCkgPiB0aGlzLnlpZWxkVGltZSkgewogICAgICAgICAgICBsYXN0ID0gRGF0ZS5ub3coKTsKICAgICAgICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICAgICAgICBhd2FpdCB0aW1lb3V0KDEpOwogICAgICAgICAgfQogICAgICAgICAgYmxvY2tTdGFydCA9IG4gKyAxOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgYXN5bmMgZ2V0TWV0YWRhdGEob3B0cyA9IHt9KSB7CiAgICAgIHJldHVybiB0aGlzLmluZGV4LmdldE1ldGFkYXRhKG9wdHMpOwogICAgfQogICAgYXN5bmMgZ2V0SGVhZGVyQnVmZmVyKG9wdHMgPSB7fSkgewogICAgICBjb25zdCB7IGZpcnN0RGF0YUxpbmUsIG1ldGFDaGFyLCBtYXhCbG9ja1NpemUgfSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEob3B0cyk7CiAgICAgIGNoZWNrQWJvcnRTaWduYWwob3B0cy5zaWduYWwpOwogICAgICBjb25zdCBtYXhGZXRjaCA9ICgoZmlyc3REYXRhTGluZSA9PT0gbnVsbCB8fCBmaXJzdERhdGFMaW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdERhdGFMaW5lLmJsb2NrUG9zaXRpb24pIHx8IDApICsgbWF4QmxvY2tTaXplOwogICAgICBsZXQgYnl0ZXMgPSBhd2FpdCB0aGlzLl9yZWFkUmVnaW9uKDAsIG1heEZldGNoLCBvcHRzKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChvcHRzLnNpZ25hbCk7CiAgICAgIHRyeSB7CiAgICAgICAgYnl0ZXMgPSBhd2FpdCB1bnppcChieXRlcyk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBjb25zb2xlLmVycm9yKGUpOwogICAgICAgIHRocm93IG5ldyBFcnJvcihgZXJyb3IgZGVjb21wcmVzc2luZyBibG9jayAke2UuY29kZX0gYXQgMCAobGVuZ3RoICR7bWF4RmV0Y2h9KSAke2V9YCk7CiAgICAgIH0KICAgICAgaWYgKG1ldGFDaGFyKSB7CiAgICAgICAgbGV0IGxhc3ROZXdsaW5lID0gLTE7CiAgICAgICAgY29uc3QgbmV3bGluZUJ5dGUgPSAiXG4iLmNoYXJDb2RlQXQoMCk7CiAgICAgICAgY29uc3QgbWV0YUJ5dGUgPSBtZXRhQ2hhci5jaGFyQ29kZUF0KDApOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgIGlmIChpID09PSBsYXN0TmV3bGluZSArIDEgJiYgYnl0ZXNbaV0gIT09IG1ldGFCeXRlKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJ5dGVzW2ldID09PSBuZXdsaW5lQnl0ZSkgewogICAgICAgICAgICBsYXN0TmV3bGluZSA9IGk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2UoMCwgbGFzdE5ld2xpbmUgKyAxKTsKICAgICAgfQogICAgICByZXR1cm4gYnl0ZXM7CiAgICB9CiAgICBhc3luYyBnZXRIZWFkZXIob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdGhpcy5nZXRIZWFkZXJCdWZmZXIob3B0cyk7CiAgICAgIHJldHVybiBieXRlcy50b1N0cmluZygidXRmOCIpOwogICAgfQogICAgYXN5bmMgZ2V0UmVmZXJlbmNlU2VxdWVuY2VOYW1lcyhvcHRzID0ge30pIHsKICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKG9wdHMpOwogICAgICByZXR1cm4gbWV0YWRhdGEucmVmSWRUb05hbWU7CiAgICB9CiAgICBjaGVja0xpbmUobWV0YWRhdGEsIHJlZ2lvblJlZk5hbWUsIHJlZ2lvblN0YXJ0LCByZWdpb25FbmQsIGxpbmUpIHsKICAgICAgY29uc3QgeyBjb2x1bW5OdW1iZXJzLCBtZXRhQ2hhciwgY29vcmRpbmF0ZVR5cGUsIGZvcm1hdCB9ID0gbWV0YWRhdGE7CiAgICAgIGlmIChsaW5lLmNoYXJBdCgwKSA9PT0gbWV0YUNoYXIpIHsKICAgICAgICByZXR1cm4geyBvdmVybGFwczogZmFsc2UgfTsKICAgICAgfQogICAgICBsZXQgeyByZWYsIHN0YXJ0LCBlbmQgfSA9IGNvbHVtbk51bWJlcnM7CiAgICAgIGlmICghcmVmKSB7CiAgICAgICAgcmVmID0gMDsKICAgICAgfQogICAgICBpZiAoIXN0YXJ0KSB7CiAgICAgICAgc3RhcnQgPSAwOwogICAgICB9CiAgICAgIGlmICghZW5kKSB7CiAgICAgICAgZW5kID0gMDsKICAgICAgfQogICAgICBpZiAoZm9ybWF0ID09PSAiVkNGIikgewogICAgICAgIGVuZCA9IDg7CiAgICAgIH0KICAgICAgY29uc3QgbWF4Q29sdW1uID0gTWF0aC5tYXgocmVmLCBzdGFydCwgZW5kKTsKICAgICAgbGV0IGN1cnJlbnRDb2x1bW5OdW1iZXIgPSAxOwogICAgICBsZXQgY3VycmVudENvbHVtblN0YXJ0ID0gMDsKICAgICAgbGV0IHJlZlNlcSA9ICIiOwogICAgICBsZXQgc3RhcnRDb29yZGluYXRlID0gLUluZmluaXR5OwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoICsgMTsgaSArPSAxKSB7CiAgICAgICAgaWYgKGxpbmVbaV0gPT09ICIJIiB8fCBpID09PSBsaW5lLmxlbmd0aCkgewogICAgICAgICAgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPT09IHJlZikgewogICAgICAgICAgICBpZiAodGhpcy5yZW5hbWVSZWZTZXEobGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpKSAhPT0gcmVnaW9uUmVmTmFtZSkgewogICAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9OwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPT09IHN0YXJ0KSB7CiAgICAgICAgICAgIHN0YXJ0Q29vcmRpbmF0ZSA9IHBhcnNlSW50KGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSwgMTApOwogICAgICAgICAgICBpZiAoY29vcmRpbmF0ZVR5cGUgPT09ICIxLWJhc2VkLWNsb3NlZCIpIHsKICAgICAgICAgICAgICBzdGFydENvb3JkaW5hdGUgLT0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoc3RhcnRDb29yZGluYXRlID49IHJlZ2lvbkVuZCkgewogICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGVuZCA9PT0gMCB8fCBlbmQgPT09IHN0YXJ0KSB7CiAgICAgICAgICAgICAgaWYgKHN0YXJ0Q29vcmRpbmF0ZSArIDEgPD0gcmVnaW9uU3RhcnQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gIlZDRiIgJiYgY3VycmVudENvbHVtbk51bWJlciA9PT0gNCkgewogICAgICAgICAgICByZWZTZXEgPSBsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSk7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPT09IGVuZCkgewogICAgICAgICAgICBsZXQgZW5kQ29vcmRpbmF0ZTsKICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gIlZDRiIpIHsKICAgICAgICAgICAgICBlbmRDb29yZGluYXRlID0gdGhpcy5fZ2V0VmNmRW5kKHN0YXJ0Q29vcmRpbmF0ZSwgcmVmU2VxLCBsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSkpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGVuZENvb3JkaW5hdGUgPSBwYXJzZUludChsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSksIDEwKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZW5kQ29vcmRpbmF0ZSA8PSByZWdpb25TdGFydCkgewogICAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBjdXJyZW50Q29sdW1uU3RhcnQgPSBpICsgMTsKICAgICAgICAgIGN1cnJlbnRDb2x1bW5OdW1iZXIgKz0gMTsKICAgICAgICAgIGlmIChjdXJyZW50Q29sdW1uTnVtYmVyID4gbWF4Q29sdW1uKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4geyBzdGFydENvb3JkaW5hdGUsIG92ZXJsYXBzOiB0cnVlIH07CiAgICB9CiAgICBfZ2V0VmNmRW5kKHN0YXJ0Q29vcmRpbmF0ZSwgcmVmU2VxLCBpbmZvKSB7CiAgICAgIGxldCBlbmRDb29yZGluYXRlID0gc3RhcnRDb29yZGluYXRlICsgcmVmU2VxLmxlbmd0aDsKICAgICAgY29uc3QgaXNUUkEgPSBpbmZvLmluZGV4T2YoIlNWVFlQRT1UUkEiKSAhPT0gLTE7CiAgICAgIGlmIChpbmZvWzBdICE9PSAiLiIgJiYgIWlzVFJBKSB7CiAgICAgICAgbGV0IHByZXZDaGFyID0gIjsiOwogICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5mby5sZW5ndGg7IGogKz0gMSkgewogICAgICAgICAgaWYgKHByZXZDaGFyID09PSAiOyIgJiYgaW5mby5zbGljZShqLCBqICsgNCkgPT09ICJFTkQ9IikgewogICAgICAgICAgICBsZXQgdmFsdWVFbmQgPSBpbmZvLmluZGV4T2YoIjsiLCBqKTsKICAgICAgICAgICAgaWYgKHZhbHVlRW5kID09PSAtMSkgewogICAgICAgICAgICAgIHZhbHVlRW5kID0gaW5mby5sZW5ndGg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZW5kQ29vcmRpbmF0ZSA9IHBhcnNlSW50KGluZm8uc2xpY2UoaiArIDQsIHZhbHVlRW5kKSwgMTApOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIHByZXZDaGFyID0gaW5mb1tqXTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoaXNUUkEpIHsKICAgICAgICByZXR1cm4gc3RhcnRDb29yZGluYXRlICsgMTsKICAgICAgfQogICAgICByZXR1cm4gZW5kQ29vcmRpbmF0ZTsKICAgIH0KICAgIGFzeW5jIGxpbmVDb3VudChyZWZOYW1lLCBvcHRzID0ge30pIHsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXgubGluZUNvdW50KHJlZk5hbWUsIG9wdHMpOwogICAgfQogICAgYXN5bmMgX3JlYWRSZWdpb24ocG9zLCBzaXplLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgYiA9IGltcG9ydF9idWZmZXI3LkJ1ZmZlci5hbGxvYyhzaXplKTsKICAgICAgY29uc3QgeyBieXRlc1JlYWQsIGJ1ZmZlciB9ID0gYXdhaXQgdGhpcy5maWxlaGFuZGxlLnJlYWQoYiwgMCwgc2l6ZSwgcG9zLCBvcHRzKTsKICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBieXRlc1JlYWQpOwogICAgfQogICAgYXN5bmMgcmVhZENodW5rKGMsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcmVhZFJlZ2lvbihjLm1pbnYuYmxvY2tQb3NpdGlvbiwgYy5mZXRjaGVkU2l6ZSgpLCBvcHRzKTsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gdW56aXBDaHVua1NsaWNlKGRhdGEsIGMpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvciBkZWNvbXByZXNzaW5nIGMgJHtjLnRvU3RyaW5nKCl9ICR7ZX1gKTsKICAgICAgfQogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCt2Y2ZANS4wLjEwL25vZGVfbW9kdWxlcy9AZ21vZC92Y2YvZXNtL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdmNmQDUuMC4xMC9ub2RlX21vZHVsZXMvQGdtb2QvdmNmL2VzbS9wYXJzZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK3ZjZkA1LjAuMTAvbm9kZV9tb2R1bGVzL0BnbW9kL3ZjZi9lc20vdmNmUmVzZXJ2ZWQuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIHZjZlJlc2VydmVkX2RlZmF1bHQgPSB7CiAgICBJbmZvRmllbGRzOiB7CiAgICAgIEFBOiB7IE51bWJlcjogMSwgVHlwZTogIlN0cmluZyIsIERlc2NyaXB0aW9uOiAiQW5jZXN0cmFsIGFsbGVsZSIgfSwKICAgICAgQUM6IHsKICAgICAgICBOdW1iZXI6ICJBIiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJBbGxlbGUgY291bnQgaW4gZ2Vub3R5cGVzLCBmb3IgZWFjaCBBTFQgYWxsZWxlLCBpbiB0aGUgc2FtZSBvcmRlciBhcyBsaXN0ZWQiCiAgICAgIH0sCiAgICAgIEFEOiB7CiAgICAgICAgTnVtYmVyOiAiUiIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiVG90YWwgcmVhZCBkZXB0aCBmb3IgZWFjaCBhbGxlbGUiCiAgICAgIH0sCiAgICAgIEFERjogewogICAgICAgIE51bWJlcjogIlIiLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlJlYWQgZGVwdGggZm9yIGVhY2ggYWxsZWxlIG9uIHRoZSBmb3J3YXJkIHN0cmFuZCIKICAgICAgfSwKICAgICAgQURSOiB7CiAgICAgICAgTnVtYmVyOiAiUiIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiUmVhZCBkZXB0aCBmb3IgZWFjaCBhbGxlbGUgb24gdGhlIHJldmVyc2Ugc3RyYW5kIgogICAgICB9LAogICAgICBBRjogewogICAgICAgIE51bWJlcjogIkEiLAogICAgICAgIFR5cGU6ICJGbG9hdCIsCiAgICAgICAgRGVzY3JpcHRpb246ICJBbGxlbGUgZnJlcXVlbmN5IGZvciBlYWNoIEFMVCBhbGxlbGUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgbGlzdGVkIChlc3RpbWF0ZWQgZnJvbSBwcmltYXJ5IGRhdGEsIG5vdCBjYWxsZWQgZ2Vub3R5cGVzKSIKICAgICAgfSwKICAgICAgQU46IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiVG90YWwgbnVtYmVyIG9mIGFsbGVsZXMgaW4gY2FsbGVkIGdlbm90eXBlcyIKICAgICAgfSwKICAgICAgQlE6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkZsb2F0IiwKICAgICAgICBEZXNjcmlwdGlvbjogIlJNUyBiYXNlIHF1YWxpdHkiCiAgICAgIH0sCiAgICAgIENJR0FSOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJGbG9hdCIsCiAgICAgICAgRGVzY3JpcHRpb246ICJDaWdhciBzdHJpbmcgZGVzY3JpYmluZyBob3cgdG8gYWxpZ24gYW4gYWx0ZXJuYXRlIGFsbGVsZSB0byB0aGUgcmVmZXJlbmNlIGFsbGVsZSIKICAgICAgfSwKICAgICAgREI6IHsKICAgICAgICBOdW1iZXI6IDAsCiAgICAgICAgVHlwZTogIkZsYWciLAogICAgICAgIERlc2NyaXB0aW9uOiAiZGJTTlAgbWVtYmVyc2hpcCIKICAgICAgfSwKICAgICAgRFA6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiY29tYmluZWQgZGVwdGggYWNyb3NzIHNhbXBsZXMiCiAgICAgIH0sCiAgICAgIEVORDogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJFbmQgcG9zaXRpb24gKGZvciB1c2Ugd2l0aCBzeW1ib2xpYyBhbGxlbGVzKSIKICAgICAgfSwKICAgICAgSDI6IHsKICAgICAgICBOdW1iZXI6IDAsCiAgICAgICAgVHlwZTogIkZsYWciLAogICAgICAgIERlc2NyaXB0aW9uOiAiSGFwTWFwMiBtZW1iZXJzaGlwIgogICAgICB9LAogICAgICBIMzogewogICAgICAgIE51bWJlcjogMCwKICAgICAgICBUeXBlOiAiRmxhZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJIYXBNYXAzIG1lbWJlcnNoaXAiCiAgICAgIH0sCiAgICAgIE1ROiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6IG51bGwsCiAgICAgICAgRGVzY3JpcHRpb246ICJSTVMgbWFwcGluZyBxdWFsaXR5IgogICAgICB9LAogICAgICBNUTA6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiTnVtYmVyIG9mIE1BUFEgPT0gMCByZWFkcyIKICAgICAgfSwKICAgICAgTlM6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiTnVtYmVyIG9mIHNhbXBsZXMgd2l0aCBkYXRhIgogICAgICB9LAogICAgICBTQjogewogICAgICAgIE51bWJlcjogNCwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJTdHJhbmQgYmlhcyIKICAgICAgfSwKICAgICAgU09NQVRJQzogewogICAgICAgIE51bWJlcjogMCwKICAgICAgICBUeXBlOiAiRmxhZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJTb21hdGljIG11dGF0aW9uIChmb3IgY2FuY2VyIGdlbm9taWNzKSIKICAgICAgfSwKICAgICAgVkFMSURBVEVEOiB7CiAgICAgICAgTnVtYmVyOiAwLAogICAgICAgIFR5cGU6ICJGbGFnIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlZhbGlkYXRlZCBieSBmb2xsb3ctdXAgZXhwZXJpbWVudCIKICAgICAgfSwKICAgICAgIjEwMDBHIjogewogICAgICAgIE51bWJlcjogMCwKICAgICAgICBUeXBlOiAiRmxhZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICIxMDAwIEdlbm9tZXMgbWVtYmVyc2hpcCIKICAgICAgfSwKICAgICAgSU1QUkVDSVNFOiB7CiAgICAgICAgTnVtYmVyOiAwLAogICAgICAgIFR5cGU6ICJGbGFnIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkltcHJlY2lzZSBzdHJ1Y3R1cmFsIHZhcmlhdGlvbiIKICAgICAgfSwKICAgICAgTk9WRUw6IHsKICAgICAgICBOdW1iZXI6IDAsCiAgICAgICAgVHlwZTogIkZsYWciLAogICAgICAgIERlc2NyaXB0aW9uOiAiSW5kaWNhdGVzIGEgbm92ZWwgc3RydWN0dXJhbCB2YXJpYXRpb24iCiAgICAgIH0sCiAgICAgIFNWVFlQRTogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlR5cGUgb2Ygc3RydWN0dXJhbCB2YXJpYW50IgogICAgICB9LAogICAgICBTVkxFTjogewogICAgICAgIE51bWJlcjogbnVsbCwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJEaWZmZXJlbmNlIGluIGxlbmd0aCBiZXR3ZWVuIFJFRiBhbmQgQUxUIGFsbGVsZXMiCiAgICAgIH0sCiAgICAgIENJUE9TOiB7CiAgICAgICAgTnVtYmVyOiAyLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkNvbmZpZGVuY2UgaW50ZXJ2YWwgYXJvdW5kIFBPUyBmb3IgaW1wcmVjaXNlIHZhcmlhbnRzIgogICAgICB9LAogICAgICBDSUVORDogewogICAgICAgIE51bWJlcjogMiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJDb25maWRlbmNlIGludGVydmFsIGFyb3VuZCBFTkQgZm9yIGltcHJlY2lzZSB2YXJpYW50cyIKICAgICAgfSwKICAgICAgSE9NTEVOOiB7CiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiTGVuZ3RoIG9mIGJhc2UgcGFpciBpZGVudGljYWwgbWljcm8taG9tb2xvZ3kgYXQgZXZlbnQgYnJlYWtwb2ludHMiCiAgICAgIH0sCiAgICAgIEhPTVNFUTogewogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiU2VxdWVuY2Ugb2YgYmFzZSBwYWlyIGlkZW50aWNhbCBtaWNyby1ob21vbG9neSBhdCBldmVudCBicmVha3BvaW50cyIKICAgICAgfSwKICAgICAgQktQVElEOiB7CiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJJRCBvZiB0aGUgYXNzZW1ibGVkIGFsdGVybmF0ZSBhbGxlbGUgaW4gdGhlIGFzc2VtYmx5IGZpbGUiCiAgICAgIH0sCiAgICAgIE1FSU5GTzogewogICAgICAgIE51bWJlcjogNCwKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIk1vYmlsZSBlbGVtZW50IGluZm8gb2YgdGhlIGZvcm0gTkFNRSxTVEFSVCxFTkQsUE9MQVJJVFkiCiAgICAgIH0sCiAgICAgIE1FVFJBTlM6IHsKICAgICAgICBOdW1iZXI6IDQsCiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJNb2JpbGUgZWxlbWVudCB0cmFuc2R1Y3Rpb24gaW5mbyBvZiB0aGUgZm9ybSBDSFIsU1RBUlQsRU5ELFBPTEFSSVRZIgogICAgICB9LAogICAgICBER1ZJRDogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIklEIG9mIHRoaXMgZWxlbWVudCBpbiBEYXRhYmFzZSBvZiBHZW5vbWljIFZhcmlhdGlvbiIKICAgICAgfSwKICAgICAgREJWQVJJRDogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIklEIG9mIHRoaXMgZWxlbWVudCBpbiBEQlZBUiIKICAgICAgfSwKICAgICAgREJSSVBJRDogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIklEIG9mIHRoaXMgZWxlbWVudCBpbiBEQlJJUCIKICAgICAgfSwKICAgICAgTUFURUlEOiB7CiAgICAgICAgTnVtYmVyOiBudWxsLAogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiSUQgb2YgbWF0ZSBicmVha2VuZHMiCiAgICAgIH0sCiAgICAgIFBBUklEOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiSUQgb2YgcGFydG5lciBicmVha2VuZCIKICAgICAgfSwKICAgICAgRVZFTlQ6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJJRCBvZiBldmVudCBhc3NvY2lhdGVkIHRvIGJyZWFrZW5kIgogICAgICB9LAogICAgICBDSUxFTjogewogICAgICAgIE51bWJlcjogMiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJDb25maWRlbmNlIGludGVydmFsIGFyb3VuZCB0aGUgaW5zZXJ0ZWQgbWF0ZXJpYWwgYmV0d2VlbiBicmVha2VuZCIKICAgICAgfSwKICAgICAgRFBBREo6IHsgVHlwZTogIkludGVnZXIiLCBEZXNjcmlwdGlvbjogIlJlYWQgRGVwdGggb2YgYWRqYWNlbmN5IiB9LAogICAgICBDTjogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJDb3B5IG51bWJlciBvZiBzZWdtZW50IGNvbnRhaW5pbmcgYnJlYWtlbmQiCiAgICAgIH0sCiAgICAgIENOQURKOiB7CiAgICAgICAgTnVtYmVyOiBudWxsLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkNvcHkgbnVtYmVyIG9mIGFkamFjZW5jeSIKICAgICAgfSwKICAgICAgQ0lDTjogewogICAgICAgIE51bWJlcjogMiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJDb25maWRlbmNlIGludGVydmFsIGFyb3VuZCBjb3B5IG51bWJlciBmb3IgdGhlIHNlZ21lbnQiCiAgICAgIH0sCiAgICAgIENJQ05BREo6IHsKICAgICAgICBOdW1iZXI6IG51bGwsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiQ29uZmlkZW5jZSBpbnRlcnZhbCBhcm91bmQgY29weSBudW1iZXIgZm9yIHRoZSBhZGphY2VuY3kiCiAgICAgIH0KICAgIH0sCiAgICBHZW5vdHlwZUZpZWxkczogewogICAgICBBRDogewogICAgICAgIE51bWJlcjogIlIiLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlJlYWQgZGVwdGggZm9yIGVhY2ggYWxsZWxlIgogICAgICB9LAogICAgICBBREY6IHsKICAgICAgICBOdW1iZXI6ICJSIiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJSZWFkIGRlcHRoIGZvciBlYWNoIGFsbGVsZSBvbiB0aGUgZm9yd2FyZCBzdHJhbmQiCiAgICAgIH0sCiAgICAgIEFEUjogewogICAgICAgIE51bWJlcjogIlIiLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlJlYWQgZGVwdGggZm9yIGVhY2ggYWxsZWxlIG9uIHRoZSByZXZlcnNlIHN0cmFuZCIKICAgICAgfSwKICAgICAgRFA6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiUmVhZCBkZXB0aCIKICAgICAgfSwKICAgICAgRUM6IHsKICAgICAgICBOdW1iZXI6ICJBIiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJFeHBlY3RlZCBhbHRlcm5hdGUgYWxsZWxlIGNvdW50cyIKICAgICAgfSwKICAgICAgRlQ6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICdGaWx0ZXIgaW5kaWNhdGluZyBpZiB0aGlzIGdlbm90eXBlIHdhcyAiY2FsbGVkIicKICAgICAgfSwKICAgICAgR0w6IHsKICAgICAgICBOdW1iZXI6ICJHIiwKICAgICAgICBUeXBlOiAiRmxvYXQiLAogICAgICAgIERlc2NyaXB0aW9uOiAiR2Vub3R5cGUgbGlrZWxpaG9vZHMiCiAgICAgIH0sCiAgICAgIEdQOiB7CiAgICAgICAgTnVtYmVyOiAiRyIsCiAgICAgICAgVHlwZTogIkZsb2F0IiwKICAgICAgICBEZXNjcmlwdGlvbjogIkdlbm90eXBlIHBvc3RlcmlvciBwcm9iYWJpbGl0aWVzIgogICAgICB9LAogICAgICBHUTogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJDb25kaXRpb25hbCBnZW5vdHlwZSBxdWFsaXR5IgogICAgICB9LAogICAgICBHVDogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkdlbm90eXBlIgogICAgICB9LAogICAgICBIUTogewogICAgICAgIE51bWJlcjogMiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJIYXBsb3R5cGUgcXVhbGl0eSIKICAgICAgfSwKICAgICAgTVE6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiUk1TIG1hcHBpbmcgcXVhbGl0eSIKICAgICAgfSwKICAgICAgUEw6IHsKICAgICAgICBOdW1iZXI6ICJHIiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJQaHJlZC1zY2FsZWQgZ2Vub3R5cGUgbGlrZWxpaG9vZHMgcm91bmRlZCB0byB0aGUgY2xvc2VzdCBpbnRlZ2VyIgogICAgICB9LAogICAgICBQUTogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJQaGFzaW5nIHF1YWxpdHkiCiAgICAgIH0sCiAgICAgIFBTOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlBoYXNlIHNldCIKICAgICAgfQogICAgfSwKICAgIEFsdFR5cGVzOiB7CiAgICAgIERFTDogewogICAgICAgIERlc2NyaXB0aW9uOiAiRGVsZXRpb24gcmVsYXRpdmUgdG8gdGhlIHJlZmVyZW5jZSIKICAgICAgfSwKICAgICAgSU5TOiB7CiAgICAgICAgRGVzY3JpcHRpb246ICJJbnNlcnRpb24gb2Ygbm92ZWwgc2VxdWVuY2UgcmVsYXRpdmUgdG8gdGhlIHJlZmVyZW5jZSIKICAgICAgfSwKICAgICAgRFVQOiB7CiAgICAgICAgRGVzY3JpcHRpb246ICJSZWdpb24gb2YgZWxldmF0ZWQgY29weSBudW1iZXIgcmVsYXRpdmUgdG8gdGhlIHJlZmVyZW5jZSIKICAgICAgfSwKICAgICAgSU5WOiB7CiAgICAgICAgRGVzY3JpcHRpb246ICJJbnZlcnNpb24gb2YgcmVmZXJlbmNlIHNlcXVlbmNlIgogICAgICB9LAogICAgICBDTlY6IHsKICAgICAgICBEZXNjcmlwdGlvbjogIkNvcHkgbnVtYmVyIHZhcmlhYmxlIHJlZ2lvbiAobWF5IGJlIGJvdGggZGVsZXRpb24gYW5kIGR1cGxpY2F0aW9uKSIKICAgICAgfSwKICAgICAgIkRVUDpUQU5ERU0iOiB7CiAgICAgICAgRGVzY3JpcHRpb246ICJUYW5kZW0gZHVwbGljYXRpb24iCiAgICAgIH0sCiAgICAgICJERUw6TUUiOiB7CiAgICAgICAgRGVzY3JpcHRpb246ICJEZWxldGlvbiBvZiBtb2JpbGUgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlIgogICAgICB9LAogICAgICAiSU5TOk1FIjogewogICAgICAgIERlc2NyaXB0aW9uOiAiSW5zZXJ0aW9uIG9mIGEgbW9iaWxlIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHJlZmVyZW5jZSIKICAgICAgfSwKICAgICAgTk9OX1JFRjogewogICAgICAgIERlc2NyaXB0aW9uOiAiUmVwcmVzZW50cyBhbnkgcG9zc2libGUgYWx0ZXJuYXRpdmUgYWxsZWxlIGF0IHRoaXMgbG9jYXRpb24iCiAgICAgIH0sCiAgICAgICIqIjogewogICAgICAgIERlc2NyaXB0aW9uOiAiUmVwcmVzZW50cyBhbnkgcG9zc2libGUgYWx0ZXJuYXRpdmUgYWxsZWxlIGF0IHRoaXMgbG9jYXRpb24iCiAgICAgIH0KICAgIH0sCiAgICBGaWx0ZXJUeXBlczogewogICAgICBQQVNTOiB7CiAgICAgICAgRGVzY3JpcHRpb246ICJQYXNzZWQgYWxsIGZpbHRlcnMiCiAgICAgIH0KICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdmNmQDUuMC4xMC9ub2RlX21vZHVsZXMvQGdtb2QvdmNmL2VzbS9wYXJzZS5qcwogIGZ1bmN0aW9uIFZhcmlhbnQoc3R1ZmYpIHsKICAgIE9iamVjdC5hc3NpZ24odGhpcywgc3R1ZmYpOwogIH0KICBmdW5jdGlvbiBkZWNvZGVVUklDb21wb25lbnROb1Rocm93KHVyaSkgewogICAgdHJ5IHsKICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh1cmkpOwogICAgfSBjYXRjaCAoZSkgewogICAgICByZXR1cm4gdXJpOwogICAgfQogIH0KICB2YXIgVkNGID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoeyBoZWFkZXIgPSAiIiwgc3RyaWN0ID0gdHJ1ZSB9KSB7CiAgICAgIGlmICghaGVhZGVyIHx8ICFoZWFkZXIubGVuZ3RoKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJlbXB0eSBoZWFkZXIgcmVjZWl2ZWQiKTsKICAgICAgfQogICAgICBjb25zdCBoZWFkZXJMaW5lcyA9IGhlYWRlci5zcGxpdCgvW1xyXG5dKy8pLmZpbHRlcigobGluZSkgPT4gbGluZSk7CiAgICAgIGlmICghaGVhZGVyTGluZXMubGVuZ3RoKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJubyBub24tZW1wdHkgaGVhZGVyIGxpbmVzIHNwZWNpZmllZCIpOwogICAgICB9CiAgICAgIHRoaXMuc3RyaWN0ID0gc3RyaWN0OwogICAgICB0aGlzLm1ldGFkYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh7CiAgICAgICAgSU5GTzogdmNmUmVzZXJ2ZWRfZGVmYXVsdC5JbmZvRmllbGRzLAogICAgICAgIEZPUk1BVDogdmNmUmVzZXJ2ZWRfZGVmYXVsdC5HZW5vdHlwZUZpZWxkcywKICAgICAgICBBTFQ6IHZjZlJlc2VydmVkX2RlZmF1bHQuQWx0VHlwZXMsCiAgICAgICAgRklMVEVSOiB2Y2ZSZXNlcnZlZF9kZWZhdWx0LkZpbHRlclR5cGVzCiAgICAgIH0pKTsKICAgICAgbGV0IGxhc3RMaW5lOwogICAgICBoZWFkZXJMaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7CiAgICAgICAgaWYgKCFsaW5lLnN0YXJ0c1dpdGgoIiMiKSkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgbGluZSBpbiBoZWFkZXI6CiR7bGluZX1gKTsKICAgICAgICB9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aCgiIyMiKSkgewogICAgICAgICAgdGhpcy5fcGFyc2VNZXRhZGF0YShsaW5lKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbGFzdExpbmUgPSBsaW5lOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGlmICghbGFzdExpbmUpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vIGZvcm1hdCBsaW5lIGZvdW5kIGluIGhlYWRlciIpOwogICAgICB9CiAgICAgIGNvbnN0IGZpZWxkcyA9IGxhc3RMaW5lLnRyaW0oKS5zcGxpdCgiCSIpOwogICAgICBjb25zdCB0aGlzSGVhZGVyID0gZmllbGRzLnNsaWNlKDAsIDgpOwogICAgICBjb25zdCBjb3JyZWN0SGVhZGVyID0gWwogICAgICAgICIjQ0hST00iLAogICAgICAgICJQT1MiLAogICAgICAgICJJRCIsCiAgICAgICAgIlJFRiIsCiAgICAgICAgIkFMVCIsCiAgICAgICAgIlFVQUwiLAogICAgICAgICJGSUxURVIiLAogICAgICAgICJJTkZPIgogICAgICBdOwogICAgICBpZiAoZmllbGRzLmxlbmd0aCA8IDgpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZDRiBoZWFkZXIgbWlzc2luZyBjb2x1bW5zOgoke2xhc3RMaW5lfWApOwogICAgICB9IGVsc2UgaWYgKHRoaXNIZWFkZXIubGVuZ3RoICE9PSBjb3JyZWN0SGVhZGVyLmxlbmd0aCB8fCAhdGhpc0hlYWRlci5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSA9PT0gY29ycmVjdEhlYWRlcltpbmRleF0pKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWQ0YgY29sdW1uIGhlYWRlcnMgbm90IGNvcnJlY3Q6CiR7bGFzdExpbmV9YCk7CiAgICAgIH0KICAgICAgdGhpcy5zYW1wbGVzID0gZmllbGRzLnNsaWNlKDkpOwogICAgfQogICAgX3BhcnNlR2Vub3R5cGVzKGZvcm1hdCwgcHJlcmVzdCkgewogICAgICBjb25zdCByZXN0ID0gcHJlcmVzdC5zcGxpdCgiCSIpOwogICAgICBjb25zdCBnZW5vdHlwZXMgPSB7fTsKICAgICAgY29uc3QgZm9ybWF0S2V5cyA9IGZvcm1hdCA9PT0gbnVsbCB8fCBmb3JtYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdC5zcGxpdCgiOiIpOwogICAgICBpZiAoZm9ybWF0S2V5cykgewogICAgICAgIHRoaXMuc2FtcGxlcy5mb3JFYWNoKChzYW1wbGUsIGluZGV4KSA9PiB7CiAgICAgICAgICBnZW5vdHlwZXNbc2FtcGxlXSA9IHt9OwogICAgICAgICAgZm9ybWF0S2V5cy5mb3JFYWNoKChrZXkpID0+IHsKICAgICAgICAgICAgZ2Vub3R5cGVzW3NhbXBsZV1ba2V5XSA9IG51bGw7CiAgICAgICAgICB9KTsKICAgICAgICAgIHJlc3RbaW5kZXhdLnNwbGl0KCI6IikuZmlsdGVyKChmKSA9PiBmKS5mb3JFYWNoKCh2YWwsIGluZGV4MikgPT4gewogICAgICAgICAgICBsZXQgdGhpc1ZhbHVlOwogICAgICAgICAgICBpZiAodmFsID09PSAiIiB8fCB2YWwgPT09ICIuIiB8fCB2YWwgPT09IHZvaWQgMCkgewogICAgICAgICAgICAgIHRoaXNWYWx1ZSA9IG51bGw7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IHZhbC5zcGxpdCgiLCIpLm1hcCgoZW50KSA9PiBlbnQgPT09ICIuIiA/IG51bGwgOiBlbnQpOwogICAgICAgICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuZ2V0TWV0YWRhdGEoIkZPUk1BVCIsIGZvcm1hdEtleXNbaW5kZXgyXSwgIlR5cGUiKTsKICAgICAgICAgICAgICBpZiAodmFsdWVUeXBlID09PSAiSW50ZWdlciIgfHwgdmFsdWVUeXBlID09PSAiRmxvYXQiKSB7CiAgICAgICAgICAgICAgICB0aGlzVmFsdWUgPSBlbnRyaWVzLm1hcCgodmFsMikgPT4gdmFsMiA/ICt2YWwyIDogdmFsMik7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXNWYWx1ZSA9IGVudHJpZXM7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGdlbm90eXBlc1tzYW1wbGVdW2Zvcm1hdEtleXNbaW5kZXgyXV0gPSB0aGlzVmFsdWU7CiAgICAgICAgICB9LCB7fSk7CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGdlbm90eXBlczsKICAgIH0KICAgIF9wYXJzZU1ldGFkYXRhKGxpbmUpIHsKICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLnRyaW0oKS5tYXRjaCgvXiMjKC4rPyk9KC4qKS8pOwogICAgICBpZiAoIW1hdGNoKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5lIGlzIG5vdCBhIHZhbGlkIG1ldGFkYXRhIGxpbmU6ICR7bGluZX1gKTsKICAgICAgfQogICAgICBjb25zdCBbbWV0YUtleSwgbWV0YVZhbF0gPSBtYXRjaC5zbGljZSgxLCAzKTsKICAgICAgaWYgKG1ldGFWYWwuc3RhcnRzV2l0aCgiPCIpKSB7CiAgICAgICAgaWYgKCEobWV0YUtleSBpbiB0aGlzLm1ldGFkYXRhKSkgewogICAgICAgICAgdGhpcy5tZXRhZGF0YVttZXRhS2V5XSA9IHt9OwogICAgICAgIH0KICAgICAgICBjb25zdCBbaWQsIGtleVZhbHNdID0gdGhpcy5fcGFyc2VTdHJ1Y3R1cmVkTWV0YVZhbChtZXRhVmFsKTsKICAgICAgICB0aGlzLm1ldGFkYXRhW21ldGFLZXldW2lkXSA9IGtleVZhbHM7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5tZXRhZGF0YVttZXRhS2V5XSA9IG1ldGFWYWw7CiAgICAgIH0KICAgIH0KICAgIF9wYXJzZVN0cnVjdHVyZWRNZXRhVmFsKG1ldGFWYWwpIHsKICAgICAgY29uc3Qga2V5VmFscyA9IHRoaXMuX3BhcnNlS2V5VmFsdWUobWV0YVZhbC5yZXBsYWNlKC9ePHw+JC9nLCAiIiksICIsIik7CiAgICAgIGNvbnN0IGlkID0ga2V5VmFscy5JRDsKICAgICAgZGVsZXRlIGtleVZhbHMuSUQ7CiAgICAgIGlmICgiTnVtYmVyIiBpbiBrZXlWYWxzKSB7CiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oTnVtYmVyKGtleVZhbHMuTnVtYmVyKSkpIHsKICAgICAgICAgIGtleVZhbHMuTnVtYmVyID0gTnVtYmVyKGtleVZhbHMuTnVtYmVyKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIFtpZCwga2V5VmFsc107CiAgICB9CiAgICBnZXRNZXRhZGF0YSguLi5hcmdzKSB7CiAgICAgIGxldCBmaWx0ZXJlZE1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgZmlsdGVyZWRNZXRhZGF0YSA9IGZpbHRlcmVkTWV0YWRhdGFbYXJnc1tpXV07CiAgICAgICAgaWYgKCFmaWx0ZXJlZE1ldGFkYXRhKSB7CiAgICAgICAgICByZXR1cm4gZmlsdGVyZWRNZXRhZGF0YTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIGZpbHRlcmVkTWV0YWRhdGE7CiAgICB9CiAgICBfcGFyc2VLZXlWYWx1ZShzdHIsIHBhaXJTZXBhcmF0b3IgPSAiOyIpIHsKICAgICAgY29uc3QgZGF0YSA9IHt9OwogICAgICBsZXQgY3VycktleSA9ICIiOwogICAgICBsZXQgY3VyclZhbHVlID0gIiI7CiAgICAgIGxldCBzdGF0ZSA9IDE7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgaWYgKHN0YXRlID09PSAxKSB7CiAgICAgICAgICBpZiAoc3RyW2ldID09PSAiPSIpIHsKICAgICAgICAgICAgc3RhdGUgPSAyOwogICAgICAgICAgfSBlbHNlIGlmIChzdHJbaV0gIT09IHBhaXJTZXBhcmF0b3IpIHsKICAgICAgICAgICAgY3VycktleSArPSBzdHJbaV07CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJWYWx1ZSA9PT0gIiIpIHsKICAgICAgICAgICAgZGF0YVtjdXJyS2V5XSA9IG51bGw7CiAgICAgICAgICAgIGN1cnJLZXkgPSAiIjsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAyKSB7CiAgICAgICAgICBpZiAoc3RyW2ldID09PSBwYWlyU2VwYXJhdG9yKSB7CiAgICAgICAgICAgIGRhdGFbY3VycktleV0gPSBjdXJyVmFsdWU7CiAgICAgICAgICAgIGN1cnJLZXkgPSAiIjsKICAgICAgICAgICAgY3VyclZhbHVlID0gIiI7CiAgICAgICAgICAgIHN0YXRlID0gMTsKICAgICAgICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSAnIicpIHsKICAgICAgICAgICAgc3RhdGUgPSAzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY3VyclZhbHVlICs9IHN0cltpXTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAzKSB7CiAgICAgICAgICBpZiAoc3RyW2ldICE9PSAnIicpIHsKICAgICAgICAgICAgY3VyclZhbHVlICs9IHN0cltpXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN0YXRlID0gMjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKHN0YXRlID09PSAyIHx8IHN0YXRlID09PSAzKSB7CiAgICAgICAgZGF0YVtjdXJyS2V5XSA9IGN1cnJWYWx1ZTsKICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gMSkgewogICAgICAgIGRhdGFbY3VycktleV0gPSBudWxsOwogICAgICB9CiAgICAgIHJldHVybiBkYXRhOwogICAgfQogICAgcGFyc2VMaW5lKGxpbmUpIHsKICAgICAgbGluZSA9IGxpbmUudHJpbSgpOwogICAgICBpZiAoIWxpbmUubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgfQogICAgICBjb25zdCBwYXJzZXIgPSB0aGlzOwogICAgICBsZXQgY3VyckNoYXIgPSAwOwogICAgICBmb3IgKGxldCBjdXJyRmllbGQgPSAwOyBjdXJyQ2hhciA8IGxpbmUubGVuZ3RoOyBjdXJyQ2hhciArPSAxKSB7CiAgICAgICAgaWYgKGxpbmVbY3VyckNoYXJdID09PSAiCSIpIHsKICAgICAgICAgIGN1cnJGaWVsZCArPSAxOwogICAgICAgIH0KICAgICAgICBpZiAoY3VyckZpZWxkID09PSA5KSB7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc3QgZmllbGRzID0gbGluZS5zdWJzdHIoMCwgY3VyckNoYXIpLnNwbGl0KCIJIik7CiAgICAgIGNvbnN0IHJlc3QgPSBsaW5lLnN1YnN0cihjdXJyQ2hhciArIDEpOwogICAgICBjb25zdCBbQ0hST00sIFBPUywgSUQsIFJFRiwgQUxULCBRVUFMLCBGSUxURVJdID0gZmllbGRzOwogICAgICBjb25zdCBjaHJvbSA9IENIUk9NOwogICAgICBjb25zdCBwb3MgPSArUE9TOwogICAgICBjb25zdCBpZCA9IElEID09PSAiLiIgPyBudWxsIDogSUQuc3BsaXQoIjsiKTsKICAgICAgY29uc3QgcmVmID0gUkVGOwogICAgICBjb25zdCBhbHQgPSBBTFQgPT09ICIuIiA/IG51bGwgOiBBTFQuc3BsaXQoIiwiKTsKICAgICAgY29uc3QgcXVhbCA9IFFVQUwgPT09ICIuIiA/IG51bGwgOiArUVVBTDsKICAgICAgY29uc3QgZmlsdGVyID0gRklMVEVSID09PSAiLiIgPyBudWxsIDogRklMVEVSLnNwbGl0KCI7Iik7CiAgICAgIGlmICh0aGlzLnN0cmljdCAmJiBmaWVsZHNbN10gPT09IHZvaWQgMCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigibm8gSU5GTyBmaWVsZCBzcGVjaWZpZWQsIG11c3QgY29udGFpbiBhdCBsZWFzdCBhICcuJyAodHVybiBvZmYgc3RyaWN0IG1vZGUgdG8gYWxsb3cpIik7CiAgICAgIH0KICAgICAgY29uc3QgaW5mbyA9IGZpZWxkc1s3XSA9PT0gdm9pZCAwIHx8IGZpZWxkc1s3XSA9PT0gIi4iID8ge30gOiB0aGlzLl9wYXJzZUtleVZhbHVlKGZpZWxkc1s3XSk7CiAgICAgIE9iamVjdC5rZXlzKGluZm8pLmZvckVhY2goKGtleSkgPT4gewogICAgICAgIGxldCBpdGVtczsKICAgICAgICBpZiAoaW5mb1trZXldKSB7CiAgICAgICAgICBpdGVtcyA9IGluZm9ba2V5XS5zcGxpdCgiLCIpLm1hcCgodmFsKSA9PiB2YWwgPT09ICIuIiA/IG51bGwgOiB2YWwpLm1hcCgoZikgPT4gZiA/IGRlY29kZVVSSUNvbXBvbmVudE5vVGhyb3coZikgOiBmKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaXRlbXMgPSBpbmZvW2tleV07CiAgICAgICAgfQogICAgICAgIGNvbnN0IGl0ZW1UeXBlID0gdGhpcy5nZXRNZXRhZGF0YSgiSU5GTyIsIGtleSwgIlR5cGUiKTsKICAgICAgICBpZiAoaXRlbVR5cGUpIHsKICAgICAgICAgIGlmIChpdGVtVHlwZSA9PT0gIkludGVnZXIiIHx8IGl0ZW1UeXBlID09PSAiRmxvYXQiKSB7CiAgICAgICAgICAgIGl0ZW1zID0gaXRlbXMubWFwKCh2YWwpID0+IHsKICAgICAgICAgICAgICBpZiAodmFsID09PSBudWxsKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWwpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbVR5cGUgPT09ICJGbGFnIikgewogICAgICAgICAgICBpZiAoaW5mb1trZXldKSB7CiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbmZvIGZpZWxkICR7a2V5fSBpcyBhIEZsYWcgYW5kIHNob3VsZCBub3QgaGF2ZSBhIHZhbHVlIChnb3QgdmFsdWUgJHtpbmZvW2tleV19KWApOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGl0ZW1zID0gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpbmZvW2tleV0gPSBpdGVtczsKICAgICAgfSk7CiAgICAgIGNvbnN0IHZhcmlhbnQgPSBuZXcgVmFyaWFudCh7CiAgICAgICAgQ0hST006IGNocm9tLAogICAgICAgIFBPUzogcG9zLAogICAgICAgIEFMVDogYWx0LAogICAgICAgIElORk86IGluZm8sCiAgICAgICAgUkVGOiByZWYsCiAgICAgICAgRklMVEVSOiBmaWx0ZXIgJiYgZmlsdGVyLmxlbmd0aCA9PT0gMSAmJiBmaWx0ZXJbMF0gPT09ICJQQVNTIiA/ICJQQVNTIiA6IGZpbHRlciwKICAgICAgICBJRDogaWQsCiAgICAgICAgUVVBTDogcXVhbAogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhcmlhbnQsICJTQU1QTEVTIiwgewogICAgICAgIGdldCgpIHsKICAgICAgICAgIGNvbnN0IHNhbXBsZXMgPSBwYXJzZXIuX3BhcnNlR2Vub3R5cGVzKGZpZWxkc1s4XSwgcmVzdCk7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgIlNBTVBMRVMiLCB7CiAgICAgICAgICAgIHZhbHVlOiBzYW1wbGVzLAogICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlCiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiBzYW1wbGVzOwogICAgICAgIH0sCiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgIH0pOwogICAgICByZXR1cm4gdmFyaWFudDsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdmNmQDUuMC4xMC9ub2RlX21vZHVsZXMvQGdtb2QvdmNmL2VzbS9pbmRleC5qcwogIHZhciBlc21fZGVmYXVsdCA9IFZDRjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvd29ya2VyLm1qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X3dvcmtlciA9IF9fdG9Nb2R1bGUocmVxdWlyZV93b3JrZXIoKSk7CiAgdmFyIGV4cG9zZSA9IGltcG9ydF93b3JrZXIuZGVmYXVsdC5leHBvc2U7CiAgdmFyIHJlZ2lzdGVyU2VyaWFsaXplciA9IGltcG9ydF93b3JrZXIuZGVmYXVsdC5yZWdpc3RlclNlcmlhbGl6ZXI7CiAgdmFyIFRyYW5zZmVyID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LlRyYW5zZmVyOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9sb2Rhc2guanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAib2JqZWN0IiAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDsKICB2YXIgZnJlZUdsb2JhbF9kZWZhdWx0ID0gZnJlZUdsb2JhbDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMKICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAib2JqZWN0IiAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjsKICB2YXIgcm9vdCA9IGZyZWVHbG9iYWxfZGVmYXVsdCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpOwogIHZhciByb290X2RlZmF1bHQgPSByb290OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzCiAgdmFyIFN5bWJvbDIgPSByb290X2RlZmF1bHQuU3ltYm9sOwogIHZhciBTeW1ib2xfZGVmYXVsdCA9IFN5bWJvbDI7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRSYXdUYWcuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTsKICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTsKICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZzsKICB2YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2xfZGVmYXVsdCA/IFN5bWJvbF9kZWZhdWx0LnRvU3RyaW5nVGFnIDogdm9pZCAwOwogIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkgewogICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLCB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107CiAgICB0cnkgewogICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB2b2lkIDA7CiAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7CiAgICB9IGNhdGNoIChlKSB7CiAgICB9CiAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7CiAgICBpZiAodW5tYXNrZWQpIHsKICAgICAgaWYgKGlzT3duKSB7CiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnOwogICAgICB9IGVsc2UgewogICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBnZXRSYXdUYWdfZGVmYXVsdCA9IGdldFJhd1RhZzsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBvYmplY3RQcm90bzIgPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZzIgPSBvYmplY3RQcm90bzIudG9TdHJpbmc7CiAgZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHsKICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZzIuY2FsbCh2YWx1ZSk7CiAgfQogIHZhciBvYmplY3RUb1N0cmluZ19kZWZhdWx0ID0gb2JqZWN0VG9TdHJpbmc7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzCiAgdmFyIG51bGxUYWcgPSAiW29iamVjdCBOdWxsXSI7CiAgdmFyIHVuZGVmaW5lZFRhZyA9ICJbb2JqZWN0IFVuZGVmaW5lZF0iOwogIHZhciBzeW1Ub1N0cmluZ1RhZzIgPSBTeW1ib2xfZGVmYXVsdCA/IFN5bWJvbF9kZWZhdWx0LnRvU3RyaW5nVGFnIDogdm9pZCAwOwogIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHsKICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZzsKICAgIH0KICAgIHJldHVybiBzeW1Ub1N0cmluZ1RhZzIgJiYgc3ltVG9TdHJpbmdUYWcyIGluIE9iamVjdCh2YWx1ZSkgPyBnZXRSYXdUYWdfZGVmYXVsdCh2YWx1ZSkgOiBvYmplY3RUb1N0cmluZ19kZWZhdWx0KHZhbHVlKTsKICB9CiAgdmFyIGJhc2VHZXRUYWdfZGVmYXVsdCA9IGJhc2VHZXRUYWc7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHsKICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAib2JqZWN0IjsKICB9CiAgdmFyIGlzT2JqZWN0TGlrZV9kZWZhdWx0ID0gaXNPYmplY3RMaWtlOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcwogIHZhciBzeW1ib2xUYWcgPSAiW29iamVjdCBTeW1ib2xdIjsKICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkgewogICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAic3ltYm9sIiB8fCBpc09iamVjdExpa2VfZGVmYXVsdCh2YWx1ZSkgJiYgYmFzZUdldFRhZ19kZWZhdWx0KHZhbHVlKSA9PSBzeW1ib2xUYWc7CiAgfQogIHZhciBpc1N5bWJvbF9kZWZhdWx0ID0gaXNTeW1ib2w7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHsKICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgYXJyYXlNYXBfZGVmYXVsdCA9IGFycmF5TWFwOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTsKICB2YXIgaXNBcnJheV9kZWZhdWx0ID0gaXNBcnJheTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9JbnRlZ2VyLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9OdW1iZXIuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVHJpbS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RyaW1tZWRFbmRJbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgcmVXaGl0ZXNwYWNlID0gL1xzLzsKICBmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7CiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoOwogICAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7CiAgICB9CiAgICByZXR1cm4gaW5kZXg7CiAgfQogIHZhciB0cmltbWVkRW5kSW5kZXhfZGVmYXVsdCA9IHRyaW1tZWRFbmRJbmRleDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUcmltLmpzCiAgdmFyIHJlVHJpbVN0YXJ0ID0gL15ccysvOwogIGZ1bmN0aW9uIGJhc2VUcmltKHN0cmluZykgewogICAgcmV0dXJuIHN0cmluZyA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXhfZGVmYXVsdChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgIiIpIDogc3RyaW5nOwogIH0KICB2YXIgYmFzZVRyaW1fZGVmYXVsdCA9IGJhc2VUcmltOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkgewogICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7CiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAib2JqZWN0IiB8fCB0eXBlID09ICJmdW5jdGlvbiIpOwogIH0KICB2YXIgaXNPYmplY3RfZGVmYXVsdCA9IGlzT2JqZWN0OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcwogIHZhciBOQU4gPSAwIC8gMDsKICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pOwogIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pOwogIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pOwogIHZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDsKICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkgewogICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAibnVtYmVyIikgewogICAgICByZXR1cm4gdmFsdWU7CiAgICB9CiAgICBpZiAoaXNTeW1ib2xfZGVmYXVsdCh2YWx1ZSkpIHsKICAgICAgcmV0dXJuIE5BTjsKICAgIH0KICAgIGlmIChpc09iamVjdF9kZWZhdWx0KHZhbHVlKSkgewogICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAiZnVuY3Rpb24iID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7CiAgICAgIHZhbHVlID0gaXNPYmplY3RfZGVmYXVsdChvdGhlcikgPyBvdGhlciArICIiIDogb3RoZXI7CiAgICB9CiAgICBpZiAodHlwZW9mIHZhbHVlICE9ICJzdHJpbmciKSB7CiAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlOwogICAgfQogICAgdmFsdWUgPSBiYXNlVHJpbV9kZWZhdWx0KHZhbHVlKTsKICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7CiAgICByZXR1cm4gaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KSA6IHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWU7CiAgfQogIHZhciB0b051bWJlcl9kZWZhdWx0ID0gdG9OdW1iZXI7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvRmluaXRlLmpzCiAgdmFyIElORklOSVRZID0gMSAvIDA7CiAgdmFyIE1BWF9JTlRFR0VSID0gMTc5NzY5MzEzNDg2MjMxNTdlMjkyOwogIGZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7CiAgICBpZiAoIXZhbHVlKSB7CiAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDsKICAgIH0KICAgIHZhbHVlID0gdG9OdW1iZXJfZGVmYXVsdCh2YWx1ZSk7CiAgICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHsKICAgICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyAtMSA6IDE7CiAgICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7CiAgICB9CiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwOwogIH0KICB2YXIgdG9GaW5pdGVfZGVmYXVsdCA9IHRvRmluaXRlOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0ludGVnZXIuanMKICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHsKICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZV9kZWZhdWx0KHZhbHVlKSwgcmVtYWluZGVyID0gcmVzdWx0ICUgMTsKICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCA6IDA7CiAgfQogIHZhciB0b0ludGVnZXJfZGVmYXVsdCA9IHRvSW50ZWdlcjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgYXN5bmNUYWcgPSAiW29iamVjdCBBc3luY0Z1bmN0aW9uXSI7CiAgdmFyIGZ1bmNUYWcgPSAiW29iamVjdCBGdW5jdGlvbl0iOwogIHZhciBnZW5UYWcgPSAiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0iOwogIHZhciBwcm94eVRhZyA9ICJbb2JqZWN0IFByb3h5XSI7CiAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkgewogICAgaWYgKCFpc09iamVjdF9kZWZhdWx0KHZhbHVlKSkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICB2YXIgdGFnID0gYmFzZUdldFRhZ19kZWZhdWx0KHZhbHVlKTsKICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7CiAgfQogIHZhciBpc0Z1bmN0aW9uX2RlZmF1bHQgPSBpc0Z1bmN0aW9uOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weUFycmF5LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7CiAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aDsKICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpOwogICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHsKICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTsKICAgIH0KICAgIHJldHVybiBhcnJheTsKICB9CiAgdmFyIGNvcHlBcnJheV9kZWZhdWx0ID0gY29weUFycmF5OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7CiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXGQqKSQvOwogIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkgewogICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7CiAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7CiAgICByZXR1cm4gISFsZW5ndGggJiYgKHR5cGUgPT0gIm51bWJlciIgfHwgdHlwZSAhPSAic3ltYm9sIiAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkgJiYgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpOwogIH0KICB2YXIgaXNJbmRleF9kZWZhdWx0ID0gaXNJbmRleDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7CiAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8IHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7CiAgfQogIHZhciBlcV9kZWZhdWx0ID0gZXE7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0l0ZXJhdGVlQ2FsbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBNQVhfU0FGRV9JTlRFR0VSMiA9IDkwMDcxOTkyNTQ3NDA5OTE7CiAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHsKICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gIm51bWJlciIgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSMjsKICB9CiAgdmFyIGlzTGVuZ3RoX2RlZmF1bHQgPSBpc0xlbmd0aDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanMKICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkgewogICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGhfZGVmYXVsdCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uX2RlZmF1bHQodmFsdWUpOwogIH0KICB2YXIgaXNBcnJheUxpa2VfZGVmYXVsdCA9IGlzQXJyYXlMaWtlOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMKICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkgewogICAgaWYgKCFpc09iamVjdF9kZWZhdWx0KG9iamVjdCkpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7CiAgICBpZiAodHlwZSA9PSAibnVtYmVyIiA/IGlzQXJyYXlMaWtlX2RlZmF1bHQob2JqZWN0KSAmJiBpc0luZGV4X2RlZmF1bHQoaW5kZXgsIG9iamVjdC5sZW5ndGgpIDogdHlwZSA9PSAic3RyaW5nIiAmJiBpbmRleCBpbiBvYmplY3QpIHsKICAgICAgcmV0dXJuIGVxX2RlZmF1bHQob2JqZWN0W2luZGV4XSwgdmFsdWUpOwogICAgfQogICAgcmV0dXJuIGZhbHNlOwogIH0KICB2YXIgaXNJdGVyYXRlZUNhbGxfZGVmYXVsdCA9IGlzSXRlcmF0ZWVDYWxsOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIG9iamVjdFByb3RvMyA9IE9iamVjdC5wcm90b3R5cGU7CiAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHsKICAgIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsIHByb3RvID0gdHlwZW9mIEN0b3IgPT0gImZ1bmN0aW9uIiAmJiBDdG9yLnByb3RvdHlwZSB8fCBvYmplY3RQcm90bzM7CiAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvOwogIH0KICB2YXIgaXNQcm90b3R5cGVfZGVmYXVsdCA9IGlzUHJvdG90eXBlOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHsKICAgIHZhciBpbmRleCA9IC0xLCByZXN1bHQgPSBBcnJheShuKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbikgewogICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGJhc2VUaW1lc19kZWZhdWx0ID0gYmFzZVRpbWVzOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FyZ3VtZW50cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgYXJnc1RhZyA9ICJbb2JqZWN0IEFyZ3VtZW50c10iOwogIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkgewogICAgcmV0dXJuIGlzT2JqZWN0TGlrZV9kZWZhdWx0KHZhbHVlKSAmJiBiYXNlR2V0VGFnX2RlZmF1bHQodmFsdWUpID09IGFyZ3NUYWc7CiAgfQogIHZhciBiYXNlSXNBcmd1bWVudHNfZGVmYXVsdCA9IGJhc2VJc0FyZ3VtZW50czsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMKICB2YXIgb2JqZWN0UHJvdG80ID0gT2JqZWN0LnByb3RvdHlwZTsKICB2YXIgaGFzT3duUHJvcGVydHkyID0gb2JqZWN0UHJvdG80Lmhhc093blByb3BlcnR5OwogIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvNC5wcm9wZXJ0eUlzRW51bWVyYWJsZTsKICB2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHNfZGVmYXVsdChmdW5jdGlvbigpIHsKICAgIHJldHVybiBhcmd1bWVudHM7CiAgfSgpKSA/IGJhc2VJc0FyZ3VtZW50c19kZWZhdWx0IDogZnVuY3Rpb24odmFsdWUpIHsKICAgIHJldHVybiBpc09iamVjdExpa2VfZGVmYXVsdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkyLmNhbGwodmFsdWUsICJjYWxsZWUiKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgImNhbGxlZSIpOwogIH07CiAgdmFyIGlzQXJndW1lbnRzX2RlZmF1bHQgPSBpc0FyZ3VtZW50czsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIHZhciBzdHViRmFsc2VfZGVmYXVsdCA9IHN0dWJGYWxzZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMKICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAib2JqZWN0IiAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7CiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICJvYmplY3QiICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTsKICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0czsKICB2YXIgQnVmZmVyOSA9IG1vZHVsZUV4cG9ydHMgPyByb290X2RlZmF1bHQuQnVmZmVyIDogdm9pZCAwOwogIHZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlcjkgPyBCdWZmZXI5LmlzQnVmZmVyIDogdm9pZCAwOwogIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZV9kZWZhdWx0OwogIHZhciBpc0J1ZmZlcl9kZWZhdWx0ID0gaXNCdWZmZXI7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1R5cGVkQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGFyZ3NUYWcyID0gIltvYmplY3QgQXJndW1lbnRzXSI7CiAgdmFyIGFycmF5VGFnID0gIltvYmplY3QgQXJyYXldIjsKICB2YXIgYm9vbFRhZyA9ICJbb2JqZWN0IEJvb2xlYW5dIjsKICB2YXIgZGF0ZVRhZyA9ICJbb2JqZWN0IERhdGVdIjsKICB2YXIgZXJyb3JUYWcgPSAiW29iamVjdCBFcnJvcl0iOwogIHZhciBmdW5jVGFnMiA9ICJbb2JqZWN0IEZ1bmN0aW9uXSI7CiAgdmFyIG1hcFRhZyA9ICJbb2JqZWN0IE1hcF0iOwogIHZhciBudW1iZXJUYWcgPSAiW29iamVjdCBOdW1iZXJdIjsKICB2YXIgb2JqZWN0VGFnID0gIltvYmplY3QgT2JqZWN0XSI7CiAgdmFyIHJlZ2V4cFRhZyA9ICJbb2JqZWN0IFJlZ0V4cF0iOwogIHZhciBzZXRUYWcgPSAiW29iamVjdCBTZXRdIjsKICB2YXIgc3RyaW5nVGFnID0gIltvYmplY3QgU3RyaW5nXSI7CiAgdmFyIHdlYWtNYXBUYWcgPSAiW29iamVjdCBXZWFrTWFwXSI7CiAgdmFyIGFycmF5QnVmZmVyVGFnID0gIltvYmplY3QgQXJyYXlCdWZmZXJdIjsKICB2YXIgZGF0YVZpZXdUYWcgPSAiW29iamVjdCBEYXRhVmlld10iOwogIHZhciBmbG9hdDMyVGFnID0gIltvYmplY3QgRmxvYXQzMkFycmF5XSI7CiAgdmFyIGZsb2F0NjRUYWcgPSAiW29iamVjdCBGbG9hdDY0QXJyYXldIjsKICB2YXIgaW50OFRhZyA9ICJbb2JqZWN0IEludDhBcnJheV0iOwogIHZhciBpbnQxNlRhZyA9ICJbb2JqZWN0IEludDE2QXJyYXldIjsKICB2YXIgaW50MzJUYWcgPSAiW29iamVjdCBJbnQzMkFycmF5XSI7CiAgdmFyIHVpbnQ4VGFnID0gIltvYmplY3QgVWludDhBcnJheV0iOwogIHZhciB1aW50OENsYW1wZWRUYWcgPSAiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0iOwogIHZhciB1aW50MTZUYWcgPSAiW29iamVjdCBVaW50MTZBcnJheV0iOwogIHZhciB1aW50MzJUYWcgPSAiW29iamVjdCBVaW50MzJBcnJheV0iOwogIHZhciB0eXBlZEFycmF5VGFncyA9IHt9OwogIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7CiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZzJdID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWcyXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7CiAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkgewogICAgcmV0dXJuIGlzT2JqZWN0TGlrZV9kZWZhdWx0KHZhbHVlKSAmJiBpc0xlbmd0aF9kZWZhdWx0KHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnX2RlZmF1bHQodmFsdWUpXTsKICB9CiAgdmFyIGJhc2VJc1R5cGVkQXJyYXlfZGVmYXVsdCA9IGJhc2VJc1R5cGVkQXJyYXk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5hcnkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHsKICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkgewogICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7CiAgICB9OwogIH0KICB2YXIgYmFzZVVuYXJ5X2RlZmF1bHQgPSBiYXNlVW5hcnk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19ub2RlVXRpbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgZnJlZUV4cG9ydHMyID0gdHlwZW9mIGV4cG9ydHMgPT0gIm9iamVjdCIgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzOwogIHZhciBmcmVlTW9kdWxlMiA9IGZyZWVFeHBvcnRzMiAmJiB0eXBlb2YgbW9kdWxlID09ICJvYmplY3QiICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTsKICB2YXIgbW9kdWxlRXhwb3J0czIgPSBmcmVlTW9kdWxlMiAmJiBmcmVlTW9kdWxlMi5leHBvcnRzID09PSBmcmVlRXhwb3J0czI7CiAgdmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0czIgJiYgZnJlZUdsb2JhbF9kZWZhdWx0LnByb2Nlc3M7CiAgdmFyIG5vZGVVdGlsID0gZnVuY3Rpb24oKSB7CiAgICB0cnkgewogICAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlMiAmJiBmcmVlTW9kdWxlMi5yZXF1aXJlICYmIGZyZWVNb2R1bGUyLnJlcXVpcmUoInV0aWwiKS50eXBlczsKICAgICAgaWYgKHR5cGVzKSB7CiAgICAgICAgcmV0dXJuIHR5cGVzOwogICAgICB9CiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoInV0aWwiKTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgIH0KICB9KCk7CiAgdmFyIG5vZGVVdGlsX2RlZmF1bHQgPSBub2RlVXRpbDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNUeXBlZEFycmF5LmpzCiAgdmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbF9kZWZhdWx0ICYmIG5vZGVVdGlsX2RlZmF1bHQuaXNUeXBlZEFycmF5OwogIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5X2RlZmF1bHQobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5X2RlZmF1bHQ7CiAgdmFyIGlzVHlwZWRBcnJheV9kZWZhdWx0ID0gaXNUeXBlZEFycmF5OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcwogIHZhciBvYmplY3RQcm90bzUgPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eTMgPSBvYmplY3RQcm90bzUuaGFzT3duUHJvcGVydHk7CiAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7CiAgICB2YXIgaXNBcnIgPSBpc0FycmF5X2RlZmF1bHQodmFsdWUpLCBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50c19kZWZhdWx0KHZhbHVlKSwgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcl9kZWZhdWx0KHZhbHVlKSwgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheV9kZWZhdWx0KHZhbHVlKSwgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLCByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lc19kZWZhdWx0KHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLCBsZW5ndGggPSByZXN1bHQubGVuZ3RoOwogICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7CiAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5My5jYWxsKHZhbHVlLCBrZXkpKSAmJiAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gImxlbmd0aCIgfHwgaXNCdWZmICYmIChrZXkgPT0gIm9mZnNldCIgfHwga2V5ID09ICJwYXJlbnQiKSB8fCBpc1R5cGUgJiYgKGtleSA9PSAiYnVmZmVyIiB8fCBrZXkgPT0gImJ5dGVMZW5ndGgiIHx8IGtleSA9PSAiYnl0ZU9mZnNldCIpIHx8IGlzSW5kZXhfZGVmYXVsdChrZXksIGxlbmd0aCkpKSkgewogICAgICAgIHJlc3VsdC5wdXNoKGtleSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBhcnJheUxpa2VLZXlzX2RlZmF1bHQgPSBhcnJheUxpa2VLZXlzOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkgewogICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykgewogICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7CiAgICB9OwogIH0KICB2YXIgb3ZlckFyZ19kZWZhdWx0ID0gb3ZlckFyZzsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMKICB2YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmdfZGVmYXVsdChPYmplY3Qua2V5cywgT2JqZWN0KTsKICB2YXIgbmF0aXZlS2V5c19kZWZhdWx0ID0gbmF0aXZlS2V5czsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzCiAgdmFyIG9iamVjdFByb3RvNiA9IE9iamVjdC5wcm90b3R5cGU7CiAgdmFyIGhhc093blByb3BlcnR5NCA9IG9iamVjdFByb3RvNi5oYXNPd25Qcm9wZXJ0eTsKICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHsKICAgIGlmICghaXNQcm90b3R5cGVfZGVmYXVsdChvYmplY3QpKSB7CiAgICAgIHJldHVybiBuYXRpdmVLZXlzX2RlZmF1bHQob2JqZWN0KTsKICAgIH0KICAgIHZhciByZXN1bHQgPSBbXTsKICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkgewogICAgICBpZiAoaGFzT3duUHJvcGVydHk0LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAiY29uc3RydWN0b3IiKSB7CiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGJhc2VLZXlzX2RlZmF1bHQgPSBiYXNlS2V5czsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcwogIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7CiAgICByZXR1cm4gaXNBcnJheUxpa2VfZGVmYXVsdChvYmplY3QpID8gYXJyYXlMaWtlS2V5c19kZWZhdWx0KG9iamVjdCkgOiBiYXNlS2V5c19kZWZhdWx0KG9iamVjdCk7CiAgfQogIHZhciBrZXlzX2RlZmF1bHQgPSBrZXlzOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUNsYW1wLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikgewogICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7CiAgICAgIGlmICh1cHBlciAhPT0gdm9pZCAwKSB7CiAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7CiAgICAgIH0KICAgICAgaWYgKGxvd2VyICE9PSB2b2lkIDApIHsKICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjsKICAgICAgfQogICAgfQogICAgcmV0dXJuIG51bWJlcjsKICB9CiAgdmFyIGJhc2VDbGFtcF9kZWZhdWx0ID0gYmFzZUNsYW1wOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVmFsdWVzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykgewogICAgcmV0dXJuIGFycmF5TWFwX2RlZmF1bHQocHJvcHMsIGZ1bmN0aW9uKGtleSkgewogICAgICByZXR1cm4gb2JqZWN0W2tleV07CiAgICB9KTsKICB9CiAgdmFyIGJhc2VWYWx1ZXNfZGVmYXVsdCA9IGJhc2VWYWx1ZXM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3ZhbHVlcy5qcwogIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHsKICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlc19kZWZhdWx0KG9iamVjdCwga2V5c19kZWZhdWx0KG9iamVjdCkpOwogIH0KICB2YXIgdmFsdWVzX2RlZmF1bHQgPSB2YWx1ZXM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmFuZG9tLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3I7CiAgdmFyIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tOwogIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7CiAgICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpOwogIH0KICB2YXIgYmFzZVJhbmRvbV9kZWZhdWx0ID0gYmFzZVJhbmRvbTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc2FtcGxlU2l6ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U2FtcGxlU2l6ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NodWZmbGVTZWxmLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7CiAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBsYXN0SW5kZXggPSBsZW5ndGggLSAxOwogICAgc2l6ZSA9IHNpemUgPT09IHZvaWQgMCA/IGxlbmd0aCA6IHNpemU7CiAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHsKICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tX2RlZmF1bHQoaW5kZXgsIGxhc3RJbmRleCksIHZhbHVlID0gYXJyYXlbcmFuZF07CiAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdOwogICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTsKICAgIH0KICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7CiAgICByZXR1cm4gYXJyYXk7CiAgfQogIHZhciBzaHVmZmxlU2VsZl9kZWZhdWx0ID0gc2h1ZmZsZVNlbGY7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNhbXBsZVNpemUuanMKICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHsKICAgIHJldHVybiBzaHVmZmxlU2VsZl9kZWZhdWx0KGNvcHlBcnJheV9kZWZhdWx0KGFycmF5KSwgYmFzZUNsYW1wX2RlZmF1bHQobiwgMCwgYXJyYXkubGVuZ3RoKSk7CiAgfQogIHZhciBhcnJheVNhbXBsZVNpemVfZGVmYXVsdCA9IGFycmF5U2FtcGxlU2l6ZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTYW1wbGVTaXplLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJhc2VTYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4pIHsKICAgIHZhciBhcnJheSA9IHZhbHVlc19kZWZhdWx0KGNvbGxlY3Rpb24pOwogICAgcmV0dXJuIHNodWZmbGVTZWxmX2RlZmF1bHQoYXJyYXksIGJhc2VDbGFtcF9kZWZhdWx0KG4sIDAsIGFycmF5Lmxlbmd0aCkpOwogIH0KICB2YXIgYmFzZVNhbXBsZVNpemVfZGVmYXVsdCA9IGJhc2VTYW1wbGVTaXplOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zYW1wbGVTaXplLmpzCiAgZnVuY3Rpb24gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuLCBndWFyZCkgewogICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGxfZGVmYXVsdChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB2b2lkIDApIHsKICAgICAgbiA9IDE7CiAgICB9IGVsc2UgewogICAgICBuID0gdG9JbnRlZ2VyX2RlZmF1bHQobik7CiAgICB9CiAgICB2YXIgZnVuYyA9IGlzQXJyYXlfZGVmYXVsdChjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZV9kZWZhdWx0IDogYmFzZVNhbXBsZVNpemVfZGVmYXVsdDsKICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pOwogIH0KICB2YXIgc2FtcGxlU2l6ZV9kZWZhdWx0ID0gc2FtcGxlU2l6ZTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdXRpbHMudHMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9kMy1hcnJheUAyLjEyLjEvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2QzLWFycmF5QDIuMTIuMS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBhc2NlbmRpbmdfZGVmYXVsdChhLCBiKSB7CiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vZDMtYXJyYXlAMi4xMi4xL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0b3IuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmlzZWN0b3JfZGVmYXVsdChmKSB7CiAgICBsZXQgZGVsdGEgPSBmOwogICAgbGV0IGNvbXBhcmUgPSBmOwogICAgaWYgKGYubGVuZ3RoID09PSAxKSB7CiAgICAgIGRlbHRhID0gKGQsIHgpID0+IGYoZCkgLSB4OwogICAgICBjb21wYXJlID0gYXNjZW5kaW5nQ29tcGFyYXRvcihmKTsKICAgIH0KICAgIGZ1bmN0aW9uIGxlZnQoYSwgeCwgbG8sIGhpKSB7CiAgICAgIGlmIChsbyA9PSBudWxsKQogICAgICAgIGxvID0gMDsKICAgICAgaWYgKGhpID09IG51bGwpCiAgICAgICAgaGkgPSBhLmxlbmd0aDsKICAgICAgd2hpbGUgKGxvIDwgaGkpIHsKICAgICAgICBjb25zdCBtaWQgPSBsbyArIGhpID4+PiAxOwogICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKQogICAgICAgICAgbG8gPSBtaWQgKyAxOwogICAgICAgIGVsc2UKICAgICAgICAgIGhpID0gbWlkOwogICAgICB9CiAgICAgIHJldHVybiBsbzsKICAgIH0KICAgIGZ1bmN0aW9uIHJpZ2h0KGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIHdoaWxlIChsbyA8IGhpKSB7CiAgICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTsKICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkKICAgICAgICAgIGhpID0gbWlkOwogICAgICAgIGVsc2UKICAgICAgICAgIGxvID0gbWlkICsgMTsKICAgICAgfQogICAgICByZXR1cm4gbG87CiAgICB9CiAgICBmdW5jdGlvbiBjZW50ZXIoYSwgeCwgbG8sIGhpKSB7CiAgICAgIGlmIChsbyA9PSBudWxsKQogICAgICAgIGxvID0gMDsKICAgICAgaWYgKGhpID09IG51bGwpCiAgICAgICAgaGkgPSBhLmxlbmd0aDsKICAgICAgY29uc3QgaSA9IGxlZnQoYSwgeCwgbG8sIGhpIC0gMSk7CiAgICAgIHJldHVybiBpID4gbG8gJiYgZGVsdGEoYVtpIC0gMV0sIHgpID4gLWRlbHRhKGFbaV0sIHgpID8gaSAtIDEgOiBpOwogICAgfQogICAgcmV0dXJuIHsgbGVmdCwgY2VudGVyLCByaWdodCB9OwogIH0KICBmdW5jdGlvbiBhc2NlbmRpbmdDb21wYXJhdG9yKGYpIHsKICAgIHJldHVybiAoZCwgeCkgPT4gYXNjZW5kaW5nX2RlZmF1bHQoZihkKSwgeCk7CiAgfQoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy91dGlscy50cwogIHZhciBEYXRhU291cmNlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoZmlsZSwgY2hyb21TaXplcywgb3B0aW9ucykgewogICAgICB0aGlzLmZpbGUgPSBmaWxlOwogICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOwogICAgICB0aGlzLmNocm9tSW5mbyA9IHNpemVzVG9DaHJvbUluZm8oY2hyb21TaXplcyk7CiAgICAgIHRoaXMudGlsZXNldEluZm8gPSB0aWxlc2V0SW5mb0Zyb21DaHJvbUluZm8odGhpcy5jaHJvbUluZm8pOwogICAgfQogICAgY2hyb21JbmZvOwogICAgdGlsZXNldEluZm87CiAgfTsKICB2YXIgY2hyb21JbmZvQmlzZWN0b3IgPSBiaXNlY3Rvcl9kZWZhdWx0KChkKSA9PiBkLnBvcykubGVmdDsKICB2YXIgY2hyVG9BYnMgPSAoY2hyb20sIGNocm9tUG9zLCBjaHJvbUluZm8pID0+IGNocm9tSW5mby5jaHJQb3NpdGlvbnNbY2hyb21dLnBvcyArIGNocm9tUG9zOwogIHZhciBhYnNUb0NociA9IChhYnNQb3NpdGlvbiwgY2hyb21JbmZvKSA9PiB7CiAgICBpZiAoIWNocm9tSW5mbyB8fCAhY2hyb21JbmZvLmN1bVBvc2l0aW9ucyB8fCAhY2hyb21JbmZvLmN1bVBvc2l0aW9ucy5sZW5ndGgpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICBsZXQgaW5zZXJ0UG9pbnQgPSBjaHJvbUluZm9CaXNlY3RvcihjaHJvbUluZm8uY3VtUG9zaXRpb25zLCBhYnNQb3NpdGlvbik7CiAgICBjb25zdCBsYXN0Q2hyID0gY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tjaHJvbUluZm8uY3VtUG9zaXRpb25zLmxlbmd0aCAtIDFdLmNocjsKICAgIGNvbnN0IGxhc3RMZW5ndGggPSBjaHJvbUluZm8uY2hyb21MZW5ndGhzW2xhc3RDaHJdOwogICAgaW5zZXJ0UG9pbnQgLT0gaW5zZXJ0UG9pbnQgPiAwICYmIDE7CiAgICBsZXQgY2hyUG9zaXRpb24gPSBNYXRoLmZsb29yKGFic1Bvc2l0aW9uIC0gY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tpbnNlcnRQb2ludF0ucG9zKTsKICAgIGxldCBvZmZzZXQgPSAwOwogICAgaWYgKGNoclBvc2l0aW9uIDwgMCkgewogICAgICBvZmZzZXQgPSBjaHJQb3NpdGlvbiAtIDE7CiAgICAgIGNoclBvc2l0aW9uID0gMTsKICAgIH0KICAgIGlmIChpbnNlcnRQb2ludCA9PT0gY2hyb21JbmZvLmN1bVBvc2l0aW9ucy5sZW5ndGggLSAxICYmIGNoclBvc2l0aW9uID4gbGFzdExlbmd0aCkgewogICAgICBvZmZzZXQgPSBjaHJQb3NpdGlvbiAtIGxhc3RMZW5ndGg7CiAgICAgIGNoclBvc2l0aW9uID0gbGFzdExlbmd0aDsKICAgIH0KICAgIHJldHVybiBbY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tpbnNlcnRQb2ludF0uY2hyLCBjaHJQb3NpdGlvbiwgb2Zmc2V0LCBpbnNlcnRQb2ludF07CiAgfTsKICBmdW5jdGlvbiB0aWxlc2V0SW5mb0Zyb21DaHJvbUluZm8oY2hyb21JbmZvLCB0aWxlU2l6ZSA9IDEwMjQpIHsKICAgIHJldHVybiB7CiAgICAgIHRpbGVfc2l6ZTogdGlsZVNpemUsCiAgICAgIGJpbnNfcGVyX2RpbWVuc2lvbjogdGlsZVNpemUsCiAgICAgIG1heF96b29tOiBNYXRoLmNlaWwoTWF0aC5sb2coY2hyb21JbmZvLnRvdGFsTGVuZ3RoIC8gdGlsZVNpemUpIC8gTWF0aC5sb2coMikpLAogICAgICBtYXhfd2lkdGg6IGNocm9tSW5mby50b3RhbExlbmd0aCwKICAgICAgbWluX3BvczogWzBdLAogICAgICBtYXhfcG9zOiBbY2hyb21JbmZvLnRvdGFsTGVuZ3RoXQogICAgfTsKICB9CiAgZnVuY3Rpb24gc2l6ZXNUb0Nocm9tSW5mbyhzaXplcykgewogICAgY29uc3QgaW5mbyA9IHsKICAgICAgY3VtUG9zaXRpb25zOiBbXSwKICAgICAgY2hyb21MZW5ndGhzOiB7fSwKICAgICAgY2hyUG9zaXRpb25zOiB7fSwKICAgICAgdG90YWxMZW5ndGg6IDAKICAgIH07CiAgICBzaXplcy5mb3JFYWNoKChbY2hyLCBsZW5ndGhdLCBpKSA9PiB7CiAgICAgIGNvbnN0IGNoclBvc2l0aW9uID0geyBpZDogaSwgY2hyLCBwb3M6IGluZm8udG90YWxMZW5ndGggfTsKICAgICAgaW5mby5jaHJQb3NpdGlvbnNbY2hyXSA9IGNoclBvc2l0aW9uOwogICAgICBpbmZvLmNocm9tTGVuZ3Roc1tjaHJdID0gbGVuZ3RoOwogICAgICBpbmZvLmN1bVBvc2l0aW9ucy5wdXNoKGNoclBvc2l0aW9uKTsKICAgICAgaW5mby50b3RhbExlbmd0aCArPSBsZW5ndGg7CiAgICB9KTsKICAgIHJldHVybiB7CiAgICAgIC4uLmluZm8sCiAgICAgIGFic1RvQ2hyOiAoYWJzUG9zKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGFic1RvQ2hyKGFic1BvcywgaW5mbykgOiBudWxsLAogICAgICBjaHJUb0FiczogKFtjaHJOYW1lLCBjaHJQb3NdKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGNoclRvQWJzKGNock5hbWUsIGNoclBvcywgaW5mbykgOiBudWxsCiAgICB9OwogIH0KICB2YXIgUmVtb3RlRmlsZTIgPSBjbGFzcyBleHRlbmRzIFJlbW90ZUZpbGUgewogICAgcmVhZCA9IGFzeW5jIChidWZmZXIsIG9mZnNldCA9IDAsIGxlbmd0aCwgcG9zaXRpb24gPSAwLCBvcHRzID0ge30pID0+IHsKICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgIGlmIChsZW5ndGggPCBJbmZpbml0eSkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tJHtwb3NpdGlvbiArIGxlbmd0aH1gOwogICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gSW5maW5pdHkgJiYgcG9zaXRpb24gIT09IDApIHsKICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LWA7CiAgICAgIH0KICAgICAgY29uc3QgYXJncyA9IHsKICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsCiAgICAgICAgLi4ub3ZlcnJpZGVzLAogICAgICAgIGhlYWRlcnM6IHsKICAgICAgICAgIC4uLmhlYWRlcnMsCiAgICAgICAgICAuLi5vdmVycmlkZXMuaGVhZGVycywKICAgICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcy5oZWFkZXJzCiAgICAgICAgfSwKICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgIHJlZGlyZWN0OiAiZm9sbG93IiwKICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgc2lnbmFsCiAgICAgIH07CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncyk7CiAgICAgIGlmICghcmVzcG9uc2Uub2spIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gJHt0aGlzLnVybH1gKTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHsKICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICAgICAgY29uc3QgYnl0ZXNDb3BpZWQgPSByZXNwb25zZURhdGEuY29weShidWZmZXIsIG9mZnNldCwgMCwgTWF0aC5taW4obGVuZ3RoLCByZXNwb25zZURhdGEubGVuZ3RoKSk7CiAgICAgICAgY29uc3QgcmVzID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoImNvbnRlbnQtcmFuZ2UiKTsKICAgICAgICBjb25zdCBzaXplTWF0Y2ggPSAvXC8oXGQrKSQvLmV4ZWMocmVzIHx8ICIiKTsKICAgICAgICBpZiAoc2l6ZU1hdGNoICYmIHNpemVNYXRjaFsxXSkgewogICAgICAgICAgdGhpcy5fc3RhdCA9IHsgc2l6ZTogcGFyc2VJbnQoc2l6ZU1hdGNoWzFdLCAxMCkgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYnl0ZXNSZWFkOiBieXRlc0NvcGllZCwgYnVmZmVyIH07CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSBmZXRjaGluZyAke3RoaXMudXJsfWApOwogICAgfTsKICB9OwoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy92Y2YvdXRpbHMudHMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGdldE11dGF0aW9uVHlwZSA9IChyZWYsIGFsdCkgPT4gewogICAgaWYgKCFhbHQpCiAgICAgIHJldHVybiAidW5rbm93biI7CiAgICBpZiAocmVmLmxlbmd0aCA9PT0gYWx0Lmxlbmd0aCkKICAgICAgcmV0dXJuICJzdWJzdGl0dXRpb24iOwogICAgaWYgKHJlZi5sZW5ndGggPiBhbHQubGVuZ3RoKQogICAgICByZXR1cm4gImRlbGV0aW9uIjsKICAgIGlmIChyZWYubGVuZ3RoIDwgYWx0Lmxlbmd0aCkKICAgICAgcmV0dXJuICJpbnNlcnRpb24iOwogICAgcmV0dXJuICJ1bmtub3duIjsKICB9OwogIHZhciBnZXRTdWJzdGl0dXRpb25UeXBlID0gKHJlZiwgYWx0KSA9PiB7CiAgICBzd2l0Y2ggKHJlZiArIGFsdCkgewogICAgICBjYXNlICJDQSI6CiAgICAgIGNhc2UgIkdUIjoKICAgICAgICByZXR1cm4gIkM+QSI7CiAgICAgIGNhc2UgIkNHIjoKICAgICAgY2FzZSAiR0MiOgogICAgICAgIHJldHVybiAiQz5HIjsKICAgICAgY2FzZSAiQ1QiOgogICAgICBjYXNlICJHQSI6CiAgICAgICAgcmV0dXJuICJDPlQiOwogICAgICBjYXNlICJUQSI6CiAgICAgIGNhc2UgIkFUIjoKICAgICAgICByZXR1cm4gIlQ+QSI7CiAgICAgIGNhc2UgIlRDIjoKICAgICAgY2FzZSAiQUciOgogICAgICAgIHJldHVybiAiVD5DIjsKICAgICAgY2FzZSAiVEciOgogICAgICBjYXNlICJBQyI6CiAgICAgICAgcmV0dXJuICJUPkciOwogICAgICBkZWZhdWx0OgogICAgICAgIHJldHVybiAidW5rbm93biI7CiAgICB9CiAgfTsKICBmdW5jdGlvbiByZWNvcmRUb1RpbGUodmNmUmVjb3JkLCBjaHJQb3MsIHByZXZBYnNQb3MpIHsKICAgIGNvbnN0IGFic1BvcyA9IGNoclBvcyArIHZjZlJlY29yZC5QT1MgKyAxOwogICAgbGV0IEFMVDsKICAgIGlmIChBcnJheS5pc0FycmF5KHZjZlJlY29yZC5BTFQpICYmIHZjZlJlY29yZC5BTFQubGVuZ3RoID4gMCkgewogICAgICBBTFQgPSB2Y2ZSZWNvcmQuQUxUWzBdOwogICAgfQogICAgY29uc3QgRElTVFBSRVYgPSAhcHJldkFic1BvcyA/IG51bGwgOiBhYnNQb3MgLSBwcmV2QWJzUG9zOwogICAgY29uc3QgRElTVFBSRVZMT0dFID0gIXByZXZBYnNQb3MgPyBudWxsIDogTWF0aC5sb2coYWJzUG9zIC0gcHJldkFic1Bvcyk7CiAgICBjb25zdCBNVVRUWVBFID0gZ2V0TXV0YXRpb25UeXBlKHZjZlJlY29yZC5SRUYsIEFMVCk7CiAgICBjb25zdCBTVUJUWVBFID0gZ2V0U3Vic3RpdHV0aW9uVHlwZSh2Y2ZSZWNvcmQuUkVGLCBBTFQpOwogICAgY29uc3QgUE9TRU5EID0gYWJzUG9zICsgdmNmUmVjb3JkLlJFRi5sZW5ndGg7CiAgICBjb25zdCBkYXRhID0gewogICAgICAuLi52Y2ZSZWNvcmQsCiAgICAgIEFMVCwKICAgICAgTVVUVFlQRSwKICAgICAgU1VCVFlQRSwKICAgICAgSU5GTzogSlNPTi5zdHJpbmdpZnkodmNmUmVjb3JkLklORk8pLAogICAgICBPUklHSU5BTFBPUzogdmNmUmVjb3JkLlBPUywKICAgICAgUE9TOiBhYnNQb3MsCiAgICAgIFBPU0VORCwKICAgICAgRElTVFBSRVYsCiAgICAgIERJU1RQUkVWTE9HRQogICAgfTsKICAgIE9iamVjdC5rZXlzKHZjZlJlY29yZC5JTkZPKS5mb3JFYWNoKChrZXkpID0+IHsKICAgICAgY29uc3QgdmFsID0gdmNmUmVjb3JkLklORk9ba2V5XTsKICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgewogICAgICAgIGRhdGFba2V5XSA9IHZhbC5qb2luKCIsICIpOwogICAgICB9IGVsc2UgewogICAgICAgIGRhdGFba2V5XSA9IHZhbDsKICAgICAgfQogICAgfSk7CiAgICByZXR1cm4gZGF0YTsKICB9CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL3ZjZi92Y2Ytd29ya2VyLnRzP3dvcmtlciZpbmxpbmU/d29ya2VyX2ZpbGUKICB2YXIgdmNmRmlsZXMgPSBuZXcgTWFwKCk7CiAgdmFyIFZjZkZpbGUgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3Rvcih0YmksIHVpZCkgewogICAgICB0aGlzLnRiaSA9IHRiaTsKICAgICAgdGhpcy4jdWlkID0gdWlkOwogICAgfQogICAgI3BhcnNlcjsKICAgICN1aWQ7CiAgICBzdGF0aWMgZnJvbVVybCh1cmwsIGluZGV4VXJsLCB1aWQsIHVybEZldGNoT3B0aW9ucywgaW5kZXhVcmxGZXRjaE9wdGlvbnMpIHsKICAgICAgY29uc3QgdGJpID0gbmV3IFRhYml4SW5kZXhlZEZpbGUoewogICAgICAgIGZpbGVoYW5kbGU6IG5ldyBSZW1vdGVGaWxlMih1cmwsIHsgb3ZlcnJpZGVzOiB1cmxGZXRjaE9wdGlvbnMgfSksCiAgICAgICAgdGJpRmlsZWhhbmRsZTogbmV3IFJlbW90ZUZpbGUyKGluZGV4VXJsLCB7IG92ZXJyaWRlczogaW5kZXhVcmxGZXRjaE9wdGlvbnMgfSkKICAgICAgfSk7CiAgICAgIHJldHVybiBuZXcgVmNmRmlsZSh0YmksIHVpZCk7CiAgICB9CiAgICBhc3luYyBnZXRQYXJzZXIoKSB7CiAgICAgIGlmICghdGhpcy4jcGFyc2VyKSB7CiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy50YmkuZ2V0SGVhZGVyKCk7CiAgICAgICAgdGhpcy4jcGFyc2VyID0gbmV3IGVzbV9kZWZhdWx0KHsgaGVhZGVyIH0pOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLiNwYXJzZXI7CiAgICB9CiAgICBhc3luYyBnZXRUaWxlRGF0YShtaW5YLCBtYXhYKSB7CiAgICAgIGNvbnN0IHNvdXJjZSA9IGRhdGFTb3VyY2VzLmdldCh0aGlzLiN1aWQpOwogICAgICBjb25zdCBwYXJzZXIgPSBhd2FpdCB0aGlzLmdldFBhcnNlcigpOwogICAgICBsZXQgY3VyTWluWCA9IG1pblg7CiAgICAgIGNvbnN0IHsgY2hyb21MZW5ndGhzLCBjdW1Qb3NpdGlvbnMgfSA9IHNvdXJjZS5jaHJvbUluZm87CiAgICAgIGNvbnN0IHJlY29yZFByb21pc2VzID0gW107CiAgICAgIGZvciAoY29uc3QgY3VtUG9zIG9mIGN1bVBvc2l0aW9ucykgewogICAgICAgIGNvbnN0IGNocm9tTmFtZSA9IGN1bVBvcy5jaHI7CiAgICAgICAgY29uc3QgY2hyb21TdGFydCA9IGN1bVBvcy5wb3M7CiAgICAgICAgY29uc3QgY2hyb21FbmQgPSBjdW1Qb3MucG9zICsgY2hyb21MZW5ndGhzW2Nocm9tTmFtZV07CiAgICAgICAgbGV0IHN0YXJ0UG9zLCBlbmRQb3M7CiAgICAgICAgaWYgKGNocm9tU3RhcnQgPiBjdXJNaW5YIHx8IGN1ck1pblggPj0gY2hyb21FbmQpIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgICBsZXQgcHJldlBPUzsKICAgICAgICBjb25zdCB0aWxlc1Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gewogICAgICAgICAgY29uc3QgdGlsZXMgPSBbXTsKICAgICAgICAgIGNvbnN0IGxpbmVDYWxsYmFjayA9IChsaW5lKSA9PiB7CiAgICAgICAgICAgIGNvbnN0IHZjZlJlY29yZCA9IHBhcnNlci5wYXJzZUxpbmUobGluZSk7CiAgICAgICAgICAgIGNvbnN0IHZjZlRpbGUgPSByZWNvcmRUb1RpbGUodmNmUmVjb3JkLCBjaHJvbVN0YXJ0LCBwcmV2UE9TKTsKICAgICAgICAgICAgcHJldlBPUyA9IHZjZlRpbGUuUE9TOwogICAgICAgICAgICB0aWxlcy5wdXNoKHZjZlRpbGUpOwogICAgICAgICAgfTsKICAgICAgICAgIGlmIChtYXhYID4gY2hyb21FbmQpIHsKICAgICAgICAgICAgc3RhcnRQb3MgPSBjdXJNaW5YIC0gY2hyb21TdGFydDsKICAgICAgICAgICAgZW5kUG9zID0gY2hyb21FbmQgLSBjaHJvbVN0YXJ0OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc3RhcnRQb3MgPSBNYXRoLmZsb29yKGN1ck1pblggLSBjaHJvbVN0YXJ0KTsKICAgICAgICAgICAgZW5kUG9zID0gTWF0aC5jZWlsKG1heFggLSBjaHJvbVN0YXJ0KTsKICAgICAgICAgIH0KICAgICAgICAgIHNvdXJjZS5maWxlLnRiaS5nZXRMaW5lcyhjaHJvbU5hbWUsIHN0YXJ0UG9zLCBlbmRQb3MsIGxpbmVDYWxsYmFjaykudGhlbigoKSA9PiB7CiAgICAgICAgICAgIHJlc29sdmUodGlsZXMpOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgICAgcmVjb3JkUHJvbWlzZXMucHVzaCh0aWxlc1Byb21pc2UpOwogICAgICAgIGlmIChtYXhYIDw9IGNocm9tRW5kKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgY3VyTWluWCA9IGNocm9tRW5kOwogICAgICB9CiAgICAgIGNvbnN0IHRpbGVBcnJheXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZWNvcmRQcm9taXNlcyk7CiAgICAgIHJldHVybiB0aWxlQXJyYXlzLmZsYXQoKTsKICAgIH0KICB9OwogIHZhciB0aWxlVmFsdWVzID0ge307CiAgdmFyIGRhdGFTb3VyY2VzID0gbmV3IE1hcCgpOwogIGZ1bmN0aW9uIGluaXQodWlkLCB2Y2YsIGNocm9tU2l6ZXMsIG9wdGlvbnMgPSB7fSkgewogICAgbGV0IHZjZkZpbGUgPSB2Y2ZGaWxlcy5nZXQodmNmLnVybCk7CiAgICBpZiAoIXZjZkZpbGUpIHsKICAgICAgdmNmRmlsZSA9IFZjZkZpbGUuZnJvbVVybCh2Y2YudXJsLCB2Y2YuaW5kZXhVcmwsIHVpZCwgb3B0aW9ucy51cmxGZXRjaE9wdGlvbnMsIG9wdGlvbnMuaW5kZXhVcmxGZXRjaE9wdGlvbnMpOwogICAgfQogICAgY29uc3QgZGF0YVNvdXJjZSA9IG5ldyBEYXRhU291cmNlKHZjZkZpbGUsIGNocm9tU2l6ZXMsIHsKICAgICAgc2FtcGxlTGVuZ3RoOiAxZTMsCiAgICAgIC4uLm9wdGlvbnMKICAgIH0pOwogICAgZGF0YVNvdXJjZXMuc2V0KHVpZCwgZGF0YVNvdXJjZSk7CiAgfQogIHZhciB0aWxlc2V0SW5mbyA9ICh1aWQpID0+IHsKICAgIHJldHVybiBkYXRhU291cmNlcy5nZXQodWlkKS50aWxlc2V0SW5mbzsKICB9OwogIHZhciB0aWxlID0gYXN5bmMgKHVpZCwgeiwgeCkgPT4gewogICAgY29uc3Qgc291cmNlID0gZGF0YVNvdXJjZXMuZ2V0KHVpZCk7CiAgICBjb25zdCBDQUNIRV9LRVkgPSBgJHt1aWR9LiR7en0uJHt4fWA7CiAgICB0aWxlVmFsdWVzW0NBQ0hFX0tFWV0gPSBbXTsKICAgIGNvbnN0IHRpbGVXaWR0aCA9ICtzb3VyY2UudGlsZXNldEluZm8ubWF4X3dpZHRoIC8gMiAqKiArejsKICAgIGNvbnN0IG1pblggPSBzb3VyY2UudGlsZXNldEluZm8ubWluX3Bvc1swXSArIHggKiB0aWxlV2lkdGg7CiAgICBjb25zdCBtYXhYID0gc291cmNlLnRpbGVzZXRJbmZvLm1pbl9wb3NbMF0gKyAoeCArIDEpICogdGlsZVdpZHRoOwogICAgdGlsZVZhbHVlc1tDQUNIRV9LRVldID0gYXdhaXQgc291cmNlLmZpbGUuZ2V0VGlsZURhdGEobWluWCwgbWF4WCk7CiAgICByZXR1cm4gdGlsZVZhbHVlc1tDQUNIRV9LRVldOwogIH07CiAgdmFyIGZldGNoVGlsZXNEZWJvdW5jZWQgPSBhc3luYyAodWlkLCB0aWxlSWRzKSA9PiB7CiAgICBjb25zdCB0aWxlcyA9IHt9OwogICAgY29uc3QgdmFsaWRUaWxlSWRzID0gW107CiAgICBjb25zdCB0aWxlUHJvbWlzZXMgPSBbXTsKICAgIGZvciAoY29uc3QgdGlsZUlkIG9mIHRpbGVJZHMpIHsKICAgICAgY29uc3QgcGFydHMgPSB0aWxlSWQuc3BsaXQoIi4iKTsKICAgICAgY29uc3QgeiA9IHBhcnNlSW50KHBhcnRzWzBdLCAxMCk7CiAgICAgIGNvbnN0IHggPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOwogICAgICBpZiAoTnVtYmVyLmlzTmFOKHgpIHx8IE51bWJlci5pc05hTih6KSkgewogICAgICAgIGNvbnNvbGUud2FybigiSW52YWxpZCB0aWxlIHpvb20gb3IgcG9zaXRpb246IiwgeiwgeCk7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgdmFsaWRUaWxlSWRzLnB1c2godGlsZUlkKTsKICAgICAgdGlsZVByb21pc2VzLnB1c2godGlsZSh1aWQsIHosIHgpKTsKICAgIH0KICAgIHJldHVybiBQcm9taXNlLmFsbCh0aWxlUHJvbWlzZXMpLnRoZW4oKHZhbHVlczIpID0+IHsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMyLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgdmFsaWRUaWxlSWQgPSB2YWxpZFRpbGVJZHNbaV07CiAgICAgICAgdGlsZXNbdmFsaWRUaWxlSWRdID0gdmFsdWVzMltpXTsKICAgICAgICB0aWxlc1t2YWxpZFRpbGVJZF0udGlsZVBvc2l0aW9uSWQgPSB2YWxpZFRpbGVJZDsKICAgICAgfQogICAgICByZXR1cm4gdGlsZXM7CiAgICB9KTsKICB9OwogIHZhciBnZXRUYWJ1bGFyRGF0YSA9ICh1aWQsIHRpbGVJZHMpID0+IHsKICAgIGNvbnN0IGRhdGEgPSBbXTsKICAgIHRpbGVJZHMuZm9yRWFjaCgodGlsZUlkKSA9PiB7CiAgICAgIGNvbnN0IHBhcnRzID0gdGlsZUlkLnNwbGl0KCIuIik7CiAgICAgIGNvbnN0IHogPSBwYXJzZUludChwYXJ0c1swXSwgMTApOwogICAgICBjb25zdCB4ID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsKICAgICAgY29uc3QgdGlsZVZhbHVlID0gdGlsZVZhbHVlc1tgJHt1aWR9LiR7en0uJHt4fWBdOwogICAgICBpZiAoIXRpbGVWYWx1ZSkgewogICAgICAgIGNvbnNvbGUud2FybihgTm8gdGlsZSBkYXRhIGNvbnN0cnVjdGVkICgke3RpbGVJZH0pYCk7CiAgICAgIH0KICAgICAgZGF0YS5wdXNoKHRpbGVWYWx1ZSk7CiAgICB9KTsKICAgIGxldCBvdXRwdXQgPSBPYmplY3QudmFsdWVzKGRhdGEpLmZsYXQoKTsKICAgIGNvbnN0IHNhbXBsZUxlbmd0aCA9IGRhdGFTb3VyY2VzLmdldCh1aWQpLm9wdGlvbnMuc2FtcGxlTGVuZ3RoOwogICAgaWYgKG91dHB1dC5sZW5ndGggPj0gc2FtcGxlTGVuZ3RoKSB7CiAgICAgIGNvbnN0IGhpZ2hQcmlvcml0eSA9IG91dHB1dC5zb3J0KChhLCBiKSA9PiAtKGEuRElTVFBSRVYgPz8gMCkgKyAoYi5ESVNUUFJFViA/PyAwKSkuc2xpY2UoMCwgc2FtcGxlTGVuZ3RoIC8gMik7CiAgICAgIG91dHB1dCA9IHNhbXBsZVNpemVfZGVmYXVsdChvdXRwdXQsIHNhbXBsZUxlbmd0aCAvIDIpLmNvbmNhdChoaWdoUHJpb3JpdHkpOwogICAgfQogICAgY29uc3QgYnVmZmVyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG91dHB1dCkpLmJ1ZmZlcjsKICAgIHJldHVybiBUcmFuc2ZlcihidWZmZXIsIFtidWZmZXJdKTsKICB9OwogIHZhciB0aWxlRnVuY3Rpb25zID0gewogICAgaW5pdCwKICAgIHRpbGVzZXRJbmZvLAogICAgZmV0Y2hUaWxlc0RlYm91bmNlZCwKICAgIHRpbGUsCiAgICBnZXRUYWJ1bGFyRGF0YQogIH07CiAgZXhwb3NlKHRpbGVGdW5jdGlvbnMpOwp9KSgpOwovKiEKICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuCiAqCiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+CiAqIEBsaWNlbnNlICBNSVQKICovCi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovCi8qKgogKiBAbGljZW5zZQogKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+CiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz0iZXMiIC1vIC4vYAogKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+CiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT4KICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT4KICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzCiAqLwo=";
const blob$2 = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs$2)], { type: "text/javascript;charset=utf-8" });
function Worker$3() {
  const objURL = blob$2 && (window.URL || window.webkitURL).createObjectURL(blob$2);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs$2, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const DEBOUNCE_TIME$2 = 200;
class VcfDataFetcher {
  constructor(HGC, config2) {
    __publicField(this, "dataConfig", {});
    // required for higlass
    __publicField(this, "uid");
    __publicField(this, "prevRequestTime");
    __publicField(this, "track");
    __publicField(this, "toFetch");
    __publicField(this, "fetchTimeout");
    __publicField(this, "worker");
    this.uid = HGC.libraries.slugid.nice();
    this.prevRequestTime = 0;
    this.toFetch = /* @__PURE__ */ new Set();
    const { url, indexUrl, assembly, ...options } = config2;
    this.worker = spawn(new Worker$3()).then(async (worker) => {
      const chromSizes = Object.entries(computeChromSizes(assembly).size);
      await worker.init(this.uid, { url, indexUrl }, chromSizes, options);
      return worker;
    });
  }
  /*
   * Collect Tileset Information, such as tile size and genomic positions
   */
  async tilesetInfo(callback) {
    (await this.worker).tilesetInfo(this.uid).then(callback);
  }
  fetchTilesDebounced(receivedTiles, tileIds) {
    this.track.drawLoadingCue();
    tileIds.forEach((tileId) => this.toFetch.add(tileId));
    if (this.fetchTimeout) {
      clearTimeout(this.fetchTimeout);
    }
    this.fetchTimeout = setTimeout(() => {
      this.sendFetch(receivedTiles, [...this.toFetch]);
      this.toFetch.clear();
    }, DEBOUNCE_TIME$2);
  }
  async sendFetch(receivedTiles, tileIds) {
    (await this.worker).fetchTilesDebounced(this.uid, tileIds).then(receivedTiles);
  }
  async getTabularData(tileIds) {
    const buf = await (await this.worker).getTabularData(this.uid, tileIds);
    return JSON.parse(new TextDecoder().decode(buf));
  }
}
__publicField(VcfDataFetcher, "config", { type: "vcf" });
const BigInt32 = BigInt(32);
function getBigInt64(dataView, byteOffset, littleEndian) {
  const littleEndianMask = Number(!!littleEndian);
  const bigEndianMask = Number(!littleEndian);
  return BigInt(dataView.getInt32(byteOffset, littleEndian) * bigEndianMask + dataView.getInt32(byteOffset + 4, littleEndian) * littleEndianMask) << BigInt32 | BigInt(dataView.getUint32(byteOffset, littleEndian) * littleEndianMask + dataView.getUint32(byteOffset + 4, littleEndian) * bigEndianMask);
}
function getBigUint64(dataView, byteOffset, littleEndian) {
  const a = dataView.getUint32(byteOffset, littleEndian);
  const b = dataView.getUint32(byteOffset + 4, littleEndian);
  const littleEndianMask = Number(!!littleEndian);
  const bigEndianMask = Number(!littleEndian);
  return BigInt(a * bigEndianMask + b * littleEndianMask) << BigInt32 | BigInt(a * littleEndianMask + b * bigEndianMask);
}
function setBigInt64(dataView, byteOffset, value, littleEndian) {
  const hi = Number(value >> BigInt32);
  const lo = Number(value & BigInt(4294967295));
  if (littleEndian) {
    dataView.setInt32(byteOffset + 4, hi, littleEndian);
    dataView.setUint32(byteOffset, lo, littleEndian);
  } else {
    dataView.setInt32(byteOffset, hi, littleEndian);
    dataView.setUint32(byteOffset + 4, lo, littleEndian);
  }
}
function setBigUint64(dataView, byteOffset, value, littleEndian) {
  const hi = Number(value >> BigInt32);
  const lo = Number(value & BigInt(4294967295));
  if (littleEndian) {
    dataView.setUint32(byteOffset + 4, hi, littleEndian);
    dataView.setUint32(byteOffset, lo, littleEndian);
  } else {
    dataView.setUint32(byteOffset, hi, littleEndian);
    dataView.setUint32(byteOffset + 4, lo, littleEndian);
  }
}
if (!("getBigInt64" in DataView)) {
  DataView.prototype.getBigInt64 = function(byteOffset, littleEndian) {
    return getBigInt64(this, byteOffset, littleEndian);
  };
}
if (!("getBigUint64" in DataView)) {
  DataView.prototype.getBigUint64 = function(byteOffset, littleEndian) {
    return getBigUint64(this, byteOffset, littleEndian);
  };
}
if (!("setBigInt64" in DataView)) {
  DataView.prototype.setBigInt64 = function(byteOffset, value, littleEndian) {
    setBigInt64(this, byteOffset, value, littleEndian);
  };
}
if (!("setBigUint64" in DataView)) {
  DataView.prototype.setBigUint64 = function(byteOffset, value, littleEndian) {
    setBigUint64(this, byteOffset, value, littleEndian);
  };
}
class Context {
  constructor(importPath, useContextVariables) {
    this.code = "";
    this.scopes = [["vars"]];
    this.bitFields = [];
    this.tmpVariableCount = 0;
    this.references = /* @__PURE__ */ new Map();
    this.imports = [];
    this.reverseImports = /* @__PURE__ */ new Map();
    this.useContextVariables = false;
    this.importPath = importPath;
    this.useContextVariables = useContextVariables;
  }
  generateVariable(name2) {
    const scopes = [...this.scopes[this.scopes.length - 1]];
    if (name2) {
      scopes.push(name2);
    }
    return scopes.join(".");
  }
  generateOption(val) {
    switch (typeof val) {
      case "number":
        return val.toString();
      case "string":
        return this.generateVariable(val);
      case "function":
        return `${this.addImport(val)}.call(${this.generateVariable()}, vars)`;
    }
  }
  generateError(err2) {
    this.pushCode(`throw new Error(${err2});`);
  }
  generateTmpVariable() {
    return "$tmp" + this.tmpVariableCount++;
  }
  pushCode(code) {
    this.code += code + "\n";
  }
  pushPath(name2) {
    if (name2) {
      this.scopes[this.scopes.length - 1].push(name2);
    }
  }
  popPath(name2) {
    if (name2) {
      this.scopes[this.scopes.length - 1].pop();
    }
  }
  pushScope(name2) {
    this.scopes.push([name2]);
  }
  popScope() {
    this.scopes.pop();
  }
  addImport(im) {
    if (!this.importPath)
      return `(${im})`;
    let id = this.reverseImports.get(im);
    if (!id) {
      id = this.imports.push(im) - 1;
      this.reverseImports.set(im, id);
    }
    return `${this.importPath}[${id}]`;
  }
  addReference(alias) {
    if (!this.references.has(alias)) {
      this.references.set(alias, { resolved: false, requested: false });
    }
  }
  markResolved(alias) {
    const reference = this.references.get(alias);
    if (reference) {
      reference.resolved = true;
    }
  }
  markRequested(aliasList) {
    aliasList.forEach((alias) => {
      const reference = this.references.get(alias);
      if (reference) {
        reference.requested = true;
      }
    });
  }
  getUnresolvedReferences() {
    return Array.from(this.references).filter(([_, reference]) => !reference.resolved && !reference.requested).map(([alias, _]) => alias);
  }
}
const aliasRegistry = /* @__PURE__ */ new Map();
const FUNCTION_PREFIX = "___parser_";
const PRIMITIVE_SIZES = {
  uint8: 1,
  uint16le: 2,
  uint16be: 2,
  uint32le: 4,
  uint32be: 4,
  int8: 1,
  int16le: 2,
  int16be: 2,
  int32le: 4,
  int32be: 4,
  int64be: 8,
  int64le: 8,
  uint64be: 8,
  uint64le: 8,
  floatle: 4,
  floatbe: 4,
  doublele: 8,
  doublebe: 8
};
const PRIMITIVE_NAMES = {
  uint8: "Uint8",
  uint16le: "Uint16",
  uint16be: "Uint16",
  uint32le: "Uint32",
  uint32be: "Uint32",
  int8: "Int8",
  int16le: "Int16",
  int16be: "Int16",
  int32le: "Int32",
  int32be: "Int32",
  int64be: "BigInt64",
  int64le: "BigInt64",
  uint64be: "BigUint64",
  uint64le: "BigUint64",
  floatle: "Float32",
  floatbe: "Float32",
  doublele: "Float64",
  doublebe: "Float64"
};
const PRIMITIVE_LITTLE_ENDIANS = {
  uint8: false,
  uint16le: true,
  uint16be: false,
  uint32le: true,
  uint32be: false,
  int8: false,
  int16le: true,
  int16be: false,
  int32le: true,
  int32be: false,
  int64be: false,
  int64le: true,
  uint64be: false,
  uint64le: true,
  floatle: true,
  floatbe: false,
  doublele: true,
  doublebe: false
};
class Parser {
  constructor() {
    this.varName = "";
    this.type = "";
    this.options = {};
    this.endian = "be";
    this.useContextVariables = false;
  }
  static start() {
    return new Parser();
  }
  primitiveGenerateN(type2, ctx) {
    const typeName = PRIMITIVE_NAMES[type2];
    const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type2];
    ctx.pushCode(`${ctx.generateVariable(this.varName)} = dataView.get${typeName}(offset, ${littleEndian});`);
    ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type2]};`);
  }
  primitiveN(type2, varName, options) {
    return this.setNextParser(type2, varName, options);
  }
  useThisEndian(type2) {
    return type2 + this.endian.toLowerCase();
  }
  uint8(varName, options = {}) {
    return this.primitiveN("uint8", varName, options);
  }
  uint16(varName, options = {}) {
    return this.primitiveN(this.useThisEndian("uint16"), varName, options);
  }
  uint16le(varName, options = {}) {
    return this.primitiveN("uint16le", varName, options);
  }
  uint16be(varName, options = {}) {
    return this.primitiveN("uint16be", varName, options);
  }
  uint32(varName, options = {}) {
    return this.primitiveN(this.useThisEndian("uint32"), varName, options);
  }
  uint32le(varName, options = {}) {
    return this.primitiveN("uint32le", varName, options);
  }
  uint32be(varName, options = {}) {
    return this.primitiveN("uint32be", varName, options);
  }
  int8(varName, options = {}) {
    return this.primitiveN("int8", varName, options);
  }
  int16(varName, options = {}) {
    return this.primitiveN(this.useThisEndian("int16"), varName, options);
  }
  int16le(varName, options = {}) {
    return this.primitiveN("int16le", varName, options);
  }
  int16be(varName, options = {}) {
    return this.primitiveN("int16be", varName, options);
  }
  int32(varName, options = {}) {
    return this.primitiveN(this.useThisEndian("int32"), varName, options);
  }
  int32le(varName, options = {}) {
    return this.primitiveN("int32le", varName, options);
  }
  int32be(varName, options = {}) {
    return this.primitiveN("int32be", varName, options);
  }
  bigIntVersionCheck() {
    if (!DataView.prototype.getBigInt64)
      throw new Error("BigInt64 is unsupported on this runtime");
  }
  int64(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN(this.useThisEndian("int64"), varName, options);
  }
  int64be(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN("int64be", varName, options);
  }
  int64le(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN("int64le", varName, options);
  }
  uint64(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN(this.useThisEndian("uint64"), varName, options);
  }
  uint64be(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN("uint64be", varName, options);
  }
  uint64le(varName, options = {}) {
    this.bigIntVersionCheck();
    return this.primitiveN("uint64le", varName, options);
  }
  floatle(varName, options = {}) {
    return this.primitiveN("floatle", varName, options);
  }
  floatbe(varName, options = {}) {
    return this.primitiveN("floatbe", varName, options);
  }
  doublele(varName, options = {}) {
    return this.primitiveN("doublele", varName, options);
  }
  doublebe(varName, options = {}) {
    return this.primitiveN("doublebe", varName, options);
  }
  bitN(size, varName, options) {
    options.length = size;
    return this.setNextParser("bit", varName, options);
  }
  bit1(varName, options = {}) {
    return this.bitN(1, varName, options);
  }
  bit2(varName, options = {}) {
    return this.bitN(2, varName, options);
  }
  bit3(varName, options = {}) {
    return this.bitN(3, varName, options);
  }
  bit4(varName, options = {}) {
    return this.bitN(4, varName, options);
  }
  bit5(varName, options = {}) {
    return this.bitN(5, varName, options);
  }
  bit6(varName, options = {}) {
    return this.bitN(6, varName, options);
  }
  bit7(varName, options = {}) {
    return this.bitN(7, varName, options);
  }
  bit8(varName, options = {}) {
    return this.bitN(8, varName, options);
  }
  bit9(varName, options = {}) {
    return this.bitN(9, varName, options);
  }
  bit10(varName, options = {}) {
    return this.bitN(10, varName, options);
  }
  bit11(varName, options = {}) {
    return this.bitN(11, varName, options);
  }
  bit12(varName, options = {}) {
    return this.bitN(12, varName, options);
  }
  bit13(varName, options = {}) {
    return this.bitN(13, varName, options);
  }
  bit14(varName, options = {}) {
    return this.bitN(14, varName, options);
  }
  bit15(varName, options = {}) {
    return this.bitN(15, varName, options);
  }
  bit16(varName, options = {}) {
    return this.bitN(16, varName, options);
  }
  bit17(varName, options = {}) {
    return this.bitN(17, varName, options);
  }
  bit18(varName, options = {}) {
    return this.bitN(18, varName, options);
  }
  bit19(varName, options = {}) {
    return this.bitN(19, varName, options);
  }
  bit20(varName, options = {}) {
    return this.bitN(20, varName, options);
  }
  bit21(varName, options = {}) {
    return this.bitN(21, varName, options);
  }
  bit22(varName, options = {}) {
    return this.bitN(22, varName, options);
  }
  bit23(varName, options = {}) {
    return this.bitN(23, varName, options);
  }
  bit24(varName, options = {}) {
    return this.bitN(24, varName, options);
  }
  bit25(varName, options = {}) {
    return this.bitN(25, varName, options);
  }
  bit26(varName, options = {}) {
    return this.bitN(26, varName, options);
  }
  bit27(varName, options = {}) {
    return this.bitN(27, varName, options);
  }
  bit28(varName, options = {}) {
    return this.bitN(28, varName, options);
  }
  bit29(varName, options = {}) {
    return this.bitN(29, varName, options);
  }
  bit30(varName, options = {}) {
    return this.bitN(30, varName, options);
  }
  bit31(varName, options = {}) {
    return this.bitN(31, varName, options);
  }
  bit32(varName, options = {}) {
    return this.bitN(32, varName, options);
  }
  namely(alias) {
    aliasRegistry.set(alias, this);
    this.alias = alias;
    return this;
  }
  skip(length, options = {}) {
    return this.seek(length, options);
  }
  seek(relOffset, options = {}) {
    if (options.assert) {
      throw new Error("assert option on seek is not allowed.");
    }
    return this.setNextParser("seek", "", { length: relOffset });
  }
  string(varName, options) {
    if (!options.zeroTerminated && !options.length && !options.greedy) {
      throw new Error("One of length, zeroTerminated, or greedy must be defined for string.");
    }
    if ((options.zeroTerminated || options.length) && options.greedy) {
      throw new Error("greedy is mutually exclusive with length and zeroTerminated for string.");
    }
    if (options.stripNull && !(options.length || options.greedy)) {
      throw new Error("length or greedy must be defined if stripNull is enabled.");
    }
    options.encoding = options.encoding || "utf8";
    return this.setNextParser("string", varName, options);
  }
  buffer(varName, options) {
    if (!options.length && !options.readUntil) {
      throw new Error("length or readUntil must be defined for buffer.");
    }
    return this.setNextParser("buffer", varName, options);
  }
  wrapped(varName, options) {
    if (typeof options !== "object" && typeof varName === "object") {
      options = varName;
      varName = "";
    }
    if (!options || !options.wrapper || !options.type) {
      throw new Error("Both wrapper and type must be defined for wrapped.");
    }
    if (!options.length && !options.readUntil) {
      throw new Error("length or readUntil must be defined for wrapped.");
    }
    return this.setNextParser("wrapper", varName, options);
  }
  array(varName, options) {
    if (!options.readUntil && !options.length && !options.lengthInBytes) {
      throw new Error("One of readUntil, length and lengthInBytes must be defined for array.");
    }
    if (!options.type) {
      throw new Error("type is required for array.");
    }
    if (typeof options.type === "string" && !aliasRegistry.has(options.type) && !(options.type in PRIMITIVE_SIZES)) {
      throw new Error(`Array element type "${options.type}" is unkown.`);
    }
    return this.setNextParser("array", varName, options);
  }
  choice(varName, options) {
    if (typeof options !== "object" && typeof varName === "object") {
      options = varName;
      varName = "";
    }
    if (!options) {
      throw new Error("tag and choices are are required for choice.");
    }
    if (!options.tag) {
      throw new Error("tag is requird for choice.");
    }
    if (!options.choices) {
      throw new Error("choices is required for choice.");
    }
    for (const keyString in options.choices) {
      const key = parseInt(keyString, 10);
      const value = options.choices[key];
      if (isNaN(key)) {
        throw new Error(`Choice key "${keyString}" is not a number.`);
      }
      if (typeof value === "string" && !aliasRegistry.has(value) && !(value in PRIMITIVE_SIZES)) {
        throw new Error(`Choice type "${value}" is unkown.`);
      }
    }
    return this.setNextParser("choice", varName, options);
  }
  nest(varName, options) {
    if (typeof options !== "object" && typeof varName === "object") {
      options = varName;
      varName = "";
    }
    if (!options || !options.type) {
      throw new Error("type is required for nest.");
    }
    if (!(options.type instanceof Parser) && !aliasRegistry.has(options.type)) {
      throw new Error("type must be a known parser name or a Parser object.");
    }
    if (!(options.type instanceof Parser) && !varName) {
      throw new Error("type must be a Parser object if the variable name is omitted.");
    }
    return this.setNextParser("nest", varName, options);
  }
  pointer(varName, options) {
    if (!options.offset) {
      throw new Error("offset is required for pointer.");
    }
    if (!options.type) {
      throw new Error("type is required for pointer.");
    }
    if (typeof options.type === "string" && !(options.type in PRIMITIVE_SIZES) && !aliasRegistry.has(options.type)) {
      throw new Error(`Pointer type "${options.type}" is unkown.`);
    }
    return this.setNextParser("pointer", varName, options);
  }
  saveOffset(varName, options = {}) {
    return this.setNextParser("saveOffset", varName, options);
  }
  endianness(endianness) {
    switch (endianness.toLowerCase()) {
      case "little":
        this.endian = "le";
        break;
      case "big":
        this.endian = "be";
        break;
      default:
        throw new Error('endianness must be one of "little" or "big"');
    }
    return this;
  }
  endianess(endianess) {
    return this.endianness(endianess);
  }
  useContextVars(useContextVariables = true) {
    this.useContextVariables = useContextVariables;
    return this;
  }
  create(constructorFn) {
    if (!(constructorFn instanceof Function)) {
      throw new Error("Constructor must be a Function object.");
    }
    this.constructorFn = constructorFn;
    return this;
  }
  getContext(importPath) {
    const ctx = new Context(importPath, this.useContextVariables);
    ctx.pushCode("var dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.length);");
    if (!this.alias) {
      this.addRawCode(ctx);
    } else {
      this.addAliasedCode(ctx);
      ctx.pushCode(`return ${FUNCTION_PREFIX + this.alias}(0).result;`);
    }
    return ctx;
  }
  getCode() {
    const importPath = "imports";
    return this.getContext(importPath).code;
  }
  addRawCode(ctx) {
    ctx.pushCode("var offset = 0;");
    ctx.pushCode(`var vars = ${this.constructorFn ? "new constructorFn()" : "{}"};`);
    ctx.pushCode("vars.$parent = null;");
    ctx.pushCode("vars.$root = vars;");
    this.generate(ctx);
    this.resolveReferences(ctx);
    ctx.pushCode("delete vars.$parent;");
    ctx.pushCode("delete vars.$root;");
    ctx.pushCode("return vars;");
  }
  addAliasedCode(ctx) {
    ctx.pushCode(`function ${FUNCTION_PREFIX + this.alias}(offset, context) {`);
    ctx.pushCode(`var vars = ${this.constructorFn ? "new constructorFn()" : "{}"};`);
    ctx.pushCode("var ctx = Object.assign({$parent: null, $root: vars}, context || {});");
    ctx.pushCode(`vars = Object.assign(vars, ctx);`);
    this.generate(ctx);
    ctx.markResolved(this.alias);
    this.resolveReferences(ctx);
    ctx.pushCode("Object.keys(ctx).forEach(function (item) { delete vars[item]; });");
    ctx.pushCode("return { offset: offset, result: vars };");
    ctx.pushCode("}");
    return ctx;
  }
  resolveReferences(ctx) {
    const references = ctx.getUnresolvedReferences();
    ctx.markRequested(references);
    references.forEach((alias) => {
      var _a;
      (_a = aliasRegistry.get(alias)) === null || _a === void 0 ? void 0 : _a.addAliasedCode(ctx);
    });
  }
  compile() {
    const importPath = "imports";
    const ctx = this.getContext(importPath);
    this.compiled = new Function(importPath, "TextDecoder", `return function (buffer, constructorFn) { ${ctx.code} };`)(ctx.imports, TextDecoder);
  }
  sizeOf() {
    let size = NaN;
    if (Object.keys(PRIMITIVE_SIZES).indexOf(this.type) >= 0) {
      size = PRIMITIVE_SIZES[this.type];
    } else if (this.type === "string" && typeof this.options.length === "number") {
      size = this.options.length;
    } else if (this.type === "buffer" && typeof this.options.length === "number") {
      size = this.options.length;
    } else if (this.type === "array" && typeof this.options.length === "number") {
      let elementSize = NaN;
      if (typeof this.options.type === "string") {
        elementSize = PRIMITIVE_SIZES[this.options.type];
      } else if (this.options.type instanceof Parser) {
        elementSize = this.options.type.sizeOf();
      }
      size = this.options.length * elementSize;
    } else if (this.type === "seek") {
      size = this.options.length;
    } else if (this.type === "nest") {
      size = this.options.type.sizeOf();
    } else if (!this.type) {
      size = 0;
    }
    if (this.next) {
      size += this.next.sizeOf();
    }
    return size;
  }
  // Follow the parser chain till the root and start parsing from there
  parse(buffer) {
    if (!this.compiled) {
      this.compile();
    }
    return this.compiled(buffer, this.constructorFn);
  }
  setNextParser(type2, varName, options) {
    const parser = new Parser();
    parser.type = type2;
    parser.varName = varName;
    parser.options = options;
    parser.endian = this.endian;
    if (this.head) {
      this.head.next = parser;
    } else {
      this.next = parser;
    }
    this.head = parser;
    return this;
  }
  // Call code generator for this parser
  generate(ctx) {
    if (this.type) {
      switch (this.type) {
        case "uint8":
        case "uint16le":
        case "uint16be":
        case "uint32le":
        case "uint32be":
        case "int8":
        case "int16le":
        case "int16be":
        case "int32le":
        case "int32be":
        case "int64be":
        case "int64le":
        case "uint64be":
        case "uint64le":
        case "floatle":
        case "floatbe":
        case "doublele":
        case "doublebe":
          this.primitiveGenerateN(this.type, ctx);
          break;
        case "bit":
          this.generateBit(ctx);
          break;
        case "string":
          this.generateString(ctx);
          break;
        case "buffer":
          this.generateBuffer(ctx);
          break;
        case "seek":
          this.generateSeek(ctx);
          break;
        case "nest":
          this.generateNest(ctx);
          break;
        case "array":
          this.generateArray(ctx);
          break;
        case "choice":
          this.generateChoice(ctx);
          break;
        case "pointer":
          this.generatePointer(ctx);
          break;
        case "saveOffset":
          this.generateSaveOffset(ctx);
          break;
        case "wrapper":
          this.generateWrapper(ctx);
          break;
      }
      if (this.type !== "bit")
        this.generateAssert(ctx);
    }
    const varName = ctx.generateVariable(this.varName);
    if (this.options.formatter && this.type !== "bit") {
      this.generateFormatter(ctx, varName, this.options.formatter);
    }
    return this.generateNext(ctx);
  }
  generateAssert(ctx) {
    if (!this.options.assert) {
      return;
    }
    const varName = ctx.generateVariable(this.varName);
    switch (typeof this.options.assert) {
      case "function":
        {
          const func = ctx.addImport(this.options.assert);
          ctx.pushCode(`if (!${func}.call(vars, ${varName})) {`);
        }
        break;
      case "number":
        ctx.pushCode(`if (${this.options.assert} !== ${varName}) {`);
        break;
      case "string":
        ctx.pushCode(`if (${JSON.stringify(this.options.assert)} !== ${varName}) {`);
        break;
      default:
        throw new Error("assert option must be a string, number or a function.");
    }
    ctx.generateError(`"Assertion error: ${varName} is " + ${JSON.stringify(this.options.assert.toString())}`);
    ctx.pushCode("}");
  }
  // Recursively call code generators and append results
  generateNext(ctx) {
    if (this.next) {
      ctx = this.next.generate(ctx);
    }
    return ctx;
  }
  generateBit(ctx) {
    const parser = JSON.parse(JSON.stringify(this));
    parser.options = this.options;
    parser.generateAssert = this.generateAssert.bind(this);
    parser.generateFormatter = this.generateFormatter.bind(this);
    parser.varName = ctx.generateVariable(parser.varName);
    ctx.bitFields.push(parser);
    if (!this.next || this.next && ["bit", "nest"].indexOf(this.next.type) < 0) {
      const val = ctx.generateTmpVariable();
      ctx.pushCode(`var ${val} = 0;`);
      const getMaxBits = (from = 0) => {
        let sum3 = 0;
        for (let i = from; i < ctx.bitFields.length; i++) {
          const length = ctx.bitFields[i].options.length;
          if (sum3 + length > 32)
            break;
          sum3 += length;
        }
        return sum3;
      };
      const getBytes = (sum3) => {
        if (sum3 <= 8) {
          ctx.pushCode(`${val} = dataView.getUint8(offset);`);
          sum3 = 8;
        } else if (sum3 <= 16) {
          ctx.pushCode(`${val} = dataView.getUint16(offset);`);
          sum3 = 16;
        } else if (sum3 <= 24) {
          ctx.pushCode(`${val} = (dataView.getUint16(offset) << 8) | dataView.getUint8(offset + 2);`);
          sum3 = 24;
        } else {
          ctx.pushCode(`${val} = dataView.getUint32(offset);`);
          sum3 = 32;
        }
        ctx.pushCode(`offset += ${sum3 / 8};`);
        return sum3;
      };
      let bitOffset = 0;
      const isBigEndian = this.endian === "be";
      let sum2 = 0;
      let rem = 0;
      ctx.bitFields.forEach((parser2, i) => {
        let length = parser2.options.length;
        if (length > rem) {
          if (rem) {
            const mask2 = -1 >>> 32 - rem;
            ctx.pushCode(`${parser2.varName} = (${val} & 0x${mask2.toString(16)}) << ${length - rem};`);
            length -= rem;
          }
          bitOffset = 0;
          rem = sum2 = getBytes(getMaxBits(i) - rem);
        }
        const offset = isBigEndian ? sum2 - bitOffset - length : bitOffset;
        const mask = -1 >>> 32 - length;
        ctx.pushCode(`${parser2.varName} ${length < parser2.options.length ? "|=" : "="} ${val} >> ${offset} & 0x${mask.toString(16)};`);
        if (parser2.options.length === 32) {
          ctx.pushCode(`${parser2.varName} >>>= 0`);
        }
        if (parser2.options.assert) {
          parser2.generateAssert(ctx);
        }
        if (parser2.options.formatter) {
          parser2.generateFormatter(ctx, parser2.varName, parser2.options.formatter);
        }
        bitOffset += length;
        rem -= length;
      });
      ctx.bitFields = [];
    }
  }
  generateSeek(ctx) {
    const length = ctx.generateOption(this.options.length);
    ctx.pushCode(`offset += ${length};`);
  }
  generateString(ctx) {
    const name2 = ctx.generateVariable(this.varName);
    const start = ctx.generateTmpVariable();
    const encoding = this.options.encoding;
    const isHex = encoding.toLowerCase() === "hex";
    const toHex = 'b => b.toString(16).padStart(2, "0")';
    if (this.options.length && this.options.zeroTerminated) {
      const len = this.options.length;
      ctx.pushCode(`var ${start} = offset;`);
      ctx.pushCode(`while(dataView.getUint8(offset++) !== 0 && offset - ${start} < ${len});`);
      const end = `offset - ${start} < ${len} ? offset - 1 : offset`;
      ctx.pushCode(isHex ? `${name2} = Array.from(buffer.subarray(${start}, ${end}), ${toHex}).join('');` : `${name2} = new TextDecoder('${encoding}').decode(buffer.subarray(${start}, ${end}));`);
    } else if (this.options.length) {
      const len = ctx.generateOption(this.options.length);
      ctx.pushCode(isHex ? `${name2} = Array.from(buffer.subarray(offset, offset + ${len}), ${toHex}).join('');` : `${name2} = new TextDecoder('${encoding}').decode(buffer.subarray(offset, offset + ${len}));`);
      ctx.pushCode(`offset += ${len};`);
    } else if (this.options.zeroTerminated) {
      ctx.pushCode(`var ${start} = offset;`);
      ctx.pushCode("while(dataView.getUint8(offset++) !== 0);");
      ctx.pushCode(isHex ? `${name2} = Array.from(buffer.subarray(${start}, offset - 1), ${toHex}).join('');` : `${name2} = new TextDecoder('${encoding}').decode(buffer.subarray(${start}, offset - 1));`);
    } else if (this.options.greedy) {
      ctx.pushCode(`var ${start} = offset;`);
      ctx.pushCode("while(buffer.length > offset++);");
      ctx.pushCode(isHex ? `${name2} = Array.from(buffer.subarray(${start}, offset), ${toHex}).join('');` : `${name2} = new TextDecoder('${encoding}').decode(buffer.subarray(${start}, offset));`);
    }
    if (this.options.stripNull) {
      ctx.pushCode(`${name2} = ${name2}.replace(/\\x00+$/g, '')`);
    }
  }
  generateBuffer(ctx) {
    const varName = ctx.generateVariable(this.varName);
    if (typeof this.options.readUntil === "function") {
      const pred = this.options.readUntil;
      const start = ctx.generateTmpVariable();
      const cur = ctx.generateTmpVariable();
      ctx.pushCode(`var ${start} = offset;`);
      ctx.pushCode(`var ${cur} = 0;`);
      ctx.pushCode(`while (offset < buffer.length) {`);
      ctx.pushCode(`${cur} = dataView.getUint8(offset);`);
      const func = ctx.addImport(pred);
      ctx.pushCode(`if (${func}.call(${ctx.generateVariable()}, ${cur}, buffer.subarray(offset))) break;`);
      ctx.pushCode(`offset += 1;`);
      ctx.pushCode(`}`);
      ctx.pushCode(`${varName} = buffer.subarray(${start}, offset);`);
    } else if (this.options.readUntil === "eof") {
      ctx.pushCode(`${varName} = buffer.subarray(offset);`);
    } else {
      const len = ctx.generateOption(this.options.length);
      ctx.pushCode(`${varName} = buffer.subarray(offset, offset + ${len});`);
      ctx.pushCode(`offset += ${len};`);
    }
    if (this.options.clone) {
      ctx.pushCode(`${varName} = buffer.constructor.from(${varName});`);
    }
  }
  generateArray(ctx) {
    const length = ctx.generateOption(this.options.length);
    const lengthInBytes = ctx.generateOption(this.options.lengthInBytes);
    const type2 = this.options.type;
    const counter = ctx.generateTmpVariable();
    const lhs = ctx.generateVariable(this.varName);
    const item = ctx.generateTmpVariable();
    const key = this.options.key;
    const isHash = typeof key === "string";
    if (isHash) {
      ctx.pushCode(`${lhs} = {};`);
    } else {
      ctx.pushCode(`${lhs} = [];`);
    }
    if (typeof this.options.readUntil === "function") {
      ctx.pushCode("do {");
    } else if (this.options.readUntil === "eof") {
      ctx.pushCode(`for (var ${counter} = 0; offset < buffer.length; ${counter}++) {`);
    } else if (lengthInBytes !== void 0) {
      ctx.pushCode(`for (var ${counter} = offset + ${lengthInBytes}; offset < ${counter}; ) {`);
    } else {
      ctx.pushCode(`for (var ${counter} = ${length}; ${counter} > 0; ${counter}--) {`);
    }
    if (typeof type2 === "string") {
      if (!aliasRegistry.get(type2)) {
        const typeName = PRIMITIVE_NAMES[type2];
        const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type2];
        ctx.pushCode(`var ${item} = dataView.get${typeName}(offset, ${littleEndian});`);
        ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type2]};`);
      } else {
        const tempVar = ctx.generateTmpVariable();
        ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + type2}(offset, {`);
        if (ctx.useContextVariables) {
          const parentVar = ctx.generateVariable();
          ctx.pushCode(`$parent: ${parentVar},`);
          ctx.pushCode(`$root: ${parentVar}.$root,`);
          if (!this.options.readUntil && lengthInBytes === void 0) {
            ctx.pushCode(`$index: ${length} - ${counter},`);
          }
        }
        ctx.pushCode(`});`);
        ctx.pushCode(`var ${item} = ${tempVar}.result; offset = ${tempVar}.offset;`);
        if (type2 !== this.alias)
          ctx.addReference(type2);
      }
    } else if (type2 instanceof Parser) {
      ctx.pushCode(`var ${item} = {};`);
      const parentVar = ctx.generateVariable();
      ctx.pushScope(item);
      if (ctx.useContextVariables) {
        ctx.pushCode(`${item}.$parent = ${parentVar};`);
        ctx.pushCode(`${item}.$root = ${parentVar}.$root;`);
        if (!this.options.readUntil && lengthInBytes === void 0) {
          ctx.pushCode(`${item}.$index = ${length} - ${counter};`);
        }
      }
      type2.generate(ctx);
      if (ctx.useContextVariables) {
        ctx.pushCode(`delete ${item}.$parent;`);
        ctx.pushCode(`delete ${item}.$root;`);
        ctx.pushCode(`delete ${item}.$index;`);
      }
      ctx.popScope();
    }
    if (isHash) {
      ctx.pushCode(`${lhs}[${item}.${key}] = ${item};`);
    } else {
      ctx.pushCode(`${lhs}.push(${item});`);
    }
    ctx.pushCode("}");
    if (typeof this.options.readUntil === "function") {
      const pred = this.options.readUntil;
      const func = ctx.addImport(pred);
      ctx.pushCode(`while (!${func}.call(${ctx.generateVariable()}, ${item}, buffer.subarray(offset)));`);
    }
  }
  generateChoiceCase(ctx, varName, type2) {
    if (typeof type2 === "string") {
      const varName2 = ctx.generateVariable(this.varName);
      if (!aliasRegistry.has(type2)) {
        const typeName = PRIMITIVE_NAMES[type2];
        const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type2];
        ctx.pushCode(`${varName2} = dataView.get${typeName}(offset, ${littleEndian});`);
        ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type2]}`);
      } else {
        const tempVar = ctx.generateTmpVariable();
        ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + type2}(offset, {`);
        if (ctx.useContextVariables) {
          ctx.pushCode(`$parent: ${varName2}.$parent,`);
          ctx.pushCode(`$root: ${varName2}.$root,`);
        }
        ctx.pushCode(`});`);
        ctx.pushCode(`${varName2} = ${tempVar}.result; offset = ${tempVar}.offset;`);
        if (type2 !== this.alias)
          ctx.addReference(type2);
      }
    } else if (type2 instanceof Parser) {
      ctx.pushPath(varName);
      type2.generate(ctx);
      ctx.popPath(varName);
    }
  }
  generateChoice(ctx) {
    const tag = ctx.generateOption(this.options.tag);
    const nestVar = ctx.generateVariable(this.varName);
    if (this.varName) {
      ctx.pushCode(`${nestVar} = {};`);
      if (ctx.useContextVariables) {
        const parentVar = ctx.generateVariable();
        ctx.pushCode(`${nestVar}.$parent = ${parentVar};`);
        ctx.pushCode(`${nestVar}.$root = ${parentVar}.$root;`);
      }
    }
    ctx.pushCode(`switch(${tag}) {`);
    for (const tagString in this.options.choices) {
      const tag2 = parseInt(tagString, 10);
      const type2 = this.options.choices[tag2];
      ctx.pushCode(`case ${tag2}:`);
      this.generateChoiceCase(ctx, this.varName, type2);
      ctx.pushCode("break;");
    }
    ctx.pushCode("default:");
    if (this.options.defaultChoice) {
      this.generateChoiceCase(ctx, this.varName, this.options.defaultChoice);
    } else {
      ctx.generateError(`"Met undefined tag value " + ${tag} + " at choice"`);
    }
    ctx.pushCode("}");
    if (this.varName && ctx.useContextVariables) {
      ctx.pushCode(`delete ${nestVar}.$parent;`);
      ctx.pushCode(`delete ${nestVar}.$root;`);
    }
  }
  generateNest(ctx) {
    const nestVar = ctx.generateVariable(this.varName);
    if (this.options.type instanceof Parser) {
      if (this.varName) {
        ctx.pushCode(`${nestVar} = {};`);
        if (ctx.useContextVariables) {
          const parentVar = ctx.generateVariable();
          ctx.pushCode(`${nestVar}.$parent = ${parentVar};`);
          ctx.pushCode(`${nestVar}.$root = ${parentVar}.$root;`);
        }
      }
      ctx.pushPath(this.varName);
      this.options.type.generate(ctx);
      ctx.popPath(this.varName);
      if (this.varName && ctx.useContextVariables) {
        if (ctx.useContextVariables) {
          ctx.pushCode(`delete ${nestVar}.$parent;`);
          ctx.pushCode(`delete ${nestVar}.$root;`);
        }
      }
    } else if (aliasRegistry.has(this.options.type)) {
      const tempVar = ctx.generateTmpVariable();
      ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + this.options.type}(offset, {`);
      if (ctx.useContextVariables) {
        const parentVar = ctx.generateVariable();
        ctx.pushCode(`$parent: ${parentVar},`);
        ctx.pushCode(`$root: ${parentVar}.$root,`);
      }
      ctx.pushCode(`});`);
      ctx.pushCode(`${nestVar} = ${tempVar}.result; offset = ${tempVar}.offset;`);
      if (this.options.type !== this.alias) {
        ctx.addReference(this.options.type);
      }
    }
  }
  generateWrapper(ctx) {
    const wrapperVar = ctx.generateVariable(this.varName);
    const wrappedBuf = ctx.generateTmpVariable();
    if (typeof this.options.readUntil === "function") {
      const pred = this.options.readUntil;
      const start = ctx.generateTmpVariable();
      const cur = ctx.generateTmpVariable();
      ctx.pushCode(`var ${start} = offset;`);
      ctx.pushCode(`var ${cur} = 0;`);
      ctx.pushCode(`while (offset < buffer.length) {`);
      ctx.pushCode(`${cur} = dataView.getUint8(offset);`);
      const func2 = ctx.addImport(pred);
      ctx.pushCode(`if (${func2}.call(${ctx.generateVariable()}, ${cur}, buffer.subarray(offset))) break;`);
      ctx.pushCode(`offset += 1;`);
      ctx.pushCode(`}`);
      ctx.pushCode(`${wrappedBuf} = buffer.subarray(${start}, offset);`);
    } else if (this.options.readUntil === "eof") {
      ctx.pushCode(`${wrappedBuf} = buffer.subarray(offset);`);
    } else {
      const len = ctx.generateOption(this.options.length);
      ctx.pushCode(`${wrappedBuf} = buffer.subarray(offset, offset + ${len});`);
      ctx.pushCode(`offset += ${len};`);
    }
    if (this.options.clone) {
      ctx.pushCode(`${wrappedBuf} = buffer.constructor.from(${wrappedBuf});`);
    }
    const tempBuf = ctx.generateTmpVariable();
    const tempOff = ctx.generateTmpVariable();
    const tempView = ctx.generateTmpVariable();
    const func = ctx.addImport(this.options.wrapper);
    ctx.pushCode(`${wrappedBuf} = ${func}.call(this, ${wrappedBuf}).subarray(0);`);
    ctx.pushCode(`var ${tempBuf} = buffer;`);
    ctx.pushCode(`var ${tempOff} = offset;`);
    ctx.pushCode(`var ${tempView} = dataView;`);
    ctx.pushCode(`buffer = ${wrappedBuf};`);
    ctx.pushCode(`offset = 0;`);
    ctx.pushCode(`dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.length);`);
    if (this.options.type instanceof Parser) {
      if (this.varName) {
        ctx.pushCode(`${wrapperVar} = {};`);
      }
      ctx.pushPath(this.varName);
      this.options.type.generate(ctx);
      ctx.popPath(this.varName);
    } else if (aliasRegistry.has(this.options.type)) {
      const tempVar = ctx.generateTmpVariable();
      ctx.pushCode(`var ${tempVar} = ${FUNCTION_PREFIX + this.options.type}(0);`);
      ctx.pushCode(`${wrapperVar} = ${tempVar}.result;`);
      if (this.options.type !== this.alias) {
        ctx.addReference(this.options.type);
      }
    }
    ctx.pushCode(`buffer = ${tempBuf};`);
    ctx.pushCode(`dataView = ${tempView};`);
    ctx.pushCode(`offset = ${tempOff};`);
  }
  generateFormatter(ctx, varName, formatter) {
    if (typeof formatter === "function") {
      const func = ctx.addImport(formatter);
      ctx.pushCode(`${varName} = ${func}.call(${ctx.generateVariable()}, ${varName});`);
    }
  }
  generatePointer(ctx) {
    const type2 = this.options.type;
    const offset = ctx.generateOption(this.options.offset);
    const tempVar = ctx.generateTmpVariable();
    const nestVar = ctx.generateVariable(this.varName);
    ctx.pushCode(`var ${tempVar} = offset;`);
    ctx.pushCode(`offset = ${offset};`);
    if (this.options.type instanceof Parser) {
      ctx.pushCode(`${nestVar} = {};`);
      if (ctx.useContextVariables) {
        const parentVar = ctx.generateVariable();
        ctx.pushCode(`${nestVar}.$parent = ${parentVar};`);
        ctx.pushCode(`${nestVar}.$root = ${parentVar}.$root;`);
      }
      ctx.pushPath(this.varName);
      this.options.type.generate(ctx);
      ctx.popPath(this.varName);
      if (ctx.useContextVariables) {
        ctx.pushCode(`delete ${nestVar}.$parent;`);
        ctx.pushCode(`delete ${nestVar}.$root;`);
      }
    } else if (aliasRegistry.has(this.options.type)) {
      const tempVar2 = ctx.generateTmpVariable();
      ctx.pushCode(`var ${tempVar2} = ${FUNCTION_PREFIX + this.options.type}(offset, {`);
      if (ctx.useContextVariables) {
        const parentVar = ctx.generateVariable();
        ctx.pushCode(`$parent: ${parentVar},`);
        ctx.pushCode(`$root: ${parentVar}.$root,`);
      }
      ctx.pushCode(`});`);
      ctx.pushCode(`${nestVar} = ${tempVar2}.result; offset = ${tempVar2}.offset;`);
      if (this.options.type !== this.alias) {
        ctx.addReference(this.options.type);
      }
    } else if (Object.keys(PRIMITIVE_SIZES).indexOf(this.options.type) >= 0) {
      const typeName = PRIMITIVE_NAMES[type2];
      const littleEndian = PRIMITIVE_LITTLE_ENDIANS[type2];
      ctx.pushCode(`${nestVar} = dataView.get${typeName}(offset, ${littleEndian});`);
      ctx.pushCode(`offset += ${PRIMITIVE_SIZES[type2]};`);
    }
    ctx.pushCode(`offset = ${tempVar};`);
  }
  generateSaveOffset(ctx) {
    const varName = ctx.generateVariable(this.varName);
    ctx.pushCode(`${varName} = offset`);
  }
}
var esm = {};
var AbortablePromiseCache$1 = {};
var abortcontrollerPonyfill = {};
var cjsPonyfill = {};
Object.defineProperty(cjsPonyfill, "__esModule", { value: true });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
var Emitter = /* @__PURE__ */ function() {
  function Emitter2() {
    _classCallCheck(this, Emitter2);
    Object.defineProperty(this, "listeners", {
      value: {},
      writable: true,
      configurable: true
    });
  }
  _createClass(Emitter2, [{
    key: "addEventListener",
    value: function addEventListener(type2, callback, options) {
      if (!(type2 in this.listeners)) {
        this.listeners[type2] = [];
      }
      this.listeners[type2].push({
        callback,
        options
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type2, callback) {
      if (!(type2 in this.listeners)) {
        return;
      }
      var stack = this.listeners[type2];
      for (var i = 0, l = stack.length; i < l; i++) {
        if (stack[i].callback === callback) {
          stack.splice(i, 1);
          return;
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (!(event.type in this.listeners)) {
        return;
      }
      var stack = this.listeners[event.type];
      var stackToCall = stack.slice();
      for (var i = 0, l = stackToCall.length; i < l; i++) {
        var listener = stackToCall[i];
        try {
          listener.callback.call(this, event);
        } catch (e) {
          Promise.resolve().then(function() {
            throw e;
          });
        }
        if (listener.options && listener.options.once) {
          this.removeEventListener(event.type, listener.callback);
        }
      }
      return !event.defaultPrevented;
    }
  }]);
  return Emitter2;
}();
var AbortSignal$1 = /* @__PURE__ */ function(_Emitter) {
  _inherits(AbortSignal2, _Emitter);
  var _super = _createSuper(AbortSignal2);
  function AbortSignal2() {
    var _this;
    _classCallCheck(this, AbortSignal2);
    _this = _super.call(this);
    if (!_this.listeners) {
      Emitter.call(_assertThisInitialized(_this));
    }
    Object.defineProperty(_assertThisInitialized(_this), "aborted", {
      value: false,
      writable: true,
      configurable: true
    });
    Object.defineProperty(_assertThisInitialized(_this), "onabort", {
      value: null,
      writable: true,
      configurable: true
    });
    Object.defineProperty(_assertThisInitialized(_this), "reason", {
      value: void 0,
      writable: true,
      configurable: true
    });
    return _this;
  }
  _createClass(AbortSignal2, [{
    key: "toString",
    value: function toString2() {
      return "[object AbortSignal]";
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (event.type === "abort") {
        this.aborted = true;
        if (typeof this.onabort === "function") {
          this.onabort.call(this, event);
        }
      }
      _get(_getPrototypeOf(AbortSignal2.prototype), "dispatchEvent", this).call(this, event);
    }
  }]);
  return AbortSignal2;
}(Emitter);
var AbortController$1 = /* @__PURE__ */ function() {
  function AbortController2() {
    _classCallCheck(this, AbortController2);
    Object.defineProperty(this, "signal", {
      value: new AbortSignal$1(),
      writable: true,
      configurable: true
    });
  }
  _createClass(AbortController2, [{
    key: "abort",
    value: function abort(reason) {
      var event;
      try {
        event = new Event("abort");
      } catch (e) {
        if (typeof document !== "undefined") {
          if (!document.createEvent) {
            event = document.createEventObject();
            event.type = "abort";
          } else {
            event = document.createEvent("Event");
            event.initEvent("abort", false, false);
          }
        } else {
          event = {
            type: "abort",
            bubbles: false,
            cancelable: false
          };
        }
      }
      var signalReason = reason;
      if (signalReason === void 0) {
        if (typeof document === "undefined") {
          signalReason = new Error("This operation was aborted");
          signalReason.name = "AbortError";
        } else {
          try {
            signalReason = new DOMException("signal is aborted without reason");
          } catch (err2) {
            signalReason = new Error("This operation was aborted");
            signalReason.name = "AbortError";
          }
        }
      }
      this.signal.reason = signalReason;
      this.signal.dispatchEvent(event);
    }
  }, {
    key: "toString",
    value: function toString2() {
      return "[object AbortController]";
    }
  }]);
  return AbortController2;
}();
if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
  AbortController$1.prototype[Symbol.toStringTag] = "AbortController";
  AbortSignal$1.prototype[Symbol.toStringTag] = "AbortSignal";
}
function polyfillNeeded(self2) {
  if (self2.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
    console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill");
    return true;
  }
  return typeof self2.Request === "function" && !self2.Request.prototype.hasOwnProperty("signal") || !self2.AbortController;
}
function abortableFetchDecorator(patchTargets) {
  if ("function" === typeof patchTargets) {
    patchTargets = {
      fetch: patchTargets
    };
  }
  var _patchTargets = patchTargets, fetch = _patchTargets.fetch, _patchTargets$Request = _patchTargets.Request, NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request, NativeAbortController = _patchTargets.AbortController, _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL, __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;
  if (!polyfillNeeded({
    fetch,
    Request: NativeRequest,
    AbortController: NativeAbortController,
    __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL
  })) {
    return {
      fetch,
      Request
    };
  }
  var Request = NativeRequest;
  if (Request && !Request.prototype.hasOwnProperty("signal") || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
    Request = function Request2(input, init2) {
      var signal;
      if (init2 && init2.signal) {
        signal = init2.signal;
        delete init2.signal;
      }
      var request = new NativeRequest(input, init2);
      if (signal) {
        Object.defineProperty(request, "signal", {
          writable: false,
          enumerable: false,
          configurable: true,
          value: signal
        });
      }
      return request;
    };
    Request.prototype = NativeRequest.prototype;
  }
  var realFetch = fetch;
  var abortableFetch = function abortableFetch2(input, init2) {
    var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init2 ? init2.signal : void 0;
    if (signal) {
      var abortError;
      try {
        abortError = new DOMException("Aborted", "AbortError");
      } catch (err2) {
        abortError = new Error("Aborted");
        abortError.name = "AbortError";
      }
      if (signal.aborted) {
        return Promise.reject(abortError);
      }
      var cancellation = new Promise(function(_, reject) {
        signal.addEventListener("abort", function() {
          return reject(abortError);
        }, {
          once: true
        });
      });
      if (init2 && init2.signal) {
        delete init2.signal;
      }
      return Promise.race([cancellation, realFetch(input, init2)]);
    }
    return realFetch(input, init2);
  };
  return {
    fetch: abortableFetch,
    Request
  };
}
cjsPonyfill.AbortController = AbortController$1;
cjsPonyfill.AbortSignal = AbortSignal$1;
cjsPonyfill.abortableFetch = abortableFetchDecorator;
Object.defineProperty(abortcontrollerPonyfill, "__esModule", { value: true });
abortcontrollerPonyfill.AbortSignal = abortcontrollerPonyfill.AbortController = void 0;
const cjs_ponyfill_1 = cjsPonyfill;
var getGlobal = function() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof commonjsGlobal !== "undefined") {
    return commonjsGlobal;
  }
  throw new Error("unable to locate global object");
};
let AbortController = typeof getGlobal().AbortController === "undefined" ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;
abortcontrollerPonyfill.AbortController = AbortController;
let AbortSignal = typeof getGlobal().AbortController === "undefined" ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;
abortcontrollerPonyfill.AbortSignal = AbortSignal;
var AggregateAbortController$1 = {};
Object.defineProperty(AggregateAbortController$1, "__esModule", { value: true });
const abortcontroller_ponyfill_1$1 = abortcontrollerPonyfill;
class NullSignal {
}
class AggregateAbortController {
  constructor() {
    this.signals = /* @__PURE__ */ new Set();
    this.abortController = new abortcontroller_ponyfill_1$1.AbortController();
  }
  /**
   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,
   *  will be treated as a null-signal, and this abortcontroller will no
   *  longer be abortable.
   */
  //@ts-ignore
  addSignal(signal = new NullSignal()) {
    if (this.signal.aborted) {
      throw new Error("cannot add a signal, already aborted!");
    }
    this.signals.add(signal);
    if (signal.aborted) {
      this.handleAborted(signal);
    } else if (typeof signal.addEventListener === "function") {
      signal.addEventListener("abort", () => {
        this.handleAborted(signal);
      });
    }
  }
  handleAborted(signal) {
    this.signals.delete(signal);
    if (this.signals.size === 0) {
      this.abortController.abort();
    }
  }
  get signal() {
    return this.abortController.signal;
  }
  abort() {
    this.abortController.abort();
  }
}
AggregateAbortController$1.default = AggregateAbortController;
var AggregateStatusReporter$1 = {};
Object.defineProperty(AggregateStatusReporter$1, "__esModule", { value: true });
class AggregateStatusReporter {
  constructor() {
    this.callbacks = /* @__PURE__ */ new Set();
  }
  addCallback(callback = () => {
  }) {
    this.callbacks.add(callback);
    callback(this.currentMessage);
  }
  callback(message) {
    this.currentMessage = message;
    this.callbacks.forEach((elt) => {
      elt(message);
    });
  }
}
AggregateStatusReporter$1.default = AggregateStatusReporter;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(AbortablePromiseCache$1, "__esModule", { value: true });
const abortcontroller_ponyfill_1 = abortcontrollerPonyfill;
const AggregateAbortController_1 = __importDefault$1(AggregateAbortController$1);
const AggregateStatusReporter_1 = __importDefault$1(AggregateStatusReporter$1);
class AbortablePromiseCache {
  constructor({ fill, cache: cache2 }) {
    if (typeof fill !== "function") {
      throw new TypeError("must pass a fill function");
    }
    if (typeof cache2 !== "object") {
      throw new TypeError("must pass a cache object");
    }
    if (typeof cache2.get !== "function" || typeof cache2.set !== "function" || typeof cache2.delete !== "function") {
      throw new TypeError("cache must implement get(key), set(key, val), and and delete(key)");
    }
    this.cache = cache2;
    this.fillCallback = fill;
  }
  static isAbortException(exception) {
    return (
      // DOMException
      exception.name === "AbortError" || // standard-ish non-DOM abort exception
      //@ts-ignore
      exception.code === "ERR_ABORTED" || // stringified DOMException
      exception.message === "AbortError: aborted" || // stringified standard-ish exception
      exception.message === "Error: aborted"
    );
  }
  evict(key, entry) {
    if (this.cache.get(key) === entry) {
      this.cache.delete(key);
    }
  }
  fill(key, data2, signal, statusCallback) {
    const aborter = new AggregateAbortController_1.default();
    const statusReporter = new AggregateStatusReporter_1.default();
    statusReporter.addCallback(statusCallback);
    const newEntry = {
      aborter,
      promise: this.fillCallback(data2, aborter.signal, (message) => {
        statusReporter.callback(message);
      }),
      settled: false,
      statusReporter,
      get aborted() {
        return this.aborter.signal.aborted;
      }
    };
    newEntry.aborter.addSignal(signal);
    newEntry.aborter.signal.addEventListener("abort", () => {
      if (!newEntry.settled) {
        this.evict(key, newEntry);
      }
    });
    newEntry.promise.then(() => {
      newEntry.settled = true;
    }, () => {
      newEntry.settled = true;
      this.evict(key, newEntry);
    }).catch((e) => {
      console.error(e);
      throw e;
    });
    this.cache.set(key, newEntry);
  }
  static checkSinglePromise(promise, signal) {
    function checkForSingleAbort() {
      if (signal && signal.aborted) {
        throw Object.assign(new Error("aborted"), { code: "ERR_ABORTED" });
      }
    }
    return promise.then((result) => {
      checkForSingleAbort();
      return result;
    }, (error) => {
      checkForSingleAbort();
      throw error;
    });
  }
  has(key) {
    return this.cache.has(key);
  }
  /**
   * Callback for getting status of the pending async
   *
   * @callback statusCallback
   * @param {any} status, current status string or message object
   */
  /**
   * @param {any} key cache key to use for this request
   * @param {any} data data passed as the first argument to the fill callback
   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request
   * @param {statusCallback} a callback to get the current status of a pending async operation
   */
  get(key, data2, signal, statusCallback) {
    if (!signal && data2 instanceof abortcontroller_ponyfill_1.AbortSignal) {
      throw new TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");
    }
    const cacheEntry = this.cache.get(key);
    if (cacheEntry) {
      if (cacheEntry.aborted && !cacheEntry.settled) {
        this.evict(key, cacheEntry);
        return this.get(key, data2, signal, statusCallback);
      }
      if (cacheEntry.settled) {
        return cacheEntry.promise;
      }
      cacheEntry.aborter.addSignal(signal);
      cacheEntry.statusReporter.addCallback(statusCallback);
      return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);
    }
    this.fill(key, data2, signal, statusCallback);
    return AbortablePromiseCache.checkSinglePromise(
      //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-
      //eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      this.cache.get(key).promise,
      signal
    );
  }
  /**
   * delete the given entry from the cache. if it exists and its fill request has
   * not yet settled, the fill will be signaled to abort.
   *
   * @param {any} key
   */
  delete(key) {
    const cachedEntry = this.cache.get(key);
    if (cachedEntry) {
      if (!cachedEntry.settled) {
        cachedEntry.aborter.abort();
      }
      this.cache.delete(key);
    }
  }
  /**
   * Clear all requests from the cache. Aborts any that have not settled.
   * @returns {number} count of entries deleted
   */
  clear() {
    const keyIter = this.cache.keys();
    let deleteCount = 0;
    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {
      this.delete(result.value);
      deleteCount += 1;
    }
    return deleteCount;
  }
}
AbortablePromiseCache$1.default = AbortablePromiseCache;
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(esm, "__esModule", { value: true });
const AbortablePromiseCache_1 = __importDefault(AbortablePromiseCache$1);
var _default = esm.default = AbortablePromiseCache_1.default;
class Range {
  constructor(arg1, arg2) {
    this.ranges = arguments.length === 2 ? [{ min: arg1, max: arg2 }] : 0 in arg1 ? Object.assign({}, arg1) : [arg1];
  }
  min() {
    return this.ranges[0].min;
  }
  max() {
    return this.ranges[this.ranges.length - 1].max;
  }
  contains(pos) {
    for (let s = 0; s < this.ranges.length; s += 1) {
      const r = this.ranges[s];
      if (r.min <= pos && r.max >= pos) {
        return true;
      }
    }
    return false;
  }
  isContiguous() {
    return this.ranges.length > 1;
  }
  getRanges() {
    return this.ranges.map((r) => new Range(r.min, r.max));
  }
  toString() {
    return this.ranges.map((r) => `[${r.min}-${r.max}]`).join(",");
  }
  union(s1) {
    const ranges = this.getRanges().concat(s1.getRanges()).sort(this.rangeOrder);
    const oranges = [];
    let current = ranges[0];
    for (let i = 1; i < ranges.length; i += 1) {
      const nxt = ranges[i];
      if (nxt.min() > current.max() + 1) {
        oranges.push(current);
        current = nxt;
      } else if (nxt.max() > current.max()) {
        current = new Range(current.min(), nxt.max());
      }
    }
    oranges.push(current);
    if (oranges.length === 1) {
      return oranges[0];
    }
    return new Range(oranges);
  }
  intersection(arg) {
    let s0 = this;
    let s1 = arg;
    const r0 = this.ranges();
    const r1 = s1.ranges();
    const l0 = r0.length;
    const l1 = r1.length;
    let i0 = 0;
    let i1 = 0;
    const or = [];
    while (i0 < l0 && i1 < l1) {
      s0 = r0[i0];
      s1 = r1[i1];
      const lapMin = Math.max(s0.min(), s1.min());
      const lapMax = Math.min(s0.max(), s1.max());
      if (lapMax >= lapMin) {
        or.push(new Range(lapMin, lapMax));
      }
      if (s0.max() > s1.max()) {
        i1 += 1;
      } else {
        i0 += 1;
      }
    }
    if (or.length === 0) {
      throw new Error("found range of length 0");
    }
    if (or.length === 1) {
      return or[0];
    }
    return new Range(or);
  }
  coverage() {
    let tot = 0;
    const rl = this.ranges();
    for (let ri = 0; ri < rl.length; ri += 1) {
      const r = rl[ri];
      tot += r.max() - r.min() + 1;
    }
    return tot;
  }
  rangeOrder(tmpa, tmpb) {
    let a = tmpa;
    let b = tmpb;
    if (arguments.length < 2) {
      b = a;
      a = this;
    }
    if (a.min() < b.min()) {
      return -1;
    }
    if (a.min() > b.min()) {
      return 1;
    }
    if (a.max() < b.max()) {
      return -1;
    }
    if (b.max() > a.max()) {
      return 1;
    }
    return 0;
  }
}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
const send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
const send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
const bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
const bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
const gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m2;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m2 = s.heap[--h];
      if (m2 > max_code) {
        continue;
      }
      if (tree[m2 * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
        tree[m2 * 2 + 1] = bits;
      }
      n--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
const tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
const bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
const smaller = (tree, n, m2, depth) => {
  const _n2 = n * 2;
  const _m2 = m2 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m2];
};
const pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
const compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
const build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m2;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m2 = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m2;
    tree[node * 2] = tree[n * 2] + tree[m2 * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m2] ? s.depth[n] : s.depth[m2]) + 1;
    tree[n * 2 + 1] = tree[m2 * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
const scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
const _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
const zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
const slide_hash = (s) => {
  let n, m2;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m2 = s.head[--p];
    s.head[p] = m2 >= wsize ? m2 - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m2 = s.prev[--p];
    s.prev[p] = m2 >= wsize ? m2 - wsize : 0;
  } while (--n);
};
let HASH_ZLIB = (s, prev, data2) => (prev << s.hash_shift ^ data2) & s.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
const flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
const putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
const read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
const longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
const fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
const deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
const deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
const lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy2 = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy2), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy2;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy2;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max2) => {
  const len = max2 || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max2));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max2) => {
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  let pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data2 === "string") {
    strm.input = strings.string2buf(data2);
  } else if (toString$1.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type2, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min2 = 0, max2 = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min2 = 1; min2 < max2; min2++) {
    if (count[min2] !== 0) {
      break;
    }
  }
  if (root < min2) {
    root = min2;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type2 === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min2;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min2 = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min2;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src, end, copy2) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy2 >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    state.window.set(src.subarray(end - copy2, end - copy2 + dist), state.wnext);
    copy2 -= dist;
    if (copy2) {
      state.window.set(src.subarray(end - copy2, end), 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy2;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy2
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy2), put);
            have -= copy2;
            next += copy2;
            left -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy2 = _out - left;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left) {
            copy2 = left;
          }
          left -= copy2;
          state.length -= copy2;
          do {
            output[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString$2 = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString$2.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data2[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflateRaw_1 = inflateRaw;
function unzip(input) {
  return inflateRaw_1(input.subarray(2));
}
class AbortError extends Error {
  constructor(message) {
    super(message);
    this.code = "ERR_ABORTED";
  }
}
function groupBlocks(blocks) {
  blocks.sort((b0, b1) => Number(b0.offset) - Number(b1.offset));
  const blockGroups = [];
  let lastBlock;
  let lastBlockEnd;
  for (let i = 0; i < blocks.length; i += 1) {
    if (lastBlock && lastBlockEnd && Number(blocks[i].offset) - lastBlockEnd <= 2e3) {
      lastBlock.length = BigInt(Number(lastBlock.length) + Number(blocks[i].length) - lastBlockEnd + Number(blocks[i].offset));
      lastBlock.blocks.push(blocks[i]);
    } else {
      blockGroups.push(lastBlock = {
        blocks: [blocks[i]],
        length: blocks[i].length,
        offset: blocks[i].offset
      });
    }
    lastBlockEnd = Number(lastBlock.offset) + Number(lastBlock.length);
  }
  return blockGroups;
}
function checkAbortSignal(signal) {
  if (!signal) {
    return;
  }
  if (signal.aborted) {
    if (typeof DOMException !== "undefined") {
      throw new DOMException("aborted", "AbortError");
    } else {
      const e = new AbortError("aborted");
      e.code = "ERR_ABORTED";
      throw e;
    }
  }
}
const BIG_WIG_TYPE_GRAPH = 1;
const BIG_WIG_TYPE_VSTEP = 2;
const BIG_WIG_TYPE_FSTEP = 3;
function coordFilter(s1, e1, s2, e2) {
  return s1 < e2 && e1 >= s2;
}
function getParsers$1(isBigEndian) {
  const le = isBigEndian ? "big" : "little";
  const summaryParser = new Parser().endianess(le).uint32("chromId").uint32("start").uint32("end").uint32("validCnt").floatle("minScore").floatle("maxScore").floatle("sumData").floatle("sumSqData").saveOffset("offset");
  const leafParser = new Parser().endianess(le).uint8("isLeaf").skip(1).uint16("cnt").choice({
    tag: "isLeaf",
    choices: {
      1: new Parser().endianess(le).array("blocksToFetch", {
        length: "cnt",
        type: new Parser().endianess(le).uint32("startChrom").uint32("startBase").uint32("endChrom").uint32("endBase").uint64("blockOffset").uint64("blockSize").saveOffset("offset")
      }),
      0: new Parser().array("recurOffsets", {
        length: "cnt",
        type: new Parser().endianess(le).uint32("startChrom").uint32("startBase").uint32("endChrom").uint32("endBase").uint64("blockOffset").saveOffset("offset")
      })
    }
  });
  const bigBedParser = new Parser().endianess(le).uint32("chromId").int32("start").int32("end").string("rest", {
    zeroTerminated: true
  }).saveOffset("offset");
  const bigWigParser = new Parser().endianess(le).skip(4).int32("blockStart").skip(4).uint32("itemStep").uint32("itemSpan").uint8("blockType").skip(1).uint16("itemCount").choice({
    tag: "blockType",
    choices: {
      [BIG_WIG_TYPE_FSTEP]: new Parser().array("items", {
        length: "itemCount",
        type: new Parser().floatle("score")
      }),
      [BIG_WIG_TYPE_VSTEP]: new Parser().array("items", {
        length: "itemCount",
        type: new Parser().endianess(le).int32("start").floatle("score")
      }),
      [BIG_WIG_TYPE_GRAPH]: new Parser().array("items", {
        length: "itemCount",
        type: new Parser().endianess(le).int32("start").int32("end").floatle("score")
      })
    }
  });
  return {
    bigWigParser,
    bigBedParser,
    summaryParser,
    leafParser
  };
}
class BlockView {
  constructor(bbi, refsByName, cirTreeOffset, isBigEndian, isCompressed, blockType) {
    this.bbi = bbi;
    this.refsByName = refsByName;
    this.cirTreeOffset = cirTreeOffset;
    this.isBigEndian = isBigEndian;
    this.isCompressed = isCompressed;
    this.blockType = blockType;
    this.featureCache = new _default({
      cache: new QuickLRU({ maxSize: 1e3 }),
      fill: async (requestData, signal) => {
        const len = Number(requestData.length);
        const off = Number(requestData.offset);
        const { buffer } = await this.bbi.read(Buffer2.alloc(len), 0, len, off, {
          signal
        });
        return buffer;
      }
    });
    if (!(cirTreeOffset >= 0)) {
      throw new Error("invalid cirTreeOffset!");
    }
    const parsers = getParsers$1(isBigEndian);
    this.leafParser = parsers.leafParser;
    this.bigBedParser = parsers.bigBedParser;
  }
  async readWigData(chrName, start, end, observer, opts) {
    try {
      const { refsByName, bbi, cirTreeOffset, isBigEndian } = this;
      const chrId = refsByName[chrName];
      if (chrId === void 0) {
        observer.complete();
      }
      const request = { chrId, start, end };
      if (!this.cirTreePromise) {
        this.cirTreePromise = bbi.read(Buffer2.alloc(48), 0, 48, Number(cirTreeOffset), opts);
      }
      const { buffer } = await this.cirTreePromise;
      const cirBlockSize = isBigEndian ? buffer.readUInt32BE(4) : buffer.readUInt32LE(4);
      let blocksToFetch = [];
      let outstanding = 0;
      const cirFobRecur2 = (cirBlockData, offset, level) => {
        try {
          const data2 = cirBlockData.subarray(offset);
          const p = this.leafParser.parse(data2);
          if (p.blocksToFetch) {
            blocksToFetch = blocksToFetch.concat(p.blocksToFetch.filter(filterFeats).map((l) => ({
              offset: l.blockOffset,
              length: l.blockSize
            })));
          }
          if (p.recurOffsets) {
            const recurOffsets = p.recurOffsets.filter(filterFeats).map((l) => Number(l.blockOffset));
            if (recurOffsets.length > 0) {
              cirFobRecur(recurOffsets, level + 1);
            }
          }
        } catch (e) {
          observer.error(e);
        }
      };
      const filterFeats = (b) => {
        const { startChrom, startBase, endChrom, endBase } = b;
        return (startChrom < chrId || startChrom === chrId && startBase <= end) && (endChrom > chrId || endChrom === chrId && endBase >= start);
      };
      const cirFobStartFetch = async (off, fr, level) => {
        try {
          const length = fr.max() - fr.min();
          const offset = fr.min();
          const resultBuffer = await this.featureCache.get(`${length}_${offset}`, { length, offset }, opts.signal);
          for (let i = 0; i < off.length; i += 1) {
            if (fr.contains(off[i])) {
              cirFobRecur2(resultBuffer, off[i] - offset, level);
              outstanding -= 1;
              if (outstanding === 0) {
                this.readFeatures(observer, blocksToFetch, { ...opts, request });
              }
            }
          }
        } catch (e) {
          observer.error(e);
        }
      };
      const cirFobRecur = (offset, level) => {
        try {
          outstanding += offset.length;
          const maxCirBlockSpan = 4 + Number(cirBlockSize) * 32;
          let spans = new Range(offset[0], offset[0] + maxCirBlockSpan);
          for (let i = 1; i < offset.length; i += 1) {
            const blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);
            spans = spans.union(blockSpan);
          }
          spans.getRanges().map((fr) => cirFobStartFetch(offset, fr, level));
        } catch (e) {
          observer.error(e);
        }
      };
      return cirFobRecur([Number(cirTreeOffset) + 48], 1);
    } catch (e) {
      observer.error(e);
    }
  }
  parseSummaryBlock(buffer, startOffset, request) {
    const features = [];
    let offset = startOffset;
    const dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.length);
    while (offset < buffer.byteLength) {
      const chromId = dataView.getUint32(offset, true);
      offset += 4;
      const start = dataView.getUint32(offset, true);
      offset += 4;
      const end = dataView.getUint32(offset, true);
      offset += 4;
      const validCnt = dataView.getUint32(offset, true);
      offset += 4;
      const minScore = dataView.getFloat32(offset, true);
      offset += 4;
      const maxScore = dataView.getFloat32(offset, true);
      offset += 4;
      const sumData = dataView.getFloat32(offset, true);
      offset += 4;
      offset += 4;
      if (request ? chromId === request.chrId && coordFilter(start, end, request.start, request.end) : true) {
        features.push({
          start,
          end,
          maxScore,
          minScore,
          summary: true,
          score: sumData / (validCnt || 1)
        });
      }
    }
    return features;
  }
  parseBigBedBlock(data2, startOffset, offset, request) {
    const items2 = [];
    let currOffset = startOffset;
    while (currOffset < data2.byteLength) {
      const res = this.bigBedParser.parse(data2.subarray(currOffset));
      items2.push({ ...res, uniqueId: `bb-${offset + currOffset}` });
      currOffset += res.offset;
    }
    return request ? items2.filter((f) => coordFilter(f.start, f.end, request.start, request.end)) : items2;
  }
  parseBigWigBlock(buffer, startOffset, request) {
    const b = buffer.subarray(startOffset);
    const dataView = new DataView(b.buffer, b.byteOffset, b.length);
    let offset = 0;
    offset += 4;
    const blockStart = dataView.getInt32(offset, true);
    offset += 8;
    const itemStep = dataView.getUint32(offset, true);
    offset += 4;
    const itemSpan = dataView.getUint32(offset, true);
    offset += 4;
    const blockType = dataView.getUint8(offset);
    offset += 2;
    const itemCount = dataView.getUint16(offset, true);
    offset += 2;
    const items2 = new Array(itemCount);
    switch (blockType) {
      case 1:
        for (let i = 0; i < itemCount; i++) {
          const start = dataView.getInt32(offset, true);
          offset += 4;
          const end = dataView.getInt32(offset, true);
          offset += 4;
          const score = dataView.getFloat32(offset, true);
          offset += 4;
          items2[i] = { start, end, score };
        }
        break;
      case 2:
        for (let i = 0; i < itemCount; i++) {
          const start = dataView.getInt32(offset, true);
          offset += 4;
          const score = dataView.getFloat32(offset, true);
          offset += 4;
          items2[i] = { score, start, end: start + itemSpan };
        }
        break;
      case 3:
        for (let i = 0; i < itemCount; i++) {
          const score = dataView.getFloat32(offset, true);
          offset += 4;
          const start = blockStart + i * itemStep;
          items2[i] = { score, start, end: start + itemSpan };
        }
        break;
    }
    return request ? items2.filter((f) => coordFilter(f.start, f.end, request.start, request.end)) : items2;
  }
  async readFeatures(observer, blocks, opts = {}) {
    try {
      const { blockType, isCompressed } = this;
      const { signal, request } = opts;
      const blockGroupsToFetch = groupBlocks(blocks);
      checkAbortSignal(signal);
      await Promise.all(blockGroupsToFetch.map(async (blockGroup) => {
        checkAbortSignal(signal);
        const { length, offset } = blockGroup;
        const data2 = await this.featureCache.get(`${length}_${offset}`, blockGroup, signal);
        blockGroup.blocks.forEach((block) => {
          checkAbortSignal(signal);
          let blockOffset = Number(block.offset) - Number(blockGroup.offset);
          let resultData = data2;
          if (isCompressed) {
            resultData = unzip(data2.subarray(blockOffset));
            blockOffset = 0;
          }
          checkAbortSignal(signal);
          switch (blockType) {
            case "summary":
              observer.next(this.parseSummaryBlock(resultData, blockOffset, request));
              break;
            case "bigwig":
              observer.next(this.parseBigWigBlock(resultData, blockOffset, request));
              break;
            case "bigbed":
              observer.next(this.parseBigBedBlock(resultData, blockOffset, Number(block.offset) * (1 << 8), request));
              break;
            default:
              console.warn(`Don't know what to do with ${blockType}`);
          }
        });
      }));
      observer.complete();
    } catch (e) {
      observer.error(e);
    }
  }
}
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err2, i) {
      return i + 1 + ") " + err2.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err2) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err2 instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err2.errors));
              } else {
                errors.push(err2);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config$2 = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err2) {
  timeoutProvider.setTimeout(function() {
    {
      throw err2;
    }
  });
}
function noop() {
}
function errorContext(cb) {
  {
    cb();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped)
      ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err2) {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._error(err2);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err2) {
    try {
      this.destination.error(err2);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err2) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err2);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err2);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config$2.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err2) {
  throw err2;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x) {
  return x;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe2) {
    if (subscribe2) {
      this._subscribe = subscribe2;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err2) {
      sink.error(err2);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err2) {
            reject(err2);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err2) {
        return reject(err2);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe2) {
    return new Observable2(subscribe2);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config$2.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init2) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init2(liftedSource, this);
        } catch (err2) {
          this.error(err2);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err2) {
        destination.error(err2);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err2) {
      try {
        onError(err2);
      } catch (err3) {
        destination.error(err3);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve2, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve2(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve2(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}
function reduce(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
}
var arrReducer = function(arr, value) {
  return arr.push(value), arr;
};
function toArray() {
  return operate(function(source, subscriber) {
    reduce(arrReducer, [])(source).subscribe(subscriber);
  });
}
const BIG_WIG_MAGIC = -2003829722;
const BIG_BED_MAGIC = -2021002517;
function toString(arr) {
  return new TextDecoder().decode(arr);
}
function getParsers(isBE) {
  const le = isBE ? "big" : "little";
  const headerParser = new Parser().endianess(le).int32("magic").uint16("version").uint16("numZoomLevels").uint64("chromTreeOffset").uint64("unzoomedDataOffset").uint64("unzoomedIndexOffset").uint16("fieldCount").uint16("definedFieldCount").uint64("asOffset").uint64("totalSummaryOffset").uint32("uncompressBufSize").uint64("extHeaderOffset").array("zoomLevels", {
    length: "numZoomLevels",
    type: new Parser().endianess(le).uint32("reductionLevel").uint32("reserved").uint64("dataOffset").uint64("indexOffset")
  });
  const totalSummaryParser = new Parser().endianess(le).uint64("basesCovered").doublele("scoreMin").doublele("scoreMax").doublele("scoreSum").doublele("scoreSumSquares");
  const chromTreeParser = new Parser().endianess(le).uint32("magic").uint32("blockSize").uint32("keySize").uint32("valSize").uint64("itemCount");
  const isLeafNode = new Parser().endianess(le).uint8("isLeafNode").skip(1).uint16("cnt").saveOffset("offset");
  return {
    chromTreeParser,
    totalSummaryParser,
    headerParser,
    isLeafNode
  };
}
class BBI {
  /* fetch and parse header information from a bigwig or bigbed file
   * @param abortSignal - abort the operation, can be null
   * @return a Header object
   */
  getHeader(opts = {}) {
    const options = "aborted" in opts ? { signal: opts } : opts;
    if (!this.headerP) {
      this.headerP = this._getHeader(options).catch((e) => {
        this.headerP = void 0;
        throw e;
      });
    }
    return this.headerP;
  }
  /*
   * @param filehandle - a filehandle from generic-filehandle or implementing something similar to the node10 fs.promises API
   * @param path - a Local file path as a string
   * @param url - a URL string
   * @param renameRefSeqs - an optional method to rename the internal reference sequences using a mapping function
   */
  constructor(options = {}) {
    const { filehandle, renameRefSeqs = (s) => s, path, url } = options;
    this.renameRefSeqs = renameRefSeqs;
    if (filehandle) {
      this.bbi = filehandle;
    } else if (url) {
      this.bbi = new RemoteFile$1(url);
    } else if (path) {
      this.bbi = new LocalFile(path);
    } else {
      throw new Error("no file given");
    }
  }
  async _getHeader(opts) {
    const header = await this._getMainHeader(opts);
    const chroms = await this._readChromTree(header, opts);
    return { ...header, ...chroms };
  }
  async _getMainHeader(opts, requestSize = 2e3) {
    const { buffer } = await this.bbi.read(Buffer2.alloc(requestSize), 0, requestSize, 0, opts);
    const isBigEndian = this._isBigEndian(buffer);
    const ret = getParsers(isBigEndian);
    const header = ret.headerParser.parse(buffer);
    const { magic, asOffset, totalSummaryOffset } = header;
    header.fileType = magic === BIG_BED_MAGIC ? "bigbed" : "bigwig";
    if (asOffset > requestSize || totalSummaryOffset > requestSize) {
      return this._getMainHeader(opts, requestSize * 2);
    }
    if (asOffset) {
      const off = Number(header.asOffset);
      header.autoSql = toString(buffer.subarray(off, buffer.indexOf(0, off)));
    }
    if (header.totalSummaryOffset > requestSize) {
      return this._getMainHeader(opts, requestSize * 2);
    }
    if (header.totalSummaryOffset) {
      const tail = buffer.subarray(Number(header.totalSummaryOffset));
      const sum2 = ret.totalSummaryParser.parse(tail);
      header.totalSummary = { ...sum2, basesCovered: Number(sum2.basesCovered) };
    }
    return { ...header, isBigEndian };
  }
  _isBigEndian(buffer) {
    let ret = buffer.readInt32LE(0);
    if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
      return false;
    }
    ret = buffer.readInt32BE(0);
    if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
      return true;
    }
    throw new Error("not a BigWig/BigBed file");
  }
  // todo: add progress if long running
  async _readChromTree(header, opts) {
    const isBE = header.isBigEndian;
    const le = isBE ? "big" : "little";
    const refsByNumber = [];
    const refsByName = {};
    let unzoomedDataOffset = Number(header.unzoomedDataOffset);
    const chromTreeOffset = Number(header.chromTreeOffset);
    while (unzoomedDataOffset % 4 !== 0) {
      unzoomedDataOffset += 1;
    }
    const off = unzoomedDataOffset - chromTreeOffset;
    const { buffer } = await this.bbi.read(Buffer2.alloc(off), 0, off, Number(chromTreeOffset), opts);
    const p = getParsers(isBE);
    const { keySize } = p.chromTreeParser.parse(buffer);
    const leafNodeParser = new Parser().endianess(le).string("key", { stripNull: true, length: keySize }).uint32("refId").uint32("refSize").saveOffset("offset");
    const nonleafNodeParser = new Parser().endianess(le).skip(keySize).uint64("childOffset").saveOffset("offset");
    const rootNodeOffset = 32;
    const bptReadNode = async (currentOffset) => {
      let offset = currentOffset;
      if (offset >= buffer.length) {
        throw new Error("reading beyond end of buffer");
      }
      const ret = p.isLeafNode.parse(buffer.subarray(offset));
      const { isLeafNode, cnt } = ret;
      offset += ret.offset;
      if (isLeafNode) {
        for (let n = 0; n < cnt; n += 1) {
          const leafRet = leafNodeParser.parse(buffer.subarray(offset));
          offset += leafRet.offset;
          const { key, refId, refSize } = leafRet;
          const refRec = { name: key, id: refId, length: refSize };
          refsByName[this.renameRefSeqs(key)] = refId;
          refsByNumber[refId] = refRec;
        }
      } else {
        const nextNodes = [];
        for (let n = 0; n < cnt; n += 1) {
          const nonleafRet = nonleafNodeParser.parse(buffer.subarray(offset));
          const { childOffset } = nonleafRet;
          offset += nonleafRet.offset;
          nextNodes.push(bptReadNode(Number(childOffset) - Number(chromTreeOffset)));
        }
        await Promise.all(nextNodes);
      }
    };
    await bptReadNode(rootNodeOffset);
    return {
      refsByName,
      refsByNumber
    };
  }
  /*
   * fetches the "unzoomed" view of the bigwig data. this is the default for bigbed
   * @param abortSignal - a signal to optionally abort this operation
   */
  async getUnzoomedView(opts) {
    const { unzoomedIndexOffset, refsByName, uncompressBufSize, isBigEndian, fileType } = await this.getHeader(opts);
    return new BlockView(this.bbi, refsByName, unzoomedIndexOffset, isBigEndian, uncompressBufSize > 0, fileType);
  }
  /**
   * Gets features from a BigWig file
   *
   * @param refName - The chromosome name
   * @param start - The start of a region
   * @param end - The end of a region
   * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use
   */
  async getFeatureStream(refName, start, end, opts = {
    scale: 1
  }) {
    await this.getHeader(opts);
    const chrName = this.renameRefSeqs(refName);
    let view;
    if (opts.basesPerSpan) {
      view = await this.getView(1 / opts.basesPerSpan, opts);
    } else if (opts.scale) {
      view = await this.getView(opts.scale, opts);
    } else {
      view = await this.getView(1, opts);
    }
    if (!view) {
      throw new Error("unable to get block view for data");
    }
    return new Observable((observer) => {
      view.readWigData(chrName, start, end, observer, opts);
    });
  }
  async getFeatures(refName, start, end, opts = {
    scale: 1
  }) {
    const ob = await this.getFeatureStream(refName, start, end, opts);
    const ret = await firstValueFrom(ob.pipe(toArray()));
    return ret.flat();
  }
}
class BigWig extends BBI {
  /**
   * Retrieves a BlockView of a specific zoomLevel
   *
   * @param scale - number
   * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use
   */
  async getView(scale, opts) {
    const { zoomLevels, refsByName, fileSize, isBigEndian, uncompressBufSize } = await this.getHeader(opts);
    const basesPerPx = 1 / scale;
    let maxLevel = zoomLevels.length;
    if (!fileSize) {
      maxLevel -= 1;
    }
    for (let i = maxLevel; i >= 0; i -= 1) {
      const zh = zoomLevels[i];
      if (zh && zh.reductionLevel <= 2 * basesPerPx) {
        const indexOffset = Number(zh.indexOffset);
        return new BlockView(this.bbi, refsByName, indexOffset, isBigEndian, uncompressBufSize > 0, "summary");
      }
    }
    return this.getUnzoomedView(opts);
  }
}
function BigWigDataFetcher(HGC, dataConfig) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  const cls = class BigWigDataFetcherClass {
    constructor() {
      __publicField(this, "dataConfig");
      __publicField(this, "bwFileHeader");
      __publicField(this, "bwFile");
      __publicField(this, "TILE_SIZE");
      __publicField(this, "errorTxt");
      __publicField(this, "dataPromises");
      __publicField(this, "chromSizes");
      __publicField(this, "assembly");
      __publicField(this, "tilesetInfoLoading");
      this.dataConfig = dataConfig;
      this.assembly = this.dataConfig.assembly;
      this.bwFileHeader = null;
      this.bwFile = null;
      this.TILE_SIZE = 1024;
      this.errorTxt = "";
      this.dataPromises = [];
      const chromosomeSizes = computeChromSizes(this.assembly).size;
      const chromosomeCumPositions = [];
      const chromosomePositions = {};
      let prevEndPosition = 0;
      Object.keys(computeChromSizes(this.assembly).size).forEach((chrStr, i) => {
        const positionInfo = {
          id: i,
          chr: chrStr,
          pos: prevEndPosition
        };
        chromosomeCumPositions.push(positionInfo);
        chromosomePositions[chrStr] = positionInfo;
        prevEndPosition += computeChromSizes(this.assembly).size[chrStr];
      });
      this.chromSizes = {
        chrToAbs: (chrom, chromPos) => this.chromSizes.chrPositions[chrom].pos + chromPos,
        cumPositions: chromosomeCumPositions,
        chrPositions: chromosomePositions,
        totalLength: prevEndPosition,
        chromLengths: chromosomeSizes
      };
      this.dataPromises.push(this.loadBBI(dataConfig));
    }
    async loadBBI(dataConfig2) {
      if (dataConfig2.url) {
        this.bwFile = new BigWig({
          filehandle: new RemoteFile(dataConfig2.url, { overrides: dataConfig2.urlFetchOptions })
        });
        return this.bwFile.getHeader().then((h) => {
          this.bwFileHeader = h;
        });
      } else {
        console.error('Please enter a "url" field to the data config');
        return null;
      }
    }
    tilesetInfo(callback) {
      this.tilesetInfoLoading = true;
      return Promise.all(this.dataPromises).then(() => {
        this.tilesetInfoLoading = false;
        const totalLength = this.chromSizes.totalLength;
        const retVal = {
          tile_size: this.TILE_SIZE,
          max_zoom: Math.ceil(Math.log(totalLength / this.TILE_SIZE) / Math.log(2)),
          max_width: 2 ** Math.ceil(Math.log(totalLength) / Math.log(2)),
          min_pos: [0],
          max_pos: [totalLength]
        };
        if (callback) {
          callback(retVal);
        }
        return retVal;
      }).catch((err2) => {
        this.tilesetInfoLoading = false;
        console.error(err2);
        if (callback) {
          callback({
            error: `Error parsing bigwig: ${err2}`
          });
        }
        return null;
      });
    }
    fetchTilesDebounced(receivedTiles, tileIds) {
      const tiles = {};
      const validTileIds = [];
      const tilePromises = [];
      for (const tileId of tileIds) {
        const parts = tileId.split(".");
        const z = parseInt(parts[0], 10);
        const x = parseInt(parts[1], 10);
        if (Number.isNaN(x) || Number.isNaN(z)) {
          console.warn("Invalid tile zoom or position:", z, x);
          continue;
        }
        validTileIds.push(tileId);
        tilePromises.push(this.tile(z, x));
      }
      Promise.all(tilePromises).then((values) => {
        for (let i = 0; i < values.length; i++) {
          const validTileId = validTileIds[i];
          tiles[validTileId] = values[i];
          tiles[validTileId].tilePositionId = validTileId;
        }
        receivedTiles(tiles);
      });
      return tiles;
    }
    async tile(z, x) {
      const tsInfo = await this.tilesetInfo();
      const tileWidth = +tsInfo.max_width / 2 ** +z;
      const recordPromises = [];
      const tile = {
        tilePos: [x],
        tileId: `bigwig.${z}.${x}`,
        zoomLevel: z
      };
      const minXOriginal = tsInfo.min_pos[0] + x * tileWidth;
      let minX = minXOriginal;
      const maxX = tsInfo.min_pos[0] + (x + 1) * tileWidth;
      const basesPerPixel = this.determineScale(minX, maxX);
      const basesPerBin = (maxX - minX) / this.TILE_SIZE;
      const binStarts = [];
      for (let i = 0; i < this.TILE_SIZE; i++) {
        binStarts.push(minX + i * basesPerBin);
      }
      const { chromLengths, cumPositions } = this.chromSizes;
      cumPositions.forEach((cumPos) => {
        const chromName = cumPos.chr;
        const chromStart = cumPos.pos;
        const chromEnd = cumPos.pos + chromLengths[chromName];
        let startPos, endPos;
        if (chromStart <= minX && minX < chromEnd) {
          if (maxX > chromEnd) {
            startPos = minX - chromStart;
            endPos = chromEnd - chromStart;
            recordPromises.push(
              this.bwFile.getFeatures(chromName, startPos, endPos, {
                scale: 1 / basesPerPixel
              }).then((values) => {
                values.forEach((v) => {
                  v["startAbs"] = HGC.utils.chrToAbs(chromName, v.start, this.chromSizes);
                  v["endAbs"] = HGC.utils.chrToAbs(chromName, v.end, this.chromSizes);
                });
                return values;
              })
            );
            minX = chromEnd;
          } else {
            startPos = Math.floor(minX - chromStart);
            endPos = Math.ceil(maxX - chromStart);
            if (!this.bwFile)
              return;
            recordPromises.push(
              this.bwFile.getFeatures(chromName, startPos, endPos, {
                scale: 1 / basesPerPixel
              }).then((values) => {
                values.forEach((v) => {
                  v["startAbs"] = HGC.utils.chrToAbs(chromName, v.start, this.chromSizes);
                  v["endAbs"] = HGC.utils.chrToAbs(chromName, v.end, this.chromSizes);
                });
                return values;
              })
            );
            return;
          }
        }
      });
      return Promise.all(recordPromises).then((v) => {
        const values = v.flat();
        const dense = [];
        for (let i = 0; i < this.TILE_SIZE; i++) {
          dense.push(null);
        }
        binStarts.forEach((curStart, index) => {
          if (curStart < minXOriginal || curStart > maxX) {
            return;
          }
          const filtered = values.filter((v2) => {
            return curStart >= v2.startAbs && curStart < v2.endAbs;
          }).map((v2) => v2.score);
          dense[index] = filtered.length > 0 ? filtered[0] : null;
        });
        const dde = new HGC.utils.DenseDataExtrema1D(dense);
        tile.min_value = Math.min(...dense);
        tile.max_value = Math.max(...dense);
        tile.dense = dense;
        tile.denseDataExtrema = dde;
        tile.minNonZero = dde.minNonZeroInTile;
        tile.maxNonZero = dde.maxNonZeroInTile;
        return tile;
      });
    }
    // We never want to request more than 1024 * 20 elements from the file.
    determineScale(minX, maxX) {
      const reductionLevels = [1];
      const numRequestedElements = maxX - minX;
      if (!this.bwFileHeader) {
        throw Error("no bigwig header");
      }
      this.bwFileHeader.zoomLevels.forEach((z) => {
        reductionLevels.push(z.reductionLevel);
      });
      let level;
      reductionLevels.forEach((rl) => {
        if (level)
          return;
        const numElementsFromFile = numRequestedElements / rl;
        if (numElementsFromFile <= this.TILE_SIZE * 20) {
          level = rl;
        }
      });
      return level || reductionLevels.slice(-1)[0];
    }
  };
  return new cls();
}
BigWigDataFetcher.config = {
  type: "bigwig"
};
function filterData(filter, data2) {
  const { field, not: not2 } = filter;
  let output = Array.from(data2);
  if (IsOneOfFilter(filter)) {
    const { oneOf: oneOf2 } = filter;
    output = output.filter((d) => {
      return not2 ? oneOf2.indexOf(d[field]) === -1 : oneOf2.indexOf(d[field]) !== -1;
    });
  } else if (IsRangeFilter(filter)) {
    const { inRange } = filter;
    output = output.filter((d) => {
      const value = +d[field];
      return not2 ? !(inRange[0] <= value && value <= inRange[1]) : inRange[0] <= value && value <= inRange[1];
    });
  } else if (IsIncludeFilter(filter)) {
    const { include } = filter;
    output = output.filter((d) => {
      return not2 ? `${d[field]}`.includes(include) : !`${d[field]}`.includes(include);
    });
  }
  return output;
}
function concatString(concat, data2) {
  const { fields, separator, newField } = concat;
  let output = Array.from(data2);
  output = output.map((d) => {
    const strs = fields.map((f) => d[f]);
    d[newField] = strs.join(separator);
    return d;
  });
  return output;
}
function replaceString(_, data2) {
  const { field, replace, newField } = _;
  let output = Array.from(data2);
  output = output.map((d) => {
    d[newField] = d[field];
    replace.forEach((r) => {
      const { from, to } = r;
      d[newField] = d[newField].toString().replaceAll(from, to);
    });
    return d;
  });
  return output;
}
function calculateData(log, data2) {
  const { field, base, newField } = log;
  let output = Array.from(data2);
  output = output.map((d) => {
    if (+d[field]) {
      if (base === "e") {
        d[newField != null ? newField : field] = Math.log(+d[field]);
      } else {
        d[newField != null ? newField : field] = Math.log(+d[field]) / Math.log(base != null ? base : 10);
      }
    }
    return d;
  });
  return output;
}
function calculateGenomicLength(_, data2) {
  const { startField, endField, newField } = _;
  const output = Array.from(data2);
  output.forEach((d) => {
    const s = d[startField];
    const e = d[endField];
    if (!s || !e) {
      return;
    }
    d[newField] = Math.abs(+e - +s);
  });
  return output;
}
function inferSvType(_, data2) {
  const { firstBp, secondBp, newField } = _;
  const output = Array.from(data2);
  const [DUP, TRA, DEL, t2tINV, h2hINV] = ["DUP", "TRA", "DEL", "t2tINV", "h2hINV"];
  output.forEach((d) => {
    const chr1 = d[firstBp.chrField];
    const chr2 = d[secondBp.chrField];
    if (chr1 !== chr2) {
      d[newField] = TRA;
      return;
    }
    let pos1 = d[firstBp.posField];
    let pos2 = d[secondBp.posField];
    let strand1 = d[firstBp.strandField];
    let strand2 = d[secondBp.strandField];
    if (pos1 > pos2) {
      const _pos = pos1;
      const _strand = strand1;
      pos1 = pos2;
      strand1 = strand2;
      pos2 = _pos;
      strand2 = _strand;
    }
    switch (`${strand1}${strand2}`) {
      case "+-":
        d[newField] = DEL;
        break;
      case "--":
        d[newField] = t2tINV;
        break;
      case "++":
        d[newField] = h2hINV;
        break;
      case "-+":
        d[newField] = DUP;
        break;
      default:
        d[newField] = "unknown";
    }
  });
  return output;
}
function aggregateCoverage(_, data2, scale) {
  const { startField, endField, newField, groupField } = _;
  const coverage = {};
  const binSize = 1;
  data2.forEach((d) => {
    const curStart = scale(d[startField]);
    const curEnd = scale(d[endField]);
    const group2 = groupField ? d[groupField] : "__NO_GROUP__";
    const adjustedStart = Math.floor(curStart);
    for (let i = adjustedStart; i < curEnd; i += binSize) {
      if (!coverage[group2]) {
        coverage[group2] = {};
      }
      if (!coverage[group2][i]) {
        coverage[group2][i] = 0;
      }
      coverage[group2][i]++;
    }
  });
  const output = Object.entries(coverage).flatMap((group2) => {
    const [groupName, coverageRecords] = group2;
    return Object.entries(coverageRecords).map((entry) => {
      const [key, value] = entry;
      return {
        [startField]: scale.invert(+key),
        [endField]: scale.invert(+key + binSize),
        [newField != null ? newField : "coverage"]: value,
        [groupField != null ? groupField : "group"]: groupName
      };
    });
  });
  return output;
}
function displace(t, data2, scale) {
  const { boundingBox, method, newField } = t;
  const { startField, endField, groupField } = boundingBox;
  let paddingInBp = 0;
  if (boundingBox.padding && scale && !boundingBox.isPaddingBP) {
    paddingInBp = Math.abs(scale.invert(boundingBox.padding) - scale.invert(0));
  } else if (boundingBox.padding && boundingBox.isPaddingBP) {
    paddingInBp = boundingBox.padding;
  }
  const base = Array.from(data2);
  if (base && base.length > 0) {
    if (!Object.keys(base[0]).find((d) => d === startField) || !Object.keys(base[0]).find((d) => d === endField)) {
      return base;
    }
  }
  if (method === "pile") {
    const { maxRows } = t;
    const occupiedSpaceInRows = {};
    const sorted = base.sort((a, b) => a[startField] - b[startField]);
    sorted.forEach((d) => {
      const start = +d[startField] - paddingInBp;
      const end = +d[endField] + paddingInBp;
      const group2 = groupField ? d[groupField] : "__NO_GROUP__";
      if (!occupiedSpaceInRows[group2]) {
        occupiedSpaceInRows[group2] = [];
      }
      let rowIndex = occupiedSpaceInRows[group2].findIndex((d2) => {
        if (end < d2.start) {
          d2.start = start;
          return true;
        } else if (d2.end < start) {
          d2.end = end;
          return true;
        }
        return false;
      });
      if (rowIndex === -1) {
        occupiedSpaceInRows[group2].push({ start, end });
        rowIndex = occupiedSpaceInRows[group2].length - 1;
      }
      d[newField] = `${maxRows && maxRows <= rowIndex ? maxRows - 1 : rowIndex}`;
    });
  } else if (method === "spread") {
    const boundingBoxes = [];
    base.sort((a, b) => a[startField] - b[startField]).forEach((d) => {
      let start = d[startField] - paddingInBp;
      let end = d[endField] + paddingInBp;
      let overlapped = boundingBoxes.filter(
        (box) => box.start === start && end === box.end || box.start < start && start < box.end || box.start < end && end < box.end || start < box.start && box.end < end
      );
      if (overlapped.length > 0) {
        let trial = 0;
        do {
          overlapped = boundingBoxes.filter(
            (box) => box.start === start && end === box.end || box.start < start && start < box.end || box.start < end && end < box.end || start < box.start && box.end < end
          );
          if (overlapped.length > 0) {
            if (trial % 2 === 0) {
              start += paddingInBp * trial;
              end += paddingInBp * trial;
            } else {
              start -= paddingInBp * trial;
              end -= paddingInBp * trial;
            }
          }
          trial++;
        } while (overlapped.length > 0 && trial < 1e3);
      }
      d[`${newField}Start`] = `${start + paddingInBp}`;
      d[`${newField}Etart`] = `${end - paddingInBp}`;
      boundingBoxes.push({ start, end });
    });
  }
  return base;
}
function splitExon(split, data2, assembly = "hg38") {
  const { separator, fields, flag } = split;
  let output = Array.from(data2);
  output = output.map((d) => {
    const newRows = [];
    fields.forEach((f) => {
      const { field, type: type2, newField, chrField } = f;
      const splitted = d[field].toString().split(separator);
      splitted.forEach((s, i) => {
        let newValue = s;
        if (type2 === "genomic") {
          newValue = computeChromSizes(assembly).interval[d[chrField]][0] + +s;
        }
        if (!newRows[i]) {
          newRows[i] = Object.assign(JSON.parse(JSON.stringify(d)), {
            [newField]: newValue,
            [flag.field]: flag.value
          });
        } else {
          newRows[i][newField] = newValue;
        }
      });
    });
    return [d, ...newRows];
  }).reduce((a, b) => a.concat(b), []);
  return output;
}
function parseSubJSON(_, data2) {
  const { field, genomicField, baseGenomicField, genomicLengthField } = _;
  let output = Array.from(data2);
  output = output.map((d) => {
    let newRows = JSON.parse(d[field]);
    newRows = newRows.map((row) => {
      var _a, _b;
      if (row[genomicField] && d[baseGenomicField]) {
        row[`${genomicField}_start`] = +row[genomicField] + +d[baseGenomicField];
        row[`${genomicField}_end`] = +row[genomicField] + +d[baseGenomicField] + +row[genomicLengthField];
      }
      return Object.assign(JSON.parse(JSON.stringify(d)), {
        ...row,
        [`${genomicField}_start`]: row[`${genomicField}_start`],
        [`${genomicField}_end`]: row[`${genomicField}_end`],
        type: (_b = (_a = row.type) != null ? _a : row.variant) != null ? _b : null,
        isParsedRow: "yes"
      });
    });
    return [d, ...newRows];
  }).reduce((a, b) => a.concat(b), []);
  return output;
}
function aggregateData(spec, data2) {
  if (getChannelKeysByAggregateFnc(spec).length === 0) {
    return data2;
  }
  const nChannelKeys = getChannelKeysByType(spec, "nominal");
  if (nChannelKeys.length !== 1) {
    console.warn("Currently, we only support aggregating datasets with single nominal field.");
    return data2;
  }
  const nFieldSpec = spec[nChannelKeys[0]];
  if (!IsChannelDeep(nFieldSpec)) {
    return data2;
  }
  const nField = nFieldSpec.field;
  if (!nField) {
    return data2;
  }
  const qChannelKeys = [...getChannelKeysByType(spec, "quantitative"), ...getChannelKeysByType(spec, "genomic")];
  const aggregated = [];
  const uniqueCategories = Array.from(new Set(data2.map((d) => d[nField])));
  let failed = false;
  uniqueCategories.forEach((c) => {
    const datum = {};
    datum[nField] = c;
    qChannelKeys.forEach((q) => {
      const qFieldSpec = spec[q];
      if (!IsChannelDeep(qFieldSpec)) {
        failed = true;
        return;
      }
      const { field: qField } = qFieldSpec;
      if (!qField || !("aggregate" in qFieldSpec)) {
        failed = true;
        return;
      }
      datum[qField] = qFieldSpec.aggregate === "max" ? Math.max(...data2.filter((d) => d[nField] === c).map((d) => +d[qField])) : Math.min(...data2.filter((d) => d[nField] === c).map((d) => +d[qField]));
    });
    aggregated.push(datum);
  });
  return !failed ? aggregated : data2;
}
class CsvDataFetcherClass {
  constructor(dataConfig) {
    /**
     * Fetches CSV file from url, parses it, and sets this.#parsedData
     */
    __privateAdd(this, _fetchCsv);
    /**
     * Function passed into DSV parser to process each row
     * @param row An object which contains the row information. The keys are the column names
     * @param genomicFieldsToConvert From data config
     * @param chromosomeField From data config
     * @param genomicFields From data config
     * @returns The processed row
     */
    __privateAdd(this, _processCsvRow);
    /**
     * Calculates the cumulative chromosome position based on the chromosome name and position
     * @param chromName A string, the name of the chromosome
     * @param chromPosition A string, the position within the chromosome
     */
    __privateAdd(this, _calcCumulativePos);
    /**
     * Called by this.tilesetInfo() to call a callback function with tileset info.
     */
    __privateAdd(this, _generateTilesetInfo);
    /**
     * Creates an object to associate a tile position with the corresponding data
     * @param z An integer, the z coordinate of the tile
     * @param x An integer, the x coordinate of the tile
     * @param y An integer, the y coordinate of the tile
     * @returns A promise of an object with tile coordinates and data
     */
    __privateAdd(this, _tile);
    /**
     * This function calculates chromosome position and size based on the assembly (this.#assembly)
     * @returns An object containing chromosome information and a way to calculate absolute position
     */
    __privateAdd(this, _generateChomSizeInfo);
    __publicField(this, "dataConfig");
    // @ts-ignore
    __publicField(this, "tilesetInfoLoading");
    // Used in TiledPixiTrack
    __privateAdd(this, _dataPromise, void 0);
    __privateAdd(this, _chromSizes, void 0);
    __privateAdd(this, _parsedData, void 0);
    // Either set in the constructor or in #fetchCsv()
    __privateAdd(this, _assembly, void 0);
    __privateAdd(this, _filter, void 0);
    __privateAdd(this, _file, void 0);
    this.dataConfig = dataConfig;
    this.tilesetInfoLoading = false;
    __privateSet(this, _assembly, this.dataConfig.assembly);
    __privateSet(this, _filter, this.dataConfig.filter);
    if (!dataConfig.url) {
      console.error("Please provide the `url` of the data");
    }
    const { urlFetchOptions, url } = dataConfig;
    __privateSet(this, _file, new RemoteFile(url, { overrides: urlFetchOptions }));
    __privateSet(this, _chromSizes, __privateMethod(this, _generateChomSizeInfo, generateChomSizeInfo_fn).call(this));
    __privateSet(this, _dataPromise, __privateMethod(this, _fetchCsv, fetchCsv_fn).call(this));
  }
  /**
   * Called in TiledPixiTrack
   */
  tilesetInfo(callback) {
    if (!__privateGet(this, _dataPromise)) {
      return;
    }
    this.tilesetInfoLoading = true;
    return __privateGet(this, _dataPromise).then(() => __privateMethod(this, _generateTilesetInfo, generateTilesetInfo_fn).call(this, callback)).catch((err2) => {
      this.tilesetInfoLoading = false;
      console.error("[Gosling Data Fetcher] Error parsing data:", err2);
    });
  }
  /**
   * Called in TiledPixiTrack.
   * @param receivedTiles A function from TiledPixiTrack which takes in all the loaded tiles
   * @param tileIds An array of tile IDs. Ex. ['1.0', '1.1']
   */
  fetchTilesDebounced(receivedTiles, tileIds) {
    const tiles = {};
    const validTileIds = [];
    const tilePromises = [];
    for (const tileId of tileIds) {
      const parts = tileId.split(".");
      const z = parseInt(parts[0], 10);
      const x = parseInt(parts[1], 10);
      const y = parseInt(parts[2], 10);
      if (Number.isNaN(x) || Number.isNaN(z)) {
        console.warn("[Gosling Data Fetcher] Invalid tile zoom or position:", z, x, y);
        continue;
      }
      validTileIds.push(tileId);
      tilePromises.push(__privateMethod(this, _tile, tile_fn).call(this, z, x, y));
    }
    Promise.all(tilePromises).then((tileInfo) => {
      tileInfo.forEach((tileInfo2, i) => {
        if (tileInfo2) {
          const validTileId = validTileIds[i];
          tiles[validTileId] = tileInfo2;
          tiles[validTileId].tilePositionId = validTileId;
        }
      });
      receivedTiles(tiles);
    });
  }
}
_dataPromise = new WeakMap();
_chromSizes = new WeakMap();
_parsedData = new WeakMap();
_assembly = new WeakMap();
_filter = new WeakMap();
_file = new WeakMap();
_fetchCsv = new WeakSet();
fetchCsv_fn = async function() {
  var _a, _b;
  const { chromosomeField, genomicFields, headerNames, longToWideId, genomicFieldsToConvert } = this.dataConfig;
  const separator = (_a = this.dataConfig.separator) != null ? _a : ",";
  try {
    const buffer = await __privateGet(this, _file).readFile();
    const text = buffer.toString();
    const textWithHeader = headerNames ? `${headerNames.join(separator)}
${text}` : text;
    const parsedCSV = dsvFormat(separator).parse(
      textWithHeader,
      (row) => __privateMethod(this, _processCsvRow, processCsvRow_fn).call(this, row, genomicFieldsToConvert, chromosomeField, genomicFields)
    );
    if (longToWideId && ((_b = parsedCSV[0]) == null ? void 0 : _b[longToWideId])) {
      const columnNames = Object.keys(parsedCSV[0]);
      const newJson = {};
      parsedCSV.forEach((row) => {
        if (!newJson[row[longToWideId]]) {
          newJson[row[longToWideId]] = JSON.parse(JSON.stringify(row));
        } else {
          columnNames.forEach((colName) => {
            newJson[row[longToWideId]][`${colName}_2`] = row[colName];
          });
        }
      });
      __privateSet(this, _parsedData, Object.keys(newJson).map((k_3) => newJson[k_3]));
    } else {
      __privateSet(this, _parsedData, parsedCSV);
    }
  } catch (error) {
    console.error("[Gosling Data Fetcher] Error fetching data", error);
  }
};
_processCsvRow = new WeakSet();
processCsvRow_fn = function(row, genomicFieldsToConvert, chromosomeField, genomicFields) {
  try {
    if (genomicFieldsToConvert) {
      genomicFieldsToConvert.forEach((chromMap) => {
        const genomicFields_1 = chromMap.genomicFields;
        const chromName = row[chromMap.chromosomeField];
        genomicFields_1.forEach((positionCol) => {
          const chromPosition = row[positionCol];
          row[positionCol] = String(__privateMethod(this, _calcCumulativePos, calcCumulativePos_fn).call(this, chromName, chromPosition));
        });
      });
    } else if (chromosomeField && genomicFields) {
      genomicFields.forEach((positionCol_1) => {
        const chromPosition_1 = row[positionCol_1];
        const chromName_1 = row[chromosomeField];
        row[positionCol_1] = String(__privateMethod(this, _calcCumulativePos, calcCumulativePos_fn).call(this, chromName_1, chromPosition_1));
      });
    }
    return row;
  } catch (e) {
    return void 0;
  }
};
_calcCumulativePos = new WeakSet();
calcCumulativePos_fn = function(chromName, chromPosition) {
  if (__privateGet(this, _assembly) !== "unknown") {
    const chrName = sanitizeChrName(chromName, __privateGet(this, _assembly), this.dataConfig.chromosomePrefix);
    return computeChromSizes(__privateGet(this, _assembly)).interval[chrName][0] + +chromPosition;
  } else {
    return chromPosition;
  }
};
_generateTilesetInfo = new WeakSet();
generateTilesetInfo_fn = function(callback) {
  this.tilesetInfoLoading = false;
  const TILE_SIZE = 1024;
  const totalLength = __privateGet(this, _chromSizes).totalLength;
  const retVal = {
    tile_size: TILE_SIZE,
    max_zoom: Math.ceil(Math.log(totalLength / TILE_SIZE) / Math.log(2)),
    max_width: totalLength,
    min_pos: [0, 0],
    max_pos: [totalLength, totalLength]
  };
  if (callback) {
    callback(retVal);
  }
  return retVal;
};
_tile = new WeakSet();
tile_fn = async function(z, x, y) {
  var _a, _b;
  const tilesetInfo = await this.tilesetInfo();
  if (!tilesetInfo)
    return;
  const tileWidth = +tilesetInfo.max_width / 2 ** +z;
  const minX = tilesetInfo.min_pos[0] + x * tileWidth;
  const maxX = tilesetInfo.min_pos[0] + (x + 1) * tileWidth;
  let tabularData = filterUsingGenoPos(__privateGet(this, _parsedData), [minX, maxX], this.dataConfig);
  (_a = __privateGet(this, _filter)) == null ? void 0 : _a.forEach((f) => {
    tabularData = filterData(f, tabularData);
  });
  const sizeLimit = (_b = this.dataConfig.sampleLength) != null ? _b : 1e3;
  return {
    // sample the data to make it managable for visualization components
    tabularData: tabularData.length > sizeLimit ? sampleSize(tabularData, sizeLimit) : tabularData,
    server: null,
    tilePos: [x, y],
    zoomLevel: z
  };
};
_generateChomSizeInfo = new WeakSet();
generateChomSizeInfo_fn = function() {
  const chromosomeSizes = computeChromSizes(__privateGet(this, _assembly)).size;
  const chromosomeCumPositions = [];
  const chromosomePositions = {};
  let prevEndPosition = 0;
  Object.keys(chromosomeSizes).forEach((chrStr, i) => {
    const positionInfo = {
      id: i,
      chr: chrStr,
      pos: prevEndPosition
    };
    chromosomeCumPositions.push(positionInfo);
    chromosomePositions[chrStr] = positionInfo;
    prevEndPosition += chromosomeSizes[chrStr];
  });
  return {
    chrToAbs: (chrom, chromPos) => __privateGet(this, _chromSizes).chrPositions[chrom].pos + chromPos,
    cumPositions: chromosomeCumPositions,
    chrPositions: chromosomePositions,
    totalLength: prevEndPosition,
    chromLengths: chromosomeSizes
  };
};
function CsvDataFetcher(_HGC, dataConfig, _pubsub) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  return new CsvDataFetcherClass(dataConfig);
}
CsvDataFetcher.config = {
  type: "csv"
};
function JsonDataFetcher(HGC, ...args) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  class JsonDataFetcherClass {
    constructor(params) {
      __publicField(this, "dataConfig");
      // @ts-ignore
      __publicField(this, "tilesetInfoLoading");
      __publicField(this, "chromSizes");
      __publicField(this, "values");
      __publicField(this, "assembly");
      const [dataConfig] = params;
      this.dataConfig = dataConfig;
      this.tilesetInfoLoading = false;
      this.assembly = this.dataConfig.assembly;
      if (!dataConfig.values) {
        console.error("Please provide `values` of the JSON data");
        return;
      }
      const chromosomeSizes = computeChromSizes(this.assembly).size;
      const chromosomeCumPositions = [];
      const chromosomePositions = {};
      let prevEndPosition = 0;
      Object.keys(computeChromSizes(this.assembly).size).forEach((chrStr, i) => {
        const positionInfo = {
          id: i,
          chr: chrStr,
          pos: prevEndPosition
        };
        chromosomeCumPositions.push(positionInfo);
        chromosomePositions[chrStr] = positionInfo;
        prevEndPosition += computeChromSizes(this.assembly).size[chrStr];
      });
      this.chromSizes = {
        chrToAbs: (chrom, chromPos) => this.chromSizes.chrPositions[chrom].pos + chromPos,
        cumPositions: chromosomeCumPositions,
        chrPositions: chromosomePositions,
        totalLength: prevEndPosition,
        chromLengths: chromosomeSizes
      };
      const { chromosomeField, genomicFields, genomicFieldsToConvert } = this.dataConfig;
      this.values = dataConfig.values.map((row) => {
        try {
          if (genomicFieldsToConvert) {
            genomicFieldsToConvert.forEach((chromMap) => {
              const genomicFields2 = chromMap.genomicFields;
              const chromName = sanitizeChrName(row[chromMap.chromosomeField], this.assembly);
              genomicFields2.forEach((positionCol) => {
                const chromPosition = row[positionCol];
                row[positionCol] = String(this.chromSizes.chrToAbs(chromName, chromPosition));
              });
            });
          } else if (chromosomeField && genomicFields) {
            genomicFields.forEach((positionCol) => {
              const chromPosition = row[positionCol];
              const chromName = sanitizeChrName(row[chromosomeField], this.assembly);
              row[positionCol] = String(this.chromSizes.chrToAbs(chromName, chromPosition));
            });
          }
          return row;
        } catch (e) {
          return void 0;
        }
      });
    }
    tilesetInfo(callback) {
      this.tilesetInfoLoading = false;
      const TILE_SIZE = 1024;
      const totalLength = this.chromSizes.totalLength;
      const retVal = {
        tile_size: TILE_SIZE,
        max_zoom: Math.ceil(Math.log(totalLength / TILE_SIZE) / Math.log(2)),
        max_width: totalLength,
        min_pos: [0, 0],
        max_pos: [totalLength, totalLength]
      };
      if (callback) {
        callback(retVal);
      }
      return retVal;
    }
    fetchTilesDebounced(receivedTiles, tileIds) {
      const tiles = {};
      const validTileIds = [];
      const tilePromises = [];
      for (const tileId of tileIds) {
        const parts = tileId.split(".");
        const z = parseInt(parts[0], 10);
        const x = parseInt(parts[1], 10);
        const y = parseInt(parts[2], 10);
        if (Number.isNaN(x) || Number.isNaN(z)) {
          console.warn("[Gosling Data Fetcher] Invalid tile zoom or position:", z, x, y);
          continue;
        }
        validTileIds.push(tileId);
        tilePromises.push(this.tile(z, x, y));
      }
      Promise.all(tilePromises).then((values) => {
        values.forEach((value, i) => {
          const validTileId = validTileIds[i];
          tiles[validTileId] = value;
          tiles[validTileId].tilePositionId = validTileId;
        });
        receivedTiles(tiles);
      });
      return tiles;
    }
    tile(z, x, y) {
      var _a;
      const tsInfo = this.tilesetInfo();
      const tileWidth = +tsInfo.max_width / 2 ** +z;
      const minX = tsInfo.min_pos[0] + x * tileWidth;
      const maxX = tsInfo.min_pos[0] + (x + 1) * tileWidth;
      let tabularData = filterUsingGenoPos(this.values, [minX, maxX], this.dataConfig);
      const sizeLimit = (_a = this.dataConfig.sampleLength) != null ? _a : 1e3;
      if (sizeLimit < tabularData.length) {
        tabularData = this.dataConfig.sampleType === "first" ? tabularData.slice(0, sizeLimit) : sampleSize(tabularData, sizeLimit);
      }
      return {
        tabularData,
        server: null,
        tilePos: [x, y],
        zoomLevel: z
      };
    }
  }
  return new JsonDataFetcherClass(args);
}
JsonDataFetcher.config = {
  type: "json"
};
const encodedJs$1 = "KCgpID0+IHsKICB2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlOwogIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgdmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwogIHZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzOwogIHZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CiAgdmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogIHZhciBfX2VzbSA9IChmbiwgcmVzKSA9PiBmdW5jdGlvbiBfX2luaXQoKSB7CiAgICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltPYmplY3Qua2V5cyhmbilbMF1dKShmbiA9IDApKSwgcmVzOwogIH07CiAgdmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkgewogICAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbT2JqZWN0LmtleXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7CiAgfTsKICB2YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHsKICAgIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7CiAgICBmb3IgKHZhciBuYW1lIGluIGFsbCkKICAgICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTsKICB9OwogIHZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4gewogICAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09ICJvYmplY3QiIHx8IHR5cGVvZiBtb2R1bGUyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSkKICAgICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09ICJkZWZhdWx0IikKICAgICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7CiAgICB9CiAgICByZXR1cm4gdGFyZ2V0OwogIH07CiAgdmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4gewogICAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgImRlZmF1bHQiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiAiZGVmYXVsdCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTsKICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vYmFzZTY0LWpzQDEuNS4xL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMKICB2YXIgcmVxdWlyZV9iYXNlNjRfanMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYmFzZTY0LWpzQDEuNS4xL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBleHBvcnRzMi5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDsKICAgICAgZXhwb3J0czIudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheTsKICAgICAgZXhwb3J0czIuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXk7CiAgICAgIHZhciBsb29rdXAgPSBbXTsKICAgICAgdmFyIHJldkxvb2t1cCA9IFtdOwogICAgICB2YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICJ1bmRlZmluZWQiID8gVWludDhBcnJheSA6IEFycmF5OwogICAgICB2YXIgY29kZSA9ICJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIjsKICAgICAgZm9yIChpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkgewogICAgICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07CiAgICAgICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpOwogICAgICB9CiAgICAgIHZhciBpOwogICAgICB2YXIgbGVuOwogICAgICByZXZMb29rdXBbIi0iLmNoYXJDb2RlQXQoMCldID0gNjI7CiAgICAgIHJldkxvb2t1cFsiXyIuY2hhckNvZGVBdCgwKV0gPSA2MzsKICAgICAgZnVuY3Rpb24gZ2V0TGVucyhiNjQpIHsKICAgICAgICB2YXIgbGVuMiA9IGI2NC5sZW5ndGg7CiAgICAgICAgaWYgKGxlbjIgJSA0ID4gMCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Iik7CiAgICAgICAgfQogICAgICAgIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCI9Iik7CiAgICAgICAgaWYgKHZhbGlkTGVuID09PSAtMSkKICAgICAgICAgIHZhbGlkTGVuID0gbGVuMjsKICAgICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlbjIgPyAwIDogNCAtIHZhbGlkTGVuICUgNDsKICAgICAgICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGgoYjY0KSB7CiAgICAgICAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7CiAgICAgICAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTsKICAgICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTsKICAgICAgICByZXR1cm4gKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikgewogICAgICAgIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdG9CeXRlQXJyYXkoYjY0KSB7CiAgICAgICAgdmFyIHRtcDsKICAgICAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTsKICAgICAgICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdOwogICAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdOwogICAgICAgIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpOwogICAgICAgIHZhciBjdXJCeXRlID0gMDsKICAgICAgICB2YXIgbGVuMiA9IHBsYWNlSG9sZGVyc0xlbiA+IDAgPyB2YWxpZExlbiAtIDQgOiB2YWxpZExlbjsKICAgICAgICB2YXIgaTI7CiAgICAgICAgZm9yIChpMiA9IDA7IGkyIDwgbGVuMjsgaTIgKz0gNCkgewogICAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMTggfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPDwgMTIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAyKV0gPDwgNiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDMpXTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDE2ICYgMjU1OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1OwogICAgICAgIH0KICAgICAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7CiAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldID4+IDQ7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkgewogICAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMTAgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPDwgNCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA+PiAyOwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gYXJyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pIHsKICAgICAgICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDYzXSArIGxvb2t1cFtudW0gPj4gMTIgJiA2M10gKyBsb29rdXBbbnVtID4+IDYgJiA2M10gKyBsb29rdXBbbnVtICYgNjNdOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVuY29kZUNodW5rKHVpbnQ4LCBzdGFydCwgZW5kKSB7CiAgICAgICAgdmFyIHRtcDsKICAgICAgICB2YXIgb3V0cHV0ID0gW107CiAgICAgICAgZm9yICh2YXIgaTIgPSBzdGFydDsgaTIgPCBlbmQ7IGkyICs9IDMpIHsKICAgICAgICAgIHRtcCA9ICh1aW50OFtpMl0gPDwgMTYgJiAxNjcxMTY4MCkgKyAodWludDhbaTIgKyAxXSA8PCA4ICYgNjUyODApICsgKHVpbnQ4W2kyICsgMl0gJiAyNTUpOwogICAgICAgICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oIiIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21CeXRlQXJyYXkodWludDgpIHsKICAgICAgICB2YXIgdG1wOwogICAgICAgIHZhciBsZW4yID0gdWludDgubGVuZ3RoOwogICAgICAgIHZhciBleHRyYUJ5dGVzID0gbGVuMiAlIDM7CiAgICAgICAgdmFyIHBhcnRzID0gW107CiAgICAgICAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7CiAgICAgICAgZm9yICh2YXIgaTIgPSAwLCBsZW4yMiA9IGxlbjIgLSBleHRyYUJ5dGVzOyBpMiA8IGxlbjIyOyBpMiArPSBtYXhDaHVua0xlbmd0aCkgewogICAgICAgICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaTIsIGkyICsgbWF4Q2h1bmtMZW5ndGggPiBsZW4yMiA/IGxlbjIyIDogaTIgKyBtYXhDaHVua0xlbmd0aCkpOwogICAgICAgIH0KICAgICAgICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkgewogICAgICAgICAgdG1wID0gdWludDhbbGVuMiAtIDFdOwogICAgICAgICAgcGFydHMucHVzaChsb29rdXBbdG1wID4+IDJdICsgbG9va3VwW3RtcCA8PCA0ICYgNjNdICsgIj09Iik7CiAgICAgICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7CiAgICAgICAgICB0bXAgPSAodWludDhbbGVuMiAtIDJdIDw8IDgpICsgdWludDhbbGVuMiAtIDFdOwogICAgICAgICAgcGFydHMucHVzaChsb29rdXBbdG1wID4+IDEwXSArIGxvb2t1cFt0bXAgPj4gNCAmIDYzXSArIGxvb2t1cFt0bXAgPDwgMiAmIDYzXSArICI9Iik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCIiKTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vaWVlZTc1NEAxLjIuMS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcwogIHZhciByZXF1aXJlX2llZWU3NTQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vaWVlZTc1NEAxLjIuMS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBleHBvcnRzMi5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogICAgICAgIHZhciBlLCBtOwogICAgICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxOwogICAgICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwogICAgICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTsKICAgICAgICB2YXIgbkJpdHMgPSAtNzsKICAgICAgICB2YXIgaSA9IGlzTEUgPyBuQnl0ZXMgLSAxIDogMDsKICAgICAgICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7CiAgICAgICAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07CiAgICAgICAgaSArPSBkOwogICAgICAgIGUgPSBzICYgKDEgPDwgLW5CaXRzKSAtIDE7CiAgICAgICAgcyA+Pj0gLW5CaXRzOwogICAgICAgIG5CaXRzICs9IGVMZW47CiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkgewogICAgICAgIH0KICAgICAgICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxOwogICAgICAgIGUgPj49IC1uQml0czsKICAgICAgICBuQml0cyArPSBtTGVuOwogICAgICAgIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgaWYgKGUgPT09IDApIHsKICAgICAgICAgIGUgPSAxIC0gZUJpYXM7CiAgICAgICAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7CiAgICAgICAgICByZXR1cm4gbSA/IE5hTiA6IChzID8gLTEgOiAxKSAqIEluZmluaXR5OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pOwogICAgICAgICAgZSA9IGUgLSBlQmlhczsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKICAgICAgICB2YXIgZSwgbSwgYzsKICAgICAgICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTsKICAgICAgICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTsKICAgICAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7CiAgICAgICAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDA7CiAgICAgICAgdmFyIGkgPSBpc0xFID8gMCA6IG5CeXRlcyAtIDE7CiAgICAgICAgdmFyIGQgPSBpc0xFID8gMSA6IC0xOwogICAgICAgIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDsKICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTsKICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkgewogICAgICAgICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwOwogICAgICAgICAgZSA9IGVNYXg7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTsKICAgICAgICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHsKICAgICAgICAgICAgZS0tOwogICAgICAgICAgICBjICo9IDI7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZSArIGVCaWFzID49IDEpIHsKICAgICAgICAgICAgdmFsdWUgKz0gcnQgLyBjOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHZhbHVlICogYyA+PSAyKSB7CiAgICAgICAgICAgIGUrKzsKICAgICAgICAgICAgYyAvPSAyOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7CiAgICAgICAgICAgIG0gPSAwOwogICAgICAgICAgICBlID0gZU1heDsKICAgICAgICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHsKICAgICAgICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pOwogICAgICAgICAgICBlID0gZSArIGVCaWFzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pOwogICAgICAgICAgICBlID0gMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDI1NSwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIGUgPSBlIDw8IG1MZW4gfCBtOwogICAgICAgIGVMZW4gKz0gbUxlbjsKICAgICAgICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAyNTUsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkgewogICAgICAgIH0KICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9idWZmZXJANi4wLjMvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcwogIHZhciByZXF1aXJlX2J1ZmZlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9idWZmZXJANi4wLjMvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBiYXNlNjQgPSByZXF1aXJlX2Jhc2U2NF9qcygpOwogICAgICB2YXIgaWVlZTc1NCA9IHJlcXVpcmVfaWVlZTc1NCgpOwogICAgICB2YXIgY3VzdG9tSW5zcGVjdFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICJmdW5jdGlvbiIgJiYgdHlwZW9mIFN5bWJvbFsiZm9yIl0gPT09ICJmdW5jdGlvbiIgPyBTeW1ib2xbImZvciJdKCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSIpIDogbnVsbDsKICAgICAgZXhwb3J0czIuQnVmZmVyID0gQnVmZmVyMTA7CiAgICAgIGV4cG9ydHMyLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyOwogICAgICBleHBvcnRzMi5JTlNQRUNUX01BWF9CWVRFUyA9IDUwOwogICAgICB2YXIgS19NQVhfTEVOR1RIID0gMjE0NzQ4MzY0NzsKICAgICAgZXhwb3J0czIua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSDsKICAgICAgQnVmZmVyMTAuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KCk7CiAgICAgIGlmICghQnVmZmVyMTAuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4iKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpIHsKICAgICAgICB0cnkgewogICAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSk7CiAgICAgICAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIDQyOwogICAgICAgICAgfSB9OwogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSk7CiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90byk7CiAgICAgICAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MjsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIxMC5wcm90b3R5cGUsICJwYXJlbnQiLCB7CiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcih0aGlzKSkKICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyMTAucHJvdG90eXBlLCAib2Zmc2V0IiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIodGhpcykpCiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0OwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihsZW5ndGgpIHsKICAgICAgICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlICInICsgbGVuZ3RoICsgJyIgaXMgaW52YWxpZCBmb3Igb3B0aW9uICJzaXplIicpOwogICAgICAgIH0KICAgICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpOwogICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlcjEwLnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBCdWZmZXIxMChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAibnVtYmVyIikgewogICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInN0cmluZyIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucG9vbFNpemUgPSA4MTkyOwogICAgICBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAic3RyaW5nIikgewogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpOwogICAgICAgIH0KICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpOwogICAgICAgIH0KICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgIiArIHR5cGVvZiB2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHwgdmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gInVuZGVmaW5lZCIgJiYgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fCB2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAidmFsdWUiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpOwogICAgICAgIH0KICAgICAgICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKCk7CiAgICAgICAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpOwogICAgICAgIGlmIChiKQogICAgICAgICAgcmV0dXJuIGI7CiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICJ1bmRlZmluZWQiICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyMTAuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCJzdHJpbmciKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgIiArIHR5cGVvZiB2YWx1ZSk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAuZnJvbSA9IGZ1bmN0aW9uKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgfTsKICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlcjEwLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpOwogICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyMTAsIFVpbnQ4QXJyYXkpOwogICAgICBmdW5jdGlvbiBhc3NlcnRTaXplKHNpemUpIHsKICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcic2l6ZSIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpOwogICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgIicgKyBzaXplICsgJyIgaXMgaW52YWxpZCBmb3Igb3B0aW9uICJzaXplIicpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykgewogICAgICAgIGFzc2VydFNpemUoc2l6ZSk7CiAgICAgICAgaWYgKHNpemUgPD0gMCkgewogICAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKTsKICAgICAgICB9CiAgICAgICAgaWYgKGZpbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gInN0cmluZyIgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZykgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5hbGxvYyA9IGZ1bmN0aW9uKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSkgewogICAgICAgIGFzc2VydFNpemUoc2l6ZSk7CiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbihzaXplKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbihzaXplKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIiB8fCBlbmNvZGluZyA9PT0gIiIpIHsKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIH0KICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDsKICAgICAgICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7CiAgICAgICAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpOwogICAgICAgIGlmIChhY3R1YWwgIT09IGxlbmd0aCkgewogICAgICAgICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUFycmF5TGlrZShhcnJheSkgewogICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDsKICAgICAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQXJyYXlWaWV3KGFycmF5VmlldykgewogICAgICAgIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHsKICAgICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpOwogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignIm9mZnNldCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7CiAgICAgICAgfQogICAgICAgIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcibGVuZ3RoIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTsKICAgICAgICB9CiAgICAgICAgbGV0IGJ1ZjsKICAgICAgICBpZiAoYnl0ZU9mZnNldCA9PT0gdm9pZCAwICYmIGxlbmd0aCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSk7CiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyMTAucHJvdG90eXBlKTsKICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqKSB7CiAgICAgICAgaWYgKEJ1ZmZlcjEwLmlzQnVmZmVyKG9iaikpIHsKICAgICAgICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwOwogICAgICAgICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbik7CiAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgICAgfQogICAgICAgICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pOwogICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai5sZW5ndGggIT09IHZvaWQgMCkgewogICAgICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAibnVtYmVyIiB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkgewogICAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai50eXBlID09PSAiQnVmZmVyIiAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja2VkKGxlbmd0aCkgewogICAgICAgIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweCIgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgIiBieXRlcyIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbGVuZ3RoIHwgMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBTbG93QnVmZmVyKGxlbmd0aCkgewogICAgICAgIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmFsbG9jKCtsZW5ndGgpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIyKGIpIHsKICAgICAgICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmIGIgIT09IEJ1ZmZlcjEwLnByb3RvdHlwZTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikgewogICAgICAgIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKQogICAgICAgICAgYSA9IEJ1ZmZlcjEwLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aCk7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpCiAgICAgICAgICBiID0gQnVmZmVyMTAuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKTsKICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIxMC5pc0J1ZmZlcihiKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJidWYxIiwgImJ1ZjIiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyk7CiAgICAgICAgfQogICAgICAgIGlmIChhID09PSBiKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbGV0IHggPSBhLmxlbmd0aDsKICAgICAgICBsZXQgeSA9IGIubGVuZ3RoOwogICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkgewogICAgICAgICAgICB4ID0gYVtpXTsKICAgICAgICAgICAgeSA9IGJbaV07CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoeCA8IHkpCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKHkgPCB4KQogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nKGVuY29kaW5nKSB7CiAgICAgICAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHsKICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgIGNhc2UgInV0Zi04IjoKICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgIGNhc2UgImxhdGluMSI6CiAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfTsKICAgICAgQnVmZmVyMTAuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KGxpc3QsIGxlbmd0aCkgewogICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpOwogICAgICAgIH0KICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDApIHsKICAgICAgICAgIHJldHVybiBCdWZmZXIxMC5hbGxvYygwKTsKICAgICAgICB9CiAgICAgICAgbGV0IGk7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBsZW5ndGggPSAwOwogICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIxMC5hbGxvY1Vuc2FmZShsZW5ndGgpOwogICAgICAgIGxldCBwb3MgPSAwOwogICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBsZXQgYnVmID0gbGlzdFtpXTsKICAgICAgICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHsKICAgICAgICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7CiAgICAgICAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcihidWYpKQogICAgICAgICAgICAgICAgYnVmID0gQnVmZmVyMTAuZnJvbShidWYpOwogICAgICAgICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChidWZmZXIsIGJ1ZiwgcG9zKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmICghQnVmZmVyMTAuaXNCdWZmZXIoYnVmKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBidWYuY29weShidWZmZXIsIHBvcyk7CiAgICAgICAgICB9CiAgICAgICAgICBwb3MgKz0gYnVmLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZmZlcjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKEJ1ZmZlcjEwLmlzQnVmZmVyKHN0cmluZykpIHsKICAgICAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkgewogICAgICAgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHN0cmluZyAhPT0gInN0cmluZyIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAic3RyaW5nIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGg7CiAgICAgICAgY29uc3QgbXVzdE1hdGNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlOwogICAgICAgIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlOwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgc3dpdGNoIChlbmNvZGluZykgewogICAgICAgICAgICBjYXNlICJhc2NpaSI6CiAgICAgICAgICAgIGNhc2UgImxhdGluMSI6CiAgICAgICAgICAgIGNhc2UgImJpbmFyeSI6CiAgICAgICAgICAgICAgcmV0dXJuIGxlbjsKICAgICAgICAgICAgY2FzZSAidXRmOCI6CiAgICAgICAgICAgIGNhc2UgInV0Zi04IjoKICAgICAgICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuIGxlbiAqIDI7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMTsKICAgICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpIHsKICAgICAgICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbmNvZGluZyA9ICgiIiArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgQnVmZmVyMTAuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7CiAgICAgIGZ1bmN0aW9uIHNsb3dUb1N0cmluZyhlbmNvZGluZywgc3RhcnQsIGVuZCkgewogICAgICAgIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlOwogICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwIHx8IHN0YXJ0IDwgMCkgewogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkgewogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kID09PSB2b2lkIDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kIDw9IDApIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgZW5kID4+Pj0gMDsKICAgICAgICBzdGFydCA+Pj49IDA7CiAgICAgICAgaWYgKGVuZCA8PSBzdGFydCkgewogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIH0KICAgICAgICBpZiAoIWVuY29kaW5nKQogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgIiIpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTsKICAgICAgZnVuY3Rpb24gc3dhcChiLCBuLCBtKSB7CiAgICAgICAgY29uc3QgaSA9IGJbbl07CiAgICAgICAgYltuXSA9IGJbbV07CiAgICAgICAgYlttXSA9IGk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNigpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuICUgMiAhPT0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzIik7CiAgICAgICAgfQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHsKICAgICAgICAgIHN3YXAodGhpcywgaSwgaSArIDEpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMigpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuICUgNCAhPT0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzIik7CiAgICAgICAgfQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHsKICAgICAgICAgIHN3YXAodGhpcywgaSwgaSArIDMpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCgpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuICUgOCAhPT0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzIik7CiAgICAgICAgfQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHsKICAgICAgICAgIHN3YXAodGhpcywgaSwgaSArIDcpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKTsKICAgICAgICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlcjEwLnByb3RvdHlwZS50b1N0cmluZzsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhiKSB7CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcihiKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIiKTsKICAgICAgICBpZiAodGhpcyA9PT0gYikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHJldHVybiBCdWZmZXIxMC5jb21wYXJlKHRoaXMsIGIpID09PSAwOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7CiAgICAgICAgbGV0IHN0ciA9ICIiOwogICAgICAgIGNvbnN0IG1heCA9IGV4cG9ydHMyLklOU1BFQ1RfTUFYX0JZVEVTOwogICAgICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoImhleCIsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICIkMSAiKS50cmltKCk7CiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KQogICAgICAgICAgc3RyICs9ICIgLi4uICI7CiAgICAgICAgcmV0dXJuICI8QnVmZmVyICIgKyBzdHIgKyAiPiI7CiAgICAgIH07CiAgICAgIGlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7CiAgICAgICAgQnVmZmVyMTAucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyMTAucHJvdG90eXBlLmluc3BlY3Q7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkgewogICAgICAgICAgdGFyZ2V0ID0gQnVmZmVyMTAuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcih0YXJnZXQpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInRhcmdldCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHRhcmdldCk7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgewogICAgICAgICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPT09IHZvaWQgMCkgewogICAgICAgICAgdGhpc1N0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNFbmQgPT09IHZvaWQgMCkgewogICAgICAgICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJvdXQgb2YgcmFuZ2UgaW5kZXgiKTsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkgewogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPj0gZW5kKSB7CiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICB9CiAgICAgICAgc3RhcnQgPj4+PSAwOwogICAgICAgIGVuZCA+Pj49IDA7CiAgICAgICAgdGhpc1N0YXJ0ID4+Pj0gMDsKICAgICAgICB0aGlzRW5kID4+Pj0gMDsKICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0KQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0OwogICAgICAgIGxldCB5ID0gZW5kIC0gc3RhcnQ7CiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSk7CiAgICAgICAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7CiAgICAgICAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHsKICAgICAgICAgICAgeCA9IHRoaXNDb3B5W2ldOwogICAgICAgICAgICB5ID0gdGFyZ2V0Q29weVtpXTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh4IDwgeSkKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAoeSA8IHgpCiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICByZXR1cm4gMDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAyMTQ3NDgzNjQ3KSB7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gMjE0NzQ4MzY0NzsKICAgICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMjE0NzQ4MzY0OCkgewogICAgICAgICAgYnl0ZU9mZnNldCA9IC0yMTQ3NDgzNjQ4OwogICAgICAgIH0KICAgICAgICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQ7CiAgICAgICAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IGJ1ZmZlci5sZW5ndGggLSAxOwogICAgICAgIH0KICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDApCiAgICAgICAgICBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgewogICAgICAgICAgaWYgKGRpcikKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkgewogICAgICAgICAgaWYgKGRpcikKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IDA7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICB2YWwgPSBCdWZmZXIxMC5mcm9tKHZhbCwgZW5jb2RpbmcpOwogICAgICAgIH0KICAgICAgICBpZiAoQnVmZmVyMTAuaXNCdWZmZXIodmFsKSkgewogICAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikgewogICAgICAgICAgdmFsID0gdmFsICYgMjU1OwogICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgIGlmIChkaXIpIHsKICAgICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7CiAgICAgICAgfQogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlciIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikgewogICAgICAgIGxldCBpbmRleFNpemUgPSAxOwogICAgICAgIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoOwogICAgICAgIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoOwogICAgICAgIGlmIChlbmNvZGluZyAhPT0gdm9pZCAwKSB7CiAgICAgICAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gInVjczIiIHx8IGVuY29kaW5nID09PSAidWNzLTIiIHx8IGVuY29kaW5nID09PSAidXRmMTZsZSIgfHwgZW5jb2RpbmcgPT09ICJ1dGYtMTZsZSIpIHsKICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGluZGV4U2l6ZSA9IDI7CiAgICAgICAgICAgIGFyckxlbmd0aCAvPSAyOwogICAgICAgICAgICB2YWxMZW5ndGggLz0gMjsKICAgICAgICAgICAgYnl0ZU9mZnNldCAvPSAyOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiByZWFkKGJ1ZiwgaTIpIHsKICAgICAgICAgIGlmIChpbmRleFNpemUgPT09IDEpIHsKICAgICAgICAgICAgcmV0dXJuIGJ1ZltpMl07CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpMiAqIGluZGV4U2l6ZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGxldCBpOwogICAgICAgIGlmIChkaXIpIHsKICAgICAgICAgIGxldCBmb3VuZEluZGV4ID0gLTE7CiAgICAgICAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkgewogICAgICAgICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkKICAgICAgICAgICAgICAgIGZvdW5kSW5kZXggPSBpOwogICAgICAgICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkKICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkKICAgICAgICAgICAgICAgIGkgLT0gaSAtIGZvdW5kSW5kZXg7CiAgICAgICAgICAgICAgZm91bmRJbmRleCA9IC0xOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKQogICAgICAgICAgICBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoOwogICAgICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHsKICAgICAgICAgICAgbGV0IGZvdW5kID0gdHJ1ZTsKICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykgewogICAgICAgICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHsKICAgICAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGZvdW5kKQogICAgICAgICAgICAgIHJldHVybiBpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXModmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogICAgICAgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogICAgICAgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGhleFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7CiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldDsKICAgICAgICBpZiAoIWxlbmd0aCkgewogICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTsKICAgICAgICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHsKICAgICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoOwogICAgICAgIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7CiAgICAgICAgICBsZW5ndGggPSBzdHJMZW4gLyAyOwogICAgICAgIH0KICAgICAgICBsZXQgaTsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7CiAgICAgICAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkKICAgICAgICAgICAgcmV0dXJuIGk7CiAgICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7CiAgICAgICAgfQogICAgICAgIHJldHVybiBpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBiYXNlNjRXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHVjczJXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykgewogICAgICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgewogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIG9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IHZvaWQgMCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgZW5jb2RpbmcgPSBvZmZzZXQ7CiAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIG9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7CiAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkgewogICAgICAgICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDA7CiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKQogICAgICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7CiAgICAgICAgICAgIGxlbmd0aCA9IHZvaWQgMDsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCIpOwogICAgICAgIH0KICAgICAgICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDsKICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDAgfHwgbGVuZ3RoID4gcmVtYWluaW5nKQogICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nOwogICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzIik7CiAgICAgICAgfQogICAgICAgIGlmICghZW5jb2RpbmcpCiAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAidWNzMiI6CiAgICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICAgIGNhc2UgInV0Zi0xNmxlIjoKICAgICAgICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkKICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIgKyBlbmNvZGluZyk7CiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAoIiIgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICB0eXBlOiAiQnVmZmVyIiwKICAgICAgICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKQogICAgICAgIH07CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJhc2U2NFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHsKICAgICAgICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmOFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7CiAgICAgICAgY29uc3QgcmVzID0gW107CiAgICAgICAgbGV0IGkgPSBzdGFydDsKICAgICAgICB3aGlsZSAoaSA8IGVuZCkgewogICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldOwogICAgICAgICAgbGV0IGNvZGVQb2ludCA9IG51bGw7CiAgICAgICAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IGZpcnN0Qnl0ZSA+IDIzOSA/IDQgOiBmaXJzdEJ5dGUgPiAyMjMgPyAzIDogZmlyc3RCeXRlID4gMTkxID8gMiA6IDE7CiAgICAgICAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7CiAgICAgICAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkgewogICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAxMjgpIHsKICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07CiAgICAgICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAzMSkgPDwgNiB8IHNlY29uZEJ5dGUgJiA2MzsKICAgICAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAxMjcpIHsKICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07CiAgICAgICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKHRoaXJkQnl0ZSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDE1KSA8PCAxMiB8IChzZWNvbmRCeXRlICYgNjMpIDw8IDYgfCB0aGlyZEJ5dGUgJiA2MzsKICAgICAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAyMDQ3ICYmICh0ZW1wQ29kZVBvaW50IDwgNTUyOTYgfHwgdGVtcENvZGVQb2ludCA+IDU3MzQzKSkgewogICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwogICAgICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTsKICAgICAgICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdOwogICAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmICh0aGlyZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKGZvdXJ0aEJ5dGUgJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTggfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCAxMiB8ICh0aGlyZEJ5dGUgJiA2MykgPDwgNiB8IGZvdXJ0aEJ5dGUgJiA2MzsKICAgICAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiA2NTUzNSAmJiB0ZW1wQ29kZVBvaW50IDwgMTExNDExMikgewogICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkgewogICAgICAgICAgICBjb2RlUG9pbnQgPSA2NTUzMzsKICAgICAgICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDY1NTM1KSB7CiAgICAgICAgICAgIGNvZGVQb2ludCAtPSA2NTUzNjsKICAgICAgICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDEwMjMgfCA1NTI5Nik7CiAgICAgICAgICAgIGNvZGVQb2ludCA9IDU2MzIwIHwgY29kZVBvaW50ICYgMTAyMzsKICAgICAgICAgIH0KICAgICAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7CiAgICAgICAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKTsKICAgICAgfQogICAgICB2YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSA0MDk2OwogICAgICBmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoY29kZVBvaW50cykgewogICAgICAgIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoOwogICAgICAgIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHsKICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cyk7CiAgICAgICAgfQogICAgICAgIGxldCByZXMgPSAiIjsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHsKICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBsZXQgcmV0ID0gIiI7CiAgICAgICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTsKICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMTI3KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBsYXRpbjFTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBsZXQgcmV0ID0gIiI7CiAgICAgICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTsKICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBoZXhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBjb25zdCBsZW4gPSBidWYubGVuZ3RoOwogICAgICAgIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKQogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKQogICAgICAgICAgZW5kID0gbGVuOwogICAgICAgIGxldCBvdXQgPSAiIjsKICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG91dDsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGYxNmxlU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCk7CiAgICAgICAgbGV0IHJlcyA9ICIiOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7CiAgICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkgewogICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoOwogICAgICAgIHN0YXJ0ID0gfn5zdGFydDsKICAgICAgICBlbmQgPSBlbmQgPT09IHZvaWQgMCA/IGxlbiA6IH5+ZW5kOwogICAgICAgIGlmIChzdGFydCA8IDApIHsKICAgICAgICAgIHN0YXJ0ICs9IGxlbjsKICAgICAgICAgIGlmIChzdGFydCA8IDApCiAgICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7CiAgICAgICAgICBzdGFydCA9IGxlbjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8IDApIHsKICAgICAgICAgIGVuZCArPSBsZW47CiAgICAgICAgICBpZiAoZW5kIDwgMCkKICAgICAgICAgICAgZW5kID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGVuZCA+IGxlbikgewogICAgICAgICAgZW5kID0gbGVuOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kIDwgc3RhcnQpCiAgICAgICAgICBlbmQgPSBzdGFydDsKICAgICAgICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpOwogICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlcjEwLnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIG5ld0J1ZjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gY2hlY2tPZmZzZXQob2Zmc2V0LCBleHQsIGxlbmd0aCkgewogICAgICAgIGlmIChvZmZzZXQgJSAxICE9PSAwIHx8IG9mZnNldCA8IDApCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigib2Zmc2V0IGlzIG5vdCB1aW50Iik7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoIik7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50TEUgPSBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldF07CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnRCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoMl07CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgd2hpbGUgKGJ5dGVMZW5ndGgyID4gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aDJdICogbXVsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnQ4ID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnQxNkxFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnQxNkJFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIDw8IDggfCB0aGlzW29mZnNldCArIDFdOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnQzMkxFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpICsgdGhpc1tvZmZzZXQgKyAzXSAqIDE2Nzc3MjE2OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnQzMkJFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdICogMTY3NzcyMTYgKyAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM10pOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxvID0gZmlyc3QgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNDsKICAgICAgICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyBsYXN0ICogMiAqKiAyNDsKICAgICAgICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF07CiAgICAgICAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIGxhc3Q7CiAgICAgICAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldF07CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsOwogICAgICAgIH0KICAgICAgICBtdWwgKj0gMTI4OwogICAgICAgIGlmICh2YWwgPj0gbXVsKQogICAgICAgICAgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMik7CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMjsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldOwogICAgICAgIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7CiAgICAgICAgfQogICAgICAgIG11bCAqPSAxMjg7CiAgICAgICAgaWYgKHZhbCA+PSBtdWwpCiAgICAgICAgICB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKTsKICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTsKICAgICAgICBpZiAoISh0aGlzW29mZnNldF0gJiAxMjgpKQogICAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XTsKICAgICAgICByZXR1cm4gKDI1NSAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODsKICAgICAgICByZXR1cm4gdmFsICYgMzI3NjggPyB2YWwgfCA0Mjk0OTAxNzYwIDogdmFsOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgdGhpc1tvZmZzZXRdIDw8IDg7CiAgICAgICAgcmV0dXJuIHZhbCAmIDMyNzY4ID8gdmFsIHwgNDI5NDkwMTc2MCA6IHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYgfCB0aGlzW29mZnNldCArIDNdIDw8IDI0OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIDw8IDI0IHwgdGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM107CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gKyB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICsgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgKyAobGFzdCA8PCAyNCk7CiAgICAgICAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChmaXJzdCArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdOwogICAgICAgIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyBsYXN0KTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOCk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGNoZWNrSW50KGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikgewogICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIoYnVmKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJidWZmZXIiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTsKICAgICAgICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignInZhbHVlIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludExFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpIC0gMTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBtYXhCeXRlcywgMCk7CiAgICAgICAgfQogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgLyBtdWwgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludEJFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpIC0gMTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBtYXhCeXRlcywgMCk7CiAgICAgICAgfQogICAgICAgIGxldCBpID0gYnl0ZUxlbmd0aDIgLSAxOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgLyBtdWwgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludDggPSBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDI1NSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCA2NTUzNSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgNjU1MzUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludDMyTEUgPSBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDQyOTQ5NjcyOTUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCA0Mjk0OTY3Mjk1LCAwKTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBmdW5jdGlvbiB3cnRCaWdVSW50NjRMRShidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7CiAgICAgICAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KTsKICAgICAgICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIHJldHVybiBvZmZzZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gd3J0QmlnVUludDY0QkUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkgewogICAgICAgIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNyk7CiAgICAgICAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0ICsgN10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDZdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyA1XSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgNF0gPSBsbzsKICAgICAgICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCArIDNdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyAyXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgMV0gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldF0gPSBoaTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgODsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCIweGZmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCIweGZmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyIC0gMSk7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbGltaXQgLSAxLCAtbGltaXQpOwogICAgICAgIH0KICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IHN1YiA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHsKICAgICAgICAgICAgc3ViID0gMTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMiAtIDEpOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMiAtIDE7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IHN1YiA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7CiAgICAgICAgICAgIHN1YiA9IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsID4+IDApIC0gc3ViICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDEyNywgLTEyOCk7CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHZhbHVlID0gMjU1ICsgdmFsdWUgKyAxOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAxOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAzMjc2NywgLTMyNzY4KTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDMyNzY3LCAtMzI3NjgpOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMjE0NzQ4MzY0NywgLTIxNDc0ODM2NDgpOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDE2OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KTsKICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgdmFsdWUgPSA0Mjk0OTY3Mjk1ICsgdmFsdWUgKyAxOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiAyNDsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDE2OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoIjB4ODAwMDAwMDAwMDAwMDAwMCIpLCBCaWdJbnQoIjB4N2ZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoIjB4ODAwMDAwMDAwMDAwMDAwMCIpLCBCaWdJbnQoIjB4N2ZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICAgICAgICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgICBpZiAob2Zmc2V0IDwgMCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzNDAyODIzNDY2Mzg1Mjg4NmUyMiwgLTM0MDI4MjM0NjYzODUyODg2ZTIyKTsKICAgICAgICB9CiAgICAgICAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpOwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMTc5NzY5MzEzNDg2MjMxNTdlMjkyLCAtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKTsKICAgICAgICB9CiAgICAgICAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpOwogICAgICAgIHJldHVybiBvZmZzZXQgKyA4OwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkgewogICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIodGFyZ2V0KSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlciIpOwogICAgICAgIGlmICghc3RhcnQpCiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKQogICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpCiAgICAgICAgICB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7CiAgICAgICAgaWYgKCF0YXJnZXRTdGFydCkKICAgICAgICAgIHRhcmdldFN0YXJ0ID0gMDsKICAgICAgICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkKICAgICAgICAgIGVuZCA9IHN0YXJ0OwogICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcyIpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICAgIGlmIChlbmQgPCAwKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzIik7CiAgICAgICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKQogICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7CiAgICAgICAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDsKICAgICAgICB9CiAgICAgICAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnQ7CiAgICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwodGFyZ2V0LCB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLCB0YXJnZXRTdGFydCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBsZW47CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBlbmNvZGluZyA9IHN0YXJ0OwogICAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAic3RyaW5nIikgewogICAgICAgICAgICBlbmNvZGluZyA9IGVuZDsKICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHZvaWQgMCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmciKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICJzdHJpbmciICYmICFCdWZmZXIxMC5pc0VuY29kaW5nKGVuY29kaW5nKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHsKICAgICAgICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApOwogICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1dGY4IiAmJiBjb2RlIDwgMTI4IHx8IGVuY29kaW5nID09PSAibGF0aW4xIikgewogICAgICAgICAgICAgIHZhbCA9IGNvZGU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICB2YWwgPSB2YWwgJiAyNTU7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAiYm9vbGVhbiIpIHsKICAgICAgICAgIHZhbCA9IE51bWJlcih2YWwpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJPdXQgb2YgcmFuZ2UgaW5kZXgiKTsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8PSBzdGFydCkgewogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIHN0YXJ0ID0gc3RhcnQgPj4+IDA7CiAgICAgICAgZW5kID0gZW5kID09PSB2b2lkIDAgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMDsKICAgICAgICBpZiAoIXZhbCkKICAgICAgICAgIHZhbCA9IDA7CiAgICAgICAgbGV0IGk7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICAgIHRoaXNbaV0gPSB2YWw7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyMTAuaXNCdWZmZXIodmFsKSA/IHZhbCA6IEJ1ZmZlcjEwLmZyb20odmFsLCBlbmNvZGluZyk7CiAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7CiAgICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIHZhbCArICciIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50ICJ2YWx1ZSInKTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7CiAgICAgICAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgdmFyIGVycm9ycyA9IHt9OwogICAgICBmdW5jdGlvbiBFKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkgewogICAgICAgIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7CiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgICAgc3VwZXIoKTsKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJtZXNzYWdlIiwgewogICAgICAgICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksCiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICAgIH0pOwogICAgICAgICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYDsKICAgICAgICAgICAgdGhpcy5zdGFjazsKICAgICAgICAgICAgZGVsZXRlIHRoaXMubmFtZTsKICAgICAgICAgIH0KICAgICAgICAgIGdldCBjb2RlKCkgewogICAgICAgICAgICByZXR1cm4gc3ltOwogICAgICAgICAgfQogICAgICAgICAgc2V0IGNvZGUodmFsdWUpIHsKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJjb2RlIiwgewogICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgICAgICAgIHZhbHVlLAogICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgICAgdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0KICAgICAgRSgiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTIiwgZnVuY3Rpb24obmFtZSkgewogICAgICAgIGlmIChuYW1lKSB7CiAgICAgICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuICJBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzIjsKICAgICAgfSwgUmFuZ2VFcnJvcik7CiAgICAgIEUoIkVSUl9JTlZBTElEX0FSR19UWVBFIiwgZnVuY3Rpb24obmFtZSwgYWN0dWFsKSB7CiAgICAgICAgcmV0dXJuIGBUaGUgIiR7bmFtZX0iIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7CiAgICAgIH0sIFR5cGVFcnJvcik7CiAgICAgIEUoIkVSUl9PVVRfT0ZfUkFOR0UiLCBmdW5jdGlvbihzdHIsIHJhbmdlLCBpbnB1dCkgewogICAgICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mICIke3N0cn0iIGlzIG91dCBvZiByYW5nZS5gOwogICAgICAgIGxldCByZWNlaXZlZCA9IGlucHV0OwogICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7CiAgICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gImJpZ2ludCIpIHsKICAgICAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KTsKICAgICAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHsKICAgICAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpOwogICAgICAgICAgfQogICAgICAgICAgcmVjZWl2ZWQgKz0gIm4iOwogICAgICAgIH0KICAgICAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWA7CiAgICAgICAgcmV0dXJuIG1zZzsKICAgICAgfSwgUmFuZ2VFcnJvcik7CiAgICAgIGZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvcih2YWwpIHsKICAgICAgICBsZXQgcmVzID0gIiI7CiAgICAgICAgbGV0IGkgPSB2YWwubGVuZ3RoOwogICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAiLSIgPyAxIDogMDsKICAgICAgICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykgewogICAgICAgICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMikgewogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGlmIChidWZbb2Zmc2V0XSA9PT0gdm9pZCAwIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoMl0gPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGgyICsgMSkpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgyKSB7CiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7CiAgICAgICAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gImJpZ2ludCIgPyAibiIgOiAiIjsKICAgICAgICAgIGxldCByYW5nZTsKICAgICAgICAgIGlmIChieXRlTGVuZ3RoMiA+IDMpIHsKICAgICAgICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkgewogICAgICAgICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4fSR7bn1gOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aDIgKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogJHsoYnl0ZUxlbmd0aDIgKyAxKSAqIDggLSAxfSR7bn1gOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YDsKICAgICAgICAgIH0KICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgidmFsdWUiLCByYW5nZSwgdmFsdWUpOwogICAgICAgIH0KICAgICAgICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aDIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCBuYW1lKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgIm51bWJlciIsIHZhbHVlKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYm91bmRzRXJyb3IodmFsdWUsIGxlbmd0aCwgdHlwZSkgewogICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHsKICAgICAgICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKTsKICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICJvZmZzZXQiLCAiYW4gaW50ZWdlciIsIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKCk7CiAgICAgICAgfQogICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICJvZmZzZXQiLCBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLCB2YWx1ZSk7CiAgICAgIH0KICAgICAgdmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZzsKICAgICAgZnVuY3Rpb24gYmFzZTY0Y2xlYW4oc3RyKSB7CiAgICAgICAgc3RyID0gc3RyLnNwbGl0KCI9IilbMF07CiAgICAgICAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAiIik7CiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCAyKQogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkgewogICAgICAgICAgc3RyID0gc3RyICsgIj0iOwogICAgICAgIH0KICAgICAgICByZXR1cm4gc3RyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cmluZywgdW5pdHMpIHsKICAgICAgICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5OwogICAgICAgIGxldCBjb2RlUG9pbnQ7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7CiAgICAgICAgY29uc3QgYnl0ZXMgPSBbXTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTsKICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiA1NTI5NSAmJiBjb2RlUG9pbnQgPCA1NzM0NCkgewogICAgICAgICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHsKICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gNTYzMTkpIHsKICAgICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkgewogICAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpOwogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDU2MzIwKSB7CiAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50OwogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gNTUyOTYgPDwgMTAgfCBjb2RlUG9pbnQgLSA1NjMyMCkgKyA2NTUzNjsKICAgICAgICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgIH0KICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsOwogICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDEyOCkgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAyMDQ4KSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiA2IHwgMTkyLCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDY1NTM2KSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAxMiB8IDIyNCwgY29kZVBvaW50ID4+IDYgJiA2MyB8IDEyOCwgY29kZVBvaW50ICYgNjMgfCAxMjgpOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAxMTE0MTEyKSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAxOCB8IDI0MCwgY29kZVBvaW50ID4+IDEyICYgNjMgfCAxMjgsIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb2RlIHBvaW50Iik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlczsKICAgICAgfQogICAgICBmdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7CiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMjU1KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhzdHIsIHVuaXRzKSB7CiAgICAgICAgbGV0IGMsIGhpLCBsbzsKICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBbXTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkgewogICAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgICAgICAgaGkgPSBjID4+IDg7CiAgICAgICAgICBsbyA9IGMgJSAyNTY7CiAgICAgICAgICBieXRlQXJyYXkucHVzaChsbyk7CiAgICAgICAgICBieXRlQXJyYXkucHVzaChoaSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlQXJyYXk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhzdHIpIHsKICAgICAgICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJsaXRCdWZmZXIoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgbGV0IGk7CiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICBpZiAoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoIHx8IGkgPj0gc3JjLmxlbmd0aCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGlzSW5zdGFuY2Uob2JqLCB0eXBlKSB7CiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHwgb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG51bWJlcklzTmFOKG9iaikgewogICAgICAgIHJldHVybiBvYmogIT09IG9iajsKICAgICAgfQogICAgICB2YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IGZ1bmN0aW9uKCkgewogICAgICAgIGNvbnN0IGFscGhhYmV0ID0gIjAxMjM0NTY3ODlhYmNkZWYiOwogICAgICAgIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1Nik7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7CiAgICAgICAgICBjb25zdCBpMTYgPSBpICogMTY7CiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHsKICAgICAgICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFibGU7CiAgICAgIH0oKTsKICAgICAgZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kKGZuKSB7CiAgICAgICAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICJ1bmRlZmluZWQiID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQoKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJCaWdJbnQgbm90IHN1cHBvcnRlZCIpOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIHNyYy9hbGlhcy9idWZmZXItc2hpbS5qcwogIHZhciBpbXBvcnRfYnVmZmVyOwogIHZhciBpbml0X2J1ZmZlcl9zaGltID0gX19lc20oewogICAgInNyYy9hbGlhcy9idWZmZXItc2hpbS5qcyIoKSB7CiAgICAgIGltcG9ydF9idWZmZXIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsQDEuNy41L25vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9janMtcG9ueWZpbGwuanMKICB2YXIgcmVxdWlyZV9janNfcG9ueWZpbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsQDEuNy41L25vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9janMtcG9ueWZpbGwuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgewogICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgewogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07CiAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7CiAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7CiAgICAgICAgICBpZiAoInZhbHVlIiBpbiBkZXNjcmlwdG9yKQogICAgICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgewogICAgICAgIGlmIChwcm90b1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsKICAgICAgICBpZiAoc3RhdGljUHJvcHMpCiAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOwogICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgInByb3RvdHlwZSIsIHsKICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZQogICAgICAgIH0pOwogICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsKICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICJmdW5jdGlvbiIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7CiAgICAgICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsICJwcm90b3R5cGUiLCB7CiAgICAgICAgICB3cml0YWJsZTogZmFsc2UKICAgICAgICB9KTsKICAgICAgICBpZiAoc3VwZXJDbGFzcykKICAgICAgICAgIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsKICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mMihvMikgewogICAgICAgICAgcmV0dXJuIG8yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobzIpOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgewogICAgICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YyKG8yLCBwMikgewogICAgICAgICAgbzIuX19wcm90b19fID0gcDI7CiAgICAgICAgICByZXR1cm4gbzI7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHRyeSB7CiAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkgewogICAgICAgICAgfSkpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYyKSB7CiAgICAgICAgaWYgKHNlbGYyID09PSB2b2lkIDApIHsKICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzZWxmMjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmMiwgY2FsbCkgewogICAgICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIGNhbGwgPT09ICJmdW5jdGlvbiIpKSB7CiAgICAgICAgICByZXR1cm4gY2FsbDsKICAgICAgICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWQiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZjIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7CiAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgewogICAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7CiAgICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgewogICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOwogICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgewogICAgICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7CiAgICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsKICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqZWN0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9nZXQoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSAidW5kZWZpbmVkIiAmJiBSZWZsZWN0LmdldCkgewogICAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQyKHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7CiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmICghYmFzZSkKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmIChkZXNjLmdldCkgewogICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlOwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICB2YXIgRW1pdHRlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBFbWl0dGVyMigpIHsKICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyMik7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgImxpc3RlbmVycyIsIHsKICAgICAgICAgICAgdmFsdWU6IHt9LAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIyLCBbewogICAgICAgICAga2V5OiAiYWRkRXZlbnRMaXN0ZW5lciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgewogICAgICAgICAgICBpZiAoISh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgewogICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7CiAgICAgICAgICAgICAgY2FsbGJhY2ssCiAgICAgICAgICAgICAgb3B0aW9ucwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJyZW1vdmVFdmVudExpc3RlbmVyIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW3R5cGVdOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIGlmIChzdGFja1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spIHsKICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmICghKGV2ZW50LnR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdOwogICAgICAgICAgICB2YXIgc3RhY2tUb0NhbGwgPSBzdGFjay5zbGljZSgpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrVG9DYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHN0YWNrVG9DYWxsW2ldOwogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vcHRpb25zICYmIGxpc3RlbmVyLm9wdGlvbnMub25jZSkgewogICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGxpc3RlbmVyLmNhbGxiYWNrKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gRW1pdHRlcjI7CiAgICAgIH0oKTsKICAgICAgdmFyIEFib3J0U2lnbmFsID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9FbWl0dGVyKSB7CiAgICAgICAgX2luaGVyaXRzKEFib3J0U2lnbmFsMiwgX0VtaXR0ZXIpOwogICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWJvcnRTaWduYWwyKTsKICAgICAgICBmdW5jdGlvbiBBYm9ydFNpZ25hbDIoKSB7CiAgICAgICAgICB2YXIgX3RoaXM7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRTaWduYWwyKTsKICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7CiAgICAgICAgICBpZiAoIV90aGlzLmxpc3RlbmVycykgewogICAgICAgICAgICBFbWl0dGVyLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOwogICAgICAgICAgfQogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAiYWJvcnRlZCIsIHsKICAgICAgICAgICAgdmFsdWU6IGZhbHNlLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgIm9uYWJvcnQiLCB7CiAgICAgICAgICAgIHZhbHVlOiBudWxsLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgInJlYXNvbiIsIHsKICAgICAgICAgICAgdmFsdWU6IHZvaWQgMCwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gX3RoaXM7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhBYm9ydFNpZ25hbDIsIFt7CiAgICAgICAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIHJldHVybiAiW29iamVjdCBBYm9ydFNpZ25hbF0iOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImRpc3BhdGNoRXZlbnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHsKICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICJhYm9ydCIpIHsKICAgICAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlOwogICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbmFib3J0ID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgICAgICB0aGlzLm9uYWJvcnQuY2FsbCh0aGlzLCBldmVudCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEFib3J0U2lnbmFsMi5wcm90b3R5cGUpLCAiZGlzcGF0Y2hFdmVudCIsIHRoaXMpLmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gQWJvcnRTaWduYWwyOwogICAgICB9KEVtaXR0ZXIpOwogICAgICB2YXIgQWJvcnRDb250cm9sbGVyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkgewogICAgICAgIGZ1bmN0aW9uIEFib3J0Q29udHJvbGxlcjIoKSB7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRDb250cm9sbGVyMik7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgInNpZ25hbCIsIHsKICAgICAgICAgICAgdmFsdWU6IG5ldyBBYm9ydFNpZ25hbCgpLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgX2NyZWF0ZUNsYXNzKEFib3J0Q29udHJvbGxlcjIsIFt7CiAgICAgICAgICBrZXk6ICJhYm9ydCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7CiAgICAgICAgICAgIHZhciBldmVudDsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBldmVudCA9IG5ldyBFdmVudCgiYWJvcnQiKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7CiAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTsKICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9ICJhYm9ydCI7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCJFdmVudCIpOwogICAgICAgICAgICAgICAgICBldmVudC5pbml0RXZlbnQoImFib3J0IiwgZmFsc2UsIGZhbHNlKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZXZlbnQgPSB7CiAgICAgICAgICAgICAgICAgIHR5cGU6ICJhYm9ydCIsCiAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLAogICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZQogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHNpZ25hbFJlYXNvbiA9IHJlYXNvbjsKICAgICAgICAgICAgaWYgKHNpZ25hbFJlYXNvbiA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbiA9IG5ldyBFcnJvcigiVGhpcyBvcGVyYXRpb24gd2FzIGFib3J0ZWQiKTsKICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbi5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRE9NRXhjZXB0aW9uKCJzaWduYWwgaXMgYWJvcnRlZCB3aXRob3V0IHJlYXNvbiIpOwogICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbiA9IG5ldyBFcnJvcigiVGhpcyBvcGVyYXRpb24gd2FzIGFib3J0ZWQiKTsKICAgICAgICAgICAgICAgICAgc2lnbmFsUmVhc29uLm5hbWUgPSAiQWJvcnRFcnJvciI7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlYXNvbiA9IHNpZ25hbFJlYXNvbjsKICAgICAgICAgICAgdGhpcy5zaWduYWwuZGlzcGF0Y2hFdmVudChldmVudCk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAidG9TdHJpbmciLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gIltvYmplY3QgQWJvcnRDb250cm9sbGVyXSI7CiAgICAgICAgICB9CiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBBYm9ydENvbnRyb2xsZXIyOwogICAgICB9KCk7CiAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAidW5kZWZpbmVkIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHsKICAgICAgICBBYm9ydENvbnRyb2xsZXIucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAiQWJvcnRDb250cm9sbGVyIjsKICAgICAgICBBYm9ydFNpZ25hbC5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICJBYm9ydFNpZ25hbCI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9seWZpbGxOZWVkZWQoc2VsZjIpIHsKICAgICAgICBpZiAoc2VsZjIuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCkgewogICAgICAgICAgY29uc29sZS5sb2coIl9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEw9dHJ1ZSBpcyBzZXQsIHdpbGwgZm9yY2UgaW5zdGFsbCBwb2x5ZmlsbCIpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0eXBlb2Ygc2VsZjIuUmVxdWVzdCA9PT0gImZ1bmN0aW9uIiAmJiAhc2VsZjIuUmVxdWVzdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoInNpZ25hbCIpIHx8ICFzZWxmMi5BYm9ydENvbnRyb2xsZXI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYWJvcnRhYmxlRmV0Y2hEZWNvcmF0b3IocGF0Y2hUYXJnZXRzKSB7CiAgICAgICAgaWYgKHR5cGVvZiBwYXRjaFRhcmdldHMgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHBhdGNoVGFyZ2V0cyA9IHsKICAgICAgICAgICAgZmV0Y2g6IHBhdGNoVGFyZ2V0cwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgdmFyIF9wYXRjaFRhcmdldHMgPSBwYXRjaFRhcmdldHMsIGZldGNoID0gX3BhdGNoVGFyZ2V0cy5mZXRjaCwgX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cy5SZXF1ZXN0LCBOYXRpdmVSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID09PSB2b2lkIDAgPyBmZXRjaC5SZXF1ZXN0IDogX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0LCBOYXRpdmVBYm9ydENvbnRyb2xsZXIgPSBfcGF0Y2hUYXJnZXRzLkFib3J0Q29udHJvbGxlciwgX3BhdGNoVGFyZ2V0cyRfX0ZPUkNFID0gX3BhdGNoVGFyZ2V0cy5fX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMLCBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMID0gX3BhdGNoVGFyZ2V0cyRfX0ZPUkNFID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wYXRjaFRhcmdldHMkX19GT1JDRTsKICAgICAgICBpZiAoIXBvbHlmaWxsTmVlZGVkKHsKICAgICAgICAgIGZldGNoLAogICAgICAgICAgUmVxdWVzdDogTmF0aXZlUmVxdWVzdCwKICAgICAgICAgIEFib3J0Q29udHJvbGxlcjogTmF0aXZlQWJvcnRDb250cm9sbGVyLAogICAgICAgICAgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTAogICAgICAgIH0pKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBmZXRjaCwKICAgICAgICAgICAgUmVxdWVzdAogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgdmFyIFJlcXVlc3QgPSBOYXRpdmVSZXF1ZXN0OwogICAgICAgIGlmIChSZXF1ZXN0ICYmICFSZXF1ZXN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgic2lnbmFsIikgfHwgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCkgewogICAgICAgICAgUmVxdWVzdCA9IGZ1bmN0aW9uIFJlcXVlc3QyKGlucHV0LCBpbml0MikgewogICAgICAgICAgICB2YXIgc2lnbmFsOwogICAgICAgICAgICBpZiAoaW5pdDIgJiYgaW5pdDIuc2lnbmFsKSB7CiAgICAgICAgICAgICAgc2lnbmFsID0gaW5pdDIuc2lnbmFsOwogICAgICAgICAgICAgIGRlbGV0ZSBpbml0Mi5zaWduYWw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgTmF0aXZlUmVxdWVzdChpbnB1dCwgaW5pdDIpOwogICAgICAgICAgICBpZiAoc2lnbmFsKSB7CiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVlc3QsICJzaWduYWwiLCB7CiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsCiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICAgIHZhbHVlOiBzaWduYWwKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVxdWVzdDsKICAgICAgICAgIH07CiAgICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZSA9IE5hdGl2ZVJlcXVlc3QucHJvdG90eXBlOwogICAgICAgIH0KICAgICAgICB2YXIgcmVhbEZldGNoID0gZmV0Y2g7CiAgICAgICAgdmFyIGFib3J0YWJsZUZldGNoID0gZnVuY3Rpb24gYWJvcnRhYmxlRmV0Y2gyKGlucHV0LCBpbml0MikgewogICAgICAgICAgdmFyIHNpZ25hbCA9IFJlcXVlc3QgJiYgUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgPyBpbnB1dC5zaWduYWwgOiBpbml0MiA/IGluaXQyLnNpZ25hbCA6IHZvaWQgMDsKICAgICAgICAgIGlmIChzaWduYWwpIHsKICAgICAgICAgICAgdmFyIGFib3J0RXJyb3I7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgYWJvcnRFcnJvciA9IG5ldyBET01FeGNlcHRpb24oIkFib3J0ZWQiLCAiQWJvcnRFcnJvciIpOwogICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICBhYm9ydEVycm9yID0gbmV3IEVycm9yKCJBYm9ydGVkIik7CiAgICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgY2FuY2VsbGF0aW9uID0gbmV3IFByb21pc2UoZnVuY3Rpb24oXywgcmVqZWN0KSB7CiAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGFib3J0RXJyb3IpOwogICAgICAgICAgICAgIH0sIHsKICAgICAgICAgICAgICAgIG9uY2U6IHRydWUKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGlmIChpbml0MiAmJiBpbml0Mi5zaWduYWwpIHsKICAgICAgICAgICAgICBkZWxldGUgaW5pdDIuc2lnbmFsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvbiwgcmVhbEZldGNoKGlucHV0LCBpbml0MildKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZWFsRmV0Y2goaW5wdXQsIGluaXQyKTsKICAgICAgICB9OwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBmZXRjaDogYWJvcnRhYmxlRmV0Y2gsCiAgICAgICAgICBSZXF1ZXN0CiAgICAgICAgfTsKICAgICAgfQogICAgICBleHBvcnRzMi5BYm9ydENvbnRyb2xsZXIgPSBBYm9ydENvbnRyb2xsZXI7CiAgICAgIGV4cG9ydHMyLkFib3J0U2lnbmFsID0gQWJvcnRTaWduYWw7CiAgICAgIGV4cG9ydHMyLmFib3J0YWJsZUZldGNoID0gYWJvcnRhYmxlRmV0Y2hEZWNvcmF0b3I7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL2Fib3J0Y29udHJvbGxlci1wb255ZmlsbC5qcwogIHZhciByZXF1aXJlX2Fib3J0Y29udHJvbGxlcl9wb255ZmlsbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL2Fib3J0Y29udHJvbGxlci1wb255ZmlsbC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5BYm9ydFNpZ25hbCA9IGV4cG9ydHMyLkFib3J0Q29udHJvbGxlciA9IHZvaWQgMDsKICAgICAgdmFyIGNqc19wb255ZmlsbF8xID0gcmVxdWlyZV9janNfcG9ueWZpbGwoKTsKICAgICAgdmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiBzZWxmOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiB3aW5kb3c7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgcmV0dXJuIGdsb2JhbDsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QiKTsKICAgICAgfTsKICAgICAgdmFyIEFib3J0Q29udHJvbGxlciA9IHR5cGVvZiBnZXRHbG9iYWwoKS5BYm9ydENvbnRyb2xsZXIgPT09ICJ1bmRlZmluZWQiID8gY2pzX3BvbnlmaWxsXzEuQWJvcnRDb250cm9sbGVyIDogZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyOwogICAgICBleHBvcnRzMi5BYm9ydENvbnRyb2xsZXIgPSBBYm9ydENvbnRyb2xsZXI7CiAgICAgIHZhciBBYm9ydFNpZ25hbCA9IHR5cGVvZiBnZXRHbG9iYWwoKS5BYm9ydENvbnRyb2xsZXIgPT09ICJ1bmRlZmluZWQiID8gY2pzX3BvbnlmaWxsXzEuQWJvcnRTaWduYWwgOiBnZXRHbG9iYWwoKS5BYm9ydFNpZ25hbDsKICAgICAgZXhwb3J0czIuQWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWdncmVnYXRlQWJvcnRDb250cm9sbGVyLmpzCiAgdmFyIHJlcXVpcmVfQWdncmVnYXRlQWJvcnRDb250cm9sbGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWdncmVnYXRlQWJvcnRDb250cm9sbGVyLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBhYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGxfMSA9IHJlcXVpcmVfYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsKCk7CiAgICAgIHZhciBOdWxsU2lnbmFsID0gY2xhc3MgewogICAgICB9OwogICAgICB2YXIgQWdncmVnYXRlQWJvcnRDb250cm9sbGVyID0gY2xhc3MgewogICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgdGhpcy5zaWduYWxzID0gbmV3IFNldCgpOwogICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsXzEuQWJvcnRDb250cm9sbGVyKCk7CiAgICAgICAgfQogICAgICAgIGFkZFNpZ25hbChzaWduYWwgPSBuZXcgTnVsbFNpZ25hbCgpKSB7CiAgICAgICAgICBpZiAodGhpcy5zaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNhbm5vdCBhZGQgYSBzaWduYWwsIGFscmVhZHkgYWJvcnRlZCEiKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuc2lnbmFscy5hZGQoc2lnbmFsKTsKICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICB0aGlzLmhhbmRsZUFib3J0ZWQoc2lnbmFsKTsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsICgpID0+IHsKICAgICAgICAgICAgICB0aGlzLmhhbmRsZUFib3J0ZWQoc2lnbmFsKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGhhbmRsZUFib3J0ZWQoc2lnbmFsKSB7CiAgICAgICAgICB0aGlzLnNpZ25hbHMuZGVsZXRlKHNpZ25hbCk7CiAgICAgICAgICBpZiAodGhpcy5zaWduYWxzLnNpemUgPT09IDApIHsKICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZ2V0IHNpZ25hbCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWw7CiAgICAgICAgfQogICAgICAgIGFib3J0KCkgewogICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyLmpzCiAgdmFyIHJlcXVpcmVfQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYWJvcnRhYmxlLXByb21pc2UtY2FjaGVAMS41LjAvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlci5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIgPSBjbGFzcyB7CiAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBTZXQoKTsKICAgICAgICB9CiAgICAgICAgYWRkQ2FsbGJhY2soY2FsbGJhY2sgPSAoKSA9PiB7CiAgICAgICAgfSkgewogICAgICAgICAgdGhpcy5jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTsKICAgICAgICAgIGNhbGxiYWNrKHRoaXMuY3VycmVudE1lc3NhZ2UpOwogICAgICAgIH0KICAgICAgICBjYWxsYmFjayhtZXNzYWdlKSB7CiAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlID0gbWVzc2FnZTsKICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goKGVsdCkgPT4gewogICAgICAgICAgICBlbHQobWVzc2FnZSk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWJvcnRhYmxlUHJvbWlzZUNhY2hlLmpzCiAgdmFyIHJlcXVpcmVfQWJvcnRhYmxlUHJvbWlzZUNhY2hlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWJvcnRhYmxlUHJvbWlzZUNhY2hlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IGV4cG9ydHMyICYmIGV4cG9ydHMyLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbihtb2QpIHsKICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyAiZGVmYXVsdCI6IG1vZCB9OwogICAgICB9OwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xID0gcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwoKTsKICAgICAgdmFyIEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfQWdncmVnYXRlQWJvcnRDb250cm9sbGVyKCkpOwogICAgICB2YXIgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyKCkpOwogICAgICB2YXIgQWJvcnRhYmxlUHJvbWlzZUNhY2hlMiA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3Rvcih7IGZpbGwsIGNhY2hlIH0pIHsKICAgICAgICAgIGlmICh0eXBlb2YgZmlsbCAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBmaWxsIGZ1bmN0aW9uIik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGNhY2hlICE9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBjYWNoZSBvYmplY3QiKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgY2FjaGUuZ2V0ICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBjYWNoZS5zZXQgIT09ICJmdW5jdGlvbiIgfHwgdHlwZW9mIGNhY2hlLmRlbGV0ZSAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJjYWNoZSBtdXN0IGltcGxlbWVudCBnZXQoa2V5KSwgc2V0KGtleSwgdmFsKSwgYW5kIGFuZCBkZWxldGUoa2V5KSIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlOwogICAgICAgICAgdGhpcy5maWxsQ2FsbGJhY2sgPSBmaWxsOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgaXNBYm9ydEV4Y2VwdGlvbihleGNlcHRpb24pIHsKICAgICAgICAgIHJldHVybiBleGNlcHRpb24ubmFtZSA9PT0gIkFib3J0RXJyb3IiIHx8IGV4Y2VwdGlvbi5jb2RlID09PSAiRVJSX0FCT1JURUQiIHx8IGV4Y2VwdGlvbi5tZXNzYWdlID09PSAiQWJvcnRFcnJvcjogYWJvcnRlZCIgfHwgZXhjZXB0aW9uLm1lc3NhZ2UgPT09ICJFcnJvcjogYWJvcnRlZCI7CiAgICAgICAgfQogICAgICAgIGV2aWN0KGtleSwgZW50cnkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmdldChrZXkpID09PSBlbnRyeSkgewogICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmaWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgY29uc3QgYWJvcnRlciA9IG5ldyBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXJfMS5kZWZhdWx0KCk7CiAgICAgICAgICBjb25zdCBzdGF0dXNSZXBvcnRlciA9IG5ldyBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcl8xLmRlZmF1bHQoKTsKICAgICAgICAgIHN0YXR1c1JlcG9ydGVyLmFkZENhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgIGNvbnN0IG5ld0VudHJ5ID0gewogICAgICAgICAgICBhYm9ydGVyLAogICAgICAgICAgICBwcm9taXNlOiB0aGlzLmZpbGxDYWxsYmFjayhkYXRhLCBhYm9ydGVyLnNpZ25hbCwgKG1lc3NhZ2UpID0+IHsKICAgICAgICAgICAgICBzdGF0dXNSZXBvcnRlci5jYWxsYmFjayhtZXNzYWdlKTsKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIHNldHRsZWQ6IGZhbHNlLAogICAgICAgICAgICBzdGF0dXNSZXBvcnRlciwKICAgICAgICAgICAgZ2V0IGFib3J0ZWQoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWJvcnRlci5zaWduYWwuYWJvcnRlZDsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIG5ld0VudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICBuZXdFbnRyeS5hYm9ydGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsICgpID0+IHsKICAgICAgICAgICAgaWYgKCFuZXdFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgdGhpcy5ldmljdChrZXksIG5ld0VudHJ5KTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBuZXdFbnRyeS5wcm9taXNlLnRoZW4oKCkgPT4gewogICAgICAgICAgICBuZXdFbnRyeS5zZXR0bGVkID0gdHJ1ZTsKICAgICAgICAgIH0sICgpID0+IHsKICAgICAgICAgICAgbmV3RW50cnkuc2V0dGxlZCA9IHRydWU7CiAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4gewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpOwogICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgfSk7CiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIG5ld0VudHJ5KTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGNoZWNrU2luZ2xlUHJvbWlzZShwcm9taXNlLCBzaWduYWwpIHsKICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrRm9yU2luZ2xlQWJvcnQoKSB7CiAgICAgICAgICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcigiYWJvcnRlZCIpLCB7IGNvZGU6ICJFUlJfQUJPUlRFRCIgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4gewogICAgICAgICAgICBjaGVja0ZvclNpbmdsZUFib3J0KCk7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgICB9LCAoZXJyb3IpID0+IHsKICAgICAgICAgICAgY2hlY2tGb3JTaW5nbGVBYm9ydCgpOwogICAgICAgICAgICB0aHJvdyBlcnJvcjsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBoYXMoa2V5KSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KTsKICAgICAgICB9CiAgICAgICAgZ2V0KGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgaWYgKCFzaWduYWwgJiYgZGF0YSBpbnN0YW5jZW9mIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xLkFib3J0U2lnbmFsKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoInNlY29uZCBnZXQgYXJndW1lbnQgYXBwZWFycyB0byBiZSBhbiBBYm9ydFNpZ25hbCwgcGVyaGFwcyB5b3UgbWVhbnQgdG8gcGFzcyBgbnVsbGAgZm9yIHRoZSBmaWxsIGRhdGE/Iik7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIGlmIChjYWNoZUVudHJ5KSB7CiAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LmFib3J0ZWQgJiYgIWNhY2hlRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBjYWNoZUVudHJ5KTsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCBkYXRhLCBzaWduYWwsIHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkucHJvbWlzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYWNoZUVudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICAgIGNhY2hlRW50cnkuc3RhdHVzUmVwb3J0ZXIuYWRkQ2FsbGJhY2soc3RhdHVzQ2FsbGJhY2spOwogICAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UoY2FjaGVFbnRyeS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5maWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UodGhpcy5jYWNoZS5nZXQoa2V5KS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgIH0KICAgICAgICBkZWxldGUoa2V5KSB7CiAgICAgICAgICBjb25zdCBjYWNoZWRFbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICBpZiAoY2FjaGVkRW50cnkpIHsKICAgICAgICAgICAgaWYgKCFjYWNoZWRFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgY2FjaGVkRW50cnkuYWJvcnRlci5hYm9ydCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNsZWFyKCkgewogICAgICAgICAgY29uc3Qga2V5SXRlciA9IHRoaXMuY2FjaGUua2V5cygpOwogICAgICAgICAgbGV0IGRlbGV0ZUNvdW50ID0gMDsKICAgICAgICAgIGZvciAobGV0IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpOyAhcmVzdWx0LmRvbmU7IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpKSB7CiAgICAgICAgICAgIHRoaXMuZGVsZXRlKHJlc3VsdC52YWx1ZSk7CiAgICAgICAgICAgIGRlbGV0ZUNvdW50ICs9IDE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZGVsZXRlQ291bnQ7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vaW5kZXguanMKICB2YXIgcmVxdWlyZV9lc20gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYWJvcnRhYmxlLXByb21pc2UtY2FjaGVAMS41LjAvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9pbmRleC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfX2ltcG9ydERlZmF1bHQgPSBleHBvcnRzMiAmJiBleHBvcnRzMi5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgImRlZmF1bHQiOiBtb2QgfTsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBBYm9ydGFibGVQcm9taXNlQ2FjaGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX0Fib3J0YWJsZVByb21pc2VDYWNoZSgpKTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IEFib3J0YWJsZVByb21pc2VDYWNoZV8xLmRlZmF1bHQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9xdWljay1scnVANC4wLjEvbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcwogIHZhciByZXF1aXJlX3F1aWNrX2xydSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9xdWljay1scnVANC4wLjEvbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBRdWlja0xSVSA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHsKICAgICAgICAgIGlmICghKG9wdGlvbnMubWF4U2l6ZSAmJiBvcHRpb25zLm1heFNpemUgPiAwKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJgbWF4U2l6ZWAgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5tYXhTaXplID0gb3B0aW9ucy5tYXhTaXplOwogICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICAgIHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICB9CiAgICAgICAgX3NldChrZXksIHZhbHVlKSB7CiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTsKICAgICAgICAgIHRoaXMuX3NpemUrKzsKICAgICAgICAgIGlmICh0aGlzLl9zaXplID49IHRoaXMubWF4U2l6ZSkgewogICAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICAgICAgdGhpcy5vbGRDYWNoZSA9IHRoaXMuY2FjaGU7CiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdldChrZXkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm9sZENhY2hlLmdldChrZXkpOwogICAgICAgICAgICB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIGhhcyhrZXkpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmhhcyhrZXkpIHx8IHRoaXMub2xkQ2FjaGUuaGFzKGtleSk7CiAgICAgICAgfQogICAgICAgIHBlZWsoa2V5KSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLm9sZENhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkZWxldGUoa2V5KSB7CiAgICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTsKICAgICAgICAgIGlmIChkZWxldGVkKSB7CiAgICAgICAgICAgIHRoaXMuX3NpemUtLTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpIHx8IGRlbGV0ZWQ7CiAgICAgICAgfQogICAgICAgIGNsZWFyKCkgewogICAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpOwogICAgICAgICAgdGhpcy5vbGRDYWNoZS5jbGVhcigpOwogICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICAgICAgfQogICAgICAgICprZXlzKCkgewogICAgICAgICAgZm9yIChjb25zdCBba2V5XSBvZiB0aGlzKSB7CiAgICAgICAgICAgIHlpZWxkIGtleTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgKnZhbHVlcygpIHsKICAgICAgICAgIGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMpIHsKICAgICAgICAgICAgeWllbGQgdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7CiAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkgewogICAgICAgICAgICBjb25zdCBba2V5XSA9IGl0ZW07CiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZ2V0IHNpemUoKSB7CiAgICAgICAgICBsZXQgb2xkQ2FjaGVTaXplID0gMDsKICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMub2xkQ2FjaGUua2V5cygpKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICAgIG9sZENhY2hlU2l6ZSsrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSArIG9sZENhY2hlU2l6ZTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFF1aWNrTFJVOwogICAgfQogIH0pOwoKICAvLyAoZGlzYWJsZWQpOm5vZGVfbW9kdWxlcy8ucG5wbS9nZW5lcmljLWZpbGVoYW5kbGVAMy4xLjEvbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vbG9jYWxGaWxlCiAgdmFyIHJlcXVpcmVfbG9jYWxGaWxlID0gX19jb21tb25KUyh7CiAgICAiKGRpc2FibGVkKTpub2RlX21vZHVsZXMvLnBucG0vZ2VuZXJpYy1maWxlaGFuZGxlQDMuMS4xL25vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2xvY2FsRmlsZSIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMKICB2YXIgcmVxdWlyZV9jb21tb24gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBUWVBFRF9PSyA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgVWludDE2QXJyYXkgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBJbnQzMkFycmF5ICE9PSAidW5kZWZpbmVkIjsKICAgICAgZnVuY3Rpb24gX2hhcyhvYmosIGtleSkgewogICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmFzc2lnbiA9IGZ1bmN0aW9uKG9iaikgewogICAgICAgIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgICAgICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHsKICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7CiAgICAgICAgICBpZiAoIXNvdXJjZSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICJtdXN0IGJlIG5vbi1vYmplY3QiKTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7CiAgICAgICAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHsKICAgICAgICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9iajsKICAgICAgfTsKICAgICAgZXhwb3J0czIuc2hyaW5rQnVmID0gZnVuY3Rpb24oYnVmLCBzaXplKSB7CiAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsKICAgICAgICAgIHJldHVybiBidWY7CiAgICAgICAgfQogICAgICAgIGlmIChidWYuc3ViYXJyYXkpIHsKICAgICAgICAgIHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7CiAgICAgICAgfQogICAgICAgIGJ1Zi5sZW5ndGggPSBzaXplOwogICAgICAgIHJldHVybiBidWY7CiAgICAgIH07CiAgICAgIHZhciBmblR5cGVkID0gewogICAgICAgIGFycmF5U2V0OiBmdW5jdGlvbihkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2ZmcykgewogICAgICAgICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7CiAgICAgICAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpOwogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uKGNodW5rcykgewogICAgICAgICAgdmFyIGksIGwsIGxlbiwgcG9zLCBjaHVuaywgcmVzdWx0OwogICAgICAgICAgbGVuID0gMDsKICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTsKICAgICAgICAgIHBvcyA9IDA7CiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICBjaHVuayA9IGNodW5rc1tpXTsKICAgICAgICAgICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTsKICAgICAgICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgZm5VbnR5cGVkID0gewogICAgICAgIGFycmF5U2V0OiBmdW5jdGlvbihkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2ZmcykgewogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihjaHVua3MpIHsKICAgICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGNodW5rcyk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5zZXRUeXBlZCA9IGZ1bmN0aW9uKG9uKSB7CiAgICAgICAgaWYgKG9uKSB7CiAgICAgICAgICBleHBvcnRzMi5CdWY4ID0gVWludDhBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjE2ID0gVWludDE2QXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5CdWYzMiA9IEludDMyQXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5hc3NpZ24oZXhwb3J0czIsIGZuVHlwZWQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBleHBvcnRzMi5CdWY4ID0gQXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5CdWYxNiA9IEFycmF5OwogICAgICAgICAgZXhwb3J0czIuQnVmMzIgPSBBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLmFzc2lnbihleHBvcnRzMiwgZm5VbnR5cGVkKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLnNldFR5cGVkKFRZUEVEX09LKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzCiAgdmFyIHJlcXVpcmVfdHJlZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgWl9GSVhFRCA9IDQ7CiAgICAgIHZhciBaX0JJTkFSWSA9IDA7CiAgICAgIHZhciBaX1RFWFQgPSAxOwogICAgICB2YXIgWl9VTktOT1dOID0gMjsKICAgICAgZnVuY3Rpb24gemVybyhidWYpIHsKICAgICAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICB3aGlsZSAoLS1sZW4gPj0gMCkgewogICAgICAgICAgYnVmW2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgU1RPUkVEX0JMT0NLID0gMDsKICAgICAgdmFyIFNUQVRJQ19UUkVFUyA9IDE7CiAgICAgIHZhciBEWU5fVFJFRVMgPSAyOwogICAgICB2YXIgTUlOX01BVENIID0gMzsKICAgICAgdmFyIE1BWF9NQVRDSCA9IDI1ODsKICAgICAgdmFyIExFTkdUSF9DT0RFUyA9IDI5OwogICAgICB2YXIgTElURVJBTFMgPSAyNTY7CiAgICAgIHZhciBMX0NPREVTID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTOwogICAgICB2YXIgRF9DT0RFUyA9IDMwOwogICAgICB2YXIgQkxfQ09ERVMgPSAxOTsKICAgICAgdmFyIEhFQVBfU0laRSA9IDIgKiBMX0NPREVTICsgMTsKICAgICAgdmFyIE1BWF9CSVRTID0gMTU7CiAgICAgIHZhciBCdWZfc2l6ZSA9IDE2OwogICAgICB2YXIgTUFYX0JMX0JJVFMgPSA3OwogICAgICB2YXIgRU5EX0JMT0NLID0gMjU2OwogICAgICB2YXIgUkVQXzNfNiA9IDE2OwogICAgICB2YXIgUkVQWl8zXzEwID0gMTc7CiAgICAgIHZhciBSRVBaXzExXzEzOCA9IDE4OwogICAgICB2YXIgZXh0cmFfbGJpdHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMF07CiAgICAgIHZhciBleHRyYV9kYml0cyA9IFswLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTNdOwogICAgICB2YXIgZXh0cmFfYmxiaXRzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDIsIDMsIDddOwogICAgICB2YXIgYmxfb3JkZXIgPSBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV07CiAgICAgIHZhciBESVNUX0NPREVfTEVOID0gNTEyOwogICAgICB2YXIgc3RhdGljX2x0cmVlID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTsKICAgICAgemVybyhzdGF0aWNfbHRyZWUpOwogICAgICB2YXIgc3RhdGljX2R0cmVlID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTsKICAgICAgemVybyhzdGF0aWNfZHRyZWUpOwogICAgICB2YXIgX2Rpc3RfY29kZSA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTsKICAgICAgemVybyhfZGlzdF9jb2RlKTsKICAgICAgdmFyIF9sZW5ndGhfY29kZSA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTsKICAgICAgemVybyhfbGVuZ3RoX2NvZGUpOwogICAgICB2YXIgYmFzZV9sZW5ndGggPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTsKICAgICAgemVybyhiYXNlX2xlbmd0aCk7CiAgICAgIHZhciBiYXNlX2Rpc3QgPSBuZXcgQXJyYXkoRF9DT0RFUyk7CiAgICAgIHplcm8oYmFzZV9kaXN0KTsKICAgICAgZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7CiAgICAgICAgdGhpcy5zdGF0aWNfdHJlZSA9IHN0YXRpY190cmVlOwogICAgICAgIHRoaXMuZXh0cmFfYml0cyA9IGV4dHJhX2JpdHM7CiAgICAgICAgdGhpcy5leHRyYV9iYXNlID0gZXh0cmFfYmFzZTsKICAgICAgICB0aGlzLmVsZW1zID0gZWxlbXM7CiAgICAgICAgdGhpcy5tYXhfbGVuZ3RoID0gbWF4X2xlbmd0aDsKICAgICAgICB0aGlzLmhhc19zdHJlZSA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDsKICAgICAgfQogICAgICB2YXIgc3RhdGljX2xfZGVzYzsKICAgICAgdmFyIHN0YXRpY19kX2Rlc2M7CiAgICAgIHZhciBzdGF0aWNfYmxfZGVzYzsKICAgICAgZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykgewogICAgICAgIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsKICAgICAgICB0aGlzLm1heF9jb2RlID0gMDsKICAgICAgICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkX2NvZGUoZGlzdCkgewogICAgICAgIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwdXRfc2hvcnQocywgdykgewogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gdyAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHcgPj4+IDggJiAyNTU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHsKICAgICAgICBpZiAocy5iaV92YWxpZCA+IEJ1Zl9zaXplIC0gbGVuZ3RoKSB7CiAgICAgICAgICBzLmJpX2J1ZiB8PSB2YWx1ZSA8PCBzLmJpX3ZhbGlkICYgNjU1MzU7CiAgICAgICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICAgICAgcy5iaV9idWYgPSB2YWx1ZSA+PiBCdWZfc2l6ZSAtIHMuYmlfdmFsaWQ7CiAgICAgICAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzLmJpX2J1ZiB8PSB2YWx1ZSA8PCBzLmJpX3ZhbGlkICYgNjU1MzU7CiAgICAgICAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHsKICAgICAgICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0sIHRyZWVbYyAqIDIgKyAxXSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHsKICAgICAgICB2YXIgcmVzID0gMDsKICAgICAgICBkbyB7CiAgICAgICAgICByZXMgfD0gY29kZSAmIDE7CiAgICAgICAgICBjb2RlID4+Pj0gMTsKICAgICAgICAgIHJlcyA8PD0gMTsKICAgICAgICB9IHdoaWxlICgtLWxlbiA+IDApOwogICAgICAgIHJldHVybiByZXMgPj4+IDE7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmlfZmx1c2gocykgewogICAgICAgIGlmIChzLmJpX3ZhbGlkID09PSAxNikgewogICAgICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgICAgICAgIHMuYmlfYnVmID0gMDsKICAgICAgICAgIHMuYmlfdmFsaWQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7CiAgICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMjU1OwogICAgICAgICAgcy5iaV9idWYgPj49IDg7CiAgICAgICAgICBzLmJpX3ZhbGlkIC09IDg7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYykgewogICAgICAgIHZhciB0cmVlID0gZGVzYy5keW5fdHJlZTsKICAgICAgICB2YXIgbWF4X2NvZGUgPSBkZXNjLm1heF9jb2RlOwogICAgICAgIHZhciBzdHJlZSA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlOwogICAgICAgIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7CiAgICAgICAgdmFyIGV4dHJhID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0czsKICAgICAgICB2YXIgYmFzZSA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7CiAgICAgICAgdmFyIG1heF9sZW5ndGggPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoOwogICAgICAgIHZhciBoOwogICAgICAgIHZhciBuLCBtOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciB4Yml0czsKICAgICAgICB2YXIgZjsKICAgICAgICB2YXIgb3ZlcmZsb3cgPSAwOwogICAgICAgIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykgewogICAgICAgICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7CiAgICAgICAgfQogICAgICAgIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdID0gMDsKICAgICAgICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7CiAgICAgICAgICBuID0gcy5oZWFwW2hdOwogICAgICAgICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdICogMiArIDFdICsgMTsKICAgICAgICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkgewogICAgICAgICAgICBiaXRzID0gbWF4X2xlbmd0aDsKICAgICAgICAgICAgb3ZlcmZsb3crKzsKICAgICAgICAgIH0KICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IGJpdHM7CiAgICAgICAgICBpZiAobiA+IG1heF9jb2RlKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgcy5ibF9jb3VudFtiaXRzXSsrOwogICAgICAgICAgeGJpdHMgPSAwOwogICAgICAgICAgaWYgKG4gPj0gYmFzZSkgewogICAgICAgICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTsKICAgICAgICAgIH0KICAgICAgICAgIGYgPSB0cmVlW24gKiAyXTsKICAgICAgICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7CiAgICAgICAgICBpZiAoaGFzX3N0cmVlKSB7CiAgICAgICAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0gKyB4Yml0cyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChvdmVyZmxvdyA9PT0gMCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBkbyB7CiAgICAgICAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7CiAgICAgICAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgewogICAgICAgICAgICBiaXRzLS07CiAgICAgICAgICB9CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdLS07CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOwogICAgICAgICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tOwogICAgICAgICAgb3ZlcmZsb3cgLT0gMjsKICAgICAgICB9IHdoaWxlIChvdmVyZmxvdyA+IDApOwogICAgICAgIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkgewogICAgICAgICAgbiA9IHMuYmxfY291bnRbYml0c107CiAgICAgICAgICB3aGlsZSAobiAhPT0gMCkgewogICAgICAgICAgICBtID0gcy5oZWFwWy0taF07CiAgICAgICAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodHJlZVttICogMiArIDFdICE9PSBiaXRzKSB7CiAgICAgICAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdKSAqIHRyZWVbbSAqIDJdOwogICAgICAgICAgICAgIHRyZWVbbSAqIDIgKyAxXSA9IGJpdHM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbi0tOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KSB7CiAgICAgICAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOwogICAgICAgIHZhciBjb2RlID0gMDsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHsKICAgICAgICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSBjb2RlICsgYmxfY291bnRbYml0cyAtIDFdIDw8IDE7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykgewogICAgICAgICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXTsKICAgICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICB0cmVlW24gKiAyXSA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIGxlbmd0aDsKICAgICAgICB2YXIgY29kZTsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsKICAgICAgICBsZW5ndGggPSAwOwogICAgICAgIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHsKICAgICAgICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoOwogICAgICAgICAgZm9yIChuID0gMDsgbiA8IDEgPDwgZXh0cmFfbGJpdHNbY29kZV07IG4rKykgewogICAgICAgICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTsKICAgICAgICBkaXN0ID0gMDsKICAgICAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykgewogICAgICAgICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDsKICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAxIDw8IGV4dHJhX2RiaXRzW2NvZGVdOyBuKyspIHsKICAgICAgICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZGlzdCA+Pj0gNzsKICAgICAgICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykgewogICAgICAgICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3OwogICAgICAgICAgZm9yIChuID0gMDsgbiA8IDEgPDwgZXh0cmFfZGJpdHNbY29kZV0gLSA3OyBuKyspIHsKICAgICAgICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7CiAgICAgICAgICBibF9jb3VudFtiaXRzXSA9IDA7CiAgICAgICAgfQogICAgICAgIG4gPSAwOwogICAgICAgIHdoaWxlIChuIDw9IDE0MykgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA4OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbOF0rKzsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKG4gPD0gMjU1KSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDk7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs5XSsrOwogICAgICAgIH0KICAgICAgICB3aGlsZSAobiA8PSAyNzkpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gNzsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzddKys7CiAgICAgICAgfQogICAgICAgIHdoaWxlIChuIDw9IDI4NykgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA4OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbOF0rKzsKICAgICAgICB9CiAgICAgICAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTsKICAgICAgICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXSA9IDU7CiAgICAgICAgICBzdGF0aWNfZHRyZWVbbiAqIDJdID0gYmlfcmV2ZXJzZShuLCA1KTsKICAgICAgICB9CiAgICAgICAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTsKICAgICAgICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsIERfQ09ERVMsIE1BWF9CSVRTKTsKICAgICAgICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzLmR5bl9sdHJlZVtuICogMl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzLmR5bl9kdHJlZVtuICogMl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgewogICAgICAgICAgcy5ibF90cmVlW24gKiAyXSA9IDA7CiAgICAgICAgfQogICAgICAgIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdID0gMTsKICAgICAgICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwOwogICAgICAgIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJpX3dpbmR1cChzKSB7CiAgICAgICAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7CiAgICAgICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICAgIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHsKICAgICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7CiAgICAgICAgfQogICAgICAgIHMuYmlfYnVmID0gMDsKICAgICAgICBzLmJpX3ZhbGlkID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpIHsKICAgICAgICBiaV93aW5kdXAocyk7CiAgICAgICAgaWYgKGhlYWRlcikgewogICAgICAgICAgcHV0X3Nob3J0KHMsIGxlbik7CiAgICAgICAgICBwdXRfc2hvcnQocywgfmxlbik7CiAgICAgICAgfQogICAgICAgIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTsKICAgICAgICBzLnBlbmRpbmcgKz0gbGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHsKICAgICAgICB2YXIgX24yID0gbiAqIDI7CiAgICAgICAgdmFyIF9tMiA9IG0gKiAyOwogICAgICAgIHJldHVybiB0cmVlW19uMl0gPCB0cmVlW19tMl0gfHwgdHJlZVtfbjJdID09PSB0cmVlW19tMl0gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKSB7CiAgICAgICAgdmFyIHYgPSBzLmhlYXBba107CiAgICAgICAgdmFyIGogPSBrIDw8IDE7CiAgICAgICAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikgewogICAgICAgICAgaWYgKGogPCBzLmhlYXBfbGVuICYmIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgewogICAgICAgICAgICBqKys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdOwogICAgICAgICAgayA9IGo7CiAgICAgICAgICBqIDw8PSAxOwogICAgICAgIH0KICAgICAgICBzLmhlYXBba10gPSB2OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSkgewogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBsYzsKICAgICAgICB2YXIgbHggPSAwOwogICAgICAgIHZhciBjb2RlOwogICAgICAgIHZhciBleHRyYTsKICAgICAgICBpZiAocy5sYXN0X2xpdCAhPT0gMCkgewogICAgICAgICAgZG8gewogICAgICAgICAgICBkaXN0ID0gcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4IHwgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV07CiAgICAgICAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdOwogICAgICAgICAgICBseCsrOwogICAgICAgICAgICBpZiAoZGlzdCA9PT0gMCkgewogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdOwogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7CiAgICAgICAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTsKICAgICAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHsKICAgICAgICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdOwogICAgICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGRpc3QtLTsKICAgICAgICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpOwogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7CiAgICAgICAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTsKICAgICAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHsKICAgICAgICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdOwogICAgICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7CiAgICAgICAgfQogICAgICAgIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpIHsKICAgICAgICB2YXIgdHJlZSA9IGRlc2MuZHluX3RyZWU7CiAgICAgICAgdmFyIHN0cmVlID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7CiAgICAgICAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTsKICAgICAgICB2YXIgZWxlbXMgPSBkZXNjLnN0YXRfZGVzYy5lbGVtczsKICAgICAgICB2YXIgbiwgbTsKICAgICAgICB2YXIgbWF4X2NvZGUgPSAtMTsKICAgICAgICB2YXIgbm9kZTsKICAgICAgICBzLmhlYXBfbGVuID0gMDsKICAgICAgICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFOwogICAgICAgIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7CiAgICAgICAgICBpZiAodHJlZVtuICogMl0gIT09IDApIHsKICAgICAgICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47CiAgICAgICAgICAgIHMuZGVwdGhbbl0gPSAwOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdHJlZVtuICogMiArIDFdID0gMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7CiAgICAgICAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMDsKICAgICAgICAgIHRyZWVbbm9kZSAqIDJdID0gMTsKICAgICAgICAgIHMuZGVwdGhbbm9kZV0gPSAwOwogICAgICAgICAgcy5vcHRfbGVuLS07CiAgICAgICAgICBpZiAoaGFzX3N0cmVlKSB7CiAgICAgICAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7CiAgICAgICAgZm9yIChuID0gcy5oZWFwX2xlbiA+PiAxOyBuID49IDE7IG4tLSkgewogICAgICAgICAgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsKICAgICAgICB9CiAgICAgICAgbm9kZSA9IGVsZW1zOwogICAgICAgIGRvIHsKICAgICAgICAgIG4gPSBzLmhlYXBbMV07CiAgICAgICAgICBzLmhlYXBbMV0gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTsKICAgICAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgMSk7CiAgICAgICAgICBtID0gcy5oZWFwWzFdOwogICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOwogICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtOwogICAgICAgICAgdHJlZVtub2RlICogMl0gPSB0cmVlW24gKiAyXSArIHRyZWVbbSAqIDJdOwogICAgICAgICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxOwogICAgICAgICAgdHJlZVtuICogMiArIDFdID0gdHJlZVttICogMiArIDFdID0gbm9kZTsKICAgICAgICAgIHMuaGVhcFsxXSA9IG5vZGUrKzsKICAgICAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgMSk7CiAgICAgICAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTsKICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxXTsKICAgICAgICBnZW5fYml0bGVuKHMsIGRlc2MpOwogICAgICAgIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIHByZXZsZW4gPSAtMTsKICAgICAgICB2YXIgY3VybGVuOwogICAgICAgIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOwogICAgICAgIHZhciBjb3VudCA9IDA7CiAgICAgICAgdmFyIG1heF9jb3VudCA9IDc7CiAgICAgICAgdmFyIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgfQogICAgICAgIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0gPSA2NTUzNTsKICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgICAgIGN1cmxlbiA9IG5leHRsZW47CiAgICAgICAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdOwogICAgICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkgewogICAgICAgICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0gKz0gY291bnQ7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkgewogICAgICAgICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7CiAgICAgICAgICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdKys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXSsrOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkgewogICAgICAgICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0rKzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdKys7CiAgICAgICAgICB9CiAgICAgICAgICBjb3VudCA9IDA7CiAgICAgICAgICBwcmV2bGVuID0gY3VybGVuOwogICAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNjsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDc7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSkgewogICAgICAgIHZhciBuOwogICAgICAgIHZhciBwcmV2bGVuID0gLTE7CiAgICAgICAgdmFyIGN1cmxlbjsKICAgICAgICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXTsKICAgICAgICB2YXIgY291bnQgPSAwOwogICAgICAgIHZhciBtYXhfY291bnQgPSA3OwogICAgICAgIHZhciBtaW5fY291bnQgPSA0OwogICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgICAgIGN1cmxlbiA9IG5leHRsZW47CiAgICAgICAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdOwogICAgICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkgewogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsKICAgICAgICAgICAgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkgewogICAgICAgICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsKICAgICAgICAgICAgICBjb3VudC0tOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpOwogICAgICAgICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHsKICAgICAgICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTsKICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTsKICAgICAgICAgIH0KICAgICAgICAgIGNvdW50ID0gMDsKICAgICAgICAgIHByZXZsZW4gPSBjdXJsZW47CiAgICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBtYXhfY291bnQgPSA2OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNzsKICAgICAgICAgICAgbWluX2NvdW50ID0gNDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7CiAgICAgICAgdmFyIG1heF9ibGluZGV4OwogICAgICAgIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpOwogICAgICAgIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpOwogICAgICAgIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTsKICAgICAgICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7CiAgICAgICAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXSAhPT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDsKICAgICAgICByZXR1cm4gbWF4X2JsaW5kZXg7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpIHsKICAgICAgICB2YXIgcmFuazsKICAgICAgICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsKICAgICAgICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgNSk7CiAgICAgICAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCA0KTsKICAgICAgICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7CiAgICAgICAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLCAzKTsKICAgICAgICB9CiAgICAgICAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsKICAgICAgICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykgewogICAgICAgIHZhciBibGFja19tYXNrID0gNDA5MzYyNDQ0NzsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7CiAgICAgICAgICBpZiAoYmxhY2tfbWFzayAmIDEgJiYgcy5keW5fbHRyZWVbbiAqIDJdICE9PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBaX0JJTkFSWTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXSAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdICE9PSAwIHx8IHMuZHluX2x0cmVlWzEzICogMl0gIT09IDApIHsKICAgICAgICAgIHJldHVybiBaX1RFWFQ7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykgewogICAgICAgICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXSAhPT0gMCkgewogICAgICAgICAgICByZXR1cm4gWl9URVhUOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gWl9CSU5BUlk7CiAgICAgIH0KICAgICAgdmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTsKICAgICAgZnVuY3Rpb24gX3RyX2luaXQocykgewogICAgICAgIGlmICghc3RhdGljX2luaXRfZG9uZSkgewogICAgICAgICAgdHJfc3RhdGljX2luaXQoKTsKICAgICAgICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlOwogICAgICAgIH0KICAgICAgICBzLmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7CiAgICAgICAgcy5kX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpOwogICAgICAgIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTsKICAgICAgICBzLmJpX2J1ZiA9IDA7CiAgICAgICAgcy5iaV92YWxpZCA9IDA7CiAgICAgICAgaW5pdF9ibG9jayhzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgewogICAgICAgIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICAgIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfYWxpZ24ocykgewogICAgICAgIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7CiAgICAgICAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTsKICAgICAgICBiaV9mbHVzaChzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSB7CiAgICAgICAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsKICAgICAgICB2YXIgbWF4X2JsaW5kZXggPSAwOwogICAgICAgIGlmIChzLmxldmVsID4gMCkgewogICAgICAgICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikgewogICAgICAgICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTsKICAgICAgICAgIH0KICAgICAgICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpOwogICAgICAgICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7CiAgICAgICAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7CiAgICAgICAgICBvcHRfbGVuYiA9IHMub3B0X2xlbiArIDMgKyA3ID4+PiAzOwogICAgICAgICAgc3RhdGljX2xlbmIgPSBzLnN0YXRpY19sZW4gKyAzICsgNyA+Pj4gMzsKICAgICAgICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgewogICAgICAgICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7CiAgICAgICAgfQogICAgICAgIGlmIChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYiAmJiBidWYgIT09IC0xKSB7CiAgICAgICAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7CiAgICAgICAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikgewogICAgICAgICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7CiAgICAgICAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICAgICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7CiAgICAgICAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpOwogICAgICAgIH0KICAgICAgICBpbml0X2Jsb2NrKHMpOwogICAgICAgIGlmIChsYXN0KSB7CiAgICAgICAgICBiaV93aW5kdXAocyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYykgewogICAgICAgIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSA9IGRpc3QgPj4+IDggJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDI1NTsKICAgICAgICBzLmxhc3RfbGl0Kys7CiAgICAgICAgaWYgKGRpc3QgPT09IDApIHsKICAgICAgICAgIHMuZHluX2x0cmVlW2xjICogMl0rKzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcy5tYXRjaGVzKys7CiAgICAgICAgICBkaXN0LS07CiAgICAgICAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXSsrOwogICAgICAgICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0rKzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxOwogICAgICB9CiAgICAgIGV4cG9ydHMyLl90cl9pbml0ID0gX3RyX2luaXQ7CiAgICAgIGV4cG9ydHMyLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrOwogICAgICBleHBvcnRzMi5fdHJfZmx1c2hfYmxvY2sgPSBfdHJfZmx1c2hfYmxvY2s7CiAgICAgIGV4cG9ydHMyLl90cl90YWxseSA9IF90cl90YWxseTsKICAgICAgZXhwb3J0czIuX3RyX2FsaWduID0gX3RyX2FsaWduOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcwogIHZhciByZXF1aXJlX2FkbGVyMzIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHsKICAgICAgICB2YXIgczEgPSBhZGxlciAmIDY1NTM1IHwgMCwgczIgPSBhZGxlciA+Pj4gMTYgJiA2NTUzNSB8IDAsIG4gPSAwOwogICAgICAgIHdoaWxlIChsZW4gIT09IDApIHsKICAgICAgICAgIG4gPSBsZW4gPiAyZTMgPyAyZTMgOiBsZW47CiAgICAgICAgICBsZW4gLT0gbjsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgczEgPSBzMSArIGJ1Zltwb3MrK10gfCAwOwogICAgICAgICAgICBzMiA9IHMyICsgczEgfCAwOwogICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgIHMxICU9IDY1NTIxOwogICAgICAgICAgczIgJT0gNjU1MjE7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzMSB8IHMyIDw8IDE2IHwgMDsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBhZGxlcjMyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMKICB2YXIgcmVxdWlyZV9jcmMzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIG1ha2VUYWJsZSgpIHsKICAgICAgICB2YXIgYywgdGFibGUgPSBbXTsKICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7CiAgICAgICAgICBjID0gbjsKICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7CiAgICAgICAgICAgIGMgPSBjICYgMSA/IDM5ODgyOTIzODQgXiBjID4+PiAxIDogYyA+Pj4gMTsKICAgICAgICAgIH0KICAgICAgICAgIHRhYmxlW25dID0gYzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhYmxlOwogICAgICB9CiAgICAgIHZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpOwogICAgICBmdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHsKICAgICAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47CiAgICAgICAgY3JjIF49IC0xOwogICAgICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykgewogICAgICAgICAgY3JjID0gY3JjID4+PiA4IF4gdFsoY3JjIF4gYnVmW2ldKSAmIDI1NV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBjcmMgXiAtMTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBjcmMzMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzCiAgdmFyIHJlcXVpcmVfbWVzc2FnZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7CiAgICAgICAgMjogIm5lZWQgZGljdGlvbmFyeSIsCiAgICAgICAgMTogInN0cmVhbSBlbmQiLAogICAgICAgIDA6ICIiLAogICAgICAgICItMSI6ICJmaWxlIGVycm9yIiwKICAgICAgICAiLTIiOiAic3RyZWFtIGVycm9yIiwKICAgICAgICAiLTMiOiAiZGF0YSBlcnJvciIsCiAgICAgICAgIi00IjogImluc3VmZmljaWVudCBtZW1vcnkiLAogICAgICAgICItNSI6ICJidWZmZXIgZXJyb3IiLAogICAgICAgICItNiI6ICJpbmNvbXBhdGlibGUgdmVyc2lvbiIKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMKICB2YXIgcmVxdWlyZV9kZWZsYXRlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgdHJlZXMgPSByZXF1aXJlX3RyZWVzKCk7CiAgICAgIHZhciBhZGxlcjMyID0gcmVxdWlyZV9hZGxlcjMyKCk7CiAgICAgIHZhciBjcmMzMiA9IHJlcXVpcmVfY3JjMzIoKTsKICAgICAgdmFyIG1zZyA9IHJlcXVpcmVfbWVzc2FnZXMoKTsKICAgICAgdmFyIFpfTk9fRkxVU0ggPSAwOwogICAgICB2YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTsKICAgICAgdmFyIFpfRlVMTF9GTFVTSCA9IDM7CiAgICAgIHZhciBaX0ZJTklTSCA9IDQ7CiAgICAgIHZhciBaX0JMT0NLID0gNTsKICAgICAgdmFyIFpfT0sgPSAwOwogICAgICB2YXIgWl9TVFJFQU1fRU5EID0gMTsKICAgICAgdmFyIFpfU1RSRUFNX0VSUk9SID0gLTI7CiAgICAgIHZhciBaX0RBVEFfRVJST1IgPSAtMzsKICAgICAgdmFyIFpfQlVGX0VSUk9SID0gLTU7CiAgICAgIHZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTsKICAgICAgdmFyIFpfRklMVEVSRUQgPSAxOwogICAgICB2YXIgWl9IVUZGTUFOX09OTFkgPSAyOwogICAgICB2YXIgWl9STEUgPSAzOwogICAgICB2YXIgWl9GSVhFRCA9IDQ7CiAgICAgIHZhciBaX0RFRkFVTFRfU1RSQVRFR1kgPSAwOwogICAgICB2YXIgWl9VTktOT1dOID0gMjsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICB2YXIgTUFYX01FTV9MRVZFTCA9IDk7CiAgICAgIHZhciBNQVhfV0JJVFMgPSAxNTsKICAgICAgdmFyIERFRl9NRU1fTEVWRUwgPSA4OwogICAgICB2YXIgTEVOR1RIX0NPREVTID0gMjk7CiAgICAgIHZhciBMSVRFUkFMUyA9IDI1NjsKICAgICAgdmFyIExfQ09ERVMgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7CiAgICAgIHZhciBEX0NPREVTID0gMzA7CiAgICAgIHZhciBCTF9DT0RFUyA9IDE5OwogICAgICB2YXIgSEVBUF9TSVpFID0gMiAqIExfQ09ERVMgKyAxOwogICAgICB2YXIgTUFYX0JJVFMgPSAxNTsKICAgICAgdmFyIE1JTl9NQVRDSCA9IDM7CiAgICAgIHZhciBNQVhfTUFUQ0ggPSAyNTg7CiAgICAgIHZhciBNSU5fTE9PS0FIRUFEID0gTUFYX01BVENIICsgTUlOX01BVENIICsgMTsKICAgICAgdmFyIFBSRVNFVF9ESUNUID0gMzI7CiAgICAgIHZhciBJTklUX1NUQVRFID0gNDI7CiAgICAgIHZhciBFWFRSQV9TVEFURSA9IDY5OwogICAgICB2YXIgTkFNRV9TVEFURSA9IDczOwogICAgICB2YXIgQ09NTUVOVF9TVEFURSA9IDkxOwogICAgICB2YXIgSENSQ19TVEFURSA9IDEwMzsKICAgICAgdmFyIEJVU1lfU1RBVEUgPSAxMTM7CiAgICAgIHZhciBGSU5JU0hfU1RBVEUgPSA2NjY7CiAgICAgIHZhciBCU19ORUVEX01PUkUgPSAxOwogICAgICB2YXIgQlNfQkxPQ0tfRE9ORSA9IDI7CiAgICAgIHZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7CiAgICAgIHZhciBCU19GSU5JU0hfRE9ORSA9IDQ7CiAgICAgIHZhciBPU19DT0RFID0gMzsKICAgICAgZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkgewogICAgICAgIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07CiAgICAgICAgcmV0dXJuIGVycm9yQ29kZTsKICAgICAgfQogICAgICBmdW5jdGlvbiByYW5rKGYpIHsKICAgICAgICByZXR1cm4gKGYgPDwgMSkgLSAoZiA+IDQgPyA5IDogMCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gemVybyhidWYpIHsKICAgICAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICB3aGlsZSAoLS1sZW4gPj0gMCkgewogICAgICAgICAgYnVmW2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHsKICAgICAgICB2YXIgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgdmFyIGxlbiA9IHMucGVuZGluZzsKICAgICAgICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHsKICAgICAgICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIH0KICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpOwogICAgICAgIHN0cm0ubmV4dF9vdXQgKz0gbGVuOwogICAgICAgIHMucGVuZGluZ19vdXQgKz0gbGVuOwogICAgICAgIHN0cm0udG90YWxfb3V0ICs9IGxlbjsKICAgICAgICBzdHJtLmF2YWlsX291dCAtPSBsZW47CiAgICAgICAgcy5wZW5kaW5nIC09IGxlbjsKICAgICAgICBpZiAocy5wZW5kaW5nID09PSAwKSB7CiAgICAgICAgICBzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7CiAgICAgICAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0OwogICAgICAgIGZsdXNoX3BlbmRpbmcocy5zdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgPj4+IDggJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMjU1OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHsKICAgICAgICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBpZiAobGVuID4gc2l6ZSkgewogICAgICAgICAgbGVuID0gc2l6ZTsKICAgICAgICB9CiAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIHN0cm0uYXZhaWxfaW4gLT0gbGVuOwogICAgICAgIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTsKICAgICAgICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpOwogICAgICAgIH0gZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTsKICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X2luICs9IGxlbjsKICAgICAgICBzdHJtLnRvdGFsX2luICs9IGxlbjsKICAgICAgICByZXR1cm4gbGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7CiAgICAgICAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsKICAgICAgICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgdmFyIG1hdGNoOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsKICAgICAgICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsKICAgICAgICB2YXIgbGltaXQgPSBzLnN0cnN0YXJ0ID4gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEID8gcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMDsKICAgICAgICB2YXIgX3dpbiA9IHMud2luZG93OwogICAgICAgIHZhciB3bWFzayA9IHMud19tYXNrOwogICAgICAgIHZhciBwcmV2ID0gcy5wcmV2OwogICAgICAgIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIOwogICAgICAgIHZhciBzY2FuX2VuZDEgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdOwogICAgICAgIHZhciBzY2FuX2VuZCA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTsKICAgICAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHsKICAgICAgICAgIGNoYWluX2xlbmd0aCA+Pj0gMjsKICAgICAgICB9CiAgICAgICAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgewogICAgICAgICAgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOwogICAgICAgIH0KICAgICAgICBkbyB7CiAgICAgICAgICBtYXRjaCA9IGN1cl9tYXRjaDsKICAgICAgICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICE9PSBzY2FuX2VuZCB8fCBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8IF93aW5bbWF0Y2hdICE9PSBfd2luW3NjYW5dIHx8IF93aW5bKyttYXRjaF0gIT09IF93aW5bc2NhbiArIDFdKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgc2NhbiArPSAyOwogICAgICAgICAgbWF0Y2grKzsKICAgICAgICAgIGRvIHsKICAgICAgICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgc2NhbiA8IHN0cmVuZCk7CiAgICAgICAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7CiAgICAgICAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIOwogICAgICAgICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7CiAgICAgICAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7CiAgICAgICAgICAgIGJlc3RfbGVuID0gbGVuOwogICAgICAgICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBzY2FuX2VuZDEgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdOwogICAgICAgICAgICBzY2FuX2VuZCA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTsKICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApOwogICAgICAgIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkgewogICAgICAgICAgcmV0dXJuIGJlc3RfbGVuOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcy5sb29rYWhlYWQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmlsbF93aW5kb3cocykgewogICAgICAgIHZhciBfd19zaXplID0gcy53X3NpemU7CiAgICAgICAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjsKICAgICAgICBkbyB7CiAgICAgICAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDsKICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7CiAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7CiAgICAgICAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTsKICAgICAgICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplOwogICAgICAgICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7CiAgICAgICAgICAgIG4gPSBzLmhhc2hfc2l6ZTsKICAgICAgICAgICAgcCA9IG47CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBtID0gcy5oZWFkWy0tcF07CiAgICAgICAgICAgICAgcy5oZWFkW3BdID0gbSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwOwogICAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgICBuID0gX3dfc2l6ZTsKICAgICAgICAgICAgcCA9IG47CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBtID0gcy5wcmV2Wy0tcF07CiAgICAgICAgICAgICAgcy5wcmV2W3BdID0gbSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwOwogICAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgICBtb3JlICs9IF93X3NpemU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7CiAgICAgICAgICBzLmxvb2thaGVhZCArPSBuOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDsKICAgICAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7CiAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyOwogICAgICAgICAgICAgIHN0cisrOwogICAgICAgICAgICAgIHMuaW5zZXJ0LS07CiAgICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIG1heF9ibG9ja19zaXplID0gNjU1MzU7CiAgICAgICAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkgewogICAgICAgICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1OwogICAgICAgIH0KICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkOwogICAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTsKICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7CiAgICAgICAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDsKICAgICAgICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHsKICAgICAgICB2YXIgaGFzaF9oZWFkOwogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaGFzaF9oZWFkID0gMDsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaGFzaF9oZWFkICE9PSAwICYmIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTsKICAgICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdOwogICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGhhc2hfaGVhZDsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIHZhciBtYXhfaW5zZXJ0OwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGhhc2hfaGVhZCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgfQogICAgICAgICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDsKICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgIGlmIChoYXNoX2hlYWQgIT09IDAgJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiYgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7CiAgICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2KSkgewogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHsKICAgICAgICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7CiAgICAgICAgICAgIHMucHJldl9sZW5ndGggLT0gMjsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkgewogICAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7CiAgICAgICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7CiAgICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkgewogICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7CiAgICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkgewogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgdmFyIHByZXY7CiAgICAgICAgdmFyIHNjYW4sIHN0cmVuZDsKICAgICAgICB2YXIgX3dpbiA9IHMud2luZG93OwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHsKICAgICAgICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxOwogICAgICAgICAgICBwcmV2ID0gX3dpbltzY2FuXTsKICAgICAgICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7CiAgICAgICAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBzY2FuIDwgc3RyZW5kKTsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTsKICAgICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkgewogICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTsKICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHsKICAgICAgICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7CiAgICAgICAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5OwogICAgICAgIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDsKICAgICAgICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjsKICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jOwogICAgICB9CiAgICAgIHZhciBjb25maWd1cmF0aW9uX3RhYmxlOwogICAgICBjb25maWd1cmF0aW9uX3RhYmxlID0gWwogICAgICAgIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLAogICAgICAgIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLAogICAgICAgIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLAogICAgICAgIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KQogICAgICBdOwogICAgICBmdW5jdGlvbiBsbV9pbml0KHMpIHsKICAgICAgICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplOwogICAgICAgIHplcm8ocy5oZWFkKTsKICAgICAgICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTsKICAgICAgICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoOwogICAgICAgIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7CiAgICAgICAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47CiAgICAgICAgcy5zdHJzdGFydCA9IDA7CiAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICBzLmluc19oID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7CiAgICAgICAgdGhpcy5zdHJtID0gbnVsbDsKICAgICAgICB0aGlzLnN0YXR1cyA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7CiAgICAgICAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsKICAgICAgICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICB0aGlzLnBlbmRpbmcgPSAwOwogICAgICAgIHRoaXMud3JhcCA9IDA7CiAgICAgICAgdGhpcy5nemhlYWQgPSBudWxsOwogICAgICAgIHRoaXMuZ3ppbmRleCA9IDA7CiAgICAgICAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOwogICAgICAgIHRoaXMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgIHRoaXMud19zaXplID0gMDsKICAgICAgICB0aGlzLndfYml0cyA9IDA7CiAgICAgICAgdGhpcy53X21hc2sgPSAwOwogICAgICAgIHRoaXMud2luZG93ID0gbnVsbDsKICAgICAgICB0aGlzLndpbmRvd19zaXplID0gMDsKICAgICAgICB0aGlzLnByZXYgPSBudWxsOwogICAgICAgIHRoaXMuaGVhZCA9IG51bGw7CiAgICAgICAgdGhpcy5pbnNfaCA9IDA7CiAgICAgICAgdGhpcy5oYXNoX3NpemUgPSAwOwogICAgICAgIHRoaXMuaGFzaF9iaXRzID0gMDsKICAgICAgICB0aGlzLmhhc2hfbWFzayA9IDA7CiAgICAgICAgdGhpcy5oYXNoX3NoaWZ0ID0gMDsKICAgICAgICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5wcmV2X21hdGNoID0gMDsKICAgICAgICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgdGhpcy5zdHJzdGFydCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9zdGFydCA9IDA7CiAgICAgICAgdGhpcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHRoaXMucHJldl9sZW5ndGggPSAwOwogICAgICAgIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5sZXZlbCA9IDA7CiAgICAgICAgdGhpcy5zdHJhdGVneSA9IDA7CiAgICAgICAgdGhpcy5nb29kX21hdGNoID0gMDsKICAgICAgICB0aGlzLm5pY2VfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMuZHluX2x0cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpOwogICAgICAgIHRoaXMuZHluX2R0cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7CiAgICAgICAgdGhpcy5ibF90cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpOwogICAgICAgIHplcm8odGhpcy5keW5fbHRyZWUpOwogICAgICAgIHplcm8odGhpcy5keW5fZHRyZWUpOwogICAgICAgIHplcm8odGhpcy5ibF90cmVlKTsKICAgICAgICB0aGlzLmxfZGVzYyA9IG51bGw7CiAgICAgICAgdGhpcy5kX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuYmxfZGVzYyA9IG51bGw7CiAgICAgICAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpOwogICAgICAgIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOwogICAgICAgIHplcm8odGhpcy5oZWFwKTsKICAgICAgICB0aGlzLmhlYXBfbGVuID0gMDsKICAgICAgICB0aGlzLmhlYXBfbWF4ID0gMDsKICAgICAgICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7CiAgICAgICAgemVybyh0aGlzLmRlcHRoKTsKICAgICAgICB0aGlzLmxfYnVmID0gMDsKICAgICAgICB0aGlzLmxpdF9idWZzaXplID0gMDsKICAgICAgICB0aGlzLmxhc3RfbGl0ID0gMDsKICAgICAgICB0aGlzLmRfYnVmID0gMDsKICAgICAgICB0aGlzLm9wdF9sZW4gPSAwOwogICAgICAgIHRoaXMuc3RhdGljX2xlbiA9IDA7CiAgICAgICAgdGhpcy5tYXRjaGVzID0gMDsKICAgICAgICB0aGlzLmluc2VydCA9IDA7CiAgICAgICAgdGhpcy5iaV9idWYgPSAwOwogICAgICAgIHRoaXMuYmlfdmFsaWQgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkgewogICAgICAgIHZhciBzOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7CiAgICAgICAgfQogICAgICAgIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7CiAgICAgICAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047CiAgICAgICAgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgcy5wZW5kaW5nID0gMDsKICAgICAgICBzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICBpZiAocy53cmFwIDwgMCkgewogICAgICAgICAgcy53cmFwID0gLXMud3JhcDsKICAgICAgICB9CiAgICAgICAgcy5zdGF0dXMgPSBzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURTsKICAgICAgICBzdHJtLmFkbGVyID0gcy53cmFwID09PSAyID8gMCA6IDE7CiAgICAgICAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDsKICAgICAgICB0cmVlcy5fdHJfaW5pdChzKTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkgewogICAgICAgIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pOwogICAgICAgIGlmIChyZXQgPT09IFpfT0spIHsKICAgICAgICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHsKICAgICAgICBpZiAoIXN0cm0pIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgdmFyIHdyYXAgPSAxOwogICAgICAgIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7CiAgICAgICAgICBsZXZlbCA9IDY7CiAgICAgICAgfQogICAgICAgIGlmICh3aW5kb3dCaXRzIDwgMCkgewogICAgICAgICAgd3JhcCA9IDA7CiAgICAgICAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHsKICAgICAgICAgIHdyYXAgPSAyOwogICAgICAgICAgd2luZG93Qml0cyAtPSAxNjsKICAgICAgICB9CiAgICAgICAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8IHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8IHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyA9PT0gOCkgewogICAgICAgICAgd2luZG93Qml0cyA9IDk7CiAgICAgICAgfQogICAgICAgIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpOwogICAgICAgIHN0cm0uc3RhdGUgPSBzOwogICAgICAgIHMuc3RybSA9IHN0cm07CiAgICAgICAgcy53cmFwID0gd3JhcDsKICAgICAgICBzLmd6aGVhZCA9IG51bGw7CiAgICAgICAgcy53X2JpdHMgPSB3aW5kb3dCaXRzOwogICAgICAgIHMud19zaXplID0gMSA8PCBzLndfYml0czsKICAgICAgICBzLndfbWFzayA9IHMud19zaXplIC0gMTsKICAgICAgICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNzsKICAgICAgICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7CiAgICAgICAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7CiAgICAgICAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpOwogICAgICAgIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTsKICAgICAgICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpOwogICAgICAgIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7CiAgICAgICAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgbWVtTGV2ZWwgKyA2OwogICAgICAgIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0OwogICAgICAgIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpOwogICAgICAgIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTsKICAgICAgICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7CiAgICAgICAgcy5sZXZlbCA9IGxldmVsOwogICAgICAgIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTsKICAgICAgICBzLm1ldGhvZCA9IG1ldGhvZDsKICAgICAgICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7CiAgICAgICAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHsKICAgICAgICB2YXIgb2xkX2ZsdXNoLCBzOwogICAgICAgIHZhciBiZWcsIHZhbDsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkgewogICAgICAgICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmICghc3RybS5vdXRwdXQgfHwgIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBzdHJtLmF2YWlsX291dCA9PT0gMCA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzLnN0cm0gPSBzdHJtOwogICAgICAgIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDsKICAgICAgICBzLmxhc3RfZmx1c2ggPSBmbHVzaDsKICAgICAgICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLndyYXAgPT09IDIpIHsKICAgICAgICAgICAgc3RybS5hZGxlciA9IDA7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDMxKTsKICAgICAgICAgICAgcHV0X2J5dGUocywgMTM5KTsKICAgICAgICAgICAgcHV0X2J5dGUocywgOCk7CiAgICAgICAgICAgIGlmICghcy5nemhlYWQpIHsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6IHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgPyA0IDogMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICsgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgKyAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICsgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICsgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiA4ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lID4+IDE2ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lID4+IDI0ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6IHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgPyA0IDogMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAyNTUpOwogICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDI1NSk7CiAgICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcy5nemluZGV4ID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YXIgaGVhZGVyID0gWl9ERUZMQVRFRCArIChzLndfYml0cyAtIDggPDwgNCkgPDwgODsKICAgICAgICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7CiAgICAgICAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwOwogICAgICAgICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxOwogICAgICAgICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDI7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGhlYWRlciB8PSBsZXZlbF9mbGFncyA8PCA2OwogICAgICAgICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgewogICAgICAgICAgICAgIGhlYWRlciB8PSBQUkVTRVRfRElDVDsKICAgICAgICAgICAgfQogICAgICAgICAgICBoZWFkZXIgKz0gMzEgLSBoZWFkZXIgJSAzMTsKICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpOwogICAgICAgICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgewogICAgICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTsKICAgICAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgNjU1MzUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSAxOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEpIHsKICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDY1NTM1KSkgewogICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMjU1KTsKICAgICAgICAgICAgICBzLmd6aW5kZXgrKzsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkgewogICAgICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLm5hbWUpIHsKICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgICAgdmFsID0gMTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkgewogICAgICAgICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDI1NTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFsID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgdmFsKTsKICAgICAgICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTsKICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodmFsID09PSAwKSB7CiAgICAgICAgICAgICAgcy5nemluZGV4ID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQuY29tbWVudCkgewogICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgICB2YWwgPSAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMjU1OwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB2YWwgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwdXRfYnl0ZShzLCB2YWwpOwogICAgICAgICAgICB9IHdoaWxlICh2YWwgIT09IDApOwogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYykgewogICAgICAgICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiA4ICYgMjU1KTsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMucGVuZGluZyAhPT0gMCkgewogICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpOwogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHwgZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkgewogICAgICAgICAgdmFyIGJzdGF0ZSA9IHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6IHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDogY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKTsKICAgICAgICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkgewogICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHsKICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHsKICAgICAgICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsKICAgICAgICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTsKICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkgewogICAgICAgICAgICAgICAgemVybyhzLmhlYWQpOwogICAgICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICAgICAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7CiAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICB9CiAgICAgICAgaWYgKHMud3JhcCA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRU5EOwogICAgICAgIH0KICAgICAgICBpZiAocy53cmFwID09PSAyKSB7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gOCAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDE2ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gMjQgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luID4+IDggJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiA+PiAxNiAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luID4+IDI0ICYgMjU1KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpOwogICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDY1NTM1KTsKICAgICAgICB9CiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICBpZiAocy53cmFwID4gMCkgewogICAgICAgICAgcy53cmFwID0gLXMud3JhcDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7CiAgICAgICAgdmFyIHN0YXR1czsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJiBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJiBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiYgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJiBzdGF0dXMgIT09IEZJTklTSF9TVEFURSkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7CiAgICAgICAgfQogICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkgewogICAgICAgIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7CiAgICAgICAgdmFyIHM7CiAgICAgICAgdmFyIHN0ciwgbjsKICAgICAgICB2YXIgd3JhcDsKICAgICAgICB2YXIgYXZhaWw7CiAgICAgICAgdmFyIG5leHQ7CiAgICAgICAgdmFyIGlucHV0OwogICAgICAgIHZhciB0bXBEaWN0OwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzID0gc3RybS5zdGF0ZTsKICAgICAgICB3cmFwID0gcy53cmFwOwogICAgICAgIGlmICh3cmFwID09PSAyIHx8IHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUgfHwgcy5sb29rYWhlYWQpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgaWYgKHdyYXAgPT09IDEpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApOwogICAgICAgIH0KICAgICAgICBzLndyYXAgPSAwOwogICAgICAgIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7CiAgICAgICAgICBpZiAod3JhcCA9PT0gMCkgewogICAgICAgICAgICB6ZXJvKHMuaGVhZCk7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgICAgfQogICAgICAgICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTsKICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApOwogICAgICAgICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7CiAgICAgICAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7CiAgICAgICAgfQogICAgICAgIGF2YWlsID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDsKICAgICAgICBzdHJtLm5leHRfaW4gPSAwOwogICAgICAgIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5OwogICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgIHN0ciA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyOwogICAgICAgICAgICBzdHIrKzsKICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICBzLnN0cnN0YXJ0ID0gc3RyOwogICAgICAgICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgfQogICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7CiAgICAgICAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDsKICAgICAgICBzLmxvb2thaGVhZCA9IDA7CiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICBzdHJtLmlucHV0ID0gaW5wdXQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGF2YWlsOwogICAgICAgIHMud3JhcCA9IHdyYXA7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZXhwb3J0czIuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDsKICAgICAgZXhwb3J0czIuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyOwogICAgICBleHBvcnRzMi5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwOwogICAgICBleHBvcnRzMi5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjsKICAgICAgZXhwb3J0czIuZGVmbGF0ZSA9IGRlZmxhdGU7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kOwogICAgICBleHBvcnRzMi5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5OwogICAgICBleHBvcnRzMi5kZWZsYXRlSW5mbyA9ICJwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpIjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzCiAgdmFyIHJlcXVpcmVfc3RyaW5ncyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBTVFJfQVBQTFlfT0sgPSB0cnVlOwogICAgICB2YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7CiAgICAgIHRyeSB7CiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbMF0pOwogICAgICB9IGNhdGNoIChfXykgewogICAgICAgIFNUUl9BUFBMWV9PSyA9IGZhbHNlOwogICAgICB9CiAgICAgIHRyeSB7CiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7CiAgICAgIH0gY2F0Y2ggKF9fKSB7CiAgICAgICAgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOwogICAgICB9CiAgICAgIHZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7CiAgICAgIGZvciAocSA9IDA7IHEgPCAyNTY7IHErKykgewogICAgICAgIF91dGY4bGVuW3FdID0gcSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMTsKICAgICAgfQogICAgICB2YXIgcTsKICAgICAgX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOwogICAgICBleHBvcnRzMi5zdHJpbmcyYnVmID0gZnVuY3Rpb24oc3RyKSB7CiAgICAgICAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7CiAgICAgICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykgewogICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTsKICAgICAgICAgIGlmICgoYyAmIDY0NTEyKSA9PT0gNTUyOTYgJiYgbV9wb3MgKyAxIDwgc3RyX2xlbikgewogICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7CiAgICAgICAgICAgIGlmICgoYzIgJiA2NDUxMikgPT09IDU2MzIwKSB7CiAgICAgICAgICAgICAgYyA9IDY1NTM2ICsgKGMgLSA1NTI5NiA8PCAxMCkgKyAoYzIgLSA1NjMyMCk7CiAgICAgICAgICAgICAgbV9wb3MrKzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgYnVmX2xlbiArPSBjIDwgMTI4ID8gMSA6IGMgPCAyMDQ4ID8gMiA6IGMgPCA2NTUzNiA/IDMgOiA0OwogICAgICAgIH0KICAgICAgICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTsKICAgICAgICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7CiAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpOwogICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5NiAmJiBtX3BvcyArIDEgPCBzdHJfbGVuKSB7CiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTsKICAgICAgICAgICAgaWYgKChjMiAmIDY0NTEyKSA9PT0gNTYzMjApIHsKICAgICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAtIDU1Mjk2IDw8IDEwKSArIChjMiAtIDU2MzIwKTsKICAgICAgICAgICAgICBtX3BvcysrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYyA8IDEyOCkgewogICAgICAgICAgICBidWZbaSsrXSA9IGM7CiAgICAgICAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTkyIHwgYyA+Pj4gNjsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjICYgNjM7CiAgICAgICAgICB9IGVsc2UgaWYgKGMgPCA2NTUzNikgewogICAgICAgICAgICBidWZbaSsrXSA9IDIyNCB8IGMgPj4+IDEyOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgPj4+IDYgJiA2MzsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjICYgNjM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBidWZbaSsrXSA9IDI0MCB8IGMgPj4+IDE4OwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgPj4+IDEyICYgNjM7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gNiAmIDYzOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikgewogICAgICAgIGlmIChsZW4gPCA2NTUzNCkgewogICAgICAgICAgaWYgKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LIHx8ICFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSB7CiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQogICAgICBleHBvcnRzMi5idWYyYmluc3RyaW5nID0gZnVuY3Rpb24oYnVmKSB7CiAgICAgICAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTsKICAgICAgfTsKICAgICAgZXhwb3J0czIuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uKHN0cikgewogICAgICAgIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTsKICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgZXhwb3J0czIuYnVmMnN0cmluZyA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7CiAgICAgICAgdmFyIGksIG91dCwgYywgY19sZW47CiAgICAgICAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoOwogICAgICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTsKICAgICAgICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOyApIHsKICAgICAgICAgIGMgPSBidWZbaSsrXTsKICAgICAgICAgIGlmIChjIDwgMTI4KSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTsKICAgICAgICAgIGlmIChjX2xlbiA+IDQpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gNjU1MzM7CiAgICAgICAgICAgIGkgKz0gY19sZW4gLSAxOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAzMSA6IGNfbGVuID09PSAzID8gMTUgOiA3OwogICAgICAgICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7CiAgICAgICAgICAgIGMgPSBjIDw8IDYgfCBidWZbaSsrXSAmIDYzOwogICAgICAgICAgICBjX2xlbi0tOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGNfbGVuID4gMSkgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA2NTUzMzsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYyA8IDY1NTM2KSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjIC09IDY1NTM2OwogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA1NTI5NiB8IGMgPj4gMTAgJiAxMDIzOwogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA1NjMyMCB8IGMgJiAxMDIzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTsKICAgICAgfTsKICAgICAgZXhwb3J0czIudXRmOGJvcmRlciA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7CiAgICAgICAgdmFyIHBvczsKICAgICAgICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDsKICAgICAgICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgewogICAgICAgICAgbWF4ID0gYnVmLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgcG9zID0gbWF4IC0gMTsKICAgICAgICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICBwb3MtLTsKICAgICAgICB9CiAgICAgICAgaWYgKHBvcyA8IDApIHsKICAgICAgICAgIHJldHVybiBtYXg7CiAgICAgICAgfQogICAgICAgIGlmIChwb3MgPT09IDApIHsKICAgICAgICAgIHJldHVybiBtYXg7CiAgICAgICAgfQogICAgICAgIHJldHVybiBwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXggPyBwb3MgOiBtYXg7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzCiAgdmFyIHJlcXVpcmVfenN0cmVhbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gWlN0cmVhbSgpIHsKICAgICAgICB0aGlzLmlucHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfaW4gPSAwOwogICAgICAgIHRoaXMuYXZhaWxfaW4gPSAwOwogICAgICAgIHRoaXMudG90YWxfaW4gPSAwOwogICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfb3V0ID0gMDsKICAgICAgICB0aGlzLmF2YWlsX291dCA9IDA7CiAgICAgICAgdGhpcy50b3RhbF9vdXQgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7CiAgICAgICAgdGhpcy5kYXRhX3R5cGUgPSAyOwogICAgICAgIHRoaXMuYWRsZXIgPSAwOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFpTdHJlYW07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcwogIHZhciByZXF1aXJlX2RlZmxhdGUyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmVfZGVmbGF0ZSgpOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgc3RyaW5ncyA9IHJlcXVpcmVfc3RyaW5ncygpOwogICAgICB2YXIgbXNnID0gcmVxdWlyZV9tZXNzYWdlcygpOwogICAgICB2YXIgWlN0cmVhbSA9IHJlcXVpcmVfenN0cmVhbSgpOwogICAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICB2YXIgWl9OT19GTFVTSCA9IDA7CiAgICAgIHZhciBaX0ZJTklTSCA9IDQ7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX1NZTkNfRkxVU0gyID0gMjsKICAgICAgdmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xOwogICAgICB2YXIgWl9ERUZBVUxUX1NUUkFURUdZID0gMDsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICBmdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpCiAgICAgICAgICByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7CiAgICAgICAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHsKICAgICAgICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sCiAgICAgICAgICBtZXRob2Q6IFpfREVGTEFURUQsCiAgICAgICAgICBjaHVua1NpemU6IDE2Mzg0LAogICAgICAgICAgd2luZG93Qml0czogMTUsCiAgICAgICAgICBtZW1MZXZlbDogOCwKICAgICAgICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksCiAgICAgICAgICB0bzogIiIKICAgICAgICB9LCBvcHRpb25zIHx8IHt9KTsKICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zOwogICAgICAgIGlmIChvcHQucmF3ICYmIG9wdC53aW5kb3dCaXRzID4gMCkgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIGlmIChvcHQuZ3ppcCAmJiBvcHQud2luZG93Qml0cyA+IDAgJiYgb3B0LndpbmRvd0JpdHMgPCAxNikgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7CiAgICAgICAgfQogICAgICAgIHRoaXMuZXJyID0gMDsKICAgICAgICB0aGlzLm1zZyA9ICIiOwogICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7CiAgICAgICAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIodGhpcy5zdHJtLCBvcHQubGV2ZWwsIG9wdC5tZXRob2QsIG9wdC53aW5kb3dCaXRzLCBvcHQubWVtTGV2ZWwsIG9wdC5zdHJhdGVneSk7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC5oZWFkZXIpIHsKICAgICAgICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7CiAgICAgICAgfQogICAgICAgIGlmIChvcHQuZGljdGlvbmFyeSkgewogICAgICAgICAgdmFyIGRpY3Q7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpOwogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlOwogICAgICAgIH0KICAgICAgfQogICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBzdGF0dXMsIF9tb2RlOwogICAgICAgIGlmICh0aGlzLmVuZGVkKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIF9tb2RlID0gbW9kZSA9PT0gfn5tb2RlID8gbW9kZSA6IG1vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7CiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAic3RyaW5nIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTsKICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RybS5pbnB1dCA9IGRhdGE7CiAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9pbiA9IDA7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoOwogICAgICAgIGRvIHsKICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7CiAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSAwOwogICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9tb2RlKTsKICAgICAgICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHsKICAgICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIMikpIHsKICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IFpfU1RSRUFNX0VORCk7CiAgICAgICAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkgewogICAgICAgICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTsKICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSzsKICAgICAgICB9CiAgICAgICAgaWYgKF9tb2RlID09PSBaX1NZTkNfRkxVU0gyKSB7CiAgICAgICAgICB0aGlzLm9uRW5kKFpfT0spOwogICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9OwogICAgICBEZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihjaHVuaykgewogICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspOwogICAgICB9OwogICAgICBEZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHN0YXR1cykgewogICAgICAgIGlmIChzdGF0dXMgPT09IFpfT0spIHsKICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbigiIik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuZXJyID0gc3RhdHVzOwogICAgICAgIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZzsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykgewogICAgICAgIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpOwogICAgICAgIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpOwogICAgICAgIGlmIChkZWZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IGRlZmxhdG9yLm1zZyB8fCBtc2dbZGVmbGF0b3IuZXJyXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5yYXcgPSB0cnVlOwogICAgICAgIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5nemlwID0gdHJ1ZTsKICAgICAgICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuRGVmbGF0ZSA9IERlZmxhdGU7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGUgPSBkZWZsYXRlOwogICAgICBleHBvcnRzMi5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdzsKICAgICAgZXhwb3J0czIuZ3ppcCA9IGd6aXA7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzCiAgdmFyIHJlcXVpcmVfaW5mZmFzdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIEJBRCA9IDMwOwogICAgICB2YXIgVFlQRSA9IDEyOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgdmFyIF9pbjsKICAgICAgICB2YXIgbGFzdDsKICAgICAgICB2YXIgX291dDsKICAgICAgICB2YXIgYmVnOwogICAgICAgIHZhciBlbmQ7CiAgICAgICAgdmFyIGRtYXg7CiAgICAgICAgdmFyIHdzaXplOwogICAgICAgIHZhciB3aGF2ZTsKICAgICAgICB2YXIgd25leHQ7CiAgICAgICAgdmFyIHNfd2luZG93OwogICAgICAgIHZhciBob2xkOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciBsY29kZTsKICAgICAgICB2YXIgZGNvZGU7CiAgICAgICAgdmFyIGxtYXNrOwogICAgICAgIHZhciBkbWFzazsKICAgICAgICB2YXIgaGVyZTsKICAgICAgICB2YXIgb3A7CiAgICAgICAgdmFyIGxlbjsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgZnJvbTsKICAgICAgICB2YXIgZnJvbV9zb3VyY2U7CiAgICAgICAgdmFyIGlucHV0LCBvdXRwdXQ7CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIF9pbiA9IHN0cm0ubmV4dF9pbjsKICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7CiAgICAgICAgX291dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7CiAgICAgICAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTsKICAgICAgICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTsKICAgICAgICBkbWF4ID0gc3RhdGUuZG1heDsKICAgICAgICB3c2l6ZSA9IHN0YXRlLndzaXplOwogICAgICAgIHdoYXZlID0gc3RhdGUud2hhdmU7CiAgICAgICAgd25leHQgPSBzdGF0ZS53bmV4dDsKICAgICAgICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdzsKICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7CiAgICAgICAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTsKICAgICAgICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTsKICAgICAgICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7CiAgICAgICAgdG9wOgogICAgICAgICAgZG8gewogICAgICAgICAgICBpZiAoYml0cyA8IDE1KSB7CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107CiAgICAgICAgICAgIGRvbGVuOgogICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcCAmIDE2KSB7CiAgICAgICAgICAgICAgICAgIGxlbiA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgb3AgJj0gMTU7CiAgICAgICAgICAgICAgICAgIGlmIChvcCkgewogICAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGxlbiArPSBob2xkICYgKDEgPDwgb3ApIC0gMTsKICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IDE1KSB7CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107CiAgICAgICAgICAgICAgICAgIGRvZGlzdDoKICAgICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCAmIDE2KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgICAgICAgIG9wICY9IDE1OwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKDEgPDwgb3ApIC0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93OwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3bmV4dCA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wIC09IHduZXh0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IDM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSAzOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgNjU1MzUpICsgKGhvbGQgJiAoMSA8PCBvcCkgLSAxKV07CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgY29kZSI7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDY1NTM1KSArIChob2xkICYgKDEgPDwgb3ApIC0gMSldOwogICAgICAgICAgICAgICAgICBjb250aW51ZSBkb2xlbjsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AgJiAzMikgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTsKICAgICAgICBsZW4gPSBiaXRzID4+IDM7CiAgICAgICAgX2luIC09IGxlbjsKICAgICAgICBiaXRzIC09IGxlbiA8PCAzOwogICAgICAgIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxOwogICAgICAgIHN0cm0ubmV4dF9pbiA9IF9pbjsKICAgICAgICBzdHJtLm5leHRfb3V0ID0gX291dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpOwogICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKTsKICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICByZXR1cm47CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcwogIHZhciByZXF1aXJlX2luZnRyZWVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIE1BWEJJVFMgPSAxNTsKICAgICAgdmFyIEVOT1VHSF9MRU5TID0gODUyOwogICAgICB2YXIgRU5PVUdIX0RJU1RTID0gNTkyOwogICAgICB2YXIgQ09ERVMgPSAwOwogICAgICB2YXIgTEVOUyA9IDE7CiAgICAgIHZhciBESVNUUyA9IDI7CiAgICAgIHZhciBsYmFzZSA9IFsKICAgICAgICAzLAogICAgICAgIDQsCiAgICAgICAgNSwKICAgICAgICA2LAogICAgICAgIDcsCiAgICAgICAgOCwKICAgICAgICA5LAogICAgICAgIDEwLAogICAgICAgIDExLAogICAgICAgIDEzLAogICAgICAgIDE1LAogICAgICAgIDE3LAogICAgICAgIDE5LAogICAgICAgIDIzLAogICAgICAgIDI3LAogICAgICAgIDMxLAogICAgICAgIDM1LAogICAgICAgIDQzLAogICAgICAgIDUxLAogICAgICAgIDU5LAogICAgICAgIDY3LAogICAgICAgIDgzLAogICAgICAgIDk5LAogICAgICAgIDExNSwKICAgICAgICAxMzEsCiAgICAgICAgMTYzLAogICAgICAgIDE5NSwKICAgICAgICAyMjcsCiAgICAgICAgMjU4LAogICAgICAgIDAsCiAgICAgICAgMAogICAgICBdOwogICAgICB2YXIgbGV4dCA9IFsKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAxNiwKICAgICAgICA3MiwKICAgICAgICA3OAogICAgICBdOwogICAgICB2YXIgZGJhc2UgPSBbCiAgICAgICAgMSwKICAgICAgICAyLAogICAgICAgIDMsCiAgICAgICAgNCwKICAgICAgICA1LAogICAgICAgIDcsCiAgICAgICAgOSwKICAgICAgICAxMywKICAgICAgICAxNywKICAgICAgICAyNSwKICAgICAgICAzMywKICAgICAgICA0OSwKICAgICAgICA2NSwKICAgICAgICA5NywKICAgICAgICAxMjksCiAgICAgICAgMTkzLAogICAgICAgIDI1NywKICAgICAgICAzODUsCiAgICAgICAgNTEzLAogICAgICAgIDc2OSwKICAgICAgICAxMDI1LAogICAgICAgIDE1MzcsCiAgICAgICAgMjA0OSwKICAgICAgICAzMDczLAogICAgICAgIDQwOTcsCiAgICAgICAgNjE0NSwKICAgICAgICA4MTkzLAogICAgICAgIDEyMjg5LAogICAgICAgIDE2Mzg1LAogICAgICAgIDI0NTc3LAogICAgICAgIDAsCiAgICAgICAgMAogICAgICBdOwogICAgICB2YXIgZGV4dCA9IFsKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMiwKICAgICAgICAyMiwKICAgICAgICAyMywKICAgICAgICAyMywKICAgICAgICAyNCwKICAgICAgICAyNCwKICAgICAgICAyNSwKICAgICAgICAyNSwKICAgICAgICAyNiwKICAgICAgICAyNiwKICAgICAgICAyNywKICAgICAgICAyNywKICAgICAgICAyOCwKICAgICAgICAyOCwKICAgICAgICAyOSwKICAgICAgICAyOSwKICAgICAgICA2NCwKICAgICAgICA2NAogICAgICBdOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpIHsKICAgICAgICB2YXIgYml0cyA9IG9wdHMuYml0czsKICAgICAgICB2YXIgbGVuID0gMDsKICAgICAgICB2YXIgc3ltID0gMDsKICAgICAgICB2YXIgbWluID0gMCwgbWF4ID0gMDsKICAgICAgICB2YXIgcm9vdDIgPSAwOwogICAgICAgIHZhciBjdXJyID0gMDsKICAgICAgICB2YXIgZHJvcCA9IDA7CiAgICAgICAgdmFyIGxlZnQgPSAwOwogICAgICAgIHZhciB1c2VkID0gMDsKICAgICAgICB2YXIgaHVmZiA9IDA7CiAgICAgICAgdmFyIGluY3I7CiAgICAgICAgdmFyIGZpbGw7CiAgICAgICAgdmFyIGxvdzsKICAgICAgICB2YXIgbWFzazsKICAgICAgICB2YXIgbmV4dDsKICAgICAgICB2YXIgYmFzZSA9IG51bGw7CiAgICAgICAgdmFyIGJhc2VfaW5kZXggPSAwOwogICAgICAgIHZhciBlbmQ7CiAgICAgICAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsKICAgICAgICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7CiAgICAgICAgdmFyIGV4dHJhID0gbnVsbDsKICAgICAgICB2YXIgZXh0cmFfaW5kZXggPSAwOwogICAgICAgIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOwogICAgICAgIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7CiAgICAgICAgICBjb3VudFtsZW5dID0gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHsKICAgICAgICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7CiAgICAgICAgfQogICAgICAgIHJvb3QyID0gYml0czsKICAgICAgICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkgewogICAgICAgICAgaWYgKGNvdW50W21heF0gIT09IDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChyb290MiA+IG1heCkgewogICAgICAgICAgcm9vdDIgPSBtYXg7CiAgICAgICAgfQogICAgICAgIGlmIChtYXggPT09IDApIHsKICAgICAgICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gMSA8PCAyNCB8IDY0IDw8IDE2IHwgMDsKICAgICAgICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gMSA8PCAyNCB8IDY0IDw8IDE2IHwgMDsKICAgICAgICAgIG9wdHMuYml0cyA9IDE7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7CiAgICAgICAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHJvb3QyIDwgbWluKSB7CiAgICAgICAgICByb290MiA9IG1pbjsKICAgICAgICB9CiAgICAgICAgbGVmdCA9IDE7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgICBsZWZ0IC09IGNvdW50W2xlbl07CiAgICAgICAgICBpZiAobGVmdCA8IDApIHsKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgb2Zmc1sxXSA9IDA7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykgewogICAgICAgICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07CiAgICAgICAgfQogICAgICAgIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7CiAgICAgICAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkgewogICAgICAgICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlID09PSBDT0RFUykgewogICAgICAgICAgYmFzZSA9IGV4dHJhID0gd29yazsKICAgICAgICAgIGVuZCA9IDE5OwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykgewogICAgICAgICAgYmFzZSA9IGxiYXNlOwogICAgICAgICAgYmFzZV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBleHRyYSA9IGxleHQ7CiAgICAgICAgICBleHRyYV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBlbmQgPSAyNTY7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJhc2UgPSBkYmFzZTsKICAgICAgICAgIGV4dHJhID0gZGV4dDsKICAgICAgICAgIGVuZCA9IC0xOwogICAgICAgIH0KICAgICAgICBodWZmID0gMDsKICAgICAgICBzeW0gPSAwOwogICAgICAgIGxlbiA9IG1pbjsKICAgICAgICBuZXh0ID0gdGFibGVfaW5kZXg7CiAgICAgICAgY3VyciA9IHJvb3QyOwogICAgICAgIGRyb3AgPSAwOwogICAgICAgIGxvdyA9IC0xOwogICAgICAgIHVzZWQgPSAxIDw8IHJvb3QyOwogICAgICAgIG1hc2sgPSB1c2VkIC0gMTsKICAgICAgICBpZiAodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMgfHwgdHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykgewogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgfQogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDsKICAgICAgICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHsKICAgICAgICAgICAgaGVyZV9vcCA9IDA7CiAgICAgICAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dOwogICAgICAgICAgfSBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHsKICAgICAgICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7CiAgICAgICAgICAgIGhlcmVfdmFsID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIGluY3IgPSAxIDw8IGxlbiAtIGRyb3A7CiAgICAgICAgICBmaWxsID0gMSA8PCBjdXJyOwogICAgICAgICAgbWluID0gZmlsbDsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgZmlsbCAtPSBpbmNyOwogICAgICAgICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IGhlcmVfYml0cyA8PCAyNCB8IGhlcmVfb3AgPDwgMTYgfCBoZXJlX3ZhbCB8IDA7CiAgICAgICAgICB9IHdoaWxlIChmaWxsICE9PSAwKTsKICAgICAgICAgIGluY3IgPSAxIDw8IGxlbiAtIDE7CiAgICAgICAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHsKICAgICAgICAgICAgaW5jciA+Pj0gMTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChpbmNyICE9PSAwKSB7CiAgICAgICAgICAgIGh1ZmYgJj0gaW5jciAtIDE7CiAgICAgICAgICAgIGh1ZmYgKz0gaW5jcjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGh1ZmYgPSAwOwogICAgICAgICAgfQogICAgICAgICAgc3ltKys7CiAgICAgICAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7CiAgICAgICAgICAgIGlmIChsZW4gPT09IG1heCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAobGVuID4gcm9vdDIgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7CiAgICAgICAgICAgIGlmIChkcm9wID09PSAwKSB7CiAgICAgICAgICAgICAgZHJvcCA9IHJvb3QyOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG5leHQgKz0gbWluOwogICAgICAgICAgICBjdXJyID0gbGVuIC0gZHJvcDsKICAgICAgICAgICAgbGVmdCA9IDEgPDwgY3VycjsKICAgICAgICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7CiAgICAgICAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07CiAgICAgICAgICAgICAgaWYgKGxlZnQgPD0gMCkgewogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGN1cnIrKzsKICAgICAgICAgICAgICBsZWZ0IDw8PSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHVzZWQgKz0gMSA8PCBjdXJyOwogICAgICAgICAgICBpZiAodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMgfHwgdHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykgewogICAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrOwogICAgICAgICAgICB0YWJsZVtsb3ddID0gcm9vdDIgPDwgMjQgfCBjdXJyIDw8IDE2IHwgbmV4dCAtIHRhYmxlX2luZGV4IHwgMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGh1ZmYgIT09IDApIHsKICAgICAgICAgIHRhYmxlW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3AgPDwgMjQgfCA2NCA8PCAxNiB8IDA7CiAgICAgICAgfQogICAgICAgIG9wdHMuYml0cyA9IHJvb3QyOwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcwogIHZhciByZXF1aXJlX2luZmxhdGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBhZGxlcjMyID0gcmVxdWlyZV9hZGxlcjMyKCk7CiAgICAgIHZhciBjcmMzMiA9IHJlcXVpcmVfY3JjMzIoKTsKICAgICAgdmFyIGluZmxhdGVfZmFzdCA9IHJlcXVpcmVfaW5mZmFzdCgpOwogICAgICB2YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmVfaW5mdHJlZXMoKTsKICAgICAgdmFyIENPREVTID0gMDsKICAgICAgdmFyIExFTlMgPSAxOwogICAgICB2YXIgRElTVFMgPSAyOwogICAgICB2YXIgWl9GSU5JU0ggPSA0OwogICAgICB2YXIgWl9CTE9DSyA9IDU7CiAgICAgIHZhciBaX1RSRUVTID0gNjsKICAgICAgdmFyIFpfT0sgPSAwOwogICAgICB2YXIgWl9TVFJFQU1fRU5EID0gMTsKICAgICAgdmFyIFpfTkVFRF9ESUNUID0gMjsKICAgICAgdmFyIFpfU1RSRUFNX0VSUk9SID0gLTI7CiAgICAgIHZhciBaX0RBVEFfRVJST1IgPSAtMzsKICAgICAgdmFyIFpfTUVNX0VSUk9SID0gLTQ7CiAgICAgIHZhciBaX0JVRl9FUlJPUiA9IC01OwogICAgICB2YXIgWl9ERUZMQVRFRCA9IDg7CiAgICAgIHZhciBIRUFEID0gMTsKICAgICAgdmFyIEZMQUdTID0gMjsKICAgICAgdmFyIFRJTUUgPSAzOwogICAgICB2YXIgT1MgPSA0OwogICAgICB2YXIgRVhMRU4gPSA1OwogICAgICB2YXIgRVhUUkEgPSA2OwogICAgICB2YXIgTkFNRSA9IDc7CiAgICAgIHZhciBDT01NRU5UID0gODsKICAgICAgdmFyIEhDUkMgPSA5OwogICAgICB2YXIgRElDVElEID0gMTA7CiAgICAgIHZhciBESUNUID0gMTE7CiAgICAgIHZhciBUWVBFID0gMTI7CiAgICAgIHZhciBUWVBFRE8gPSAxMzsKICAgICAgdmFyIFNUT1JFRCA9IDE0OwogICAgICB2YXIgQ09QWV8gPSAxNTsKICAgICAgdmFyIENPUFkgPSAxNjsKICAgICAgdmFyIFRBQkxFID0gMTc7CiAgICAgIHZhciBMRU5MRU5TID0gMTg7CiAgICAgIHZhciBDT0RFTEVOUyA9IDE5OwogICAgICB2YXIgTEVOXyA9IDIwOwogICAgICB2YXIgTEVOID0gMjE7CiAgICAgIHZhciBMRU5FWFQgPSAyMjsKICAgICAgdmFyIERJU1QgPSAyMzsKICAgICAgdmFyIERJU1RFWFQgPSAyNDsKICAgICAgdmFyIE1BVENIID0gMjU7CiAgICAgIHZhciBMSVQgPSAyNjsKICAgICAgdmFyIENIRUNLID0gMjc7CiAgICAgIHZhciBMRU5HVEggPSAyODsKICAgICAgdmFyIERPTkUgPSAyOTsKICAgICAgdmFyIEJBRCA9IDMwOwogICAgICB2YXIgTUVNID0gMzE7CiAgICAgIHZhciBTWU5DID0gMzI7CiAgICAgIHZhciBFTk9VR0hfTEVOUyA9IDg1MjsKICAgICAgdmFyIEVOT1VHSF9ESVNUUyA9IDU5MjsKICAgICAgdmFyIE1BWF9XQklUUyA9IDE1OwogICAgICB2YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTOwogICAgICBmdW5jdGlvbiB6c3dhcDMyKHEpIHsKICAgICAgICByZXR1cm4gKHEgPj4+IDI0ICYgMjU1KSArIChxID4+PiA4ICYgNjUyODApICsgKChxICYgNjUyODApIDw8IDgpICsgKChxICYgMjU1KSA8PCAyNCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkgewogICAgICAgIHRoaXMubW9kZSA9IDA7CiAgICAgICAgdGhpcy5sYXN0ID0gZmFsc2U7CiAgICAgICAgdGhpcy53cmFwID0gMDsKICAgICAgICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7CiAgICAgICAgdGhpcy5mbGFncyA9IDA7CiAgICAgICAgdGhpcy5kbWF4ID0gMDsKICAgICAgICB0aGlzLmNoZWNrID0gMDsKICAgICAgICB0aGlzLnRvdGFsID0gMDsKICAgICAgICB0aGlzLmhlYWQgPSBudWxsOwogICAgICAgIHRoaXMud2JpdHMgPSAwOwogICAgICAgIHRoaXMud3NpemUgPSAwOwogICAgICAgIHRoaXMud2hhdmUgPSAwOwogICAgICAgIHRoaXMud25leHQgPSAwOwogICAgICAgIHRoaXMud2luZG93ID0gbnVsbDsKICAgICAgICB0aGlzLmhvbGQgPSAwOwogICAgICAgIHRoaXMuYml0cyA9IDA7CiAgICAgICAgdGhpcy5sZW5ndGggPSAwOwogICAgICAgIHRoaXMub2Zmc2V0ID0gMDsKICAgICAgICB0aGlzLmV4dHJhID0gMDsKICAgICAgICB0aGlzLmxlbmNvZGUgPSBudWxsOwogICAgICAgIHRoaXMuZGlzdGNvZGUgPSBudWxsOwogICAgICAgIHRoaXMubGVuYml0cyA9IDA7CiAgICAgICAgdGhpcy5kaXN0Yml0cyA9IDA7CiAgICAgICAgdGhpcy5uY29kZSA9IDA7CiAgICAgICAgdGhpcy5ubGVuID0gMDsKICAgICAgICB0aGlzLm5kaXN0ID0gMDsKICAgICAgICB0aGlzLmhhdmUgPSAwOwogICAgICAgIHRoaXMubmV4dCA9IG51bGw7CiAgICAgICAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7CiAgICAgICAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7CiAgICAgICAgdGhpcy5sZW5keW4gPSBudWxsOwogICAgICAgIHRoaXMuZGlzdGR5biA9IG51bGw7CiAgICAgICAgdGhpcy5zYW5lID0gMDsKICAgICAgICB0aGlzLmJhY2sgPSAwOwogICAgICAgIHRoaXMud2FzID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7CiAgICAgICAgc3RybS5tc2cgPSAiIjsKICAgICAgICBpZiAoc3RhdGUud3JhcCkgewogICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5tb2RlID0gSEVBRDsKICAgICAgICBzdGF0ZS5sYXN0ID0gMDsKICAgICAgICBzdGF0ZS5oYXZlZGljdCA9IDA7CiAgICAgICAgc3RhdGUuZG1heCA9IDMyNzY4OwogICAgICAgIHN0YXRlLmhlYWQgPSBudWxsOwogICAgICAgIHN0YXRlLmhvbGQgPSAwOwogICAgICAgIHN0YXRlLmJpdHMgPSAwOwogICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpOwogICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpOwogICAgICAgIHN0YXRlLnNhbmUgPSAxOwogICAgICAgIHN0YXRlLmJhY2sgPSAtMTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIHN0YXRlLndzaXplID0gMDsKICAgICAgICBzdGF0ZS53aGF2ZSA9IDA7CiAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykgewogICAgICAgIHZhciB3cmFwOwogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmICh3aW5kb3dCaXRzIDwgMCkgewogICAgICAgICAgd3JhcCA9IDA7CiAgICAgICAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7CiAgICAgICAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7CiAgICAgICAgICAgIHdpbmRvd0JpdHMgJj0gMTU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG51bGw7CiAgICAgICAgfQogICAgICAgIHN0YXRlLndyYXAgPSB3cmFwOwogICAgICAgIHN0YXRlLndiaXRzID0gd2luZG93Qml0czsKICAgICAgICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7CiAgICAgICAgdmFyIHJldDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpOwogICAgICAgIHN0cm0uc3RhdGUgPSBzdGF0ZTsKICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7CiAgICAgICAgaWYgKHJldCAhPT0gWl9PSykgewogICAgICAgICAgc3RybS5zdGF0ZSA9IG51bGw7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkgewogICAgICAgIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTsKICAgICAgfQogICAgICB2YXIgdmlyZ2luID0gdHJ1ZTsKICAgICAgdmFyIGxlbmZpeDsKICAgICAgdmFyIGRpc3RmaXg7CiAgICAgIGZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7CiAgICAgICAgaWYgKHZpcmdpbikgewogICAgICAgICAgdmFyIHN5bTsKICAgICAgICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpOwogICAgICAgICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7CiAgICAgICAgICBzeW0gPSAwOwogICAgICAgICAgd2hpbGUgKHN5bSA8IDE0NCkgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMjU2KSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gOTsKICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzeW0gPCAyODApIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA3OwogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKHN5bSA8IDI4OCkgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7CiAgICAgICAgICB9CiAgICAgICAgICBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7CiAgICAgICAgICBzeW0gPSAwOwogICAgICAgICAgd2hpbGUgKHN5bSA8IDMyKSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gNTsKICAgICAgICAgIH0KICAgICAgICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7CiAgICAgICAgICB2aXJnaW4gPSBmYWxzZTsKICAgICAgICB9CiAgICAgICAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDsKICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTsKICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7CiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA1OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkgewogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkgewogICAgICAgICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzOwogICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgc3RhdGUud2hhdmUgPSAwOwogICAgICAgICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpOwogICAgICAgIH0KICAgICAgICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkgewogICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7CiAgICAgICAgICBzdGF0ZS53bmV4dCA9IDA7CiAgICAgICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDsKICAgICAgICAgIGlmIChkaXN0ID4gY29weSkgewogICAgICAgICAgICBkaXN0ID0gY29weTsKICAgICAgICAgIH0KICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7CiAgICAgICAgICBjb3B5IC09IGRpc3Q7CiAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7CiAgICAgICAgICAgIHN0YXRlLnduZXh0ID0gY29weTsKICAgICAgICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7CiAgICAgICAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsKICAgICAgICAgICAgICBzdGF0ZS53bmV4dCA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsKICAgICAgICAgICAgICBzdGF0ZS53aGF2ZSArPSBkaXN0OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgdmFyIGlucHV0LCBvdXRwdXQ7CiAgICAgICAgdmFyIG5leHQ7CiAgICAgICAgdmFyIHB1dDsKICAgICAgICB2YXIgaGF2ZSwgbGVmdDsKICAgICAgICB2YXIgaG9sZDsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgX2luLCBfb3V0OwogICAgICAgIHZhciBjb3B5OwogICAgICAgIHZhciBmcm9tOwogICAgICAgIHZhciBmcm9tX3NvdXJjZTsKICAgICAgICB2YXIgaGVyZSA9IDA7CiAgICAgICAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7CiAgICAgICAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7CiAgICAgICAgdmFyIGxlbjsKICAgICAgICB2YXIgcmV0OwogICAgICAgIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7CiAgICAgICAgdmFyIG9wdHM7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIG9yZGVyID0gWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHwgIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87CiAgICAgICAgfQogICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7CiAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luOwogICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzOwogICAgICAgIF9pbiA9IGhhdmU7CiAgICAgICAgX291dCA9IGxlZnQ7CiAgICAgICAgcmV0ID0gWl9PSzsKICAgICAgICBpbmZfbGVhdmU6CiAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7CiAgICAgICAgICAgICAgY2FzZSBIRUFEOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwICYgMiAmJiBob2xkID09PSAzNTYxNSkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IDA7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmZsYWdzID0gMDsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICgoKGhvbGQgJiAyNTUpIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGhlYWRlciBjaGVjayI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChob2xkICYgMTUpICE9PSBaX0RFRkxBVEVEKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNDsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNDsKICAgICAgICAgICAgICAgIGxlbiA9IChob2xkICYgMTUpICsgODsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCB3aW5kb3cgc2l6ZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuOwogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgNTEyID8gRElDVElEIDogVFlQRTsKICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIEZMQUdTOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7CiAgICAgICAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMjU1KSAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTczNDQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAidW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSBob2xkID4+IDggJiAxOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7CiAgICAgICAgICAgICAgY2FzZSBUSU1FOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsyXSA9IGhvbGQgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzNdID0gaG9sZCA+Pj4gMjQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBPUzsKICAgICAgICAgICAgICBjYXNlIE9TOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSBob2xkID4+IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47CiAgICAgICAgICAgICAgY2FzZSBFWExFTjoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDEwMjQpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBOwogICAgICAgICAgICAgIGNhc2UgRVhUUkE6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAxMDI0KSB7CiAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBoYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUuaGVhZC5leHRyYSwgaW5wdXQsIG5leHQsIGNvcHksIGxlbik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTsKICAgICAgICAgICAgICBjYXNlIE5BTUU6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAyMDQ4KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNvcHkgPSAwOwogICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmIHN0YXRlLmxlbmd0aCA8IDY1NTM2KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDsKICAgICAgICAgICAgICBjYXNlIENPTU1FTlQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA0MDk2KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNvcHkgPSAwOwogICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmIHN0YXRlLmxlbmd0aCA8IDY1NTM2KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDOwogICAgICAgICAgICAgIGNhc2UgSENSQzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgNjU1MzUpKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaGVhZGVyIGNyYyBtaXNtYXRjaCI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSBzdGF0ZS5mbGFncyA+PiA5ICYgMTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgRElDVElEOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpOwogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESUNUOwogICAgICAgICAgICAgIGNhc2UgRElDVDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlOwogICAgICAgICAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICAgICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDE7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICBjYXNlIFRZUEU6CiAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhc2UgVFlQRURPOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxhc3QgPSBob2xkICYgMTsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAxOwogICAgICAgICAgICAgICAgYml0cyAtPSAxOwogICAgICAgICAgICAgICAgc3dpdGNoIChob2xkICYgMykgewogICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsKICAgICAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYmxvY2sgdHlwZSI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBTVE9SRUQ6CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7CiAgICAgICAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKGhvbGQgJiA2NTUzNSkgIT09IChob2xkID4+PiAxNiBeIDY1NTM1KSkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgNjU1MzU7CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfOwogICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjYXNlIENPUFlfOgogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7CiAgICAgICAgICAgICAgY2FzZSBDT1BZOgogICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBoYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBsZWZ0OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBsZWZ0IC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIHB1dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgVEFCTEU6CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDMxKSArIDI1NzsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA1OwogICAgICAgICAgICAgICAgYml0cyAtPSA1OwogICAgICAgICAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDMxKSArIDE7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNTsKICAgICAgICAgICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAxNSkgKyA0OwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDQ7CiAgICAgICAgICAgICAgICBiaXRzIC09IDQ7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5oYXZlID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TOwogICAgICAgICAgICAgIGNhc2UgTEVOTEVOUzoKICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gaG9sZCAmIDc7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAzOwogICAgICAgICAgICAgICAgICBiaXRzIC09IDM7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3OwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9OwogICAgICAgICAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0czsKICAgICAgICAgICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5oYXZlID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUzsKICAgICAgICAgICAgICBjYXNlIENPREVMRU5TOgogICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHsKICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyOwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiOwogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdOwogICAgICAgICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDMpOwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IDI7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzOwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgNyk7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMzsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gMzsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7CiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgbGVuID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMTI3KTsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA3OwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSA3OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiOwogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5OwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9OwogICAgICAgICAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2OwogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluOwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7CiAgICAgICAgICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0czsKICAgICAgICAgICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZXMgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsKICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY2FzZSBMRU5fOgogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgICAgICBjYXNlIExFTjoKICAgICAgICAgICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0OwogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgICAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7CiAgICAgICAgICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgICAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICAgICAgICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICAgICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgICAgICAgICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gMDsKICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKDEgPDwgc3RhdGUubGVuYml0cykgLSAxXTsKICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMjQwKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wOwogICAgICAgICAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArICgoaG9sZCAmICgxIDw8IGxhc3RfYml0cyArIGxhc3Rfb3ApIC0gMSkgPj4gbGFzdF9iaXRzKV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChsYXN0X2JpdHMgKyBoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0czsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikgewogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYgNjQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7CiAgICAgICAgICAgICAgY2FzZSBMRU5FWFQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgbiA9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKDEgPDwgc3RhdGUuZXh0cmEpIC0gMTsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7CiAgICAgICAgICAgICAgY2FzZSBESVNUOgogICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKGhlcmVfb3AgJiAyNDApID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7CiAgICAgICAgICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArICgoaG9sZCAmICgxIDw8IGxhc3RfYml0cyArIGxhc3Rfb3ApIC0gMSkgPj4gbGFzdF9iaXRzKV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChsYXN0X2JpdHMgKyBoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0czsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUOwogICAgICAgICAgICAgIGNhc2UgRElTVEVYVDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5leHRyYSkgewogICAgICAgICAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoMSA8PCBzdGF0ZS5leHRyYSkgLSAxOwogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIOwogICAgICAgICAgICAgIGNhc2UgTUFUQ0g6CiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0OwogICAgICAgICAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDsKICAgICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gbGVmdDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGxlZnQgLT0gY29weTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU47CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIExJVDoKICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICBsZWZ0LS07CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBDSEVDSzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIF9vdXQgLT0gbGVmdDsKICAgICAgICAgICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDsKICAgICAgICAgICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDsKICAgICAgICAgICAgICAgICAgaWYgKF9vdXQpIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSBzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBfb3V0ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbmNvcnJlY3QgZGF0YSBjaGVjayI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIOwogICAgICAgICAgICAgIGNhc2UgTEVOR1RIOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDQyOTQ5NjcyOTUpKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGxlbmd0aCBjaGVjayI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTsKICAgICAgICAgICAgICBjYXNlIERPTkU6CiAgICAgICAgICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7CiAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgY2FzZSBCQUQ6CiAgICAgICAgICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7CiAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgY2FzZSBNRU06CiAgICAgICAgICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAgICAgICAgICAgY2FzZSBTWU5DOgogICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0OwogICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlOwogICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgIGlmIChzdGF0ZS53c2l6ZSB8fCBfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkgewogICAgICAgICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkgewogICAgICAgICAgICBzdGF0ZS5tb2RlID0gTUVNOwogICAgICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIF9pbiAtPSBzdHJtLmF2YWlsX2luOwogICAgICAgIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgc3RybS50b3RhbF9pbiArPSBfaW47CiAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDsKICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0OwogICAgICAgIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCk7CiAgICAgICAgfQogICAgICAgIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgKyAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApOwogICAgICAgIGlmICgoX2luID09PSAwICYmIF9vdXQgPT09IDAgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHsKICAgICAgICAgIHJldCA9IFpfQlVGX0VSUk9SOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkgewogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS53aW5kb3cpIHsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG51bGw7CiAgICAgICAgfQogICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmhlYWQgPSBoZWFkOwogICAgICAgIGhlYWQuZG9uZSA9IGZhbHNlOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHsKICAgICAgICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoOwogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICB2YXIgZGljdGlkOwogICAgICAgIHZhciByZXQ7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7CiAgICAgICAgICBkaWN0aWQgPSAxOwogICAgICAgICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApOwogICAgICAgICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHsKICAgICAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpOwogICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBNRU07CiAgICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmhhdmVkaWN0ID0gMTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBleHBvcnRzMi5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyOwogICAgICBleHBvcnRzMi5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyOwogICAgICBleHBvcnRzMi5pbmZsYXRlID0gaW5mbGF0ZTsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyOwogICAgICBleHBvcnRzMi5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5OwogICAgICBleHBvcnRzMi5pbmZsYXRlSW5mbyA9ICJwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpIjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcwogIHZhciByZXF1aXJlX2NvbnN0YW50cyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7CiAgICAgICAgWl9OT19GTFVTSDogMCwKICAgICAgICBaX1BBUlRJQUxfRkxVU0g6IDEsCiAgICAgICAgWl9TWU5DX0ZMVVNIOiAyLAogICAgICAgIFpfRlVMTF9GTFVTSDogMywKICAgICAgICBaX0ZJTklTSDogNCwKICAgICAgICBaX0JMT0NLOiA1LAogICAgICAgIFpfVFJFRVM6IDYsCiAgICAgICAgWl9PSzogMCwKICAgICAgICBaX1NUUkVBTV9FTkQ6IDEsCiAgICAgICAgWl9ORUVEX0RJQ1Q6IDIsCiAgICAgICAgWl9FUlJOTzogLTEsCiAgICAgICAgWl9TVFJFQU1fRVJST1I6IC0yLAogICAgICAgIFpfREFUQV9FUlJPUjogLTMsCiAgICAgICAgWl9CVUZfRVJST1I6IC01LAogICAgICAgIFpfTk9fQ09NUFJFU1NJT046IDAsCiAgICAgICAgWl9CRVNUX1NQRUVEOiAxLAogICAgICAgIFpfQkVTVF9DT01QUkVTU0lPTjogOSwKICAgICAgICBaX0RFRkFVTFRfQ09NUFJFU1NJT046IC0xLAogICAgICAgIFpfRklMVEVSRUQ6IDEsCiAgICAgICAgWl9IVUZGTUFOX09OTFk6IDIsCiAgICAgICAgWl9STEU6IDMsCiAgICAgICAgWl9GSVhFRDogNCwKICAgICAgICBaX0RFRkFVTFRfU1RSQVRFR1k6IDAsCiAgICAgICAgWl9CSU5BUlk6IDAsCiAgICAgICAgWl9URVhUOiAxLAogICAgICAgIFpfVU5LTk9XTjogMiwKICAgICAgICBaX0RFRkxBVEVEOiA4CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcwogIHZhciByZXF1aXJlX2d6aGVhZGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gR1poZWFkZXIoKSB7CiAgICAgICAgdGhpcy50ZXh0ID0gMDsKICAgICAgICB0aGlzLnRpbWUgPSAwOwogICAgICAgIHRoaXMueGZsYWdzID0gMDsKICAgICAgICB0aGlzLm9zID0gMDsKICAgICAgICB0aGlzLmV4dHJhID0gbnVsbDsKICAgICAgICB0aGlzLmV4dHJhX2xlbiA9IDA7CiAgICAgICAgdGhpcy5uYW1lID0gIiI7CiAgICAgICAgdGhpcy5jb21tZW50ID0gIiI7CiAgICAgICAgdGhpcy5oY3JjID0gMDsKICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBHWmhlYWRlcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfaW5mbGF0ZTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZV9pbmZsYXRlKCk7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBzdHJpbmdzID0gcmVxdWlyZV9zdHJpbmdzKCk7CiAgICAgIHZhciBjID0gcmVxdWlyZV9jb25zdGFudHMoKTsKICAgICAgdmFyIG1zZyA9IHJlcXVpcmVfbWVzc2FnZXMoKTsKICAgICAgdmFyIFpTdHJlYW0gPSByZXF1aXJlX3pzdHJlYW0oKTsKICAgICAgdmFyIEdaaGVhZGVyID0gcmVxdWlyZV9nemhlYWRlcigpOwogICAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICBmdW5jdGlvbiBJbmZsYXRlMihvcHRpb25zKSB7CiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUyKSkKICAgICAgICAgIHJldHVybiBuZXcgSW5mbGF0ZTIob3B0aW9ucyk7CiAgICAgICAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHsKICAgICAgICAgIGNodW5rU2l6ZTogMTYzODQsCiAgICAgICAgICB3aW5kb3dCaXRzOiAwLAogICAgICAgICAgdG86ICIiCiAgICAgICAgfSwgb3B0aW9ucyB8fCB7fSk7CiAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0aW9uczsKICAgICAgICBpZiAob3B0LnJhdyAmJiBvcHQud2luZG93Qml0cyA+PSAwICYmIG9wdC53aW5kb3dCaXRzIDwgMTYpIHsKICAgICAgICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzOwogICAgICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7CiAgICAgICAgICAgIG9wdC53aW5kb3dCaXRzID0gLTE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAob3B0LndpbmRvd0JpdHMgPj0gMCAmJiBvcHQud2luZG93Qml0cyA8IDE2ICYmICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyArPSAzMjsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID4gMTUgJiYgb3B0LndpbmRvd0JpdHMgPCA0OCkgewogICAgICAgICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkgewogICAgICAgICAgICBvcHQud2luZG93Qml0cyB8PSAxNTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5lcnIgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTsKICAgICAgICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICB2YXIgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0Mih0aGlzLnN0cm0sIG9wdC53aW5kb3dCaXRzKTsKICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7CiAgICAgICAgfQogICAgICAgIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7CiAgICAgICAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7CiAgICAgICAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKG9wdC5yYXcpIHsKICAgICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIEluZmxhdGUyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7CiAgICAgICAgdmFyIHN0YXR1cywgX21vZGU7CiAgICAgICAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7CiAgICAgICAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTsKICAgICAgICBpZiAodGhpcy5lbmRlZCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBfbW9kZSA9IG1vZGUgPT09IH5+bW9kZSA/IG1vZGUgOiBtb2RlID09PSB0cnVlID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSDsKICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpOwogICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gIltvYmplY3QgQXJyYXlCdWZmZXJdIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gZGF0YTsKICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X2luID0gMDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7CiAgICAgICAgZG8gewogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTsKICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IDA7CiAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplOwogICAgICAgICAgfQogICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsKICAgICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkgewogICAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0aW9uYXJ5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkgewogICAgICAgICAgICBzdGF0dXMgPSBjLlpfT0s7CiAgICAgICAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7CiAgICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLm5leHRfb3V0KSB7CiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpIHsKICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7CiAgICAgICAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7CiAgICAgICAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTsKICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsOwogICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsOwogICAgICAgICAgICAgICAgaWYgKHRhaWwpIHsKICAgICAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7CiAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHsKICAgICAgICAgIF9tb2RlID0gYy5aX0ZJTklTSDsKICAgICAgICB9CiAgICAgICAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pOwogICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHsKICAgICAgICAgIHRoaXMub25FbmQoYy5aX09LKTsKICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfTsKICAgICAgSW5mbGF0ZTIucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGNodW5rKSB7CiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7CiAgICAgIH07CiAgICAgIEluZmxhdGUyLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHN0YXR1cykgewogICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9PSykgewogICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCIiKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5lcnIgPSBzdGF0dXM7CiAgICAgICAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnOwogICAgICB9OwogICAgICBmdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUyKG9wdGlvbnMpOwogICAgICAgIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpOwogICAgICAgIGlmIChpbmZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IGluZmxhdG9yLm1zZyB8fCBtc2dbaW5mbGF0b3IuZXJyXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5yYXcgPSB0cnVlOwogICAgICAgIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTsKICAgICAgfQogICAgICBleHBvcnRzMi5JbmZsYXRlID0gSW5mbGF0ZTI7CiAgICAgIGV4cG9ydHMyLmluZmxhdGUgPSBpbmZsYXRlOwogICAgICBleHBvcnRzMi5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdzsKICAgICAgZXhwb3J0czIudW5nemlwID0gaW5mbGF0ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfcGFrbyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBhc3NpZ24gPSByZXF1aXJlX2NvbW1vbigpLmFzc2lnbjsKICAgICAgdmFyIGRlZmxhdGUgPSByZXF1aXJlX2RlZmxhdGUyKCk7CiAgICAgIHZhciBpbmZsYXRlID0gcmVxdWlyZV9pbmZsYXRlMigpOwogICAgICB2YXIgY29uc3RhbnRzID0gcmVxdWlyZV9jb25zdGFudHMoKTsKICAgICAgdmFyIHBha28gPSB7fTsKICAgICAgYXNzaWduKHBha28sIGRlZmxhdGUsIGluZmxhdGUsIGNvbnN0YW50cyk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHBha287CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb25nQDQuMC4wL25vZGVfbW9kdWxlcy9sb25nL3NyYy9sb25nLmpzCiAgdmFyIHJlcXVpcmVfbG9uZyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9sb25nQDQuMC4wL25vZGVfbW9kdWxlcy9sb25nL3NyYy9sb25nLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IExvbmc0OwogICAgICB2YXIgd2FzbSA9IG51bGw7CiAgICAgIHRyeSB7CiAgICAgICAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFsKICAgICAgICAgIDAsCiAgICAgICAgICA5NywKICAgICAgICAgIDExNSwKICAgICAgICAgIDEwOSwKICAgICAgICAgIDEsCiAgICAgICAgICAwLAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAxLAogICAgICAgICAgMTMsCiAgICAgICAgICAyLAogICAgICAgICAgOTYsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNywKICAgICAgICAgIDk2LAogICAgICAgICAgNCwKICAgICAgICAgIDEyNywKICAgICAgICAgIDEyNywKICAgICAgICAgIDEyNywKICAgICAgICAgIDEyNywKICAgICAgICAgIDEsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAzLAogICAgICAgICAgNywKICAgICAgICAgIDYsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICA2LAogICAgICAgICAgNiwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxLAogICAgICAgICAgNjUsCiAgICAgICAgICAwLAogICAgICAgICAgMTEsCiAgICAgICAgICA3LAogICAgICAgICAgNTAsCiAgICAgICAgICA2LAogICAgICAgICAgMywKICAgICAgICAgIDEwOSwKICAgICAgICAgIDExNywKICAgICAgICAgIDEwOCwKICAgICAgICAgIDAsCiAgICAgICAgICAxLAogICAgICAgICAgNSwKICAgICAgICAgIDEwMCwKICAgICAgICAgIDEwNSwKICAgICAgICAgIDExOCwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE1LAogICAgICAgICAgMCwKICAgICAgICAgIDIsCiAgICAgICAgICA1LAogICAgICAgICAgMTAwLAogICAgICAgICAgMTA1LAogICAgICAgICAgMTE4LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMTcsCiAgICAgICAgICAwLAogICAgICAgICAgMywKICAgICAgICAgIDUsCiAgICAgICAgICAxMTQsCiAgICAgICAgICAxMDEsCiAgICAgICAgICAxMDksCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNSwKICAgICAgICAgIDAsCiAgICAgICAgICA0LAogICAgICAgICAgNSwKICAgICAgICAgIDExNCwKICAgICAgICAgIDEwMSwKICAgICAgICAgIDEwOSwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE3LAogICAgICAgICAgMCwKICAgICAgICAgIDUsCiAgICAgICAgICA4LAogICAgICAgICAgMTAzLAogICAgICAgICAgMTAxLAogICAgICAgICAgMTE2LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMDQsCiAgICAgICAgICAxMDUsCiAgICAgICAgICAxMDMsCiAgICAgICAgICAxMDQsCiAgICAgICAgICAwLAogICAgICAgICAgMCwKICAgICAgICAgIDEwLAogICAgICAgICAgMTkxLAogICAgICAgICAgMSwKICAgICAgICAgIDYsCiAgICAgICAgICA0LAogICAgICAgICAgMCwKICAgICAgICAgIDM1LAogICAgICAgICAgMCwKICAgICAgICAgIDExLAogICAgICAgICAgMzYsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDMyLAogICAgICAgICAgMCwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMSwKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAzMiwKICAgICAgICAgIDIsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDMsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMTI2LAogICAgICAgICAgMzQsCiAgICAgICAgICA0LAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNSwKICAgICAgICAgIDE2NywKICAgICAgICAgIDM2LAogICAgICAgICAgMCwKICAgICAgICAgIDMyLAogICAgICAgICAgNCwKICAgICAgICAgIDE2NywKICAgICAgICAgIDExLAogICAgICAgICAgMzYsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDMyLAogICAgICAgICAgMCwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMSwKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAzMiwKICAgICAgICAgIDIsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDMsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMTI3LAogICAgICAgICAgMzQsCiAgICAgICAgICA0LAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNSwKICAgICAgICAgIDE2NywKICAgICAgICAgIDM2LAogICAgICAgICAgMCwKICAgICAgICAgIDMyLAogICAgICAgICAgNCwKICAgICAgICAgIDE2NywKICAgICAgICAgIDExLAogICAgICAgICAgMzYsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDMyLAogICAgICAgICAgMCwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMSwKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAzMiwKICAgICAgICAgIDIsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDMsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMTI4LAogICAgICAgICAgMzQsCiAgICAgICAgICA0LAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNSwKICAgICAgICAgIDE2NywKICAgICAgICAgIDM2LAogICAgICAgICAgMCwKICAgICAgICAgIDMyLAogICAgICAgICAgNCwKICAgICAgICAgIDE2NywKICAgICAgICAgIDExLAogICAgICAgICAgMzYsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDMyLAogICAgICAgICAgMCwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMSwKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAzMiwKICAgICAgICAgIDIsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDMsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMTI5LAogICAgICAgICAgMzQsCiAgICAgICAgICA0LAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNSwKICAgICAgICAgIDE2NywKICAgICAgICAgIDM2LAogICAgICAgICAgMCwKICAgICAgICAgIDMyLAogICAgICAgICAgNCwKICAgICAgICAgIDE2NywKICAgICAgICAgIDExLAogICAgICAgICAgMzYsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDMyLAogICAgICAgICAgMCwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMSwKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAzMiwKICAgICAgICAgIDIsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDMsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMTMwLAogICAgICAgICAgMzQsCiAgICAgICAgICA0LAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNSwKICAgICAgICAgIDE2NywKICAgICAgICAgIDM2LAogICAgICAgICAgMCwKICAgICAgICAgIDMyLAogICAgICAgICAgNCwKICAgICAgICAgIDE2NywKICAgICAgICAgIDExCiAgICAgICAgXSkpLCB7fSkuZXhwb3J0czsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICB9CiAgICAgIGZ1bmN0aW9uIExvbmc0KGxvdywgaGlnaCwgdW5zaWduZWQpIHsKICAgICAgICB0aGlzLmxvdyA9IGxvdyB8IDA7CiAgICAgICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7CiAgICAgICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgICAgIH0KICAgICAgTG9uZzQucHJvdG90eXBlLl9faXNMb25nX187CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nNC5wcm90b3R5cGUsICJfX2lzTG9uZ19fIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZnVuY3Rpb24gaXNMb25nKG9iaikgewogICAgICAgIHJldHVybiAob2JqICYmIG9ialsiX19pc0xvbmdfXyJdKSA9PT0gdHJ1ZTsKICAgICAgfQogICAgICBMb25nNC5pc0xvbmcgPSBpc0xvbmc7CiAgICAgIHZhciBJTlRfQ0FDSEUgPSB7fTsKICAgICAgdmFyIFVJTlRfQ0FDSEUgPSB7fTsKICAgICAgZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHsKICAgICAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlOwogICAgICAgIGlmICh1bnNpZ25lZCkgewogICAgICAgICAgdmFsdWUgPj4+PSAwOwogICAgICAgICAgaWYgKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikgewogICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTsKICAgICAgICAgICAgaWYgKGNhY2hlZE9iaikKICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqOwogICAgICAgICAgfQogICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7CiAgICAgICAgICBpZiAoY2FjaGUpCiAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFsdWUgfD0gMDsKICAgICAgICAgIGlmIChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHsKICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTsKICAgICAgICAgICAgaWYgKGNhY2hlZE9iaikKICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqOwogICAgICAgICAgfQogICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpOwogICAgICAgICAgaWYgKGNhY2hlKQogICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbUludCA9IGZyb21JbnQ7CiAgICAgIGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7CiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkKICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTzsKICAgICAgICBpZiAodW5zaWduZWQpIHsKICAgICAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgICAgIHJldHVybiBVWkVSTzsKICAgICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTCkKICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTCkKICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsKICAgICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpCiAgICAgICAgICAgIHJldHVybiBNQVhfVkFMVUU7CiAgICAgICAgfQogICAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHModmFsdWUgJSBUV09fUFdSXzMyX0RCTCB8IDAsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwgfCAwLCB1bnNpZ25lZCk7CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7CiAgICAgIGZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkgewogICAgICAgIHJldHVybiBuZXcgTG9uZzQobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nNC5mcm9tQml0cyA9IGZyb21CaXRzOwogICAgICB2YXIgcG93X2RibCA9IE1hdGgucG93OwogICAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7CiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApCiAgICAgICAgICB0aHJvdyBFcnJvcigiZW1wdHkgc3RyaW5nIik7CiAgICAgICAgaWYgKHN0ciA9PT0gIk5hTiIgfHwgc3RyID09PSAiSW5maW5pdHkiIHx8IHN0ciA9PT0gIitJbmZpbml0eSIgfHwgc3RyID09PSAiLUluZmluaXR5IikKICAgICAgICAgIHJldHVybiBaRVJPOwogICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICByYWRpeCA9IHVuc2lnbmVkLCB1bnNpZ25lZCA9IGZhbHNlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgICAgICAgfQogICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7CiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KQogICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgICAgICB2YXIgcDsKICAgICAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZigiLSIpKSA+IDApCiAgICAgICAgICB0aHJvdyBFcnJvcigiaW50ZXJpb3IgaHlwaGVuIik7CiAgICAgICAgZWxzZSBpZiAocCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTsKICAgICAgICB9CiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpOwogICAgICAgIHZhciByZXN1bHQgPSBaRVJPOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7CiAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSwgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpOwogICAgICAgICAgaWYgKHNpemUgPCA4KSB7CiAgICAgICAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpOwogICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpOwogICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQogICAgICBMb25nNC5mcm9tU3RyaW5nID0gZnJvbVN0cmluZzsKICAgICAgZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHsKICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpCiAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTsKICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gInN0cmluZyIpCiAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gImJvb2xlYW4iID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpOwogICAgICB9CiAgICAgIExvbmc0LmZyb21WYWx1ZSA9IGZyb21WYWx1ZTsKICAgICAgdmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjsKICAgICAgdmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDsKICAgICAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDsKICAgICAgdmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDsKICAgICAgdmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyOwogICAgICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpOwogICAgICB2YXIgWkVSTyA9IGZyb21JbnQoMCk7CiAgICAgIExvbmc0LlpFUk8gPSBaRVJPOwogICAgICB2YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpOwogICAgICBMb25nNC5VWkVSTyA9IFVaRVJPOwogICAgICB2YXIgT05FID0gZnJvbUludCgxKTsKICAgICAgTG9uZzQuT05FID0gT05FOwogICAgICB2YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7CiAgICAgIExvbmc0LlVPTkUgPSBVT05FOwogICAgICB2YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpOwogICAgICBMb25nNC5ORUdfT05FID0gTkVHX09ORTsKICAgICAgdmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDQyOTQ5NjcyOTUgfCAwLCAyMTQ3NDgzNjQ3IHwgMCwgZmFsc2UpOwogICAgICBMb25nNC5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7CiAgICAgIHZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cyg0Mjk0OTY3Mjk1IHwgMCwgNDI5NDk2NzI5NSB8IDAsIHRydWUpOwogICAgICBMb25nNC5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7CiAgICAgIHZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAyMTQ3NDgzNjQ4IHwgMCwgZmFsc2UpOwogICAgICBMb25nNC5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7CiAgICAgIHZhciBMb25nUHJvdG90eXBlID0gTG9uZzQucHJvdG90eXBlOwogICAgICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIyKCkgewogICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKQogICAgICAgICAgcmV0dXJuICh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkgewogICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7CiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KQogICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiAiMCI7CiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7CiAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSwgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSwgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7CiAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTsKICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICByZXR1cm4gIi0iICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7CiAgICAgICAgfQogICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSwgcmVtID0gdGhpczsKICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLCBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpOwogICAgICAgICAgcmVtID0gcmVtRGl2OwogICAgICAgICAgaWYgKHJlbS5pc1plcm8oKSkKICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpCiAgICAgICAgICAgICAgZGlnaXRzID0gIjAiICsgZGlnaXRzOwogICAgICAgICAgICByZXN1bHQgPSAiIiArIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkgewogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHsKICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7CiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7CiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7CiAgICAgICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKQogICAgICAgICAgaWYgKCh2YWwgJiAxIDw8IGJpdCkgIT0gMCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvOwogICAgICBMb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkgewogICAgICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkgewogICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7CiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHsKICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzOwogICAgICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikgewogICAgICAgIHJldHVybiAhdGhpcy5lcShvdGhlcik7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUubmUgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFsczsKICAgICAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPCAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjsKICAgICAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHsKICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA8PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID4gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47CiAgICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPj0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpOwogICAgICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZykKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpCiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTsKICAgICAgICByZXR1cm4gb3RoZXIuaGlnaCA+Pj4gMCA+IHRoaXMuaGlnaCA+Pj4gMCB8fCBvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDAgPyAtMSA6IDE7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTsKICAgICAgTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSkKICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7CiAgICAgIExvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkgewogICAgICAgIGlmICghaXNMb25nKGFkZGVuZCkpCiAgICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTsKICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2OwogICAgICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjsKICAgICAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDY1NTM1OwogICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgICAgIGMwMCArPSBhMDAgKyBiMDA7CiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7CiAgICAgICAgYzAwICY9IDY1NTM1OwogICAgICAgIGMxNiArPSBhMTYgKyBiMTY7CiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICAgICAgYzE2ICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMzIgKyBiMzI7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGM0OCArPSBhNDggKyBiNDg7CiAgICAgICAgYzQ4ICY9IDY1NTM1OwogICAgICAgIHJldHVybiBmcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7CiAgICAgICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpCiAgICAgICAgICBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpOwogICAgICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0OwogICAgICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikgewogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIFpFUk87CiAgICAgICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpCiAgICAgICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpOwogICAgICAgIGlmICh3YXNtKSB7CiAgICAgICAgICB2YXIgbG93ID0gd2FzbS5tdWwodGhpcy5sb3csIHRoaXMuaGlnaCwgbXVsdGlwbGllci5sb3csIG11bHRpcGxpZXIuaGlnaCk7CiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiBaRVJPOwogICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpCiAgICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTzsKICAgICAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87CiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpOwogICAgICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7CiAgICAgICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSkKICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7CiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDsKICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjsKICAgICAgICBjMDAgJj0gNjU1MzU7CiAgICAgICAgYzE2ICs9IGExNiAqIGIwMDsKICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjsKICAgICAgICBjMTYgJj0gNjU1MzU7CiAgICAgICAgYzE2ICs9IGEwMCAqIGIxNjsKICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjsKICAgICAgICBjMTYgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGExNiAqIGIxNjsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGEwMCAqIGIzMjsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODsKICAgICAgICBjNDggJj0gNjU1MzU7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5OwogICAgICBMb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7CiAgICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpCiAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpOwogICAgICAgIGlmIChkaXZpc29yLmlzWmVybygpKQogICAgICAgICAgdGhyb3cgRXJyb3IoImRpdmlzaW9uIGJ5IHplcm8iKTsKICAgICAgICBpZiAod2FzbSkgewogICAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA9PT0gLTIxNDc0ODM2NDggJiYgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLmRpdl91IDogd2FzbS5kaXZfcykodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7CiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgICAgIHZhciBhcHByb3gsIHJlbSwgcmVzOwogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkgewogICAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkgewogICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpCiAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsKICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgICAgIHJldHVybiBPTkU7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpOwogICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7CiAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7CiAgICAgICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpOwogICAgICAgICAgICAgICAgcmV0dXJuIHJlczsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTzsKICAgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpOwogICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7CiAgICAgICAgICByZXMgPSBaRVJPOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpCiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTsKICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKQogICAgICAgICAgICByZXR1cm4gVVpFUk87CiAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKQogICAgICAgICAgICByZXR1cm4gVU9ORTsKICAgICAgICAgIHJlcyA9IFVaRVJPOwogICAgICAgIH0KICAgICAgICByZW0gPSB0aGlzOwogICAgICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7CiAgICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7CiAgICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLCBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLCBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7CiAgICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkgewogICAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7CiAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpCiAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTsKICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTsKICAgICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTsKICAgICAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikgewogICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKQogICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTsKICAgICAgICBpZiAod2FzbSkgewogICAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5yZW1fdSA6IHdhc20ucmVtX3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87CiAgICAgIExvbmdQcm90b3R5cGUucmVtID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87CiAgICAgIExvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkgewogICAgICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikgewogICAgICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykgewogICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgdGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gMzIgLSBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICBlbHNlCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgbnVtQml0cyAtIDMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSkKICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMikKICAgICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICBlbHNlCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IG51bUJpdHMgLSAzMiwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykgewogICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIG51bUJpdHMgJj0gNjM7CiAgICAgICAgaWYgKG51bUJpdHMgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIHsKICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoOwogICAgICAgICAgaWYgKG51bUJpdHMgPCAzMikgewogICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7CiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhsb3cgPj4+IG51bUJpdHMgfCBoaWdoIDw8IDMyIC0gbnVtQml0cywgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKQogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiBudW1CaXRzIC0gMzIsIDAsIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7CiAgICAgIExvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICAgICAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkgewogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7CiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMobGUpIHsKICAgICAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7CiAgICAgICAgdmFyIGhpID0gdGhpcy5oaWdoLCBsbyA9IHRoaXMubG93OwogICAgICAgIHJldHVybiBbCiAgICAgICAgICBsbyAmIDI1NSwKICAgICAgICAgIGxvID4+PiA4ICYgMjU1LAogICAgICAgICAgbG8gPj4+IDE2ICYgMjU1LAogICAgICAgICAgbG8gPj4+IDI0LAogICAgICAgICAgaGkgJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGhpID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGhpID4+PiAyNAogICAgICAgIF07CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkgewogICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgaGkgPj4+IDI0LAogICAgICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgICAgICBoaSAmIDI1NSwKICAgICAgICAgIGxvID4+PiAyNCwKICAgICAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGxvID4+PiA4ICYgMjU1LAogICAgICAgICAgbG8gJiAyNTUKICAgICAgICBdOwogICAgICB9OwogICAgICBMb25nNC5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMyKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHsKICAgICAgICByZXR1cm4gbGUgPyBMb25nNC5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZzQuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZzQuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmc0KGJ5dGVzWzBdIHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbM10gPDwgMjQsIGJ5dGVzWzRdIHwgYnl0ZXNbNV0gPDwgOCB8IGJ5dGVzWzZdIDw8IDE2IHwgYnl0ZXNbN10gPDwgMjQsIHVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZzQuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmc0KGJ5dGVzWzRdIDw8IDI0IHwgYnl0ZXNbNV0gPDwgMTYgfCBieXRlc1s2XSA8PCA4IHwgYnl0ZXNbN10sIGJ5dGVzWzBdIDw8IDI0IHwgYnl0ZXNbMV0gPDwgMTYgfCBieXRlc1syXSA8PCA4IHwgYnl0ZXNbM10sIHVuc2lnbmVkKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c0AzLjMuMC9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcwogIHZhciByZXF1aXJlX2V2ZW50cyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9ldmVudHNAMy4zLjAvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAib2JqZWN0IiA/IFJlZmxlY3QgOiBudWxsOwogICAgICB2YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gImZ1bmN0aW9uIiA/IFIuYXBwbHkgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkyKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHsKICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7CiAgICAgIH07CiAgICAgIHZhciBSZWZsZWN0T3duS2V5czsKICAgICAgaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzOwogICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsKICAgICAgICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzMih0YXJnZXQpIHsKICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpOwogICAgICAgIH07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5czIodGFyZ2V0KSB7CiAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7CiAgICAgICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKQogICAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpOwogICAgICB9CiAgICAgIHZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTjIodmFsdWUpIHsKICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlOwogICAgICB9OwogICAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7CiAgICAgICAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cy5vbmNlID0gb25jZTsKICAgICAgRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjsKICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdm9pZCAwOwogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHZvaWQgMDsKICAgICAgdmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDsKICAgICAgZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikgewogICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAibGlzdGVuZXIiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCB7CiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7CiAgICAgICAgfSwKICAgICAgICBzZXQ6IGZ1bmN0aW9uKGFyZykgewogICAgICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICJudW1iZXIiIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mICJkZWZhdWx0TWF4TGlzdGVuZXJzIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgIi4iKTsKICAgICAgICAgIH0KICAgICAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHsKICAgICAgICBpZiAodGhpcy5fZXZlbnRzID09PSB2b2lkIDAgfHwgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykgewogICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDsKICAgICAgICB9CiAgICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHZvaWQgMDsKICAgICAgfTsKICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikgewogICAgICAgIGlmICh0eXBlb2YgbiAhPT0gIm51bWJlciIgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgIm4iIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgIi4iKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7CiAgICAgICAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdm9pZCAwKQogICAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzOwogICAgICAgIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7CiAgICAgIH0KICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7CiAgICAgICAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7CiAgICAgIH07CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkgewogICAgICAgIHZhciBhcmdzID0gW107CiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspCiAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTsKICAgICAgICB2YXIgZG9FcnJvciA9IHR5cGUgPT09ICJlcnJvciI7CiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50czsKICAgICAgICBpZiAoZXZlbnRzICE9PSB2b2lkIDApCiAgICAgICAgICBkb0Vycm9yID0gZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHZvaWQgMDsKICAgICAgICBlbHNlIGlmICghZG9FcnJvcikKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICBpZiAoZG9FcnJvcikgewogICAgICAgICAgdmFyIGVyOwogICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkKICAgICAgICAgICAgZXIgPSBhcmdzWzBdOwogICAgICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHsKICAgICAgICAgICAgdGhyb3cgZXI7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCJVbmhhbmRsZWQgZXJyb3IuIiArIChlciA/ICIgKCIgKyBlci5tZXNzYWdlICsgIikiIDogIiIpKTsKICAgICAgICAgIGVyci5jb250ZXh0ID0gZXI7CiAgICAgICAgICB0aHJvdyBlcnI7CiAgICAgICAgfQogICAgICAgIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdOwogICAgICAgIGlmIChoYW5kbGVyID09PSB2b2lkIDApCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDsKICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKQogICAgICAgICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7CiAgICAgICAgdmFyIG07CiAgICAgICAgdmFyIGV2ZW50czsKICAgICAgICB2YXIgZXhpc3Rpbmc7CiAgICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7CiAgICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7CiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7CiAgICAgICAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHRhcmdldC5lbWl0KCJuZXdMaXN0ZW5lciIsIHR5cGUsIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7CiAgICAgICAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzOwogICAgICAgICAgfQogICAgICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07CiAgICAgICAgfQogICAgICAgIGlmIChleGlzdGluZyA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyOwogICAgICAgICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07CiAgICAgICAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHsKICAgICAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTsKICAgICAgICAgIH0KICAgICAgICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7CiAgICAgICAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7CiAgICAgICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7CiAgICAgICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCJQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICIgKyBleGlzdGluZy5sZW5ndGggKyAiICIgKyBTdHJpbmcodHlwZSkgKyAiIGxpc3RlbmVycyBhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQiKTsKICAgICAgICAgICAgdy5uYW1lID0gIk1heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyI7CiAgICAgICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDsKICAgICAgICAgICAgdy50eXBlID0gdHlwZTsKICAgICAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDsKICAgICAgICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFyZ2V0OwogICAgICB9CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTsKICAgICAgfTsKICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7CiAgICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkgewogICAgICAgIGlmICghdGhpcy5maXJlZCkgewogICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7CiAgICAgICAgICB0aGlzLmZpcmVkID0gdHJ1ZTsKICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKQogICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTsKICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikgewogICAgICAgIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHZvaWQgMCwgdGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciB9OwogICAgICAgIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7CiAgICAgICAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyOwogICAgICAgIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7CiAgICAgICAgcmV0dXJuIHdyYXBwZWQ7CiAgICAgIH0KICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZTIodHlwZSwgbGlzdGVuZXIpIHsKICAgICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTsKICAgICAgICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7CiAgICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7CiAgICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyOwogICAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpOwogICAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50czsKICAgICAgICBpZiAoZXZlbnRzID09PSB2b2lkIDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdOwogICAgICAgIGlmIChsaXN0ID09PSB2b2lkIDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHsKICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKQogICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07CiAgICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpCiAgICAgICAgICAgICAgdGhpcy5lbWl0KCJyZW1vdmVMaXN0ZW5lciIsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHBvc2l0aW9uID0gLTE7CiAgICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikgewogICAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyOwogICAgICAgICAgICAgIHBvc2l0aW9uID0gaTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDApCiAgICAgICAgICAgIGxpc3Quc2hpZnQoKTsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKQogICAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdOwogICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdm9pZCAwKQogICAgICAgICAgICB0aGlzLmVtaXQoInJlbW92ZUxpc3RlbmVyIiwgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHsKICAgICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7CiAgICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzOwogICAgICAgIGlmIChldmVudHMgPT09IHZvaWQgMCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHZvaWQgMCkgewogICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKICAgICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwOwogICAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHZvaWQgMCkgewogICAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkKICAgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgdmFyIGtleXMyID0gT2JqZWN0LmtleXMoZXZlbnRzKTsKICAgICAgICAgIHZhciBrZXk7CiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5czIubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAga2V5ID0ga2V5czJbaV07CiAgICAgICAgICAgIGlmIChrZXkgPT09ICJyZW1vdmVMaXN0ZW5lciIpCiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygicmVtb3ZlTGlzdGVuZXIiKTsKICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7CiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdOwogICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7CiAgICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHZvaWQgMCkgewogICAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHsKICAgICAgICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7CiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdm9pZCAwKQogICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdOwogICAgICAgIGlmIChldmxpc3RlbmVyID09PSB2b2lkIDApCiAgICAgICAgICByZXR1cm4gW107CiAgICAgICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAiZnVuY3Rpb24iKQogICAgICAgICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdOwogICAgICAgIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTsKICAgICAgfQogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7CiAgICAgICAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7CiAgICAgIH07CiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHsKICAgICAgICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7CiAgICAgIH07CiAgICAgIEV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkgewogICAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDsKICAgICAgZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7CiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50czsKICAgICAgICBpZiAoZXZlbnRzICE9PSB2b2lkIDApIHsKICAgICAgICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdOwogICAgICAgICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB2b2lkIDApIHsKICAgICAgICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gMDsKICAgICAgfQogICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkgewogICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7CiAgICAgICAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpCiAgICAgICAgICBjb3B5W2ldID0gYXJyW2ldOwogICAgICAgIHJldHVybiBjb3B5OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkgewogICAgICAgIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKykKICAgICAgICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdOwogICAgICAgIGxpc3QucG9wKCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikgewogICAgICAgIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7CiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHsKICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7CiAgICAgICAgICAgIHJlamVjdChlcnIpOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7CiAgICAgICAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoImVycm9yIiwgZXJyb3JMaXN0ZW5lcik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpOwogICAgICAgICAgfQogICAgICAgICAgOwogICAgICAgICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7CiAgICAgICAgICBpZiAobmFtZSAhPT0gImVycm9yIikgewogICAgICAgICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHsKICAgICAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAiZXJyb3IiLCBoYW5kbGVyLCBmbGFncyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHsKICAgICAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIGlmIChmbGFncy5vbmNlKSB7CiAgICAgICAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7CiAgICAgICAgICAgIGlmIChmbGFncy5vbmNlKSB7CiAgICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbGlzdGVuZXIoYXJnKTsKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgImVtaXR0ZXIiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2luaGVyaXRzQDIuMC40L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzCiAgdmFyIHJlcXVpcmVfaW5oZXJpdHNfYnJvd3NlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9pbmhlcml0c0AyLjAuNC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHsKICAgICAgICAgIGlmIChzdXBlckN0b3IpIHsKICAgICAgICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7CiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7CiAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHsKICAgICAgICAgICAgICAgIHZhbHVlOiBjdG9yLAogICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgfSBlbHNlIHsKICAgICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHsKICAgICAgICAgIGlmIChzdXBlckN0b3IpIHsKICAgICAgICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7CiAgICAgICAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB9OwogICAgICAgICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlOwogICAgICAgICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpOwogICAgICAgICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMKICB2YXIgcmVxdWlyZV9zdHJlYW1fYnJvd3NlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX2V2ZW50cygpLkV2ZW50RW1pdHRlcjsKICAgIH0KICB9KTsKCiAgLy8gKGRpc2FibGVkKTp1dGlsCiAgdmFyIHJlcXVpcmVfdXRpbCA9IF9fY29tbW9uSlMoewogICAgIihkaXNhYmxlZCk6dXRpbCIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzCiAgdmFyIHJlcXVpcmVfYnVmZmVyX2xpc3QgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsKICAgICAgICB2YXIga2V5czIgPSBPYmplY3Qua2V5cyhvYmplY3QpOwogICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7CiAgICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsKICAgICAgICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7CiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOwogICAgICAgICAgfSkpLCBrZXlzMi5wdXNoLmFwcGx5KGtleXMyLCBzeW1ib2xzKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGtleXMyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7CiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OwogICAgICAgICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkgewogICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsKICAgICAgICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhcmdldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7CiAgICAgICAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsKICAgICAgICBpZiAoa2V5IGluIG9iaikgewogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsKICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOwogICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOwogICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOwogICAgICAgICAgaWYgKCJ2YWx1ZSIgaW4gZGVzY3JpcHRvcikKICAgICAgICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7CiAgICAgICAgaWYgKHByb3RvUHJvcHMpCiAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOwogICAgICAgIGlmIChzdGF0aWNQcm9wcykKICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCAicHJvdG90eXBlIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7CiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgewogICAgICAgIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCAic3RyaW5nIik7CiAgICAgICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICJzeW1ib2wiID8ga2V5IDogU3RyaW5nKGtleSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7CiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gIm9iamVjdCIgfHwgaW5wdXQgPT09IG51bGwpCiAgICAgICAgICByZXR1cm4gaW5wdXQ7CiAgICAgICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOwogICAgICAgIGlmIChwcmltICE9PSB2b2lkIDApIHsKICAgICAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgImRlZmF1bHQiKTsKICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAib2JqZWN0IikKICAgICAgICAgICAgcmV0dXJuIHJlczsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiAoaGludCA9PT0gInN0cmluZyIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsKICAgICAgfQogICAgICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlX2J1ZmZlcigpOwogICAgICB2YXIgQnVmZmVyMTAgPSBfcmVxdWlyZS5CdWZmZXI7CiAgICAgIHZhciBfcmVxdWlyZTIgPSByZXF1aXJlX3V0aWwoKTsKICAgICAgdmFyIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDsKICAgICAgdmFyIGN1c3RvbSA9IGluc3BlY3QgJiYgaW5zcGVjdC5jdXN0b20gfHwgImluc3BlY3QiOwogICAgICBmdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHsKICAgICAgICBCdWZmZXIxMC5wcm90b3R5cGUuY29weS5jYWxsKHNyYywgdGFyZ2V0LCBvZmZzZXQpOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkgewogICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpOwogICAgICAgICAgdGhpcy5oZWFkID0gbnVsbDsKICAgICAgICAgIHRoaXMudGFpbCA9IG51bGw7CiAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhCdWZmZXJMaXN0LCBbewogICAgICAgICAga2V5OiAicHVzaCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2KSB7CiAgICAgICAgICAgIHZhciBlbnRyeSA9IHsKICAgICAgICAgICAgICBkYXRhOiB2LAogICAgICAgICAgICAgIG5leHQ6IG51bGwKICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkKICAgICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGVudHJ5OwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgdGhpcy5oZWFkID0gZW50cnk7CiAgICAgICAgICAgIHRoaXMudGFpbCA9IGVudHJ5OwogICAgICAgICAgICArK3RoaXMubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInVuc2hpZnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodikgewogICAgICAgICAgICB2YXIgZW50cnkgPSB7CiAgICAgICAgICAgICAgZGF0YTogdiwKICAgICAgICAgICAgICBuZXh0OiB0aGlzLmhlYWQKICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKQogICAgICAgICAgICAgIHRoaXMudGFpbCA9IGVudHJ5OwogICAgICAgICAgICB0aGlzLmhlYWQgPSBlbnRyeTsKICAgICAgICAgICAgKyt0aGlzLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJzaGlmdCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTsKICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKQogICAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDsKICAgICAgICAgICAgLS10aGlzLmxlbmd0aDsKICAgICAgICAgICAgcmV0dXJuIHJldDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJjbGVhciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7CiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7CiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJqb2luIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHsKICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKQogICAgICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7CiAgICAgICAgICAgIHZhciByZXQgPSAiIiArIHAuZGF0YTsKICAgICAgICAgICAgd2hpbGUgKHAgPSBwLm5leHQpCiAgICAgICAgICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7CiAgICAgICAgICAgIHJldHVybiByZXQ7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiY29uY2F0IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQobikgewogICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApCiAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmFsbG9jKDApOwogICAgICAgICAgICB2YXIgcmV0ID0gQnVmZmVyMTAuYWxsb2NVbnNhZmUobiA+Pj4gMCk7CiAgICAgICAgICAgIHZhciBwID0gdGhpcy5oZWFkOwogICAgICAgICAgICB2YXIgaSA9IDA7CiAgICAgICAgICAgIHdoaWxlIChwKSB7CiAgICAgICAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7CiAgICAgICAgICAgICAgaSArPSBwLmRhdGEubGVuZ3RoOwogICAgICAgICAgICAgIHAgPSBwLm5leHQ7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJldDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJjb25zdW1lIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHsKICAgICAgICAgICAgdmFyIHJldDsKICAgICAgICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHsKICAgICAgICAgICAgICByZXQgPSB0aGlzLmhlYWQuZGF0YS5zbGljZSgwLCBuKTsKICAgICAgICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pOwogICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkgewogICAgICAgICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXQgPSBoYXNTdHJpbmdzID8gdGhpcy5fZ2V0U3RyaW5nKG4pIDogdGhpcy5fZ2V0QnVmZmVyKG4pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZXQ7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZmlyc3QiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiX2dldFN0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7CiAgICAgICAgICAgIHZhciBwID0gdGhpcy5oZWFkOwogICAgICAgICAgICB2YXIgYyA9IDE7CiAgICAgICAgICAgIHZhciByZXQgPSBwLmRhdGE7CiAgICAgICAgICAgIG4gLT0gcmV0Lmxlbmd0aDsKICAgICAgICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHsKICAgICAgICAgICAgICB2YXIgc3RyID0gcC5kYXRhOwogICAgICAgICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47CiAgICAgICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKQogICAgICAgICAgICAgICAgcmV0ICs9IHN0cjsKICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICByZXQgKz0gc3RyLnNsaWNlKDAsIG4pOwogICAgICAgICAgICAgIG4gLT0gbmI7CiAgICAgICAgICAgICAgaWYgKG4gPT09IDApIHsKICAgICAgICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICArK2M7CiAgICAgICAgICAgICAgICAgIGlmIChwLm5leHQpCiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gcC5uZXh0OwogICAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7CiAgICAgICAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgKytjOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMubGVuZ3RoIC09IGM7CiAgICAgICAgICAgIHJldHVybiByZXQ7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiX2dldEJ1ZmZlciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJ1ZmZlcihuKSB7CiAgICAgICAgICAgIHZhciByZXQgPSBCdWZmZXIxMC5hbGxvY1Vuc2FmZShuKTsKICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7CiAgICAgICAgICAgIHZhciBjID0gMTsKICAgICAgICAgICAgcC5kYXRhLmNvcHkocmV0KTsKICAgICAgICAgICAgbiAtPSBwLmRhdGEubGVuZ3RoOwogICAgICAgICAgICB3aGlsZSAocCA9IHAubmV4dCkgewogICAgICAgICAgICAgIHZhciBidWYgPSBwLmRhdGE7CiAgICAgICAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjsKICAgICAgICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7CiAgICAgICAgICAgICAgbiAtPSBuYjsKICAgICAgICAgICAgICBpZiAobiA9PT0gMCkgewogICAgICAgICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICsrYzsKICAgICAgICAgICAgICAgICAgaWYgKHAubmV4dCkKICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBwLm5leHQ7CiAgICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gcDsKICAgICAgICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICArK2M7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5sZW5ndGggLT0gYzsKICAgICAgICAgICAgcmV0dXJuIHJldDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6IGN1c3RvbSwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7CiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7CiAgICAgICAgICAgICAgZGVwdGg6IDAsCiAgICAgICAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UKICAgICAgICAgICAgfSkpOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gQnVmZmVyTGlzdDsKICAgICAgfSgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcwogIHZhciByZXF1aXJlX2Rlc3Ryb3kgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikgewogICAgICAgIHZhciBfdGhpcyA9IHRoaXM7CiAgICAgICAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDsKICAgICAgICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkOwogICAgICAgIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkgewogICAgICAgICAgaWYgKGNiKSB7CiAgICAgICAgICAgIGNiKGVycik7CiAgICAgICAgICB9IGVsc2UgaWYgKGVycikgewogICAgICAgICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHsKICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpOwogICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkgewogICAgICAgICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTsKICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHsKICAgICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHsKICAgICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24oZXJyMikgewogICAgICAgICAgaWYgKCFjYiAmJiBlcnIyKSB7CiAgICAgICAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHsKICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIyKTsKICAgICAgICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7CiAgICAgICAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTsKICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIyKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoY2IpIHsKICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpOwogICAgICAgICAgICBjYihlcnIyKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfQogICAgICBmdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZU5UKHNlbGYyLCBlcnIpIHsKICAgICAgICBlbWl0RXJyb3JOVChzZWxmMiwgZXJyKTsKICAgICAgICBlbWl0Q2xvc2VOVChzZWxmMik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZjIpIHsKICAgICAgICBpZiAoc2VsZjIuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYyLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkKICAgICAgICAgIHJldHVybjsKICAgICAgICBpZiAoc2VsZjIuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYyLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkKICAgICAgICAgIHJldHVybjsKICAgICAgICBzZWxmMi5lbWl0KCJjbG9zZSIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHVuZGVzdHJveSgpIHsKICAgICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTsKICAgICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlOwogICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7CiAgICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlOwogICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlOwogICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTsKICAgICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTsKICAgICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTsKICAgICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTsKICAgICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYyLCBlcnIpIHsKICAgICAgICBzZWxmMi5lbWl0KCJlcnJvciIsIGVycik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHsKICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwogICAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7CiAgICAgICAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkKICAgICAgICAgIHN0cmVhbS5kZXN0cm95KGVycik7CiAgICAgICAgZWxzZQogICAgICAgICAgc3RyZWFtLmVtaXQoImVycm9yIiwgZXJyKTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7CiAgICAgICAgZGVzdHJveSwKICAgICAgICB1bmRlc3Ryb3ksCiAgICAgICAgZXJyb3JPckRlc3Ryb3kKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy1icm93c2VyLmpzCiAgdmFyIHJlcXVpcmVfZXJyb3JzX2Jyb3dzZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZXJyb3JzLWJyb3dzZXIuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgewogICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOwogICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOwogICAgICAgIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7CiAgICAgIH0KICAgICAgdmFyIGNvZGVzID0ge307CiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7CiAgICAgICAgaWYgKCFCYXNlKSB7CiAgICAgICAgICBCYXNlID0gRXJyb3I7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykgewogICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAic3RyaW5nIikgewogICAgICAgICAgICByZXR1cm4gbWVzc2FnZTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB2YXIgTm9kZUVycm9yID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9CYXNlKSB7CiAgICAgICAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IyLCBfQmFzZSk7CiAgICAgICAgICBmdW5jdGlvbiBOb2RlRXJyb3IyKGFyZzEsIGFyZzIsIGFyZzMpIHsKICAgICAgICAgICAgcmV0dXJuIF9CYXNlLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkgfHwgdGhpczsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBOb2RlRXJyb3IyOwogICAgICAgIH0oQmFzZSk7CiAgICAgICAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lOwogICAgICAgIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGU7CiAgICAgICAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7CiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7CiAgICAgICAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoOwogICAgICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24oaSkgewogICAgICAgICAgICByZXR1cm4gU3RyaW5nKGkpOwogICAgICAgICAgfSk7CiAgICAgICAgICBpZiAobGVuID4gMikgewogICAgICAgICAgICByZXR1cm4gIm9uZSBvZiAiLmNvbmNhdCh0aGluZywgIiAiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbigiLCAiKSwgIiwgb3IgIikgKyBleHBlY3RlZFtsZW4gLSAxXTsKICAgICAgICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7CiAgICAgICAgICAgIHJldHVybiAib25lIG9mICIuY29uY2F0KHRoaW5nLCAiICIpLmNvbmNhdChleHBlY3RlZFswXSwgIiBvciAiKS5jb25jYXQoZXhwZWN0ZWRbMV0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuICJvZiAiLmNvbmNhdCh0aGluZywgIiAiKS5jb25jYXQoZXhwZWN0ZWRbMF0pOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gIm9mICIuY29uY2F0KHRoaW5nLCAiICIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7CiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7CiAgICAgICAgaWYgKHRoaXNfbGVuID09PSB2b2lkIDAgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7CiAgICAgICAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7CiAgICAgICAgaWYgKHR5cGVvZiBzdGFydCAhPT0gIm51bWJlciIpIHsKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTsKICAgICAgICB9CiAgICAgIH0KICAgICAgY3JlYXRlRXJyb3JUeXBlKCJFUlJfSU5WQUxJRF9PUFRfVkFMVUUiLCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkgewogICAgICAgIHJldHVybiAnVGhlIHZhbHVlICInICsgdmFsdWUgKyAnIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gIicgKyBuYW1lICsgJyInOwogICAgICB9LCBUeXBlRXJyb3IpOwogICAgICBjcmVhdGVFcnJvclR5cGUoIkVSUl9JTlZBTElEX0FSR19UWVBFIiwgZnVuY3Rpb24obmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkgewogICAgICAgIHZhciBkZXRlcm1pbmVyOwogICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICJzdHJpbmciICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICJub3QgIikpIHsKICAgICAgICAgIGRldGVybWluZXIgPSAibXVzdCBub3QgYmUiOwogICAgICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICIiKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZGV0ZXJtaW5lciA9ICJtdXN0IGJlIjsKICAgICAgICB9CiAgICAgICAgdmFyIG1zZzsKICAgICAgICBpZiAoZW5kc1dpdGgobmFtZSwgIiBhcmd1bWVudCIpKSB7CiAgICAgICAgICBtc2cgPSAiVGhlICIuY29uY2F0KG5hbWUsICIgIikuY29uY2F0KGRldGVybWluZXIsICIgIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAidHlwZSIpKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAiLiIpID8gInByb3BlcnR5IiA6ICJhcmd1bWVudCI7CiAgICAgICAgICBtc2cgPSAnVGhlICInLmNvbmNhdChuYW1lLCAnIiAnKS5jb25jYXQodHlwZSwgIiAiKS5jb25jYXQoZGV0ZXJtaW5lciwgIiAiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICJ0eXBlIikpOwogICAgICAgIH0KICAgICAgICBtc2cgKz0gIi4gUmVjZWl2ZWQgdHlwZSAiLmNvbmNhdCh0eXBlb2YgYWN0dWFsKTsKICAgICAgICByZXR1cm4gbXNnOwogICAgICB9LCBUeXBlRXJyb3IpOwogICAgICBjcmVhdGVFcnJvclR5cGUoIkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YiLCAic3RyZWFtLnB1c2goKSBhZnRlciBFT0YiKTsKICAgICAgY3JlYXRlRXJyb3JUeXBlKCJFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCIsIGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICByZXR1cm4gIlRoZSAiICsgbmFtZSArICIgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCI7CiAgICAgIH0pOwogICAgICBjcmVhdGVFcnJvclR5cGUoIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFIiwgIlByZW1hdHVyZSBjbG9zZSIpOwogICAgICBjcmVhdGVFcnJvclR5cGUoIkVSUl9TVFJFQU1fREVTVFJPWUVEIiwgZnVuY3Rpb24obmFtZSkgewogICAgICAgIHJldHVybiAiQ2Fubm90IGNhbGwgIiArIG5hbWUgKyAiIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQiOwogICAgICB9KTsKICAgICAgY3JlYXRlRXJyb3JUeXBlKCJFUlJfTVVMVElQTEVfQ0FMTEJBQ0siLCAiQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzIik7CiAgICAgIGNyZWF0ZUVycm9yVHlwZSgiRVJSX1NUUkVBTV9DQU5OT1RfUElQRSIsICJDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlIik7CiAgICAgIGNyZWF0ZUVycm9yVHlwZSgiRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQiLCAid3JpdGUgYWZ0ZXIgZW5kIik7CiAgICAgIGNyZWF0ZUVycm9yVHlwZSgiRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyIsICJNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbSIsIFR5cGVFcnJvcik7CiAgICAgIGNyZWF0ZUVycm9yVHlwZSgiRVJSX1VOS05PV05fRU5DT0RJTkciLCBmdW5jdGlvbihhcmcpIHsKICAgICAgICByZXR1cm4gIlVua25vd24gZW5jb2Rpbmc6ICIgKyBhcmc7CiAgICAgIH0sIFR5cGVFcnJvcik7CiAgICAgIGNyZWF0ZUVycm9yVHlwZSgiRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCIsICJzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCIpOwogICAgICBtb2R1bGUyLmV4cG9ydHMuY29kZXMgPSBjb2RlczsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzCiAgdmFyIHJlcXVpcmVfc3RhdGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZV9lcnJvcnNfYnJvd3NlcigpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTsKICAgICAgZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkgewogICAgICAgIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDsKICAgICAgfQogICAgICBmdW5jdGlvbiBnZXRIaWdoV2F0ZXJNYXJrKHN0YXRlLCBvcHRpb25zLCBkdXBsZXhLZXksIGlzRHVwbGV4KSB7CiAgICAgICAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpOwogICAgICAgIGlmIChod20gIT0gbnVsbCkgewogICAgICAgICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkgewogICAgICAgICAgICB2YXIgbmFtZSA9IGlzRHVwbGV4ID8gZHVwbGV4S2V5IDogImhpZ2hXYXRlck1hcmsiOwogICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihod20pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0OwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHsKICAgICAgICBnZXRIaWdoV2F0ZXJNYXJrCiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS91dGlsLWRlcHJlY2F0ZUAxLjAuMi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcwogIHZhciByZXF1aXJlX2Jyb3dzZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdXRpbC1kZXByZWNhdGVAMS4wLjIvbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gZGVwcmVjYXRlOwogICAgICBmdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1zZykgewogICAgICAgIGlmIChjb25maWcoIm5vRGVwcmVjYXRpb24iKSkgewogICAgICAgICAgcmV0dXJuIGZuOwogICAgICAgIH0KICAgICAgICB2YXIgd2FybmVkID0gZmFsc2U7CiAgICAgICAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHsKICAgICAgICAgIGlmICghd2FybmVkKSB7CiAgICAgICAgICAgIGlmIChjb25maWcoInRocm93RGVwcmVjYXRpb24iKSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpOwogICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZygidHJhY2VEZXByZWNhdGlvbiIpKSB7CiAgICAgICAgICAgICAgY29uc29sZS50cmFjZShtc2cpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGNvbnNvbGUud2Fybihtc2cpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlcHJlY2F0ZWQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29uZmlnKG5hbWUpIHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfSBjYXRjaCAoXykgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTsKICAgICAgICBpZiAodmFsID09IG51bGwpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICJ0cnVlIjsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMKICB2YXIgcmVxdWlyZV9zdHJlYW1fd3JpdGFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBXcml0YWJsZTsKICAgICAgZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkgewogICAgICAgIHZhciBfdGhpcyA9IHRoaXM7CiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDsKICAgICAgICB0aGlzLmVudHJ5ID0gbnVsbDsKICAgICAgICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIHZhciBEdXBsZXg7CiAgICAgIFdyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlOwogICAgICB2YXIgaW50ZXJuYWxVdGlsID0gewogICAgICAgIGRlcHJlY2F0ZTogcmVxdWlyZV9icm93c2VyKCkKICAgICAgfTsKICAgICAgdmFyIFN0cmVhbSA9IHJlcXVpcmVfc3RyZWFtX2Jyb3dzZXIoKTsKICAgICAgdmFyIEJ1ZmZlcjEwID0gcmVxdWlyZV9idWZmZXIoKS5CdWZmZXI7CiAgICAgIHZhciBPdXJVaW50OEFycmF5ID0gKHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDoge30pLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24oKSB7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHsKICAgICAgICByZXR1cm4gQnVmZmVyMTAuZnJvbShjaHVuayk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHsKICAgICAgICByZXR1cm4gQnVmZmVyMTAuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5OwogICAgICB9CiAgICAgIHZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmVfZGVzdHJveSgpOwogICAgICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlX3N0YXRlKCk7CiAgICAgIHZhciBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyazsKICAgICAgdmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZV9lcnJvcnNfYnJvd3NlcigpLmNvZGVzOwogICAgICB2YXIgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRTsKICAgICAgdmFyIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQ7CiAgICAgIHZhciBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0s7CiAgICAgIHZhciBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRTsKICAgICAgdmFyIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7CiAgICAgIHZhciBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUzsKICAgICAgdmFyIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQ7CiAgICAgIHZhciBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HOwogICAgICB2YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTsKICAgICAgcmVxdWlyZV9pbmhlcml0c19icm93c2VyKCkoV3JpdGFibGUsIFN0cmVhbSk7CiAgICAgIGZ1bmN0aW9uIG5vcCgpIHsKICAgICAgfQogICAgICBmdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHsKICAgICAgICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZV9zdHJlYW1fZHVwbGV4KCk7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gImJvb2xlYW4iKQogICAgICAgICAgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7CiAgICAgICAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7CiAgICAgICAgaWYgKGlzRHVwbGV4KQogICAgICAgICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7CiAgICAgICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwgaXNEdXBsZXgpOwogICAgICAgIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOwogICAgICAgIHRoaXMuZW5kaW5nID0gZmFsc2U7CiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOwogICAgICAgIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7CiAgICAgICAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOwogICAgICAgIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgInV0ZjgiOwogICAgICAgIHRoaXMubGVuZ3RoID0gMDsKICAgICAgICB0aGlzLndyaXRpbmcgPSBmYWxzZTsKICAgICAgICB0aGlzLmNvcmtlZCA9IDA7CiAgICAgICAgdGhpcy5zeW5jID0gdHJ1ZTsKICAgICAgICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsKICAgICAgICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikgewogICAgICAgICAgb253cml0ZShzdHJlYW0sIGVyKTsKICAgICAgICB9OwogICAgICAgIHRoaXMud3JpdGVjYiA9IG51bGw7CiAgICAgICAgdGhpcy53cml0ZWxlbiA9IDA7CiAgICAgICAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsOwogICAgICAgIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CiAgICAgICAgdGhpcy5wZW5kaW5nY2IgPSAwOwogICAgICAgIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOwogICAgICAgIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7CiAgICAgICAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7CiAgICAgICAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTsKICAgICAgfQogICAgICBXcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7CiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDsKICAgICAgICB2YXIgb3V0ID0gW107CiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHsKICAgICAgICAgIG91dC5wdXNoKGN1cnJlbnQpOwogICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG91dDsKICAgICAgfTsKICAgICAgKGZ1bmN0aW9uKCkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICJidWZmZXIiLCB7CiAgICAgICAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpOwogICAgICAgICAgICB9LCAiX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgaW5zdGVhZC4iLCAiREVQMDAwMyIpCiAgICAgICAgICB9KTsKICAgICAgICB9IGNhdGNoIChfKSB7CiAgICAgICAgfQogICAgICB9KSgpOwogICAgICB2YXIgcmVhbEhhc0luc3RhbmNlOwogICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIiAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHsKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHsKICAgICAgICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpCiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkKICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2UyKG9iamVjdCkgewogICAgICAgICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7CiAgICAgICAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7CiAgICAgICAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmVfc3RyZWFtX2R1cGxleCgpOwogICAgICAgIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7CiAgICAgICAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKQogICAgICAgICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTsKICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOwogICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlOwogICAgICAgIGlmIChvcHRpb25zKSB7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2OwogICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDsKICAgICAgICB9CiAgICAgICAgU3RyZWFtLmNhbGwodGhpcyk7CiAgICAgIH0KICAgICAgV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHsKICAgICAgICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7CiAgICAgICAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7CiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7CiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7CiAgICAgICAgdmFyIGVyOwogICAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkgewogICAgICAgICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAic3RyaW5nIiAmJiAhc3RhdGUub2JqZWN0TW9kZSkgewogICAgICAgICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoImNodW5rIiwgWyJzdHJpbmciLCAiQnVmZmVyIl0sIGNodW5rKTsKICAgICAgICB9CiAgICAgICAgaWYgKGVyKSB7CiAgICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgICAgV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikgewogICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CiAgICAgICAgdmFyIHJldCA9IGZhbHNlOwogICAgICAgIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspOwogICAgICAgIGlmIChpc0J1ZiAmJiAhQnVmZmVyMTAuaXNCdWZmZXIoY2h1bmspKSB7CiAgICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBjYiA9IGVuY29kaW5nOwogICAgICAgICAgZW5jb2RpbmcgPSBudWxsOwogICAgICAgIH0KICAgICAgICBpZiAoaXNCdWYpCiAgICAgICAgICBlbmNvZGluZyA9ICJidWZmZXIiOwogICAgICAgIGVsc2UgaWYgKCFlbmNvZGluZykKICAgICAgICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nOwogICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICJmdW5jdGlvbiIpCiAgICAgICAgICBjYiA9IG5vcDsKICAgICAgICBpZiAoc3RhdGUuZW5kaW5nKQogICAgICAgICAgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7CiAgICAgICAgZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkgewogICAgICAgICAgc3RhdGUucGVuZGluZ2NiKys7CiAgICAgICAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH07CiAgICAgIFdyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKzsKICAgICAgfTsKICAgICAgV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkgewogICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLmNvcmtlZCkgewogICAgICAgICAgc3RhdGUuY29ya2VkLS07CiAgICAgICAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpCiAgICAgICAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIFdyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIikKICAgICAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTsKICAgICAgICBpZiAoIShbImhleCIsICJ1dGY4IiwgInV0Zi04IiwgImFzY2lpIiwgImJpbmFyeSIsICJiYXNlNjQiLCAidWNzMiIsICJ1Y3MtMiIsICJ1dGYxNmxlIiwgInV0Zi0xNmxlIiwgInJhdyJdLmluZGV4T2YoKGVuY29kaW5nICsgIiIpLnRvTG93ZXJDYXNlKCkpID4gLTEpKQogICAgICAgICAgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTsKICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAid3JpdGFibGVCdWZmZXIiLCB7CiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHsKICAgICAgICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAic3RyaW5nIikgewogICAgICAgICAgY2h1bmsgPSBCdWZmZXIxMC5mcm9tKGNodW5rLCBlbmNvZGluZyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBjaHVuazsKICAgICAgfQogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwgewogICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyazsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgICAgICAgaWYgKCFpc0J1ZikgewogICAgICAgICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7CiAgICAgICAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7CiAgICAgICAgICAgIGlzQnVmID0gdHJ1ZTsKICAgICAgICAgICAgZW5jb2RpbmcgPSAiYnVmZmVyIjsKICAgICAgICAgICAgY2h1bmsgPSBuZXdDaHVuazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwogICAgICAgIHN0YXRlLmxlbmd0aCArPSBsZW47CiAgICAgICAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7CiAgICAgICAgaWYgKCFyZXQpCiAgICAgICAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlOwogICAgICAgIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkgewogICAgICAgICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0OwogICAgICAgICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHsKICAgICAgICAgICAgY2h1bmssCiAgICAgICAgICAgIGVuY29kaW5nLAogICAgICAgICAgICBpc0J1ZiwKICAgICAgICAgICAgY2FsbGJhY2s6IGNiLAogICAgICAgICAgICBuZXh0OiBudWxsCiAgICAgICAgICB9OwogICAgICAgICAgaWYgKGxhc3QpIHsKICAgICAgICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHsKICAgICAgICBzdGF0ZS53cml0ZWxlbiA9IGxlbjsKICAgICAgICBzdGF0ZS53cml0ZWNiID0gY2I7CiAgICAgICAgc3RhdGUud3JpdGluZyA9IHRydWU7CiAgICAgICAgc3RhdGUuc3luYyA9IHRydWU7CiAgICAgICAgaWYgKHN0YXRlLmRlc3Ryb3llZCkKICAgICAgICAgIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCJ3cml0ZSIpKTsKICAgICAgICBlbHNlIGlmICh3cml0ZXYpCiAgICAgICAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7CiAgICAgICAgZWxzZQogICAgICAgICAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpOwogICAgICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7CiAgICAgICAgLS1zdGF0ZS5wZW5kaW5nY2I7CiAgICAgICAgaWYgKHN5bmMpIHsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpOwogICAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CiAgICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY2IoZXIpOwogICAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CiAgICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsKICAgICAgICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHsKICAgICAgICBzdGF0ZS53cml0aW5nID0gZmFsc2U7CiAgICAgICAgc3RhdGUud3JpdGVjYiA9IG51bGw7CiAgICAgICAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuOwogICAgICAgIHN0YXRlLndyaXRlbGVuID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHsKICAgICAgICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7CiAgICAgICAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jOwogICAgICAgIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7CiAgICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gImZ1bmN0aW9uIikKICAgICAgICAgIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTsKICAgICAgICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpOwogICAgICAgIGlmIChlcikKICAgICAgICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpOwogICAgICAgIGVsc2UgewogICAgICAgICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDsKICAgICAgICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHsKICAgICAgICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3luYykgewogICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7CiAgICAgICAgaWYgKCFmaW5pc2hlZCkKICAgICAgICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTsKICAgICAgICBzdGF0ZS5wZW5kaW5nY2ItLTsKICAgICAgICBjYigpOwogICAgICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7CiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHsKICAgICAgICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlOwogICAgICAgICAgc3RyZWFtLmVtaXQoImRyYWluIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHsKICAgICAgICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTsKICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7CiAgICAgICAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHsKICAgICAgICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7CiAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpOwogICAgICAgICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTsKICAgICAgICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5OwogICAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTsKICAgICAgICAgIHdoaWxlIChlbnRyeSkgewogICAgICAgICAgICBidWZmZXJbY291bnRdID0gZW50cnk7CiAgICAgICAgICAgIGlmICghZW50cnkuaXNCdWYpCiAgICAgICAgICAgICAgYWxsQnVmZmVycyA9IGZhbHNlOwogICAgICAgICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7CiAgICAgICAgICAgIGNvdW50ICs9IDE7CiAgICAgICAgICB9CiAgICAgICAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7CiAgICAgICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAiIiwgaG9sZGVyLmZpbmlzaCk7CiAgICAgICAgICBzdGF0ZS5wZW5kaW5nY2IrKzsKICAgICAgICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOwogICAgICAgICAgaWYgKGhvbGRlci5uZXh0KSB7CiAgICAgICAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0OwogICAgICAgICAgICBob2xkZXIubmV4dCA9IG51bGw7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHdoaWxlIChlbnRyeSkgewogICAgICAgICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuazsKICAgICAgICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7CiAgICAgICAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrOwogICAgICAgICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7CiAgICAgICAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7CiAgICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDsKICAgICAgICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsKICAgICAgICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKGVudHJ5ID09PSBudWxsKQogICAgICAgICAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7CiAgICAgICAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOwogICAgICB9CiAgICAgIFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgICAgICAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCJfd3JpdGUoKSIpKTsKICAgICAgfTsKICAgICAgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsOwogICAgICBXcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikgewogICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgY2IgPSBjaHVuazsKICAgICAgICAgIGNodW5rID0gbnVsbDsKICAgICAgICAgIGVuY29kaW5nID0gbnVsbDsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgY2IgPSBlbmNvZGluZzsKICAgICAgICAgIGVuY29kaW5nID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB2b2lkIDApCiAgICAgICAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7CiAgICAgICAgaWYgKHN0YXRlLmNvcmtlZCkgewogICAgICAgICAgc3RhdGUuY29ya2VkID0gMTsKICAgICAgICAgIHRoaXMudW5jb3JrKCk7CiAgICAgICAgfQogICAgICAgIGlmICghc3RhdGUuZW5kaW5nKQogICAgICAgICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgIndyaXRhYmxlTGVuZ3RoIiwgewogICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHsKICAgICAgICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7CiAgICAgICAgc3RyZWFtLl9maW5hbChmdW5jdGlvbihlcnIpIHsKICAgICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tOwogICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7CiAgICAgICAgICBzdHJlYW0uZW1pdCgicHJlZmluaXNoIik7CiAgICAgICAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTsKICAgICAgICB9KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkgewogICAgICAgIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7CiAgICAgICAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICJmdW5jdGlvbiIgJiYgIXN0YXRlLmRlc3Ryb3llZCkgewogICAgICAgICAgICBzdGF0ZS5wZW5kaW5nY2IrKzsKICAgICAgICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlOwogICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7CiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCJwcmVmaW5pc2giKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkgewogICAgICAgIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7CiAgICAgICAgaWYgKG5lZWQpIHsKICAgICAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTsKICAgICAgICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHsKICAgICAgICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlOwogICAgICAgICAgICBzdHJlYW0uZW1pdCgiZmluaXNoIik7CiAgICAgICAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkgewogICAgICAgICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7CiAgICAgICAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gbmVlZDsKICAgICAgfQogICAgICBmdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikgewogICAgICAgIHN0YXRlLmVuZGluZyA9IHRydWU7CiAgICAgICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgaWYgKGNiKSB7CiAgICAgICAgICBpZiAoc3RhdGUuZmluaXNoZWQpCiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBzdHJlYW0ub25jZSgiZmluaXNoIiwgY2IpOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5lbmRlZCA9IHRydWU7CiAgICAgICAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikgewogICAgICAgIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7CiAgICAgICAgY29ya1JlcS5lbnRyeSA9IG51bGw7CiAgICAgICAgd2hpbGUgKGVudHJ5KSB7CiAgICAgICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjazsKICAgICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tOwogICAgICAgICAgY2IoZXJyKTsKICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDsKICAgICAgICB9CiAgICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxOwogICAgICB9CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICJkZXN0cm95ZWQiLCB7CiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDsKICAgICAgICB9LAogICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7CiAgICAgICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBXcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7CiAgICAgIFdyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95OwogICAgICBXcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIsIGNiKSB7CiAgICAgICAgY2IoZXJyKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcwogIHZhciByZXF1aXJlX3N0cmVhbV9kdXBsZXggPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmopIHsKICAgICAgICB2YXIga2V5czMgPSBbXTsKICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKQogICAgICAgICAga2V5czMucHVzaChrZXkpOwogICAgICAgIHJldHVybiBrZXlzMzsKICAgICAgfTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gRHVwbGV4OwogICAgICB2YXIgUmVhZGFibGUgPSByZXF1aXJlX3N0cmVhbV9yZWFkYWJsZSgpOwogICAgICB2YXIgV3JpdGFibGUgPSByZXF1aXJlX3N0cmVhbV93cml0YWJsZSgpOwogICAgICByZXF1aXJlX2luaGVyaXRzX2Jyb3dzZXIoKShEdXBsZXgsIFJlYWRhYmxlKTsKICAgICAgewogICAgICAgIGtleXMyID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpOwogICAgICAgIGZvciAodiA9IDA7IHYgPCBrZXlzMi5sZW5ndGg7IHYrKykgewogICAgICAgICAgbWV0aG9kID0ga2V5czJbdl07CiAgICAgICAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkKICAgICAgICAgICAgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciBrZXlzMjsKICAgICAgdmFyIG1ldGhvZDsKICAgICAgdmFyIHY7CiAgICAgIGZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7CiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpCiAgICAgICAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTsKICAgICAgICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpOwogICAgICAgIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7CiAgICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTsKICAgICAgICBpZiAob3B0aW9ucykgewogICAgICAgICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKQogICAgICAgICAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7CiAgICAgICAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpCiAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTsKICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlOwogICAgICAgICAgICB0aGlzLm9uY2UoImVuZCIsIG9uZW5kKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICJ3cml0YWJsZUhpZ2hXYXRlck1hcmsiLCB7CiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAid3JpdGFibGVCdWZmZXIiLCB7CiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAid3JpdGFibGVMZW5ndGgiLCB7CiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgZnVuY3Rpb24gb25lbmQoKSB7CiAgICAgICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpCiAgICAgICAgICByZXR1cm47CiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBvbkVuZE5UKHNlbGYyKSB7CiAgICAgICAgc2VsZjIuZW5kKCk7CiAgICAgIH0KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICJkZXN0cm95ZWQiLCB7CiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdm9pZCAwIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHZvaWQgMCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7CiAgICAgICAgfSwKICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgewogICAgICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHZvaWQgMCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB2b2lkIDApIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTsKICAgICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3NhZmUtYnVmZmVyQDUuMi4xL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcwogIHZhciByZXF1aXJlX3NhZmVfYnVmZmVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3NhZmUtYnVmZmVyQDUuMi4xL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgYnVmZmVyID0gcmVxdWlyZV9idWZmZXIoKTsKICAgICAgdmFyIEJ1ZmZlcjEwID0gYnVmZmVyLkJ1ZmZlcjsKICAgICAgZnVuY3Rpb24gY29weVByb3BzKHNyYywgZHN0KSB7CiAgICAgICAgZm9yICh2YXIga2V5IGluIHNyYykgewogICAgICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKEJ1ZmZlcjEwLmZyb20gJiYgQnVmZmVyMTAuYWxsb2MgJiYgQnVmZmVyMTAuYWxsb2NVbnNhZmUgJiYgQnVmZmVyMTAuYWxsb2NVbnNhZmVTbG93KSB7CiAgICAgICAgbW9kdWxlMi5leHBvcnRzID0gYnVmZmVyOwogICAgICB9IGVsc2UgewogICAgICAgIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMyKTsKICAgICAgICBleHBvcnRzMi5CdWZmZXIgPSBTYWZlQnVmZmVyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIFNhZmVCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gQnVmZmVyMTAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIFNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIxMC5wcm90b3R5cGUpOwogICAgICBjb3B5UHJvcHMoQnVmZmVyMTAsIFNhZmVCdWZmZXIpOwogICAgICBTYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAibnVtYmVyIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXIiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgfTsKICAgICAgU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKHR5cGVvZiBzaXplICE9PSAibnVtYmVyIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlciIpOwogICAgICAgIH0KICAgICAgICB2YXIgYnVmID0gQnVmZmVyMTAoc2l6ZSk7CiAgICAgICAgaWYgKGZpbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYnVmLmZpbGwoZmlsbCk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJ1Zi5maWxsKDApOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9OwogICAgICBTYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24oc2l6ZSkgewogICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwKHNpemUpOwogICAgICB9OwogICAgICBTYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uKHNpemUpIHsKICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3N0cmluZ19kZWNvZGVyQDEuMy4wL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMKICB2YXIgcmVxdWlyZV9zdHJpbmdfZGVjb2RlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9zdHJpbmdfZGVjb2RlckAxLjMuMC9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIEJ1ZmZlcjEwID0gcmVxdWlyZV9zYWZlX2J1ZmZlcigpLkJ1ZmZlcjsKICAgICAgdmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIxMC5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7CiAgICAgICAgZW5jb2RpbmcgPSAiIiArIGVuY29kaW5nOwogICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkgewogICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgY2FzZSAicmF3IjoKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9OwogICAgICBmdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7CiAgICAgICAgaWYgKCFlbmMpCiAgICAgICAgICByZXR1cm4gInV0ZjgiOwogICAgICAgIHZhciByZXRyaWVkOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuYykgewogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiAidXRmOCI7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuICJ1dGYxNmxlIjsKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gImxhdGluMSI7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gZW5jOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmIChyZXRyaWVkKQogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgIGVuYyA9ICgiIiArIGVuYykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICByZXRyaWVkID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7CiAgICAgICAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTsKICAgICAgICBpZiAodHlwZW9mIG5lbmMgIT09ICJzdHJpbmciICYmIChCdWZmZXIxMC5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKQogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jKTsKICAgICAgICByZXR1cm4gbmVuYyB8fCBlbmM7CiAgICAgIH0KICAgICAgZXhwb3J0czIuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7CiAgICAgIGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHsKICAgICAgICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpOwogICAgICAgIHZhciBuYjsKICAgICAgICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHsKICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7CiAgICAgICAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7CiAgICAgICAgICAgIG5iID0gNDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDsKICAgICAgICAgICAgbmIgPSA0OwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7CiAgICAgICAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kOwogICAgICAgICAgICBuYiA9IDM7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlOwogICAgICAgICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICB0aGlzLmxhc3ROZWVkID0gMDsKICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDA7CiAgICAgICAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlcjEwLmFsbG9jVW5zYWZlKG5iKTsKICAgICAgfQogICAgICBTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZikgewogICAgICAgIGlmIChidWYubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIHZhciByOwogICAgICAgIHZhciBpOwogICAgICAgIGlmICh0aGlzLmxhc3ROZWVkKSB7CiAgICAgICAgICByID0gdGhpcy5maWxsTGFzdChidWYpOwogICAgICAgICAgaWYgKHIgPT09IHZvaWQgMCkKICAgICAgICAgICAgcmV0dXJuICIiOwogICAgICAgICAgaSA9IHRoaXMubGFzdE5lZWQ7CiAgICAgICAgICB0aGlzLmxhc3ROZWVkID0gMDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaSA9IDA7CiAgICAgICAgfQogICAgICAgIGlmIChpIDwgYnVmLmxlbmd0aCkKICAgICAgICAgIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7CiAgICAgICAgcmV0dXJuIHIgfHwgIiI7CiAgICAgIH07CiAgICAgIFN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7CiAgICAgIFN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDsKICAgICAgU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbihidWYpIHsKICAgICAgICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7CiAgICAgICAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpOwogICAgICAgICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpOwogICAgICAgIH0KICAgICAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpOwogICAgICAgIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7CiAgICAgICAgaWYgKGJ5dGUgPD0gMTI3KQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSA2KQogICAgICAgICAgcmV0dXJuIDI7CiAgICAgICAgZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAxNCkKICAgICAgICAgIHJldHVybiAzOwogICAgICAgIGVsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMzApCiAgICAgICAgICByZXR1cm4gNDsKICAgICAgICByZXR1cm4gYnl0ZSA+PiA2ID09PSAyID8gLTEgOiAtMjsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYyLCBidWYsIGkpIHsKICAgICAgICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxOwogICAgICAgIGlmIChqIDwgaSkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTsKICAgICAgICBpZiAobmIgPj0gMCkgewogICAgICAgICAgaWYgKG5iID4gMCkKICAgICAgICAgICAgc2VsZjIubGFzdE5lZWQgPSBuYiAtIDE7CiAgICAgICAgICByZXR1cm4gbmI7CiAgICAgICAgfQogICAgICAgIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pOwogICAgICAgIGlmIChuYiA+PSAwKSB7CiAgICAgICAgICBpZiAobmIgPiAwKQogICAgICAgICAgICBzZWxmMi5sYXN0TmVlZCA9IG5iIC0gMjsKICAgICAgICAgIHJldHVybiBuYjsKICAgICAgICB9CiAgICAgICAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7CiAgICAgICAgaWYgKG5iID49IDApIHsKICAgICAgICAgIGlmIChuYiA+IDApIHsKICAgICAgICAgICAgaWYgKG5iID09PSAyKQogICAgICAgICAgICAgIG5iID0gMDsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIHNlbGYyLmxhc3ROZWVkID0gbmIgLSAzOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG5iOwogICAgICAgIH0KICAgICAgICByZXR1cm4gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYyLCBidWYsIHApIHsKICAgICAgICBpZiAoKGJ1ZlswXSAmIDE5MikgIT09IDEyOCkgewogICAgICAgICAgc2VsZjIubGFzdE5lZWQgPSAwOwogICAgICAgICAgcmV0dXJuICJcdUZGRkQiOwogICAgICAgIH0KICAgICAgICBpZiAoc2VsZjIubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7CiAgICAgICAgICBpZiAoKGJ1ZlsxXSAmIDE5MikgIT09IDEyOCkgewogICAgICAgICAgICBzZWxmMi5sYXN0TmVlZCA9IDE7CiAgICAgICAgICAgIHJldHVybiAiXHVGRkZEIjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzZWxmMi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHsKICAgICAgICAgICAgaWYgKChidWZbMl0gJiAxOTIpICE9PSAxMjgpIHsKICAgICAgICAgICAgICBzZWxmMi5sYXN0TmVlZCA9IDI7CiAgICAgICAgICAgICAgcmV0dXJuICJcdUZGRkQiOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHsKICAgICAgICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDsKICAgICAgICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTsKICAgICAgICBpZiAociAhPT0gdm9pZCAwKQogICAgICAgICAgcmV0dXJuIHI7CiAgICAgICAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkgewogICAgICAgICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7CiAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7CiAgICAgICAgfQogICAgICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpOwogICAgICAgIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHsKICAgICAgICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7CiAgICAgICAgaWYgKCF0aGlzLmxhc3ROZWVkKQogICAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygidXRmOCIsIGkpOwogICAgICAgIHRoaXMubGFzdFRvdGFsID0gdG90YWw7CiAgICAgICAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTsKICAgICAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpOwogICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoInV0ZjgiLCBpLCBlbmQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7CiAgICAgICAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICIiOwogICAgICAgIGlmICh0aGlzLmxhc3ROZWVkKQogICAgICAgICAgcmV0dXJuIHIgKyAiXHVGRkZEIjsKICAgICAgICByZXR1cm4gcjsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7CiAgICAgICAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7CiAgICAgICAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygidXRmMTZsZSIsIGkpOwogICAgICAgICAgaWYgKHIpIHsKICAgICAgICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTsKICAgICAgICAgICAgaWYgKGMgPj0gNTUyOTYgJiYgYyA8PSA1NjMxOSkgewogICAgICAgICAgICAgIHRoaXMubGFzdE5lZWQgPSAyOwogICAgICAgICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDsKICAgICAgICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTsKICAgICAgICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICAgICAgICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByOwogICAgICAgIH0KICAgICAgICB0aGlzLmxhc3ROZWVkID0gMTsKICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDI7CiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07CiAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygidXRmMTZsZSIsIGksIGJ1Zi5sZW5ndGggLSAxKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGYxNkVuZChidWYpIHsKICAgICAgICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogIiI7CiAgICAgICAgaWYgKHRoaXMubGFzdE5lZWQpIHsKICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7CiAgICAgICAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoInV0ZjE2bGUiLCAwLCBlbmQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkgewogICAgICAgIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7CiAgICAgICAgaWYgKG4gPT09IDApCiAgICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCJiYXNlNjQiLCBpKTsKICAgICAgICB0aGlzLmxhc3ROZWVkID0gMyAtIG47CiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSAzOwogICAgICAgIGlmIChuID09PSAxKSB7CiAgICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07CiAgICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygiYmFzZTY0IiwgaSwgYnVmLmxlbmd0aCAtIG4pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHsKICAgICAgICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogIiI7CiAgICAgICAgaWYgKHRoaXMubGFzdE5lZWQpCiAgICAgICAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoImJhc2U2NCIsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTsKICAgICAgICByZXR1cm4gcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHsKICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHsKICAgICAgICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAiIjsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcwogIHZhciByZXF1aXJlX2VuZF9vZl9zdHJlYW0gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSA9IHJlcXVpcmVfZXJyb3JzX2Jyb3dzZXIoKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTsKICAgICAgZnVuY3Rpb24gb25jZShjYWxsYmFjaykgewogICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTsKICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgICAgICBpZiAoY2FsbGVkKQogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICBjYWxsZWQgPSB0cnVlOwogICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7CiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07CiAgICAgICAgICB9CiAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG5vb3AoKSB7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkgewogICAgICAgIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICJmdW5jdGlvbiI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHsKICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7CiAgICAgICAgaWYgKCFvcHRzKQogICAgICAgICAgb3B0cyA9IHt9OwogICAgICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgICAgICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTsKICAgICAgICB2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZTsKICAgICAgICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaDIoKSB7CiAgICAgICAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkKICAgICAgICAgICAgb25maW5pc2goKTsKICAgICAgICB9OwogICAgICAgIHZhciB3cml0YWJsZUVuZGVkID0gc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZDsKICAgICAgICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaDIoKSB7CiAgICAgICAgICB3cml0YWJsZSA9IGZhbHNlOwogICAgICAgICAgd3JpdGFibGVFbmRlZCA9IHRydWU7CiAgICAgICAgICBpZiAoIXJlYWRhYmxlKQogICAgICAgICAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSk7CiAgICAgICAgfTsKICAgICAgICB2YXIgcmVhZGFibGVFbmRlZCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDsKICAgICAgICB2YXIgb25lbmQgPSBmdW5jdGlvbiBvbmVuZDIoKSB7CiAgICAgICAgICByZWFkYWJsZSA9IGZhbHNlOwogICAgICAgICAgcmVhZGFibGVFbmRlZCA9IHRydWU7CiAgICAgICAgICBpZiAoIXdyaXRhYmxlKQogICAgICAgICAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSk7CiAgICAgICAgfTsKICAgICAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IyKGVycikgewogICAgICAgICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7CiAgICAgICAgfTsKICAgICAgICB2YXIgb25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UyKCkgewogICAgICAgICAgdmFyIGVycjsKICAgICAgICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkgewogICAgICAgICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKQogICAgICAgICAgICAgIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpOwogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAod3JpdGFibGUgJiYgIXdyaXRhYmxlRW5kZWQpIHsKICAgICAgICAgICAgaWYgKCFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkKICAgICAgICAgICAgICBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgdmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uIG9ucmVxdWVzdDIoKSB7CiAgICAgICAgICBzdHJlYW0ucmVxLm9uKCJmaW5pc2giLCBvbmZpbmlzaCk7CiAgICAgICAgfTsKICAgICAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHsKICAgICAgICAgIHN0cmVhbS5vbigiY29tcGxldGUiLCBvbmZpbmlzaCk7CiAgICAgICAgICBzdHJlYW0ub24oImFib3J0Iiwgb25jbG9zZSk7CiAgICAgICAgICBpZiAoc3RyZWFtLnJlcSkKICAgICAgICAgICAgb25yZXF1ZXN0KCk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHN0cmVhbS5vbigicmVxdWVzdCIsIG9ucmVxdWVzdCk7CiAgICAgICAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7CiAgICAgICAgICBzdHJlYW0ub24oImVuZCIsIG9ubGVnYWN5ZmluaXNoKTsKICAgICAgICAgIHN0cmVhbS5vbigiY2xvc2UiLCBvbmxlZ2FjeWZpbmlzaCk7CiAgICAgICAgfQogICAgICAgIHN0cmVhbS5vbigiZW5kIiwgb25lbmQpOwogICAgICAgIHN0cmVhbS5vbigiZmluaXNoIiwgb25maW5pc2gpOwogICAgICAgIGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkKICAgICAgICAgIHN0cmVhbS5vbigiZXJyb3IiLCBvbmVycm9yKTsKICAgICAgICBzdHJlYW0ub24oImNsb3NlIiwgb25jbG9zZSk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCJjb21wbGV0ZSIsIG9uZmluaXNoKTsKICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigiYWJvcnQiLCBvbmNsb3NlKTsKICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigicmVxdWVzdCIsIG9ucmVxdWVzdCk7CiAgICAgICAgICBpZiAoc3RyZWFtLnJlcSkKICAgICAgICAgICAgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcigiZmluaXNoIiwgb25maW5pc2gpOwogICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCJlbmQiLCBvbmxlZ2FjeWZpbmlzaCk7CiAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoImNsb3NlIiwgb25sZWdhY3lmaW5pc2gpOwogICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCJmaW5pc2giLCBvbmZpbmlzaCk7CiAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoImVuZCIsIG9uZW5kKTsKICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigiZXJyb3IiLCBvbmVycm9yKTsKICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigiY2xvc2UiLCBvbmNsb3NlKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGVvczsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzCiAgdmFyIHJlcXVpcmVfYXN5bmNfaXRlcmF0b3IgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3IuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX09iamVjdCRzZXRQcm90b3R5cGVPOwogICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7CiAgICAgICAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsKICAgICAgICBpZiAoa2V5IGluIG9iaikgewogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgewogICAgICAgIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCAic3RyaW5nIik7CiAgICAgICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICJzeW1ib2wiID8ga2V5IDogU3RyaW5nKGtleSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7CiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gIm9iamVjdCIgfHwgaW5wdXQgPT09IG51bGwpCiAgICAgICAgICByZXR1cm4gaW5wdXQ7CiAgICAgICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOwogICAgICAgIGlmIChwcmltICE9PSB2b2lkIDApIHsKICAgICAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgImRlZmF1bHQiKTsKICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAib2JqZWN0IikKICAgICAgICAgICAgcmV0dXJuIHJlczsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiAoaGludCA9PT0gInN0cmluZyIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsKICAgICAgfQogICAgICB2YXIgZmluaXNoZWQgPSByZXF1aXJlX2VuZF9vZl9zdHJlYW0oKTsKICAgICAgdmFyIGtMYXN0UmVzb2x2ZSA9IFN5bWJvbCgibGFzdFJlc29sdmUiKTsKICAgICAgdmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCJsYXN0UmVqZWN0Iik7CiAgICAgIHZhciBrRXJyb3IgPSBTeW1ib2woImVycm9yIik7CiAgICAgIHZhciBrRW5kZWQgPSBTeW1ib2woImVuZGVkIik7CiAgICAgIHZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woImxhc3RQcm9taXNlIik7CiAgICAgIHZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgiaGFuZGxlUHJvbWlzZSIpOwogICAgICB2YXIga1N0cmVhbSA9IFN5bWJvbCgic3RyZWFtIik7CiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgdmFsdWUsCiAgICAgICAgICBkb25lCiAgICAgICAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiByZWFkQW5kUmVzb2x2ZShpdGVyKSB7CiAgICAgICAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07CiAgICAgICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHsKICAgICAgICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7CiAgICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbCkgewogICAgICAgICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsOwogICAgICAgICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsOwogICAgICAgICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7CiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHsKICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikgewogICAgICAgIHJldHVybiBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHsKICAgICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodm9pZCAwLCB0cnVlKSk7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7CiAgICAgICAgICB9LCByZWplY3QpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgdmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24oKSB7CiAgICAgIH0pOwogICAgICB2YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7CiAgICAgICAgZ2V0IHN0cmVhbSgpIHsKICAgICAgICAgIHJldHVybiB0aGlzW2tTdHJlYW1dOwogICAgICAgIH0sCiAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHsKICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7CiAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07CiAgICAgICAgICBpZiAoZXJyb3IgIT09IG51bGwpIHsKICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzW2tFbmRlZF0pIHsKICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHZvaWQgMCwgdHJ1ZSkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXNba1N0cmVhbV0uZGVzdHJveWVkKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHsKICAgICAgICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHZvaWQgMCwgdHJ1ZSkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBsYXN0UHJvbWlzZSA9IHRoaXNba0xhc3RQcm9taXNlXTsKICAgICAgICAgIHZhciBwcm9taXNlOwogICAgICAgICAgaWYgKGxhc3RQcm9taXNlKSB7CiAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTsKICAgICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHsKICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pOwogICAgICAgICAgfQogICAgICAgICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTsKICAgICAgICAgIHJldHVybiBwcm9taXNlOwogICAgICAgIH0KICAgICAgfSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgInJldHVybiIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7CiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7CiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICByZWplY3QoZXJyKTsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHZvaWQgMCwgdHJ1ZSkpOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgIH0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTsKICAgICAgdmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjIoc3RyZWFtKSB7CiAgICAgICAgdmFyIF9PYmplY3QkY3JlYXRlOwogICAgICAgIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7CiAgICAgICAgICB2YWx1ZTogc3RyZWFtLAogICAgICAgICAgd3JpdGFibGU6IHRydWUKICAgICAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHsKICAgICAgICAgIHZhbHVlOiBudWxsLAogICAgICAgICAgd3JpdGFibGU6IHRydWUKICAgICAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwgewogICAgICAgICAgdmFsdWU6IG51bGwsCiAgICAgICAgICB3cml0YWJsZTogdHJ1ZQogICAgICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwgewogICAgICAgICAgdmFsdWU6IG51bGwsCiAgICAgICAgICB3cml0YWJsZTogdHJ1ZQogICAgICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwgewogICAgICAgICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLAogICAgICAgICAgd3JpdGFibGU6IHRydWUKICAgICAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwgewogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdG9yW2tTdHJlYW1dLnJlYWQoKTsKICAgICAgICAgICAgaWYgKGRhdGEpIHsKICAgICAgICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDsKICAgICAgICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDsKICAgICAgICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsOwogICAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlOwogICAgICAgICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDsKICAgICAgICAgICAgfQogICAgICAgICAgfSwKICAgICAgICAgIHdyaXRhYmxlOiB0cnVlCiAgICAgICAgfSksIF9PYmplY3QkY3JlYXRlKSk7CiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7CiAgICAgICAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbihlcnIpIHsKICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICJFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSIpIHsKICAgICAgICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsKICAgICAgICAgICAgaWYgKHJlamVjdCAhPT0gbnVsbCkgewogICAgICAgICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsOwogICAgICAgICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsOwogICAgICAgICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7CiAgICAgICAgICAgICAgcmVqZWN0KGVycik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdOwogICAgICAgICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHsKICAgICAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7CiAgICAgICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsOwogICAgICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsOwogICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodm9pZCAwLCB0cnVlKSk7CiAgICAgICAgICB9CiAgICAgICAgICBpdGVyYXRvcltrRW5kZWRdID0gdHJ1ZTsKICAgICAgICB9KTsKICAgICAgICBzdHJlYW0ub24oInJlYWRhYmxlIiwgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yOwogICAgICB9OwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMKICB2YXIgcmVxdWlyZV9mcm9tX2Jyb3dzZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZnJvbS1icm93c2VyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiUmVhZGFibGUuZnJvbSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyIik7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcwogIHZhciByZXF1aXJlX3N0cmVhbV9yZWFkYWJsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFJlYWRhYmxlOwogICAgICB2YXIgRHVwbGV4OwogICAgICBSZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTsKICAgICAgdmFyIEVFID0gcmVxdWlyZV9ldmVudHMoKS5FdmVudEVtaXR0ZXI7CiAgICAgIHZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQyKGVtaXR0ZXIsIHR5cGUpIHsKICAgICAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoOwogICAgICB9OwogICAgICB2YXIgU3RyZWFtID0gcmVxdWlyZV9zdHJlYW1fYnJvd3NlcigpOwogICAgICB2YXIgQnVmZmVyMTAgPSByZXF1aXJlX2J1ZmZlcigpLkJ1ZmZlcjsKICAgICAgdmFyIE91clVpbnQ4QXJyYXkgPSAodHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB7fSkuVWludDhBcnJheSB8fCBmdW5jdGlvbigpIHsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykgewogICAgICAgIHJldHVybiBCdWZmZXIxMC5mcm9tKGNodW5rKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikgewogICAgICAgIHJldHVybiBCdWZmZXIxMC5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7CiAgICAgIH0KICAgICAgdmFyIGRlYnVnVXRpbCA9IHJlcXVpcmVfdXRpbCgpOwogICAgICB2YXIgZGVidWc7CiAgICAgIGlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7CiAgICAgICAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coInN0cmVhbSIpOwogICAgICB9IGVsc2UgewogICAgICAgIGRlYnVnID0gZnVuY3Rpb24gZGVidWcyKCkgewogICAgICAgIH07CiAgICAgIH0KICAgICAgdmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlX2J1ZmZlcl9saXN0KCk7CiAgICAgIHZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmVfZGVzdHJveSgpOwogICAgICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlX3N0YXRlKCk7CiAgICAgIHZhciBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyazsKICAgICAgdmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZV9lcnJvcnNfYnJvd3NlcigpLmNvZGVzOwogICAgICB2YXIgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRTsKICAgICAgdmFyIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GOwogICAgICB2YXIgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRDsKICAgICAgdmFyIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UOwogICAgICB2YXIgU3RyaW5nRGVjb2RlcjsKICAgICAgdmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsKICAgICAgdmFyIGZyb207CiAgICAgIHJlcXVpcmVfaW5oZXJpdHNfYnJvd3NlcigpKFJlYWRhYmxlLCBTdHJlYW0pOwogICAgICB2YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTsKICAgICAgdmFyIGtQcm94eUV2ZW50cyA9IFsiZXJyb3IiLCAiY2xvc2UiLCAiZGVzdHJveSIsICJwYXVzZSIsICJyZXN1bWUiXTsKICAgICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikgewogICAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsKICAgICAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkKICAgICAgICAgIGVtaXR0ZXIub24oZXZlbnQsIGZuKTsKICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKQogICAgICAgICAgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTsKICAgICAgICBlbHNlCiAgICAgICAgICBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHsKICAgICAgICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZV9zdHJlYW1fZHVwbGV4KCk7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gImJvb2xlYW4iKQogICAgICAgICAgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7CiAgICAgICAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7CiAgICAgICAgaWYgKGlzRHVwbGV4KQogICAgICAgICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7CiAgICAgICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwgaXNEdXBsZXgpOwogICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTsKICAgICAgICB0aGlzLmxlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5waXBlcyA9IG51bGw7CiAgICAgICAgdGhpcy5waXBlc0NvdW50ID0gMDsKICAgICAgICB0aGlzLmZsb3dpbmcgPSBudWxsOwogICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsKICAgICAgICB0aGlzLnN5bmMgPSB0cnVlOwogICAgICAgIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7CiAgICAgICAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKICAgICAgICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7CiAgICAgICAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7CiAgICAgICAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7CiAgICAgICAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsKICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOwogICAgICAgIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgInV0ZjgiOwogICAgICAgIHRoaXMuYXdhaXREcmFpbiA9IDA7CiAgICAgICAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlOwogICAgICAgIHRoaXMuZGVjb2RlciA9IG51bGw7CiAgICAgICAgdGhpcy5lbmNvZGluZyA9IG51bGw7CiAgICAgICAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHsKICAgICAgICAgIGlmICghU3RyaW5nRGVjb2RlcikKICAgICAgICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmVfc3RyaW5nX2RlY29kZXIoKS5TdHJpbmdEZWNvZGVyOwogICAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7CiAgICAgICAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZzsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykgewogICAgICAgIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlX3N0cmVhbV9kdXBsZXgoKTsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKQogICAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsKICAgICAgICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4OwogICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7CiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7CiAgICAgICAgaWYgKG9wdGlvbnMpIHsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAiZnVuY3Rpb24iKQogICAgICAgICAgICB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkOwogICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7CiAgICAgICAgfQogICAgICAgIFN0cmVhbS5jYWxsKHRoaXMpOwogICAgICB9CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICJkZXN0cm95ZWQiLCB7CiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDsKICAgICAgICB9LAogICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7CiAgICAgICAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBSZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95OwogICAgICBSZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIsIGNiKSB7CiAgICAgICAgY2IoZXJyKTsKICAgICAgfTsKICAgICAgUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHsKICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogICAgICAgIHZhciBza2lwQ2h1bmtDaGVjazsKICAgICAgICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHsKICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nOwogICAgICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7CiAgICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIxMC5mcm9tKGNodW5rLCBlbmNvZGluZyk7CiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAiIjsKICAgICAgICAgICAgfQogICAgICAgICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spOwogICAgICB9OwogICAgICBSZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7CiAgICAgICAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHsKICAgICAgICBkZWJ1ZygicmVhZGFibGVBZGRDaHVuayIsIGNodW5rKTsKICAgICAgICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgaWYgKGNodW5rID09PSBudWxsKSB7CiAgICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7CiAgICAgICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgZXI7CiAgICAgICAgICBpZiAoIXNraXBDaHVua0NoZWNrKQogICAgICAgICAgICBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspOwogICAgICAgICAgaWYgKGVyKSB7CiAgICAgICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpOwogICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gInN0cmluZyIgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyMTAucHJvdG90eXBlKSB7CiAgICAgICAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgewogICAgICAgICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKQogICAgICAgICAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTsKICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHsKICAgICAgICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpOwogICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7CiAgICAgICAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7CiAgICAgICAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKQogICAgICAgICAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpOwogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkgewogICAgICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7CiAgICAgICAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkgewogICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykgewogICAgICAgICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7CiAgICAgICAgICBzdHJlYW0uZW1pdCgiZGF0YSIsIGNodW5rKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwogICAgICAgICAgaWYgKGFkZFRvRnJvbnQpCiAgICAgICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspOwogICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkKICAgICAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7CiAgICAgICAgfQogICAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykgewogICAgICAgIHZhciBlcjsKICAgICAgICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gInN0cmluZyIgJiYgY2h1bmsgIT09IHZvaWQgMCAmJiAhc3RhdGUub2JqZWN0TW9kZSkgewogICAgICAgICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoImNodW5rIiwgWyJzdHJpbmciLCAiQnVmZmVyIiwgIlVpbnQ4QXJyYXkiXSwgY2h1bmspOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZXI7CiAgICAgIH0KICAgICAgUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7CiAgICAgIH07CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykgewogICAgICAgIGlmICghU3RyaW5nRGVjb2RlcikKICAgICAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlX3N0cmluZ19kZWNvZGVyKCkuU3RyaW5nRGVjb2RlcjsKICAgICAgICB2YXIgZGVjb2RlcjIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpOwogICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXIyOwogICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7CiAgICAgICAgdmFyIHAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5oZWFkOwogICAgICAgIHZhciBjb250ZW50ID0gIiI7CiAgICAgICAgd2hpbGUgKHAgIT09IG51bGwpIHsKICAgICAgICAgIGNvbnRlbnQgKz0gZGVjb2RlcjIud3JpdGUocC5kYXRhKTsKICAgICAgICAgIHAgPSBwLm5leHQ7CiAgICAgICAgfQogICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7CiAgICAgICAgaWYgKGNvbnRlbnQgIT09ICIiKQogICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTsKICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICB2YXIgTUFYX0hXTSA9IDEwNzM3NDE4MjQ7CiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHsKICAgICAgICBpZiAobiA+PSBNQVhfSFdNKSB7CiAgICAgICAgICBuID0gTUFYX0hXTTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbi0tOwogICAgICAgICAgbiB8PSBuID4+PiAxOwogICAgICAgICAgbiB8PSBuID4+PiAyOwogICAgICAgICAgbiB8PSBuID4+PiA0OwogICAgICAgICAgbiB8PSBuID4+PiA4OwogICAgICAgICAgbiB8PSBuID4+PiAxNjsKICAgICAgICAgIG4rKzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkgewogICAgICAgIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUpCiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICBpZiAobiAhPT0gbikgewogICAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKQogICAgICAgICAgICByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykKICAgICAgICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTsKICAgICAgICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpCiAgICAgICAgICByZXR1cm4gbjsKICAgICAgICBpZiAoIXN0YXRlLmVuZGVkKSB7CiAgICAgICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7CiAgICAgIH0KICAgICAgUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7CiAgICAgICAgZGVidWcoInJlYWQiLCBuKTsKICAgICAgICBuID0gcGFyc2VJbnQobiwgMTApOwogICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgdmFyIG5PcmlnID0gbjsKICAgICAgICBpZiAobiAhPT0gMCkKICAgICAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOwogICAgICAgIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkgewogICAgICAgICAgZGVidWcoInJlYWQ6IGVtaXRSZWFkYWJsZSIsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpOwogICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkKICAgICAgICAgICAgZW5kUmVhZGFibGUodGhpcyk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTsKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KICAgICAgICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7CiAgICAgICAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHsKICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApCiAgICAgICAgICAgIGVuZFJlYWRhYmxlKHRoaXMpOwogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfQogICAgICAgIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7CiAgICAgICAgZGVidWcoIm5lZWQgcmVhZGFibGUiLCBkb1JlYWQpOwogICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHsKICAgICAgICAgIGRvUmVhZCA9IHRydWU7CiAgICAgICAgICBkZWJ1ZygibGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsiLCBkb1JlYWQpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykgewogICAgICAgICAgZG9SZWFkID0gZmFsc2U7CiAgICAgICAgICBkZWJ1ZygicmVhZGluZyBvciBlbmRlZCIsIGRvUmVhZCk7CiAgICAgICAgfSBlbHNlIGlmIChkb1JlYWQpIHsKICAgICAgICAgIGRlYnVnKCJkbyByZWFkIik7CiAgICAgICAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTsKICAgICAgICAgIHN0YXRlLnN5bmMgPSB0cnVlOwogICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkKICAgICAgICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsKICAgICAgICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7CiAgICAgICAgICBzdGF0ZS5zeW5jID0gZmFsc2U7CiAgICAgICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpCiAgICAgICAgICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7CiAgICAgICAgfQogICAgICAgIHZhciByZXQ7CiAgICAgICAgaWYgKG4gPiAwKQogICAgICAgICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpOwogICAgICAgIGVsc2UKICAgICAgICAgIHJldCA9IG51bGw7CiAgICAgICAgaWYgKHJldCA9PT0gbnVsbCkgewogICAgICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7CiAgICAgICAgICBuID0gMDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RhdGUubGVuZ3RoIC09IG47CiAgICAgICAgICBzdGF0ZS5hd2FpdERyYWluID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgaWYgKCFzdGF0ZS5lbmRlZCkKICAgICAgICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsKICAgICAgICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkKICAgICAgICAgICAgZW5kUmVhZGFibGUodGhpcyk7CiAgICAgICAgfQogICAgICAgIGlmIChyZXQgIT09IG51bGwpCiAgICAgICAgICB0aGlzLmVtaXQoImRhdGEiLCByZXQpOwogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkgewogICAgICAgIGRlYnVnKCJvbkVvZkNodW5rIik7CiAgICAgICAgaWYgKHN0YXRlLmVuZGVkKQogICAgICAgICAgcmV0dXJuOwogICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyKSB7CiAgICAgICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpOwogICAgICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgewogICAgICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7CiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc3RhdGUuZW5kZWQgPSB0cnVlOwogICAgICAgIGlmIChzdGF0ZS5zeW5jKSB7CiAgICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7CiAgICAgICAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkgewogICAgICAgICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlOwogICAgICAgICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHsKICAgICAgICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgZGVidWcoImVtaXRSZWFkYWJsZSIsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTsKICAgICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTsKICAgICAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkgewogICAgICAgICAgZGVidWcoImVtaXRSZWFkYWJsZSIsIHN0YXRlLmZsb3dpbmcpOwogICAgICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHsKICAgICAgICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgZGVidWcoImVtaXRSZWFkYWJsZV8iLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpOwogICAgICAgIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7CiAgICAgICAgICBzdHJlYW0uZW1pdCgicmVhZGFibGUiKTsKICAgICAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7CiAgICAgICAgZmxvdyhzdHJlYW0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkgewogICAgICAgIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHsKICAgICAgICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7CiAgICAgICAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHsKICAgICAgICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICBkZWJ1ZygibWF5YmVSZWFkTW9yZSByZWFkIDAiKTsKICAgICAgICAgIHN0cmVhbS5yZWFkKDApOwogICAgICAgICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKQogICAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTsKICAgICAgfQogICAgICBSZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7CiAgICAgICAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCJfcmVhZCgpIikpOwogICAgICB9OwogICAgICBSZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7CiAgICAgICAgdmFyIHNyYyA9IHRoaXM7CiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICAgICAgICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHsKICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgc3RhdGUucGlwZXMgPSBkZXN0OwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7CiAgICAgICAgZGVidWcoInBpcGUgY291bnQ9JWQgb3B0cz0laiIsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTsKICAgICAgICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyOwogICAgICAgIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7CiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpCiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTsKICAgICAgICBlbHNlCiAgICAgICAgICBzcmMub25jZSgiZW5kIiwgZW5kRm4pOwogICAgICAgIGRlc3Qub24oInVucGlwZSIsIG9udW5waXBlKTsKICAgICAgICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykgewogICAgICAgICAgZGVidWcoIm9udW5waXBlIik7CiAgICAgICAgICBpZiAocmVhZGFibGUgPT09IHNyYykgewogICAgICAgICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTsKICAgICAgICAgICAgICBjbGVhbnVwKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gb25lbmQoKSB7CiAgICAgICAgICBkZWJ1Zygib25lbmQiKTsKICAgICAgICAgIGRlc3QuZW5kKCk7CiAgICAgICAgfQogICAgICAgIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTsKICAgICAgICBkZXN0Lm9uKCJkcmFpbiIsIG9uZHJhaW4pOwogICAgICAgIHZhciBjbGVhbmVkVXAgPSBmYWxzZTsKICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkgewogICAgICAgICAgZGVidWcoImNsZWFudXAiKTsKICAgICAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoImNsb3NlIiwgb25jbG9zZSk7CiAgICAgICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCJmaW5pc2giLCBvbmZpbmlzaCk7CiAgICAgICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCJkcmFpbiIsIG9uZHJhaW4pOwogICAgICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigiZXJyb3IiLCBvbmVycm9yKTsKICAgICAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoInVucGlwZSIsIG9udW5waXBlKTsKICAgICAgICAgIHNyYy5yZW1vdmVMaXN0ZW5lcigiZW5kIiwgb25lbmQpOwogICAgICAgICAgc3JjLnJlbW92ZUxpc3RlbmVyKCJlbmQiLCB1bnBpcGUpOwogICAgICAgICAgc3JjLnJlbW92ZUxpc3RlbmVyKCJkYXRhIiwgb25kYXRhKTsKICAgICAgICAgIGNsZWFuZWRVcCA9IHRydWU7CiAgICAgICAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKQogICAgICAgICAgICBvbmRyYWluKCk7CiAgICAgICAgfQogICAgICAgIHNyYy5vbigiZGF0YSIsIG9uZGF0YSk7CiAgICAgICAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7CiAgICAgICAgICBkZWJ1Zygib25kYXRhIik7CiAgICAgICAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7CiAgICAgICAgICBkZWJ1ZygiZGVzdC53cml0ZSIsIHJldCk7CiAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkgewogICAgICAgICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7CiAgICAgICAgICAgICAgZGVidWcoImZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZSIsIHN0YXRlLmF3YWl0RHJhaW4pOwogICAgICAgICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKzsKICAgICAgICAgICAgfQogICAgICAgICAgICBzcmMucGF1c2UoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gb25lcnJvcihlcikgewogICAgICAgICAgZGVidWcoIm9uZXJyb3IiLCBlcik7CiAgICAgICAgICB1bnBpcGUoKTsKICAgICAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoImVycm9yIiwgb25lcnJvcik7CiAgICAgICAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICJlcnJvciIpID09PSAwKQogICAgICAgICAgICBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7CiAgICAgICAgfQogICAgICAgIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAiZXJyb3IiLCBvbmVycm9yKTsKICAgICAgICBmdW5jdGlvbiBvbmNsb3NlKCkgewogICAgICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigiZmluaXNoIiwgb25maW5pc2gpOwogICAgICAgICAgdW5waXBlKCk7CiAgICAgICAgfQogICAgICAgIGRlc3Qub25jZSgiY2xvc2UiLCBvbmNsb3NlKTsKICAgICAgICBmdW5jdGlvbiBvbmZpbmlzaCgpIHsKICAgICAgICAgIGRlYnVnKCJvbmZpbmlzaCIpOwogICAgICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigiY2xvc2UiLCBvbmNsb3NlKTsKICAgICAgICAgIHVucGlwZSgpOwogICAgICAgIH0KICAgICAgICBkZXN0Lm9uY2UoImZpbmlzaCIsIG9uZmluaXNoKTsKICAgICAgICBmdW5jdGlvbiB1bnBpcGUoKSB7CiAgICAgICAgICBkZWJ1ZygidW5waXBlIik7CiAgICAgICAgICBzcmMudW5waXBlKGRlc3QpOwogICAgICAgIH0KICAgICAgICBkZXN0LmVtaXQoInBpcGUiLCBzcmMpOwogICAgICAgIGlmICghc3RhdGUuZmxvd2luZykgewogICAgICAgICAgZGVidWcoInBpcGUgcmVzdW1lIik7CiAgICAgICAgICBzcmMucmVzdW1lKCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZXN0OwogICAgICB9OwogICAgICBmdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gcGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCgpIHsKICAgICAgICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTsKICAgICAgICAgIGRlYnVnKCJwaXBlT25EcmFpbiIsIHN0YXRlLmF3YWl0RHJhaW4pOwogICAgICAgICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pCiAgICAgICAgICAgIHN0YXRlLmF3YWl0RHJhaW4tLTsKICAgICAgICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICJkYXRhIikpIHsKICAgICAgICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7CiAgICAgICAgICAgIGZsb3coc3JjKTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7CiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICAgICAgICB2YXIgdW5waXBlSW5mbyA9IHsKICAgICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlCiAgICAgICAgfTsKICAgICAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7CiAgICAgICAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICBpZiAoIWRlc3QpCiAgICAgICAgICAgIGRlc3QgPSBzdGF0ZS5waXBlczsKICAgICAgICAgIHN0YXRlLnBpcGVzID0gbnVsbDsKICAgICAgICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwOwogICAgICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlOwogICAgICAgICAgaWYgKGRlc3QpCiAgICAgICAgICAgIGRlc3QuZW1pdCgidW5waXBlIiwgdGhpcywgdW5waXBlSW5mbyk7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgaWYgKCFkZXN0KSB7CiAgICAgICAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlczsKICAgICAgICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50OwogICAgICAgICAgc3RhdGUucGlwZXMgPSBudWxsOwogICAgICAgICAgc3RhdGUucGlwZXNDb3VudCA9IDA7CiAgICAgICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKQogICAgICAgICAgICBkZXN0c1tpXS5lbWl0KCJ1bnBpcGUiLCB0aGlzLCB7CiAgICAgICAgICAgICAgaGFzVW5waXBlZDogZmFsc2UKICAgICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7CiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7CiAgICAgICAgc3RhdGUucGlwZXNDb3VudCAtPSAxOwogICAgICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKQogICAgICAgICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTsKICAgICAgICBkZXN0LmVtaXQoInVucGlwZSIsIHRoaXMsIHVucGlwZUluZm8pOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBSZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHsKICAgICAgICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7CiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICAgICAgICBpZiAoZXYgPT09ICJkYXRhIikgewogICAgICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoInJlYWRhYmxlIikgPiAwOwogICAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKQogICAgICAgICAgICB0aGlzLnJlc3VtZSgpOwogICAgICAgIH0gZWxzZSBpZiAoZXYgPT09ICJyZWFkYWJsZSIpIHsKICAgICAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHsKICAgICAgICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwogICAgICAgICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7CiAgICAgICAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOwogICAgICAgICAgICBkZWJ1Zygib24gcmVhZGFibGUiLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpOwogICAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpOwogICAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7CiAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzOwogICAgICB9OwogICAgICBSZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2LCBmbikgewogICAgICAgIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTsKICAgICAgICBpZiAoZXYgPT09ICJyZWFkYWJsZSIpIHsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzOwogICAgICB9OwogICAgICBSZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24oZXYpIHsKICAgICAgICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICBpZiAoZXYgPT09ICJyZWFkYWJsZSIgfHwgZXYgPT09IHZvaWQgMCkgewogICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYyKSB7CiAgICAgICAgdmFyIHN0YXRlID0gc2VsZjIuX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmMi5saXN0ZW5lckNvdW50KCJyZWFkYWJsZSIpID4gMDsKICAgICAgICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHsKICAgICAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOwogICAgICAgIH0gZWxzZSBpZiAoc2VsZjIubGlzdGVuZXJDb3VudCgiZGF0YSIpID4gMCkgewogICAgICAgICAgc2VsZjIucmVzdW1lKCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZjIpIHsKICAgICAgICBkZWJ1ZygicmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwIik7CiAgICAgICAgc2VsZjIucmVhZCgwKTsKICAgICAgfQogICAgICBSZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICAgICAgICBpZiAoIXN0YXRlLmZsb3dpbmcpIHsKICAgICAgICAgIGRlYnVnKCJyZXN1bWUiKTsKICAgICAgICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmc7CiAgICAgICAgICByZXN1bWUodGhpcywgc3RhdGUpOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHsKICAgICAgICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkgewogICAgICAgICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkgewogICAgICAgIGRlYnVnKCJyZXN1bWUiLCBzdGF0ZS5yZWFkaW5nKTsKICAgICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHsKICAgICAgICAgIHN0cmVhbS5yZWFkKDApOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTsKICAgICAgICBzdHJlYW0uZW1pdCgicmVzdW1lIik7CiAgICAgICAgZmxvdyhzdHJlYW0pOwogICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKQogICAgICAgICAgc3RyZWFtLnJlYWQoMCk7CiAgICAgIH0KICAgICAgUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7CiAgICAgICAgZGVidWcoImNhbGwgcGF1c2UgZmxvd2luZz0laiIsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7CiAgICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHsKICAgICAgICAgIGRlYnVnKCJwYXVzZSIpOwogICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7CiAgICAgICAgICB0aGlzLmVtaXQoInBhdXNlIik7CiAgICAgICAgfQogICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHsKICAgICAgICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgZGVidWcoImZsb3ciLCBzdGF0ZS5mbG93aW5nKTsKICAgICAgICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKQogICAgICAgICAgOwogICAgICB9CiAgICAgIFJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7CiAgICAgICAgdmFyIF90aGlzID0gdGhpczsKICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogICAgICAgIHZhciBwYXVzZWQgPSBmYWxzZTsKICAgICAgICBzdHJlYW0ub24oImVuZCIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgZGVidWcoIndyYXBwZWQgZW5kIik7CiAgICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHsKICAgICAgICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTsKICAgICAgICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkKICAgICAgICAgICAgICBfdGhpcy5wdXNoKGNodW5rKTsKICAgICAgICAgIH0KICAgICAgICAgIF90aGlzLnB1c2gobnVsbCk7CiAgICAgICAgfSk7CiAgICAgICAgc3RyZWFtLm9uKCJkYXRhIiwgZnVuY3Rpb24oY2h1bmspIHsKICAgICAgICAgIGRlYnVnKCJ3cmFwcGVkIGRhdGEiKTsKICAgICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyKQogICAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOwogICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB2b2lkIDApKQogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICBlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKQogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7CiAgICAgICAgICBpZiAoIXJldCkgewogICAgICAgICAgICBwYXVzZWQgPSB0cnVlOwogICAgICAgICAgICBzdHJlYW0ucGF1c2UoKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBmb3IgKHZhciBpIGluIHN0cmVhbSkgewogICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZvaWQgMCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkgewogICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0oaSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7CiAgICAgICAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uKG4yKSB7CiAgICAgICAgICBkZWJ1Zygid3JhcHBlZCBfcmVhZCIsIG4yKTsKICAgICAgICAgIGlmIChwYXVzZWQpIHsKICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7CiAgICAgICAgICAgIHN0cmVhbS5yZXN1bWUoKTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHZvaWQgMCkgewogICAgICAgICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlX2FzeW5jX2l0ZXJhdG9yKCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgInJlYWRhYmxlSGlnaFdhdGVyTWFyayIsIHsKICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgInJlYWRhYmxlQnVmZmVyIiwgewogICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgInJlYWRhYmxlRmxvd2luZyIsIHsKICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc7CiAgICAgICAgfSwKICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkgewogICAgICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHsKICAgICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9KTsKICAgICAgUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICJyZWFkYWJsZUxlbmd0aCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkgewogICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB2YXIgcmV0OwogICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlKQogICAgICAgICAgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7CiAgICAgICAgZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHsKICAgICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyKQogICAgICAgICAgICByZXQgPSBzdGF0ZS5idWZmZXIuam9pbigiIik7CiAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKQogICAgICAgICAgICByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpOwogICAgICAgICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkgewogICAgICAgIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKICAgICAgICBkZWJ1ZygiZW5kUmVhZGFibGUiLCBzdGF0ZS5lbmRFbWl0dGVkKTsKICAgICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHsKICAgICAgICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkgewogICAgICAgIGRlYnVnKCJlbmRSZWFkYWJsZU5UIiwgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKTsKICAgICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTsKICAgICAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlOwogICAgICAgICAgc3RyZWFtLmVtaXQoImVuZCIpOwogICAgICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7CiAgICAgICAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7CiAgICAgICAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHsKICAgICAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBvcHRzKSB7CiAgICAgICAgICBpZiAoZnJvbSA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgIGZyb20gPSByZXF1aXJlX2Zyb21fYnJvd3NlcigpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHsKICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgaWYgKHhzW2ldID09PSB4KQogICAgICAgICAgICByZXR1cm4gaTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMKICB2YXIgcmVxdWlyZV9zdHJlYW1fdHJhbnNmb3JtID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3JlYWRhYmxlLXN0cmVhbUAzLjYuMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFRyYW5zZm9ybTI7CiAgICAgIHZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmVfZXJyb3JzX2Jyb3dzZXIoKS5jb2RlczsKICAgICAgdmFyIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQ7CiAgICAgIHZhciBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0s7CiAgICAgIHZhciBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORzsKICAgICAgdmFyIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDsKICAgICAgdmFyIER1cGxleCA9IHJlcXVpcmVfc3RyZWFtX2R1cGxleCgpOwogICAgICByZXF1aXJlX2luaGVyaXRzX2Jyb3dzZXIoKShUcmFuc2Zvcm0yLCBEdXBsZXgpOwogICAgICBmdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkgewogICAgICAgIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlOwogICAgICAgIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlOwogICAgICAgIHZhciBjYiA9IHRzLndyaXRlY2I7CiAgICAgICAgaWYgKGNiID09PSBudWxsKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCJlcnJvciIsIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSk7CiAgICAgICAgfQogICAgICAgIHRzLndyaXRlY2h1bmsgPSBudWxsOwogICAgICAgIHRzLndyaXRlY2IgPSBudWxsOwogICAgICAgIGlmIChkYXRhICE9IG51bGwpCiAgICAgICAgICB0aGlzLnB1c2goZGF0YSk7CiAgICAgICAgY2IoZXIpOwogICAgICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgICAgICAgcnMucmVhZGluZyA9IGZhbHNlOwogICAgICAgIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgewogICAgICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gVHJhbnNmb3JtMihvcHRpb25zKSB7CiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybTIpKQogICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0yKG9wdGlvbnMpOwogICAgICAgIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpOwogICAgICAgIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gewogICAgICAgICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksCiAgICAgICAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSwKICAgICAgICAgIHRyYW5zZm9ybWluZzogZmFsc2UsCiAgICAgICAgICB3cml0ZWNiOiBudWxsLAogICAgICAgICAgd3JpdGVjaHVuazogbnVsbCwKICAgICAgICAgIHdyaXRlZW5jb2Rpbmc6IG51bGwKICAgICAgICB9OwogICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsKICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTsKICAgICAgICBpZiAob3B0aW9ucykgewogICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07CiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDsKICAgICAgICB9CiAgICAgICAgdGhpcy5vbigicHJlZmluaXNoIiwgcHJlZmluaXNoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwcmVmaW5pc2goKSB7CiAgICAgICAgdmFyIF90aGlzID0gdGhpczsKICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAiZnVuY3Rpb24iICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkgewogICAgICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIsIGRhdGEpIHsKICAgICAgICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpOwogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIFRyYW5zZm9ybTIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHsKICAgICAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7CiAgICAgICAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7CiAgICAgIH07CiAgICAgIFRyYW5zZm9ybTIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgICAgICAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCJfdHJhbnNmb3JtKCkiKSk7CiAgICAgIH07CiAgICAgIFRyYW5zZm9ybTIucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHsKICAgICAgICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTsKICAgICAgICB0cy53cml0ZWNiID0gY2I7CiAgICAgICAgdHMud3JpdGVjaHVuayA9IGNodW5rOwogICAgICAgIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZzsKICAgICAgICBpZiAoIXRzLnRyYW5zZm9ybWluZykgewogICAgICAgICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICAgICAgICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKQogICAgICAgICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspOwogICAgICAgIH0KICAgICAgfTsKICAgICAgVHJhbnNmb3JtMi5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7CiAgICAgICAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7CiAgICAgICAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgIXRzLnRyYW5zZm9ybWluZykgewogICAgICAgICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTsKICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlOwogICAgICAgIH0KICAgICAgfTsKICAgICAgVHJhbnNmb3JtMi5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIsIGNiKSB7CiAgICAgICAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24oZXJyMikgewogICAgICAgICAgY2IoZXJyMik7CiAgICAgICAgfSk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkgewogICAgICAgIGlmIChlcikKICAgICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgiZXJyb3IiLCBlcik7CiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkKICAgICAgICAgIHN0cmVhbS5wdXNoKGRhdGEpOwogICAgICAgIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCgpOwogICAgICAgIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykKICAgICAgICAgIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HKCk7CiAgICAgICAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcwogIHZhciByZXF1aXJlX3N0cmVhbV9wYXNzdGhyb3VnaCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFBhc3NUaHJvdWdoOwogICAgICB2YXIgVHJhbnNmb3JtMiA9IHJlcXVpcmVfc3RyZWFtX3RyYW5zZm9ybSgpOwogICAgICByZXF1aXJlX2luaGVyaXRzX2Jyb3dzZXIoKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtMik7CiAgICAgIGZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKQogICAgICAgICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTsKICAgICAgICBUcmFuc2Zvcm0yLmNhbGwodGhpcywgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgICAgICAgY2IobnVsbCwgY2h1bmspOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcmVhZGFibGUtc3RyZWFtQDMuNi4yL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMKICB2YXIgcmVxdWlyZV9waXBlbGluZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWFkYWJsZS1zdHJlYW1AMy42LjIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBlb3M7CiAgICAgIGZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHsKICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgaWYgKGNhbGxlZCkKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgY2FsbGVkID0gdHJ1ZTsKICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIHZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmVfZXJyb3JzX2Jyb3dzZXIoKS5jb2RlczsKICAgICAgdmFyIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTOwogICAgICB2YXIgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRDsKICAgICAgZnVuY3Rpb24gbm9vcChlcnIpIHsKICAgICAgICBpZiAoZXJyKQogICAgICAgICAgdGhyb3cgZXJyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHsKICAgICAgICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAiZnVuY3Rpb24iOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTsKICAgICAgICB2YXIgY2xvc2VkID0gZmFsc2U7CiAgICAgICAgc3RyZWFtLm9uKCJjbG9zZSIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgY2xvc2VkID0gdHJ1ZTsKICAgICAgICB9KTsKICAgICAgICBpZiAoZW9zID09PSB2b2lkIDApCiAgICAgICAgICBlb3MgPSByZXF1aXJlX2VuZF9vZl9zdHJlYW0oKTsKICAgICAgICBlb3Moc3RyZWFtLCB7CiAgICAgICAgICByZWFkYWJsZTogcmVhZGluZywKICAgICAgICAgIHdyaXRhYmxlOiB3cml0aW5nCiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICBpZiAoZXJyKQogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICAgIGNsb3NlZCA9IHRydWU7CiAgICAgICAgICBjYWxsYmFjaygpOwogICAgICAgIH0pOwogICAgICAgIHZhciBkZXN0cm95ZWQgPSBmYWxzZTsKICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICBpZiAoY2xvc2VkKQogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICBpZiAoZGVzdHJveWVkKQogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICBkZXN0cm95ZWQgPSB0cnVlOwogICAgICAgICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKQogICAgICAgICAgICByZXR1cm4gc3RyZWFtLmFib3J0KCk7CiAgICAgICAgICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAiZnVuY3Rpb24iKQogICAgICAgICAgICByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKTsKICAgICAgICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoInBpcGUiKSk7CiAgICAgICAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiBjYWxsKGZuKSB7CiAgICAgICAgZm4oKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwaXBlKGZyb20sIHRvKSB7CiAgICAgICAgcmV0dXJuIGZyb20ucGlwZSh0byk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykgewogICAgICAgIGlmICghc3RyZWFtcy5sZW5ndGgpCiAgICAgICAgICByZXR1cm4gbm9vcDsKICAgICAgICBpZiAodHlwZW9mIHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSAhPT0gImZ1bmN0aW9uIikKICAgICAgICAgIHJldHVybiBub29wOwogICAgICAgIHJldHVybiBzdHJlYW1zLnBvcCgpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBpcGVsaW5lKCkgewogICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykgewogICAgICAgICAgc3RyZWFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTsKICAgICAgICB9CiAgICAgICAgdmFyIGNhbGxiYWNrID0gcG9wQ2FsbGJhY2soc3RyZWFtcyk7CiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpCiAgICAgICAgICBzdHJlYW1zID0gc3RyZWFtc1swXTsKICAgICAgICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygic3RyZWFtcyIpOwogICAgICAgIH0KICAgICAgICB2YXIgZXJyb3I7CiAgICAgICAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24oc3RyZWFtLCBpKSB7CiAgICAgICAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDE7CiAgICAgICAgICB2YXIgd3JpdGluZyA9IGkgPiAwOwogICAgICAgICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uKGVycikgewogICAgICAgICAgICBpZiAoIWVycm9yKQogICAgICAgICAgICAgIGVycm9yID0gZXJyOwogICAgICAgICAgICBpZiAoZXJyKQogICAgICAgICAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7CiAgICAgICAgICAgIGlmIChyZWFkaW5nKQogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKTsKICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHBpcGVsaW5lOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vc3RyZWFtLWJyb3dzZXJpZnlAMy4wLjAvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfc3RyZWFtX2Jyb3dzZXJpZnkgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vc3RyZWFtLWJyb3dzZXJpZnlAMy4wLjAvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFN0cmVhbTsKICAgICAgdmFyIEVFID0gcmVxdWlyZV9ldmVudHMoKS5FdmVudEVtaXR0ZXI7CiAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmVfaW5oZXJpdHNfYnJvd3NlcigpOwogICAgICBpbmhlcml0cyhTdHJlYW0sIEVFKTsKICAgICAgU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZV9zdHJlYW1fcmVhZGFibGUoKTsKICAgICAgU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZV9zdHJlYW1fd3JpdGFibGUoKTsKICAgICAgU3RyZWFtLkR1cGxleCA9IHJlcXVpcmVfc3RyZWFtX2R1cGxleCgpOwogICAgICBTdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZV9zdHJlYW1fdHJhbnNmb3JtKCk7CiAgICAgIFN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmVfc3RyZWFtX3Bhc3N0aHJvdWdoKCk7CiAgICAgIFN0cmVhbS5maW5pc2hlZCA9IHJlcXVpcmVfZW5kX29mX3N0cmVhbSgpOwogICAgICBTdHJlYW0ucGlwZWxpbmUgPSByZXF1aXJlX3BpcGVsaW5lKCk7CiAgICAgIFN0cmVhbS5TdHJlYW0gPSBTdHJlYW07CiAgICAgIGZ1bmN0aW9uIFN0cmVhbSgpIHsKICAgICAgICBFRS5jYWxsKHRoaXMpOwogICAgICB9CiAgICAgIFN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHsKICAgICAgICB2YXIgc291cmNlID0gdGhpczsKICAgICAgICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHsKICAgICAgICAgIGlmIChkZXN0LndyaXRhYmxlKSB7CiAgICAgICAgICAgIGlmIChkZXN0LndyaXRlKGNodW5rKSA9PT0gZmFsc2UgJiYgc291cmNlLnBhdXNlKSB7CiAgICAgICAgICAgICAgc291cmNlLnBhdXNlKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc291cmNlLm9uKCJkYXRhIiwgb25kYXRhKTsKICAgICAgICBmdW5jdGlvbiBvbmRyYWluKCkgewogICAgICAgICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7CiAgICAgICAgICAgIHNvdXJjZS5yZXN1bWUoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZGVzdC5vbigiZHJhaW4iLCBvbmRyYWluKTsKICAgICAgICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHsKICAgICAgICAgIHNvdXJjZS5vbigiZW5kIiwgb25lbmQpOwogICAgICAgICAgc291cmNlLm9uKCJjbG9zZSIsIG9uY2xvc2UpOwogICAgICAgIH0KICAgICAgICB2YXIgZGlkT25FbmQgPSBmYWxzZTsKICAgICAgICBmdW5jdGlvbiBvbmVuZCgpIHsKICAgICAgICAgIGlmIChkaWRPbkVuZCkKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgZGlkT25FbmQgPSB0cnVlOwogICAgICAgICAgZGVzdC5lbmQoKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gb25jbG9zZSgpIHsKICAgICAgICAgIGlmIChkaWRPbkVuZCkKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgZGlkT25FbmQgPSB0cnVlOwogICAgICAgICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICAgIGRlc3QuZGVzdHJveSgpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7CiAgICAgICAgICBjbGVhbnVwKCk7CiAgICAgICAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAiZXJyb3IiKSA9PT0gMCkgewogICAgICAgICAgICB0aHJvdyBlcjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc291cmNlLm9uKCJlcnJvciIsIG9uZXJyb3IpOwogICAgICAgIGRlc3Qub24oImVycm9yIiwgb25lcnJvcik7CiAgICAgICAgZnVuY3Rpb24gY2xlYW51cCgpIHsKICAgICAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcigiZGF0YSIsIG9uZGF0YSk7CiAgICAgICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCJkcmFpbiIsIG9uZHJhaW4pOwogICAgICAgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCJlbmQiLCBvbmVuZCk7CiAgICAgICAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoImNsb3NlIiwgb25jbG9zZSk7CiAgICAgICAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoImVycm9yIiwgb25lcnJvcik7CiAgICAgICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCJlcnJvciIsIG9uZXJyb3IpOwogICAgICAgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCJlbmQiLCBjbGVhbnVwKTsKICAgICAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcigiY2xvc2UiLCBjbGVhbnVwKTsKICAgICAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoImNsb3NlIiwgY2xlYW51cCk7CiAgICAgICAgfQogICAgICAgIHNvdXJjZS5vbigiZW5kIiwgY2xlYW51cCk7CiAgICAgICAgc291cmNlLm9uKCJjbG9zZSIsIGNsZWFudXApOwogICAgICAgIGRlc3Qub24oImNsb3NlIiwgY2xlYW51cCk7CiAgICAgICAgZGVzdC5lbWl0KCJwaXBlIiwgc291cmNlKTsKICAgICAgICByZXR1cm4gZGVzdDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2lzLW9ic2VydmFibGVAMi4xLjAvbm9kZV9tb2R1bGVzL2lzLW9ic2VydmFibGUvaW5kZXguanMKICB2YXIgcmVxdWlyZV9pc19vYnNlcnZhYmxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2lzLW9ic2VydmFibGVAMi4xLjAvbm9kZV9tb2R1bGVzL2lzLW9ic2VydmFibGUvaW5kZXguanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSAodmFsdWUpID0+IHsKICAgICAgICBpZiAoIXZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgU3ltYm9sLm9ic2VydmFibGUgPT09ICJzeW1ib2wiICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wub2JzZXJ2YWJsZV0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVbU3ltYm9sLm9ic2VydmFibGVdKCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsdWVbIkBAb2JzZXJ2YWJsZSJdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlWyJAQG9ic2VydmFibGUiXSgpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc2VyaWFsaXplcnMuanMKICB2YXIgcmVxdWlyZV9zZXJpYWxpemVycyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc2VyaWFsaXplcnMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuRGVmYXVsdFNlcmlhbGl6ZXIgPSBleHBvcnRzMi5leHRlbmRTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICBmdW5jdGlvbiBleHRlbmRTZXJpYWxpemVyKGV4dGVuZCwgaW1wbGVtZW50YXRpb24pIHsKICAgICAgICBjb25zdCBmYWxsYmFja0Rlc2VyaWFsaXplciA9IGV4dGVuZC5kZXNlcmlhbGl6ZS5iaW5kKGV4dGVuZCk7CiAgICAgICAgY29uc3QgZmFsbGJhY2tTZXJpYWxpemVyID0gZXh0ZW5kLnNlcmlhbGl6ZS5iaW5kKGV4dGVuZCk7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uLmRlc2VyaWFsaXplKG1lc3NhZ2UsIGZhbGxiYWNrRGVzZXJpYWxpemVyKTsKICAgICAgICAgIH0sCiAgICAgICAgICBzZXJpYWxpemUoaW5wdXQpIHsKICAgICAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uLnNlcmlhbGl6ZShpbnB1dCwgZmFsbGJhY2tTZXJpYWxpemVyKTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICAgIGV4cG9ydHMyLmV4dGVuZFNlcmlhbGl6ZXIgPSBleHRlbmRTZXJpYWxpemVyOwogICAgICB2YXIgRGVmYXVsdEVycm9yU2VyaWFsaXplciA9IHsKICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihFcnJvcihtZXNzYWdlLm1lc3NhZ2UpLCB7CiAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSwKICAgICAgICAgICAgc3RhY2s6IG1lc3NhZ2Uuc3RhY2sKICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICAgc2VyaWFsaXplKGVycm9yKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBfX2Vycm9yX21hcmtlcjogIiQkZXJyb3IiLAogICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLAogICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lLAogICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2sKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgaXNTZXJpYWxpemVkRXJyb3IgPSAodGhpbmcpID0+IHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgIl9fZXJyb3JfbWFya2VyIiBpbiB0aGluZyAmJiB0aGluZy5fX2Vycm9yX21hcmtlciA9PT0gIiQkZXJyb3IiOwogICAgICBleHBvcnRzMi5EZWZhdWx0U2VyaWFsaXplciA9IHsKICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkRXJyb3IobWVzc2FnZSkpIHsKICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIuZGVzZXJpYWxpemUobWVzc2FnZSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gbWVzc2FnZTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHNlcmlhbGl6ZShpbnB1dCkgewogICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRXJyb3IpIHsKICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIuc2VyaWFsaXplKGlucHV0KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBpbnB1dDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvY29tbW9uLmpzCiAgdmFyIHJlcXVpcmVfY29tbW9uMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvY29tbW9uLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLnNlcmlhbGl6ZSA9IGV4cG9ydHMyLmRlc2VyaWFsaXplID0gZXhwb3J0czIucmVnaXN0ZXJTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICB2YXIgc2VyaWFsaXplcnNfMSA9IHJlcXVpcmVfc2VyaWFsaXplcnMoKTsKICAgICAgdmFyIHJlZ2lzdGVyZWRTZXJpYWxpemVyID0gc2VyaWFsaXplcnNfMS5EZWZhdWx0U2VyaWFsaXplcjsKICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJTZXJpYWxpemVyMihzZXJpYWxpemVyKSB7CiAgICAgICAgcmVnaXN0ZXJlZFNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc18xLmV4dGVuZFNlcmlhbGl6ZXIocmVnaXN0ZXJlZFNlcmlhbGl6ZXIsIHNlcmlhbGl6ZXIpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLnJlZ2lzdGVyU2VyaWFsaXplciA9IHJlZ2lzdGVyU2VyaWFsaXplcjI7CiAgICAgIGZ1bmN0aW9uIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUobWVzc2FnZSk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTsKICAgICAgZnVuY3Rpb24gc2VyaWFsaXplKGlucHV0KSB7CiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRTZXJpYWxpemVyLnNlcmlhbGl6ZShpbnB1dCk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuc2VyaWFsaXplID0gc2VyaWFsaXplOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3N5bWJvbHMuanMKICB2YXIgcmVxdWlyZV9zeW1ib2xzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zeW1ib2xzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLiR3b3JrZXIgPSBleHBvcnRzMi4kdHJhbnNmZXJhYmxlID0gZXhwb3J0czIuJHRlcm1pbmF0ZSA9IGV4cG9ydHMyLiRldmVudHMgPSBleHBvcnRzMi4kZXJyb3JzID0gdm9pZCAwOwogICAgICBleHBvcnRzMi4kZXJyb3JzID0gU3ltYm9sKCJ0aHJlYWQuZXJyb3JzIik7CiAgICAgIGV4cG9ydHMyLiRldmVudHMgPSBTeW1ib2woInRocmVhZC5ldmVudHMiKTsKICAgICAgZXhwb3J0czIuJHRlcm1pbmF0ZSA9IFN5bWJvbCgidGhyZWFkLnRlcm1pbmF0ZSIpOwogICAgICBleHBvcnRzMi4kdHJhbnNmZXJhYmxlID0gU3ltYm9sKCJ0aHJlYWQudHJhbnNmZXJhYmxlIik7CiAgICAgIGV4cG9ydHMyLiR3b3JrZXIgPSBTeW1ib2woInRocmVhZC53b3JrZXIiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90cmFuc2ZlcmFibGUuanMKICB2YXIgcmVxdWlyZV90cmFuc2ZlcmFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3RyYW5zZmVyYWJsZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5UcmFuc2ZlciA9IGV4cG9ydHMyLmlzVHJhbnNmZXJEZXNjcmlwdG9yID0gdm9pZCAwOwogICAgICB2YXIgc3ltYm9sc18xID0gcmVxdWlyZV9zeW1ib2xzKCk7CiAgICAgIGZ1bmN0aW9uIGlzVHJhbnNmZXJhYmxlKHRoaW5nKSB7CiAgICAgICAgaWYgKCF0aGluZyB8fCB0eXBlb2YgdGhpbmcgIT09ICJvYmplY3QiKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGlzVHJhbnNmZXJEZXNjcmlwdG9yKHRoaW5nKSB7CiAgICAgICAgcmV0dXJuIHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgdGhpbmdbc3ltYm9sc18xLiR0cmFuc2ZlcmFibGVdOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmlzVHJhbnNmZXJEZXNjcmlwdG9yID0gaXNUcmFuc2ZlckRlc2NyaXB0b3I7CiAgICAgIGZ1bmN0aW9uIFRyYW5zZmVyMihwYXlsb2FkLCB0cmFuc2ZlcmFibGVzKSB7CiAgICAgICAgaWYgKCF0cmFuc2ZlcmFibGVzKSB7CiAgICAgICAgICBpZiAoIWlzVHJhbnNmZXJhYmxlKHBheWxvYWQpKQogICAgICAgICAgICB0aHJvdyBFcnJvcigpOwogICAgICAgICAgdHJhbnNmZXJhYmxlcyA9IFtwYXlsb2FkXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIFtzeW1ib2xzXzEuJHRyYW5zZmVyYWJsZV06IHRydWUsCiAgICAgICAgICBzZW5kOiBwYXlsb2FkLAogICAgICAgICAgdHJhbnNmZXJhYmxlcwogICAgICAgIH07CiAgICAgIH0KICAgICAgZXhwb3J0czIuVHJhbnNmZXIgPSBUcmFuc2ZlcjI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHlwZXMvbWVzc2FnZXMuanMKICB2YXIgcmVxdWlyZV9tZXNzYWdlczIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3R5cGVzL21lc3NhZ2VzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLldvcmtlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuTWFzdGVyTWVzc2FnZVR5cGUgPSB2b2lkIDA7CiAgICAgIHZhciBNYXN0ZXJNZXNzYWdlVHlwZTsKICAgICAgKGZ1bmN0aW9uKE1hc3Rlck1lc3NhZ2VUeXBlMikgewogICAgICAgIE1hc3Rlck1lc3NhZ2VUeXBlMlsiY2FuY2VsIl0gPSAiY2FuY2VsIjsKICAgICAgICBNYXN0ZXJNZXNzYWdlVHlwZTJbInJ1biJdID0gInJ1biI7CiAgICAgIH0pKE1hc3Rlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuTWFzdGVyTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMyLk1hc3Rlck1lc3NhZ2VUeXBlID0ge30pKTsKICAgICAgdmFyIFdvcmtlck1lc3NhZ2VUeXBlOwogICAgICAoZnVuY3Rpb24oV29ya2VyTWVzc2FnZVR5cGUyKSB7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJlcnJvciJdID0gImVycm9yIjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbImluaXQiXSA9ICJpbml0IjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbInJlc3VsdCJdID0gInJlc3VsdCI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJydW5uaW5nIl0gPSAicnVubmluZyI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJ1bmNhdWdodEVycm9yIl0gPSAidW5jYXVnaHRFcnJvciI7CiAgICAgIH0pKFdvcmtlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuV29ya2VyTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMyLldvcmtlck1lc3NhZ2VUeXBlID0ge30pKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW1wbGVtZW50YXRpb24uYnJvd3Nlci5qcwogIHZhciByZXF1aXJlX2ltcGxlbWVudGF0aW9uX2Jyb3dzZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbXBsZW1lbnRhdGlvbi5icm93c2VyLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBpc1dvcmtlclJ1bnRpbWUgPSBmdW5jdGlvbiBpc1dvcmtlclJ1bnRpbWUyKCkgewogICAgICAgIGNvbnN0IGlzV2luZG93Q29udGV4dCA9IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgV2luZG93ICE9PSAidW5kZWZpbmVkIiAmJiBzZWxmIGluc3RhbmNlb2YgV2luZG93OwogICAgICAgIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgc2VsZi5wb3N0TWVzc2FnZSAmJiAhaXNXaW5kb3dDb250ZXh0ID8gdHJ1ZSA6IGZhbHNlOwogICAgICB9OwogICAgICB2YXIgcG9zdE1lc3NhZ2VUb01hc3RlciA9IGZ1bmN0aW9uIHBvc3RNZXNzYWdlVG9NYXN0ZXIyKGRhdGEsIHRyYW5zZmVyTGlzdCkgewogICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTsKICAgICAgfTsKICAgICAgdmFyIHN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMgPSBmdW5jdGlvbiBzdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzMihvbk1lc3NhZ2UpIHsKICAgICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IChtZXNzYWdlRXZlbnQpID0+IHsKICAgICAgICAgIG9uTWVzc2FnZShtZXNzYWdlRXZlbnQuZGF0YSk7CiAgICAgICAgfTsKICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHsKICAgICAgICAgIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIG1lc3NhZ2VIYW5kbGVyKTsKICAgICAgICB9OwogICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIG1lc3NhZ2VIYW5kbGVyKTsKICAgICAgICByZXR1cm4gdW5zdWJzY3JpYmU7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSB7CiAgICAgICAgaXNXb3JrZXJSdW50aW1lLAogICAgICAgIHBvc3RNZXNzYWdlVG9NYXN0ZXIsCiAgICAgICAgc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbmRleC5qcwogIHZhciByZXF1aXJlX3dvcmtlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2luZGV4LmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9fYXdhaXRlciA9IGV4cG9ydHMyICYmIGV4cG9ydHMyLl9fYXdhaXRlciB8fCBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHsKICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkgewogICAgICAgICAgICByZXNvbHZlKHZhbHVlKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgcmVqZWN0KGUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yWyJ0aHJvdyJdKHZhbHVlKSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7CiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOwogICAgICAgICAgfQogICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpOwogICAgICAgIH0pOwogICAgICB9OwogICAgICB2YXIgX19pbXBvcnREZWZhdWx0ID0gZXhwb3J0czIgJiYgZXhwb3J0czIuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKG1vZCkgewogICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7ICJkZWZhdWx0IjogbW9kIH07CiAgICAgIH07CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5leHBvc2UgPSBleHBvcnRzMi5pc1dvcmtlclJ1bnRpbWUgPSBleHBvcnRzMi5UcmFuc2ZlciA9IGV4cG9ydHMyLnJlZ2lzdGVyU2VyaWFsaXplciA9IHZvaWQgMDsKICAgICAgdmFyIGlzX29ic2VydmFibGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX2lzX29ic2VydmFibGUoKSk7CiAgICAgIHZhciBjb21tb25fMSA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICB2YXIgdHJhbnNmZXJhYmxlXzEgPSByZXF1aXJlX3RyYW5zZmVyYWJsZSgpOwogICAgICB2YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmVfbWVzc2FnZXMyKCk7CiAgICAgIHZhciBpbXBsZW1lbnRhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfaW1wbGVtZW50YXRpb25fYnJvd3NlcigpKTsKICAgICAgdmFyIGNvbW1vbl8yID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgInJlZ2lzdGVyU2VyaWFsaXplciIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gY29tbW9uXzIucmVnaXN0ZXJTZXJpYWxpemVyOwogICAgICB9IH0pOwogICAgICB2YXIgdHJhbnNmZXJhYmxlXzIgPSByZXF1aXJlX3RyYW5zZmVyYWJsZSgpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJUcmFuc2ZlciIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdHJhbnNmZXJhYmxlXzIuVHJhbnNmZXI7CiAgICAgIH0gfSk7CiAgICAgIGV4cG9ydHMyLmlzV29ya2VyUnVudGltZSA9IGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWU7CiAgICAgIHZhciBleHBvc2VDYWxsZWQgPSBmYWxzZTsKICAgICAgdmFyIGFjdGl2ZVN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7CiAgICAgIHZhciBpc01hc3RlckpvYkNhbmNlbE1lc3NhZ2UgPSAodGhpbmcpID0+IHRoaW5nICYmIHRoaW5nLnR5cGUgPT09IG1lc3NhZ2VzXzEuTWFzdGVyTWVzc2FnZVR5cGUuY2FuY2VsOwogICAgICB2YXIgaXNNYXN0ZXJKb2JSdW5NZXNzYWdlID0gKHRoaW5nKSA9PiB0aGluZyAmJiB0aGluZy50eXBlID09PSBtZXNzYWdlc18xLk1hc3Rlck1lc3NhZ2VUeXBlLnJ1bjsKICAgICAgdmFyIGlzT2JzZXJ2YWJsZSA9ICh0aGluZykgPT4gaXNfb2JzZXJ2YWJsZV8xLmRlZmF1bHQodGhpbmcpIHx8IGlzWmVuT2JzZXJ2YWJsZSh0aGluZyk7CiAgICAgIGZ1bmN0aW9uIGlzWmVuT2JzZXJ2YWJsZSh0aGluZykgewogICAgICAgIHJldHVybiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICJvYmplY3QiICYmIHR5cGVvZiB0aGluZy5zdWJzY3JpYmUgPT09ICJmdW5jdGlvbiI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVjb25zdHJ1Y3RUcmFuc2Zlcih0aGluZykgewogICAgICAgIHJldHVybiB0cmFuc2ZlcmFibGVfMS5pc1RyYW5zZmVyRGVzY3JpcHRvcih0aGluZykgPyB7IHBheWxvYWQ6IHRoaW5nLnNlbmQsIHRyYW5zZmVyYWJsZXM6IHRoaW5nLnRyYW5zZmVyYWJsZXMgfSA6IHsgcGF5bG9hZDogdGhpbmcsIHRyYW5zZmVyYWJsZXM6IHZvaWQgMCB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RGdW5jdGlvbkluaXRNZXNzYWdlKCkgewogICAgICAgIGNvbnN0IGluaXRNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5pbml0LAogICAgICAgICAgZXhwb3NlZDogewogICAgICAgICAgICB0eXBlOiAiZnVuY3Rpb24iCiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3Rlcihpbml0TWVzc2FnZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdE1vZHVsZUluaXRNZXNzYWdlKG1ldGhvZE5hbWVzKSB7CiAgICAgICAgY29uc3QgaW5pdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLmluaXQsCiAgICAgICAgICBleHBvc2VkOiB7CiAgICAgICAgICAgIHR5cGU6ICJtb2R1bGUiLAogICAgICAgICAgICBtZXRob2RzOiBtZXRob2ROYW1lcwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoaW5pdE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RKb2JFcnJvck1lc3NhZ2UodWlkLCByYXdFcnJvcikgewogICAgICAgIGNvbnN0IHsgcGF5bG9hZDogZXJyb3IsIHRyYW5zZmVyYWJsZXMgfSA9IGRlY29uc3RydWN0VHJhbnNmZXIocmF3RXJyb3IpOwogICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUuZXJyb3IsCiAgICAgICAgICB1aWQsCiAgICAgICAgICBlcnJvcjogY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoZXJyb3JNZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0Sm9iUmVzdWx0TWVzc2FnZSh1aWQsIGNvbXBsZXRlZCwgcmVzdWx0VmFsdWUpIHsKICAgICAgICBjb25zdCB7IHBheWxvYWQsIHRyYW5zZmVyYWJsZXMgfSA9IGRlY29uc3RydWN0VHJhbnNmZXIocmVzdWx0VmFsdWUpOwogICAgICAgIGNvbnN0IHJlc3VsdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnJlc3VsdCwKICAgICAgICAgIHVpZCwKICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZWQgPyB0cnVlIDogdm9pZCAwLAogICAgICAgICAgcGF5bG9hZAogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIocmVzdWx0TWVzc2FnZSwgdHJhbnNmZXJhYmxlcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEpvYlN0YXJ0TWVzc2FnZSh1aWQsIHJlc3VsdFR5cGUpIHsKICAgICAgICBjb25zdCBzdGFydE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnJ1bm5pbmcsCiAgICAgICAgICB1aWQsCiAgICAgICAgICByZXN1bHRUeXBlCiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihzdGFydE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvcikgewogICAgICAgIHRyeSB7CiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSB7CiAgICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUudW5jYXVnaHRFcnJvciwKICAgICAgICAgICAgZXJyb3I6IGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikKICAgICAgICAgIH07CiAgICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihlcnJvck1lc3NhZ2UpOwogICAgICAgIH0gY2F0Y2ggKHN1YkVycm9yKSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKCJOb3QgcmVwb3J0aW5nIHVuY2F1Z2h0IGVycm9yIGJhY2sgdG8gbWFzdGVyIHRocmVhZCBhcyBpdCBvY2N1cmVkIHdoaWxlIHJlcG9ydGluZyBhbiB1bmNhdWdodCBlcnJvciBhbHJlYWR5LlxuTGF0ZXN0IGVycm9yOiIsIHN1YkVycm9yLCAiXG5PcmlnaW5hbCBlcnJvcjoiLCBlcnJvcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJ1bkZ1bmN0aW9uKGpvYlVJRCwgZm4sIGFyZ3MpIHsKICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgewogICAgICAgICAgbGV0IHN5bmNSZXN1bHQ7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBzeW5jUmVzdWx0ID0gZm4oLi4uYXJncyk7CiAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICByZXR1cm4gcG9zdEpvYkVycm9yTWVzc2FnZShqb2JVSUQsIGVycm9yKTsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHJlc3VsdFR5cGUgPSBpc09ic2VydmFibGUoc3luY1Jlc3VsdCkgPyAib2JzZXJ2YWJsZSIgOiAicHJvbWlzZSI7CiAgICAgICAgICBwb3N0Sm9iU3RhcnRNZXNzYWdlKGpvYlVJRCwgcmVzdWx0VHlwZSk7CiAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHN5bmNSZXN1bHQpKSB7CiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN5bmNSZXN1bHQuc3Vic2NyaWJlKCh2YWx1ZSkgPT4gcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCBmYWxzZSwgY29tbW9uXzEuc2VyaWFsaXplKHZhbHVlKSksIChlcnJvcikgPT4gewogICAgICAgICAgICAgIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9LCAoKSA9PiB7CiAgICAgICAgICAgICAgcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCB0cnVlKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5zZXQoam9iVUlELCBzdWJzY3JpcHRpb24pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzeW5jUmVzdWx0OwogICAgICAgICAgICAgIHBvc3RKb2JSZXN1bHRNZXNzYWdlKGpvYlVJRCwgdHJ1ZSwgY29tbW9uXzEuc2VyaWFsaXplKHJlc3VsdCkpOwogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGV4cG9zZTIoZXhwb3NlZCkgewogICAgICAgIGlmICghaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZSgpKSB7CiAgICAgICAgICB0aHJvdyBFcnJvcigiZXhwb3NlKCkgY2FsbGVkIGluIHRoZSBtYXN0ZXIgdGhyZWFkLiIpOwogICAgICAgIH0KICAgICAgICBpZiAoZXhwb3NlQ2FsbGVkKSB7CiAgICAgICAgICB0aHJvdyBFcnJvcigiZXhwb3NlKCkgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLiBUaGlzIGlzIG5vdCBwb3NzaWJsZS4gUGFzcyBhbiBvYmplY3QgdG8gZXhwb3NlKCkgaWYgeW91IHdhbnQgdG8gZXhwb3NlIG11bHRpcGxlIGZ1bmN0aW9ucy4iKTsKICAgICAgICB9CiAgICAgICAgZXhwb3NlQ2FsbGVkID0gdHJ1ZTsKICAgICAgICBpZiAodHlwZW9mIGV4cG9zZWQgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgICBpZiAoaXNNYXN0ZXJKb2JSdW5NZXNzYWdlKG1lc3NhZ2VEYXRhKSAmJiAhbWVzc2FnZURhdGEubWV0aG9kKSB7CiAgICAgICAgICAgICAgcnVuRnVuY3Rpb24obWVzc2FnZURhdGEudWlkLCBleHBvc2VkLCBtZXNzYWdlRGF0YS5hcmdzLm1hcChjb21tb25fMS5kZXNlcmlhbGl6ZSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHBvc3RGdW5jdGlvbkluaXRNZXNzYWdlKCk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3NlZCA9PT0gIm9iamVjdCIgJiYgZXhwb3NlZCkgewogICAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMoKG1lc3NhZ2VEYXRhKSA9PiB7CiAgICAgICAgICAgIGlmIChpc01hc3RlckpvYlJ1bk1lc3NhZ2UobWVzc2FnZURhdGEpICYmIG1lc3NhZ2VEYXRhLm1ldGhvZCkgewogICAgICAgICAgICAgIHJ1bkZ1bmN0aW9uKG1lc3NhZ2VEYXRhLnVpZCwgZXhwb3NlZFttZXNzYWdlRGF0YS5tZXRob2RdLCBtZXNzYWdlRGF0YS5hcmdzLm1hcChjb21tb25fMS5kZXNlcmlhbGl6ZSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGNvbnN0IG1ldGhvZE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3NlZCkuZmlsdGVyKChrZXkpID0+IHR5cGVvZiBleHBvc2VkW2tleV0gPT09ICJmdW5jdGlvbiIpOwogICAgICAgICAgcG9zdE1vZHVsZUluaXRNZXNzYWdlKG1ldGhvZE5hbWVzKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGV4cG9zZSgpLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCwgZ290OiAke2V4cG9zZWR9YCk7CiAgICAgICAgfQogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgaWYgKGlzTWFzdGVySm9iQ2FuY2VsTWVzc2FnZShtZXNzYWdlRGF0YSkpIHsKICAgICAgICAgICAgY29uc3Qgam9iVUlEID0gbWVzc2FnZURhdGEudWlkOwogICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhY3RpdmVTdWJzY3JpcHRpb25zLmdldChqb2JVSUQpOwogICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7CiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7CiAgICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5kZWxldGUoam9iVUlEKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmV4cG9zZSA9IGV4cG9zZTI7CiAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIHNlbGYuYWRkRXZlbnRMaXN0ZW5lciA9PT0gImZ1bmN0aW9uIiAmJiBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoImVycm9yIiwgKGV2ZW50KSA9PiB7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShldmVudC5lcnJvciB8fCBldmVudCksIDI1MCk7CiAgICAgICAgfSk7CiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCJ1bmhhbmRsZWRyZWplY3Rpb24iLCAoZXZlbnQpID0+IHsKICAgICAgICAgIGNvbnN0IGVycm9yID0gZXZlbnQucmVhc29uOwogICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAic3RyaW5nIikgewogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgcHJvY2Vzcy5vbiA9PT0gImZ1bmN0aW9uIiAmJiBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICBwcm9jZXNzLm9uKCJ1bmNhdWdodEV4Y2VwdGlvbiIsIChlcnJvcikgPT4gewogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXJyb3IpLCAyNTApOwogICAgICAgIH0pOwogICAgICAgIHByb2Nlc3Mub24oInVuaGFuZGxlZFJlamVjdGlvbiIsIChlcnJvcikgPT4gewogICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAic3RyaW5nIikgewogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvZ2ZmL2dmZi13b3JrZXIudHM/d29ya2VyJmlubGluZT93b3JrZXJfZmlsZQogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK3RhYml4QDEuNS4xMS9ub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdGFiaXhJbmRleGVkRmlsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2Fib3J0YWJsZV9wcm9taXNlX2NhY2hlID0gX190b01vZHVsZShyZXF1aXJlX2VzbSgpKTsKICB2YXIgaW1wb3J0X3F1aWNrX2xydSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9xdWlja19scnUoKSk7CiAgdmFyIGltcG9ydF9idWZmZXI3ID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2dlbmVyaWMtZmlsZWhhbmRsZUAzLjEuMS9ub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2xvY2FsRmlsZSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb2NhbEZpbGUoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9nZW5lcmljLWZpbGVoYW5kbGVAMy4xLjEvbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vcmVtb3RlRmlsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2J1ZmZlcjIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwogIHZhciBSZW1vdGVGaWxlID0gY2xhc3MgewogICAgYXN5bmMgZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKSB7CiAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuYnVmZmVyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJ1ZmZlcigpOwogICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5hcnJheUJ1ZmZlciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpOwogICAgICAgIHJldHVybiBpbXBvcnRfYnVmZmVyMi5CdWZmZXIuZnJvbShyZXNwKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnZhbGlkIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LCBoYXMgbm8gYnVmZmVyIG1ldGhvZCwgYW5kIG5vIGFycmF5QnVmZmVyIG1ldGhvZCIpOwogICAgICB9CiAgICB9CiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdHMgPSB7fSkgewogICAgICB0aGlzLmJhc2VPdmVycmlkZXMgPSB7fTsKICAgICAgdGhpcy51cmwgPSBzb3VyY2U7CiAgICAgIGNvbnN0IGZldGNoID0gb3B0cy5mZXRjaCB8fCBnbG9iYWxUaGlzLmZldGNoLmJpbmQoZ2xvYmFsVGhpcyk7CiAgICAgIGlmICghZmV0Y2gpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBubyBmZXRjaCBmdW5jdGlvbiBzdXBwbGllZCwgYW5kIG5vbmUgZm91bmQgaW4gZ2xvYmFsIGVudmlyb25tZW50YCk7CiAgICAgIH0KICAgICAgaWYgKG9wdHMub3ZlcnJpZGVzKSB7CiAgICAgICAgdGhpcy5iYXNlT3ZlcnJpZGVzID0gb3B0cy5vdmVycmlkZXM7CiAgICAgIH0KICAgICAgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uID0gZmV0Y2g7CiAgICB9CiAgICBhc3luYyBmZXRjaChpbnB1dCwgaW5pdDIpIHsKICAgICAgbGV0IHJlc3BvbnNlOwogICAgICB0cnkgewogICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGlucHV0LCBpbml0Mik7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAoYCR7ZX1gLmluY2x1ZGVzKCJGYWlsZWQgdG8gZmV0Y2giKSkgewogICAgICAgICAgY29uc29sZS53YXJuKGBnZW5lcmljLWZpbGVoYW5kbGU6IHJlZmV0Y2hpbmcgJHtpbnB1dH0gdG8gYXR0ZW1wdCB0byB3b3JrIGFyb3VuZCBjaHJvbWUgQ09SUyBoZWFkZXIgY2FjaGluZyBidWdgKTsKICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGlucHV0LCB7CiAgICAgICAgICAgIC4uLmluaXQyLAogICAgICAgICAgICBjYWNoZTogInJlbG9hZCIKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBlOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gcmVzcG9uc2U7CiAgICB9CiAgICBhc3luYyByZWFkKGJ1ZmZlciwgb2Zmc2V0ID0gMCwgbGVuZ3RoLCBwb3NpdGlvbiA9IDAsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSwgc2lnbmFsLCBvdmVycmlkZXMgPSB7fSB9ID0gb3B0czsKICAgICAgaWYgKGxlbmd0aCA8IEluZmluaXR5KSB7CiAgICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS0ke3Bvc2l0aW9uICsgbGVuZ3RofWA7CiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSBJbmZpbml0eSAmJiBwb3NpdGlvbiAhPT0gMCkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tYDsKICAgICAgfQogICAgICBjb25zdCBhcmdzID0gewogICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcywKICAgICAgICAuLi5vdmVycmlkZXMsCiAgICAgICAgaGVhZGVyczogewogICAgICAgICAgLi4uaGVhZGVycywKICAgICAgICAgIC4uLm92ZXJyaWRlcy5oZWFkZXJzLAogICAgICAgICAgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLmhlYWRlcnMKICAgICAgICB9LAogICAgICAgIG1ldGhvZDogIkdFVCIsCiAgICAgICAgcmVkaXJlY3Q6ICJmb2xsb3ciLAogICAgICAgIG1vZGU6ICJjb3JzIiwKICAgICAgICBzaWduYWwKICAgICAgfTsKICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgaWYgKCFyZXNwb25zZS5vaykgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAke3RoaXMudXJsfWApOwogICAgICB9CiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiBwb3NpdGlvbiA9PT0gMCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNikgewogICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTsKICAgICAgICBjb25zdCBieXRlc0NvcGllZCA9IHJlc3BvbnNlRGF0YS5jb3B5KGJ1ZmZlciwgb2Zmc2V0LCAwLCBNYXRoLm1pbihsZW5ndGgsIHJlc3BvbnNlRGF0YS5sZW5ndGgpKTsKICAgICAgICBjb25zdCByZXMgPSByZXNwb25zZS5oZWFkZXJzLmdldCgiY29udGVudC1yYW5nZSIpOwogICAgICAgIGNvbnN0IHNpemVNYXRjaCA9IC9cLyhcZCspJC8uZXhlYyhyZXMgfHwgIiIpOwogICAgICAgIGlmIChzaXplTWF0Y2ggJiYgc2l6ZU1hdGNoWzFdKSB7CiAgICAgICAgICB0aGlzLl9zdGF0ID0geyBzaXplOiBwYXJzZUludChzaXplTWF0Y2hbMV0sIDEwKSB9OwogICAgICAgIH0KICAgICAgICByZXR1cm4geyBieXRlc1JlYWQ6IGJ5dGVzQ29waWVkLCBidWZmZXIgfTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIiR7dGhpcy51cmx9IGZldGNoIHJldHVybmVkIHN0YXR1cyAyMDAsIGV4cGVjdGVkIDIwNiIpOwogICAgICB9CiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKTsKICAgIH0KICAgIGFzeW5jIHJlYWRGaWxlKG9wdGlvbnMgPSB7fSkgewogICAgICBsZXQgZW5jb2Rpbmc7CiAgICAgIGxldCBvcHRzOwogICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICJzdHJpbmciKSB7CiAgICAgICAgZW5jb2RpbmcgPSBvcHRpb25zOwogICAgICAgIG9wdHMgPSB7fTsKICAgICAgfSBlbHNlIHsKICAgICAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7CiAgICAgICAgb3B0cyA9IG9wdGlvbnM7CiAgICAgICAgZGVsZXRlIG9wdHMuZW5jb2Rpbmc7CiAgICAgIH0KICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgIGNvbnN0IGFyZ3MgPSB7CiAgICAgICAgaGVhZGVycywKICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgIHJlZGlyZWN0OiAiZm9sbG93IiwKICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgc2lnbmFsLAogICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcywKICAgICAgICAuLi5vdmVycmlkZXMKICAgICAgfTsKICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgaWYgKCFyZXNwb25zZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiZ2VuZXJpYy1maWxlaGFuZGxlIGZhaWxlZCB0byBmZXRjaCIpOwogICAgICB9CiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkgewogICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSBmZXRjaGluZyAke3RoaXMudXJsfWApLCB7CiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cwogICAgICAgIH0pOwogICAgICB9CiAgICAgIGlmIChlbmNvZGluZyA9PT0gInV0ZjgiKSB7CiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTsKICAgICAgfQogICAgICBpZiAoZW5jb2RpbmcpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGVuY29kaW5nOiAke2VuY29kaW5nfWApOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICB9CiAgICBhc3luYyBzdGF0KCkgewogICAgICBpZiAoIXRoaXMuX3N0YXQpIHsKICAgICAgICBjb25zdCBidWYgPSBpbXBvcnRfYnVmZmVyMi5CdWZmZXIuYWxsb2NVbnNhZmUoMTApOwogICAgICAgIGF3YWl0IHRoaXMucmVhZChidWYsIDAsIDEwLCAwKTsKICAgICAgICBpZiAoIXRoaXMuX3N0YXQpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGRldGVybWluZSBzaXplIG9mIGZpbGUgYXQgJHt0aGlzLnVybH1gKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuX3N0YXQ7CiAgICB9CiAgICBhc3luYyBjbG9zZSgpIHsKICAgICAgcmV0dXJuOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9nZW5lcmljLWZpbGVoYW5kbGVAMy4xLjEvbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vYmxvYkZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXIzID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2dlbmVyaWMtZmlsZWhhbmRsZUAzLjEuMS9ub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9maWxlaGFuZGxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmd6Zi1maWxlaGFuZGxlQDEuNC43L25vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmd6Zi1maWxlaGFuZGxlQDEuNC43L25vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2JnekZpbGVoYW5kbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXI2ID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JnemYtZmlsZWhhbmRsZUAxLjQuNy9ub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS91bnppcC1wYWtvLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyNCA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CiAgdmFyIGltcG9ydF9wYWtvID0gX190b01vZHVsZShyZXF1aXJlX3Bha28oKSk7CiAgYXN5bmMgZnVuY3Rpb24gdW56aXAoaW5wdXREYXRhKSB7CiAgICB0cnkgewogICAgICBsZXQgc3RybTsKICAgICAgbGV0IHBvcyA9IDA7CiAgICAgIGxldCBpID0gMDsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGxldCB0b3RhbFNpemUgPSAwOwogICAgICBsZXQgaW5mbGF0b3I7CiAgICAgIGRvIHsKICAgICAgICBjb25zdCByZW1haW5pbmdJbnB1dCA9IGlucHV0RGF0YS5zdWJhcnJheShwb3MpOwogICAgICAgIGluZmxhdG9yID0gbmV3IGltcG9ydF9wYWtvLkluZmxhdGUoKTsKICAgICAgICAoeyBzdHJtIH0gPSBpbmZsYXRvcik7CiAgICAgICAgaW5mbGF0b3IucHVzaChyZW1haW5pbmdJbnB1dCwgaW1wb3J0X3Bha28uWl9TWU5DX0ZMVVNIKTsKICAgICAgICBpZiAoaW5mbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0b3IubXNnKTsKICAgICAgICB9CiAgICAgICAgcG9zICs9IHN0cm0ubmV4dF9pbjsKICAgICAgICBjaHVua3NbaV0gPSBpbmZsYXRvci5yZXN1bHQ7CiAgICAgICAgdG90YWxTaXplICs9IGNodW5rc1tpXS5sZW5ndGg7CiAgICAgICAgaSArPSAxOwogICAgICB9IHdoaWxlIChzdHJtLmF2YWlsX2luKTsKICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxTaXplKTsKICAgICAgZm9yIChsZXQgaTIgPSAwLCBvZmZzZXQgPSAwOyBpMiA8IGNodW5rcy5sZW5ndGg7IGkyKyspIHsKICAgICAgICByZXN1bHQuc2V0KGNodW5rc1tpMl0sIG9mZnNldCk7CiAgICAgICAgb2Zmc2V0ICs9IGNodW5rc1tpMl0ubGVuZ3RoOwogICAgICB9CiAgICAgIHJldHVybiBpbXBvcnRfYnVmZmVyNC5CdWZmZXIuZnJvbShyZXN1bHQpOwogICAgfSBjYXRjaCAoZSkgewogICAgICBpZiAoYCR7ZX1gLm1hdGNoKC9pbmNvcnJlY3QgaGVhZGVyIGNoZWNrLykpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInByb2JsZW0gZGVjb21wcmVzc2luZyBibG9jazogaW5jb3JyZWN0IGd6aXAgaGVhZGVyIGNoZWNrIik7CiAgICAgIH0KICAgICAgdGhyb3cgZTsKICAgIH0KICB9CiAgYXN5bmMgZnVuY3Rpb24gdW56aXBDaHVua1NsaWNlKGlucHV0RGF0YSwgY2h1bmspIHsKICAgIHRyeSB7CiAgICAgIGxldCBzdHJtOwogICAgICBjb25zdCB7IG1pbnYsIG1heHYgfSA9IGNodW5rOwogICAgICBsZXQgY3BvcyA9IG1pbnYuYmxvY2tQb3NpdGlvbjsKICAgICAgbGV0IGRwb3MgPSBtaW52LmRhdGFQb3NpdGlvbjsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGNvbnN0IGNwb3NpdGlvbnMgPSBbXTsKICAgICAgY29uc3QgZHBvc2l0aW9ucyA9IFtdOwogICAgICBsZXQgdG90YWxTaXplID0gMDsKICAgICAgbGV0IGkgPSAwOwogICAgICBkbyB7CiAgICAgICAgY29uc3QgcmVtYWluaW5nSW5wdXQgPSBpbnB1dERhdGEuc3ViYXJyYXkoY3BvcyAtIG1pbnYuYmxvY2tQb3NpdGlvbik7CiAgICAgICAgY29uc3QgaW5mbGF0b3IgPSBuZXcgaW1wb3J0X3Bha28uSW5mbGF0ZSgpOwogICAgICAgICh7IHN0cm0gfSA9IGluZmxhdG9yKTsKICAgICAgICBpbmZsYXRvci5wdXNoKHJlbWFpbmluZ0lucHV0LCBpbXBvcnRfcGFrby5aX1NZTkNfRkxVU0gpOwogICAgICAgIGlmIChpbmZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmZsYXRvci5tc2cpOwogICAgICAgIH0KICAgICAgICBjb25zdCBidWZmZXIyID0gaW5mbGF0b3IucmVzdWx0OwogICAgICAgIGNodW5rcy5wdXNoKGJ1ZmZlcjIpOwogICAgICAgIGxldCBsZW4gPSBidWZmZXIyLmxlbmd0aDsKICAgICAgICBjcG9zaXRpb25zLnB1c2goY3Bvcyk7CiAgICAgICAgZHBvc2l0aW9ucy5wdXNoKGRwb3MpOwogICAgICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAxICYmIG1pbnYuZGF0YVBvc2l0aW9uKSB7CiAgICAgICAgICBjaHVua3NbMF0gPSBjaHVua3NbMF0uc3ViYXJyYXkobWludi5kYXRhUG9zaXRpb24pOwogICAgICAgICAgbGVuID0gY2h1bmtzWzBdLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgY29uc3Qgb3JpZ0Nwb3MgPSBjcG9zOwogICAgICAgIGNwb3MgKz0gc3RybS5uZXh0X2luOwogICAgICAgIGRwb3MgKz0gbGVuOwogICAgICAgIGlmIChvcmlnQ3BvcyA+PSBtYXh2LmJsb2NrUG9zaXRpb24pIHsKICAgICAgICAgIGNodW5rc1tpXSA9IGNodW5rc1tpXS5zdWJhcnJheSgwLCBtYXh2LmJsb2NrUG9zaXRpb24gPT09IG1pbnYuYmxvY2tQb3NpdGlvbiA/IG1heHYuZGF0YVBvc2l0aW9uIC0gbWludi5kYXRhUG9zaXRpb24gKyAxIDogbWF4di5kYXRhUG9zaXRpb24gKyAxKTsKICAgICAgICAgIGNwb3NpdGlvbnMucHVzaChjcG9zKTsKICAgICAgICAgIGRwb3NpdGlvbnMucHVzaChkcG9zKTsKICAgICAgICAgIHRvdGFsU2l6ZSArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIHRvdGFsU2l6ZSArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgIGkrKzsKICAgICAgfSB3aGlsZSAoc3RybS5hdmFpbF9pbik7CiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsU2l6ZSk7CiAgICAgIGZvciAobGV0IGkyID0gMCwgb2Zmc2V0ID0gMDsgaTIgPCBjaHVua3MubGVuZ3RoOyBpMisrKSB7CiAgICAgICAgcmVzdWx0LnNldChjaHVua3NbaTJdLCBvZmZzZXQpOwogICAgICAgIG9mZnNldCArPSBjaHVua3NbaTJdLmxlbmd0aDsKICAgICAgfQogICAgICBjb25zdCBidWZmZXIgPSBpbXBvcnRfYnVmZmVyNC5CdWZmZXIuZnJvbShyZXN1bHQpOwogICAgICByZXR1cm4geyBidWZmZXIsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgaWYgKGAke2V9YC5tYXRjaCgvaW5jb3JyZWN0IGhlYWRlciBjaGVjay8pKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJwcm9ibGVtIGRlY29tcHJlc3NpbmcgYmxvY2s6IGluY29ycmVjdCBnemlwIGhlYWRlciBjaGVjayIpOwogICAgICB9CiAgICAgIHRocm93IGU7CiAgICB9CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmd6Zi1maWxlaGFuZGxlQDEuNC43L25vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2d6aUluZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfbG9uZyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb25nKCkpOwogIHZhciBpbXBvcnRfYnVmZmVyNSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCt0YWJpeEAxLjUuMTEvbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS91dGlsLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGxvbmdUb051bWJlcihsb25nKSB7CiAgICBpZiAobG9uZy5ncmVhdGVyVGhhbihOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgfHwgbG9uZy5sZXNzVGhhbihOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbnRlZ2VyIG92ZXJmbG93Iik7CiAgICB9CiAgICByZXR1cm4gbG9uZy50b051bWJlcigpOwogIH0KICB2YXIgQWJvcnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3IgewogIH07CiAgZnVuY3Rpb24gY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpIHsKICAgIGlmICghc2lnbmFsKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmIChzaWduYWwuYWJvcnRlZCkgewogICAgICBpZiAodHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCJhYm9ydGVkIiwgIkFib3J0RXJyb3IiKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCBlID0gbmV3IEFib3J0RXJyb3IoImFib3J0ZWQiKTsKICAgICAgICBlLmNvZGUgPSAiRVJSX0FCT1JURUQiOwogICAgICAgIHRocm93IGU7CiAgICAgIH0KICAgIH0KICB9CiAgZnVuY3Rpb24gY2FuTWVyZ2VCbG9ja3MoY2h1bmsxLCBjaHVuazIpIHsKICAgIHJldHVybiBjaHVuazIubWludi5ibG9ja1Bvc2l0aW9uIC0gY2h1bmsxLm1heHYuYmxvY2tQb3NpdGlvbiA8IDY1ZTMgJiYgY2h1bmsyLm1heHYuYmxvY2tQb3NpdGlvbiAtIGNodW5rMS5taW52LmJsb2NrUG9zaXRpb24gPCA1ZTY7CiAgfQogIGZ1bmN0aW9uIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbG93ZXN0KSB7CiAgICBjb25zdCBtZXJnZWRDaHVua3MgPSBbXTsKICAgIGxldCBsYXN0Q2h1bmsgPSBudWxsOwogICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIGNodW5rczsKICAgIH0KICAgIGNodW5rcy5zb3J0KGZ1bmN0aW9uKGMwLCBjMSkgewogICAgICBjb25zdCBkaWYgPSBjMC5taW52LmJsb2NrUG9zaXRpb24gLSBjMS5taW52LmJsb2NrUG9zaXRpb247CiAgICAgIGlmIChkaWYgIT09IDApIHsKICAgICAgICByZXR1cm4gZGlmOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBjMC5taW52LmRhdGFQb3NpdGlvbiAtIGMxLm1pbnYuZGF0YVBvc2l0aW9uOwogICAgICB9CiAgICB9KTsKICAgIGNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gewogICAgICBpZiAoIWxvd2VzdCB8fCBjaHVuay5tYXh2LmNvbXBhcmVUbyhsb3dlc3QpID4gMCkgewogICAgICAgIGlmIChsYXN0Q2h1bmsgPT09IG51bGwpIHsKICAgICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGNodW5rKTsKICAgICAgICAgIGxhc3RDaHVuayA9IGNodW5rOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoY2FuTWVyZ2VCbG9ja3MobGFzdENodW5rLCBjaHVuaykpIHsKICAgICAgICAgICAgaWYgKGNodW5rLm1heHYuY29tcGFyZVRvKGxhc3RDaHVuay5tYXh2KSA+IDApIHsKICAgICAgICAgICAgICBsYXN0Q2h1bmsubWF4diA9IGNodW5rLm1heHY7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGNodW5rKTsKICAgICAgICAgICAgbGFzdENodW5rID0gY2h1bms7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9KTsKICAgIHJldHVybiBtZXJnZWRDaHVua3M7CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdGJpLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfbG9uZzIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbG9uZygpKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK3RhYml4QDEuNS4xMS9ub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3ZpcnR1YWxPZmZzZXQuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIFZpcnR1YWxPZmZzZXQgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3RvcihibG9ja1Bvc2l0aW9uLCBkYXRhUG9zaXRpb24pIHsKICAgICAgdGhpcy5ibG9ja1Bvc2l0aW9uID0gYmxvY2tQb3NpdGlvbjsKICAgICAgdGhpcy5kYXRhUG9zaXRpb24gPSBkYXRhUG9zaXRpb247CiAgICB9CiAgICB0b1N0cmluZygpIHsKICAgICAgcmV0dXJuIGAke3RoaXMuYmxvY2tQb3NpdGlvbn06JHt0aGlzLmRhdGFQb3NpdGlvbn1gOwogICAgfQogICAgY29tcGFyZVRvKGIpIHsKICAgICAgcmV0dXJuIHRoaXMuYmxvY2tQb3NpdGlvbiAtIGIuYmxvY2tQb3NpdGlvbiB8fCB0aGlzLmRhdGFQb3NpdGlvbiAtIGIuZGF0YVBvc2l0aW9uOwogICAgfQogICAgc3RhdGljIG1pbiguLi5hcmdzKSB7CiAgICAgIGxldCBtaW47CiAgICAgIGxldCBpID0gMDsKICAgICAgZm9yICg7ICFtaW47IGkgKz0gMSkgewogICAgICAgIG1pbiA9IGFyZ3NbaV07CiAgICAgIH0KICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgaWYgKG1pbi5jb21wYXJlVG8oYXJnc1tpXSkgPiAwKSB7CiAgICAgICAgICBtaW4gPSBhcmdzW2ldOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gbWluOwogICAgfQogIH07CiAgZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCBvZmZzZXQgPSAwLCBiaWdlbmRpYW4gPSBmYWxzZSkgewogICAgaWYgKGJpZ2VuZGlhbikgewogICAgICB0aHJvdyBuZXcgRXJyb3IoImJpZy1lbmRpYW4gdmlydHVhbCBmaWxlIG9mZnNldHMgbm90IGltcGxlbWVudGVkIik7CiAgICB9CiAgICByZXR1cm4gbmV3IFZpcnR1YWxPZmZzZXQoYnl0ZXNbb2Zmc2V0ICsgN10gKiAxMDk5NTExNjI3Nzc2ICsgYnl0ZXNbb2Zmc2V0ICsgNl0gKiA0Mjk0OTY3Mjk2ICsgYnl0ZXNbb2Zmc2V0ICsgNV0gKiAxNjc3NzIxNiArIGJ5dGVzW29mZnNldCArIDRdICogNjU1MzYgKyBieXRlc1tvZmZzZXQgKyAzXSAqIDI1NiArIGJ5dGVzW29mZnNldCArIDJdLCBieXRlc1tvZmZzZXQgKyAxXSA8PCA4IHwgYnl0ZXNbb2Zmc2V0XSk7CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vY2h1bmsuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIENodW5rID0gY2xhc3MgewogICAgY29uc3RydWN0b3IobWludiwgbWF4diwgYmluLCBmZXRjaGVkU2l6ZSA9IHZvaWQgMCkgewogICAgICB0aGlzLm1pbnYgPSBtaW52OwogICAgICB0aGlzLm1heHYgPSBtYXh2OwogICAgICB0aGlzLmJpbiA9IGJpbjsKICAgICAgdGhpcy5fZmV0Y2hlZFNpemUgPSBmZXRjaGVkU2l6ZTsKICAgIH0KICAgIHRvVW5pcXVlU3RyaW5nKCkgewogICAgICByZXR1cm4gYCR7dGhpcy5taW52fS4uJHt0aGlzLm1heHZ9IChiaW4gJHt0aGlzLmJpbn0sIGZldGNoZWRTaXplICR7dGhpcy5mZXRjaGVkU2l6ZSgpfSlgOwogICAgfQogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiB0aGlzLnRvVW5pcXVlU3RyaW5nKCk7CiAgICB9CiAgICBjb21wYXJlVG8oYikgewogICAgICByZXR1cm4gdGhpcy5taW52LmNvbXBhcmVUbyhiLm1pbnYpIHx8IHRoaXMubWF4di5jb21wYXJlVG8oYi5tYXh2KSB8fCB0aGlzLmJpbiAtIGIuYmluOwogICAgfQogICAgZmV0Y2hlZFNpemUoKSB7CiAgICAgIGlmICh0aGlzLl9mZXRjaGVkU2l6ZSAhPT0gdm9pZCAwKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoZWRTaXplOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLm1heHYuYmxvY2tQb3NpdGlvbiArICgxIDw8IDE2KSAtIHRoaXMubWludi5ibG9ja1Bvc2l0aW9uOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCt0YWJpeEAxLjUuMTEvbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9pbmRleEZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIEluZGV4RmlsZSA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKHsgZmlsZWhhbmRsZSwgcmVuYW1lUmVmU2VxcyA9IChuKSA9PiBuIH0pIHsKICAgICAgdGhpcy5maWxlaGFuZGxlID0gZmlsZWhhbmRsZTsKICAgICAgdGhpcy5yZW5hbWVSZWZTZXEgPSByZW5hbWVSZWZTZXFzOwogICAgfQogICAgYXN5bmMgZ2V0TWV0YWRhdGEob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgaW5kaWNlcywgLi4ucmVzdCB9ID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgcmV0dXJuIHJlc3Q7CiAgICB9CiAgICBfZmluZEZpcnN0RGF0YShjdXJyZW50RmRsLCB2aXJ0dWFsT2Zmc2V0KSB7CiAgICAgIGlmIChjdXJyZW50RmRsKSB7CiAgICAgICAgcmV0dXJuIGN1cnJlbnRGZGwuY29tcGFyZVRvKHZpcnR1YWxPZmZzZXQpID4gMCA/IHZpcnR1YWxPZmZzZXQgOiBjdXJyZW50RmRsOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB2aXJ0dWFsT2Zmc2V0OwogICAgICB9CiAgICB9CiAgICBhc3luYyBwYXJzZShvcHRzID0ge30pIHsKICAgICAgaWYgKCF0aGlzLnBhcnNlUCkgewogICAgICAgIHRoaXMucGFyc2VQID0gdGhpcy5fcGFyc2Uob3B0cykuY2F0Y2goKGUpID0+IHsKICAgICAgICAgIHRoaXMucGFyc2VQID0gdm9pZCAwOwogICAgICAgICAgdGhyb3cgZTsKICAgICAgICB9KTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5wYXJzZVA7CiAgICB9CiAgICBhc3luYyBoYXNSZWZTZXEoc2VxSWQsIG9wdHMgPSB7fSkgewogICAgICByZXR1cm4gISEoKGF3YWl0IHRoaXMucGFyc2Uob3B0cykpLmluZGljZXNbc2VxSWRdIHx8IHt9KS5iaW5JbmRleDsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdGJpLmpzCiAgdmFyIFRCSV9NQUdJQyA9IDIxNTc4MzI0OwogIHZhciBUQURfTElEWF9TSElGVCA9IDE0OwogIGZ1bmN0aW9uIHJlZzJiaW5zKGJlZywgZW5kKSB7CiAgICBiZWcgKz0gMTsKICAgIGVuZCAtPSAxOwogICAgcmV0dXJuIFsKICAgICAgWzAsIDBdLAogICAgICBbMSArIChiZWcgPj4gMjYpLCAxICsgKGVuZCA+PiAyNildLAogICAgICBbOSArIChiZWcgPj4gMjMpLCA5ICsgKGVuZCA+PiAyMyldLAogICAgICBbNzMgKyAoYmVnID4+IDIwKSwgNzMgKyAoZW5kID4+IDIwKV0sCiAgICAgIFs1ODUgKyAoYmVnID4+IDE3KSwgNTg1ICsgKGVuZCA+PiAxNyldLAogICAgICBbNDY4MSArIChiZWcgPj4gMTQpLCA0NjgxICsgKGVuZCA+PiAxNCldCiAgICBdOwogIH0KICB2YXIgVGFiaXhJbmRleCA9IGNsYXNzIGV4dGVuZHMgSW5kZXhGaWxlIHsKICAgIGFzeW5jIGxpbmVDb3VudChyZWZOYW1lLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV07CiAgICAgIGNvbnN0IGlkeCA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFpZHgpIHsKICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgY29uc3QgeyBzdGF0cyB9ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoc3RhdHMpIHsKICAgICAgICByZXR1cm4gc3RhdHMubGluZUNvdW50OwogICAgICB9CiAgICAgIHJldHVybiAtMTsKICAgIH0KICAgIGFzeW5jIF9wYXJzZShvcHRzID0ge30pIHsKICAgICAgY29uc3QgYnVmID0gYXdhaXQgdGhpcy5maWxlaGFuZGxlLnJlYWRGaWxlKG9wdHMpOwogICAgICBjb25zdCBieXRlcyA9IGF3YWl0IHVuemlwKGJ1Zik7CiAgICAgIGNoZWNrQWJvcnRTaWduYWwob3B0cy5zaWduYWwpOwogICAgICBpZiAoYnl0ZXMucmVhZFVJbnQzMkxFKDApICE9PSBUQklfTUFHSUMpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIFRCSSBmaWxlIik7CiAgICAgIH0KICAgICAgY29uc3QgcmVmQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRSg0KTsKICAgICAgY29uc3QgZm9ybWF0RmxhZ3MgPSBieXRlcy5yZWFkSW50MzJMRSg4KTsKICAgICAgY29uc3QgY29vcmRpbmF0ZVR5cGUgPSBmb3JtYXRGbGFncyAmIDY1NTM2ID8gInplcm8tYmFzZWQtaGFsZi1vcGVuIiA6ICIxLWJhc2VkLWNsb3NlZCI7CiAgICAgIGNvbnN0IGZvcm1hdE9wdHMgPSB7CiAgICAgICAgMDogImdlbmVyaWMiLAogICAgICAgIDE6ICJTQU0iLAogICAgICAgIDI6ICJWQ0YiCiAgICAgIH07CiAgICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdE9wdHNbZm9ybWF0RmxhZ3MgJiAxNV07CiAgICAgIGlmICghZm9ybWF0KSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIFRhYml4IHByZXNldCBmb3JtYXQgZmxhZ3MgJHtmb3JtYXRGbGFnc31gKTsKICAgICAgfQogICAgICBjb25zdCBjb2x1bW5OdW1iZXJzID0gewogICAgICAgIHJlZjogYnl0ZXMucmVhZEludDMyTEUoMTIpLAogICAgICAgIHN0YXJ0OiBieXRlcy5yZWFkSW50MzJMRSgxNiksCiAgICAgICAgZW5kOiBieXRlcy5yZWFkSW50MzJMRSgyMCkKICAgICAgfTsKICAgICAgY29uc3QgbWV0YVZhbHVlID0gYnl0ZXMucmVhZEludDMyTEUoMjQpOwogICAgICBjb25zdCBkZXB0aCA9IDU7CiAgICAgIGNvbnN0IG1heEJpbk51bWJlciA9ICgoMSA8PCAoZGVwdGggKyAxKSAqIDMpIC0gMSkgLyA3OwogICAgICBjb25zdCBtYXhSZWZMZW5ndGggPSAyICoqICgxNCArIGRlcHRoICogMyk7CiAgICAgIGNvbnN0IG1ldGFDaGFyID0gbWV0YVZhbHVlID8gU3RyaW5nLmZyb21DaGFyQ29kZShtZXRhVmFsdWUpIDogbnVsbDsKICAgICAgY29uc3Qgc2tpcExpbmVzID0gYnl0ZXMucmVhZEludDMyTEUoMjgpOwogICAgICBjb25zdCBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDMyKTsKICAgICAgY29uc3QgeyByZWZOYW1lVG9JZCwgcmVmSWRUb05hbWUgfSA9IHRoaXMuX3BhcnNlTmFtZUJ5dGVzKGJ5dGVzLnNsaWNlKDM2LCAzNiArIG5hbWVTZWN0aW9uTGVuZ3RoKSk7CiAgICAgIGxldCBjdXJyT2Zmc2V0ID0gMzYgKyBuYW1lU2VjdGlvbkxlbmd0aDsKICAgICAgbGV0IGZpcnN0RGF0YUxpbmU7CiAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgQXJyYXkocmVmQ291bnQpLmZpbGwoMCkubWFwKCgpID0+IHsKICAgICAgICBjb25zdCBiaW5Db3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICBjb25zdCBiaW5JbmRleCA9IHt9OwogICAgICAgIGxldCBzdGF0czsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJpbkNvdW50OyBqICs9IDEpIHsKICAgICAgICAgIGNvbnN0IGJpbiA9IGJ5dGVzLnJlYWRVSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgIGlmIChiaW4gPiBtYXhCaW5OdW1iZXIgKyAxKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigidGFiaXggaW5kZXggY29udGFpbnMgdG9vIG1hbnkgYmlucywgcGxlYXNlIHVzZSBhIENTSSBpbmRleCIpOwogICAgICAgICAgfSBlbHNlIGlmIChiaW4gPT09IG1heEJpbk51bWJlciArIDEpIHsKICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICAgIGlmIChjaHVua0NvdW50ID09PSAyKSB7CiAgICAgICAgICAgICAgc3RhdHMgPSB0aGlzLnBhcnNlUHNldWRvQmluKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDE2ICogY2h1bmtDb3VudDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgICAgICBjb25zdCBjaHVua3MgPSBuZXcgQXJyYXkoY2h1bmtDb3VudCk7CiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2h1bmtDb3VudDsgayArPSAxKSB7CiAgICAgICAgICAgICAgY29uc3QgdSA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldCk7CiAgICAgICAgICAgICAgY29uc3QgdiA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldCArIDgpOwogICAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgICAgZmlyc3REYXRhTGluZSA9IHRoaXMuX2ZpbmRGaXJzdERhdGEoZmlyc3REYXRhTGluZSwgdSk7CiAgICAgICAgICAgICAgY2h1bmtzW2tdID0gbmV3IENodW5rKHUsIHYsIGJpbik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYmluSW5kZXhbYmluXSA9IGNodW5rczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgbGluZWFyQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgbGluZWFySW5kZXggPSBuZXcgQXJyYXkobGluZWFyQ291bnQpOwogICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGluZWFyQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgbGluZWFySW5kZXhba10gPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgY3Vyck9mZnNldCArPSA4OwogICAgICAgICAgZmlyc3REYXRhTGluZSA9IHRoaXMuX2ZpbmRGaXJzdERhdGEoZmlyc3REYXRhTGluZSwgbGluZWFySW5kZXhba10pOwogICAgICAgIH0KICAgICAgICByZXR1cm4geyBiaW5JbmRleCwgbGluZWFySW5kZXgsIHN0YXRzIH07CiAgICAgIH0pOwogICAgICByZXR1cm4gewogICAgICAgIGluZGljZXMsCiAgICAgICAgbWV0YUNoYXIsCiAgICAgICAgbWF4QmluTnVtYmVyLAogICAgICAgIG1heFJlZkxlbmd0aCwKICAgICAgICBza2lwTGluZXMsCiAgICAgICAgZmlyc3REYXRhTGluZSwKICAgICAgICBjb2x1bW5OdW1iZXJzLAogICAgICAgIGNvb3JkaW5hdGVUeXBlLAogICAgICAgIGZvcm1hdCwKICAgICAgICByZWZJZFRvTmFtZSwKICAgICAgICByZWZOYW1lVG9JZCwKICAgICAgICBtYXhCbG9ja1NpemU6IDEgPDwgMTYKICAgICAgfTsKICAgIH0KICAgIHBhcnNlUHNldWRvQmluKGJ5dGVzLCBvZmZzZXQpIHsKICAgICAgY29uc3QgbGluZUNvdW50ID0gbG9uZ1RvTnVtYmVyKGltcG9ydF9sb25nMi5kZWZhdWx0LmZyb21CeXRlc0xFKGJ5dGVzLnNsaWNlKG9mZnNldCArIDE2LCBvZmZzZXQgKyAyNCksIHRydWUpKTsKICAgICAgcmV0dXJuIHsgbGluZUNvdW50IH07CiAgICB9CiAgICBfcGFyc2VOYW1lQnl0ZXMobmFtZXNCeXRlcykgewogICAgICBsZXQgY3VyclJlZklkID0gMDsKICAgICAgbGV0IGN1cnJOYW1lU3RhcnQgPSAwOwogICAgICBjb25zdCByZWZJZFRvTmFtZSA9IFtdOwogICAgICBjb25zdCByZWZOYW1lVG9JZCA9IHt9OwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzQnl0ZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBpZiAoIW5hbWVzQnl0ZXNbaV0pIHsKICAgICAgICAgIGlmIChjdXJyTmFtZVN0YXJ0IDwgaSkgewogICAgICAgICAgICBsZXQgcmVmTmFtZSA9IG5hbWVzQnl0ZXMudG9TdHJpbmcoInV0ZjgiLCBjdXJyTmFtZVN0YXJ0LCBpKTsKICAgICAgICAgICAgcmVmTmFtZSA9IHRoaXMucmVuYW1lUmVmU2VxKHJlZk5hbWUpOwogICAgICAgICAgICByZWZJZFRvTmFtZVtjdXJyUmVmSWRdID0gcmVmTmFtZTsKICAgICAgICAgICAgcmVmTmFtZVRvSWRbcmVmTmFtZV0gPSBjdXJyUmVmSWQ7CiAgICAgICAgICB9CiAgICAgICAgICBjdXJyTmFtZVN0YXJ0ID0gaSArIDE7CiAgICAgICAgICBjdXJyUmVmSWQgKz0gMTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH07CiAgICB9CiAgICBhc3luYyBibG9ja3NGb3JSYW5nZShyZWZOYW1lLCBtaW4sIG1heCwgb3B0cyA9IHt9KSB7CiAgICAgIGlmIChtaW4gPCAwKSB7CiAgICAgICAgbWluID0gMDsKICAgICAgfQogICAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpOwogICAgICBpZiAoIWluZGV4RGF0YSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCByZWZJZCA9IGluZGV4RGF0YS5yZWZOYW1lVG9JZFtyZWZOYW1lXTsKICAgICAgY29uc3QgYmEgPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghYmEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3QgbWluT2Zmc2V0ID0gYmEubGluZWFySW5kZXgubGVuZ3RoID8gYmEubGluZWFySW5kZXhbbWluID4+IFRBRF9MSURYX1NISUZUID49IGJhLmxpbmVhckluZGV4Lmxlbmd0aCA/IGJhLmxpbmVhckluZGV4Lmxlbmd0aCAtIDEgOiBtaW4gPj4gVEFEX0xJRFhfU0hJRlRdIDogbmV3IFZpcnR1YWxPZmZzZXQoMCwgMCk7CiAgICAgIGlmICghbWluT2Zmc2V0KSB7CiAgICAgICAgY29uc29sZS53YXJuKCJxdWVyeWluZyBvdXRzaWRlIG9mIHBvc3NpYmxlIHRhYml4IHJhbmdlIik7CiAgICAgIH0KICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdCaW5zID0gcmVnMmJpbnMobWluLCBtYXgpOwogICAgICBjb25zdCBjaHVua3MgPSBbXTsKICAgICAgZm9yIChjb25zdCBbc3RhcnQsIGVuZF0gb2Ygb3ZlcmxhcHBpbmdCaW5zKSB7CiAgICAgICAgZm9yIChsZXQgYmluID0gc3RhcnQ7IGJpbiA8PSBlbmQ7IGJpbisrKSB7CiAgICAgICAgICBpZiAoYmEuYmluSW5kZXhbYmluXSkgewogICAgICAgICAgICBjb25zdCBiaW5DaHVua3MgPSBiYS5iaW5JbmRleFtiaW5dOwogICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGJpbkNodW5rcy5sZW5ndGg7ICsrYykgewogICAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBDaHVuayhiaW5DaHVua3NbY10ubWludiwgYmluQ2h1bmtzW2NdLm1heHYsIGJpbikpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnN0IG5pbnR2ID0gYmEubGluZWFySW5kZXgubGVuZ3RoOwogICAgICBsZXQgbG93ZXN0ID0gbnVsbDsKICAgICAgY29uc3QgbWluTGluID0gTWF0aC5taW4obWluID4+IDE0LCBuaW50diAtIDEpOwogICAgICBjb25zdCBtYXhMaW4gPSBNYXRoLm1pbihtYXggPj4gMTQsIG5pbnR2IC0gMSk7CiAgICAgIGZvciAobGV0IGkgPSBtaW5MaW47IGkgPD0gbWF4TGluOyArK2kpIHsKICAgICAgICBjb25zdCB2cCA9IGJhLmxpbmVhckluZGV4W2ldOwogICAgICAgIGlmICh2cCkgewogICAgICAgICAgaWYgKCFsb3dlc3QgfHwgdnAuY29tcGFyZVRvKGxvd2VzdCkgPCAwKSB7CiAgICAgICAgICAgIGxvd2VzdCA9IHZwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gb3B0aW1pemVDaHVua3MoY2h1bmtzLCBsb3dlc3QpOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCt0YWJpeEAxLjUuMTEvbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9jc2kuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb25nMyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb25nKCkpOwogIHZhciBDU0kxX01BR0lDID0gMjE1ODI2NTk7CiAgdmFyIENTSTJfTUFHSUMgPSAzODM1OTg3NTsKICBmdW5jdGlvbiBsc2hpZnQobnVtLCBiaXRzKSB7CiAgICByZXR1cm4gbnVtICogMiAqKiBiaXRzOwogIH0KICBmdW5jdGlvbiByc2hpZnQobnVtLCBiaXRzKSB7CiAgICByZXR1cm4gTWF0aC5mbG9vcihudW0gLyAyICoqIGJpdHMpOwogIH0KICB2YXIgQ1NJID0gY2xhc3MgZXh0ZW5kcyBJbmRleEZpbGUgewogICAgY29uc3RydWN0b3IoYXJncykgewogICAgICBzdXBlcihhcmdzKTsKICAgICAgdGhpcy5tYXhCaW5OdW1iZXIgPSAwOwogICAgICB0aGlzLmRlcHRoID0gMDsKICAgICAgdGhpcy5taW5TaGlmdCA9IDA7CiAgICB9CiAgICBhc3luYyBsaW5lQ291bnQocmVmTmFtZSwgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBpZHggPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghaWR4KSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHsgc3RhdHMgfSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKHN0YXRzKSB7CiAgICAgICAgcmV0dXJuIHN0YXRzLmxpbmVDb3VudDsKICAgICAgfQogICAgICByZXR1cm4gLTE7CiAgICB9CiAgICBhc3luYyBpbmRleENvdigpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJDU0kgaW5kZXhlcyBkbyBub3Qgc3VwcG9ydCBpbmRleGNvdiIpOwogICAgfQogICAgcGFyc2VBdXhEYXRhKGJ5dGVzLCBvZmZzZXQpIHsKICAgICAgY29uc3QgZm9ybWF0RmxhZ3MgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQpOwogICAgICBjb25zdCBjb29yZGluYXRlVHlwZSA9IGZvcm1hdEZsYWdzICYgNjU1MzYgPyAiemVyby1iYXNlZC1oYWxmLW9wZW4iIDogIjEtYmFzZWQtY2xvc2VkIjsKICAgICAgY29uc3QgZm9ybWF0ID0geyAwOiAiZ2VuZXJpYyIsIDE6ICJTQU0iLCAyOiAiVkNGIiB9W2Zvcm1hdEZsYWdzICYgMTVdOwogICAgICBpZiAoIWZvcm1hdCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBUYWJpeCBwcmVzZXQgZm9ybWF0IGZsYWdzICR7Zm9ybWF0RmxhZ3N9YCk7CiAgICAgIH0KICAgICAgY29uc3QgY29sdW1uTnVtYmVycyA9IHsKICAgICAgICByZWY6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDQpLAogICAgICAgIHN0YXJ0OiBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyA4KSwKICAgICAgICBlbmQ6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDEyKQogICAgICB9OwogICAgICBjb25zdCBtZXRhVmFsdWUgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAxNik7CiAgICAgIGNvbnN0IG1ldGFDaGFyID0gbWV0YVZhbHVlID8gU3RyaW5nLmZyb21DaGFyQ29kZShtZXRhVmFsdWUpIDogbnVsbDsKICAgICAgY29uc3Qgc2tpcExpbmVzID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMjApOwogICAgICBjb25zdCBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDI0KTsKICAgICAgY29uc3QgeyByZWZJZFRvTmFtZSwgcmVmTmFtZVRvSWQgfSA9IHRoaXMuX3BhcnNlTmFtZUJ5dGVzKGJ5dGVzLnNsaWNlKG9mZnNldCArIDI4LCBvZmZzZXQgKyAyOCArIG5hbWVTZWN0aW9uTGVuZ3RoKSk7CiAgICAgIHJldHVybiB7CiAgICAgICAgcmVmSWRUb05hbWUsCiAgICAgICAgcmVmTmFtZVRvSWQsCiAgICAgICAgc2tpcExpbmVzLAogICAgICAgIG1ldGFDaGFyLAogICAgICAgIGNvbHVtbk51bWJlcnMsCiAgICAgICAgZm9ybWF0LAogICAgICAgIGNvb3JkaW5hdGVUeXBlCiAgICAgIH07CiAgICB9CiAgICBfcGFyc2VOYW1lQnl0ZXMobmFtZXNCeXRlcykgewogICAgICBsZXQgY3VyclJlZklkID0gMDsKICAgICAgbGV0IGN1cnJOYW1lU3RhcnQgPSAwOwogICAgICBjb25zdCByZWZJZFRvTmFtZSA9IFtdOwogICAgICBjb25zdCByZWZOYW1lVG9JZCA9IHt9OwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzQnl0ZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBpZiAoIW5hbWVzQnl0ZXNbaV0pIHsKICAgICAgICAgIGlmIChjdXJyTmFtZVN0YXJ0IDwgaSkgewogICAgICAgICAgICBsZXQgcmVmTmFtZSA9IG5hbWVzQnl0ZXMudG9TdHJpbmcoInV0ZjgiLCBjdXJyTmFtZVN0YXJ0LCBpKTsKICAgICAgICAgICAgcmVmTmFtZSA9IHRoaXMucmVuYW1lUmVmU2VxKHJlZk5hbWUpOwogICAgICAgICAgICByZWZJZFRvTmFtZVtjdXJyUmVmSWRdID0gcmVmTmFtZTsKICAgICAgICAgICAgcmVmTmFtZVRvSWRbcmVmTmFtZV0gPSBjdXJyUmVmSWQ7CiAgICAgICAgICB9CiAgICAgICAgICBjdXJyTmFtZVN0YXJ0ID0gaSArIDE7CiAgICAgICAgICBjdXJyUmVmSWQgKz0gMTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH07CiAgICB9CiAgICBhc3luYyBfcGFyc2Uob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdW56aXAoYXdhaXQgdGhpcy5maWxlaGFuZGxlLnJlYWRGaWxlKG9wdHMpKTsKICAgICAgbGV0IGNzaVZlcnNpb247CiAgICAgIGlmIChieXRlcy5yZWFkVUludDMyTEUoMCkgPT09IENTSTFfTUFHSUMpIHsKICAgICAgICBjc2lWZXJzaW9uID0gMTsKICAgICAgfSBlbHNlIGlmIChieXRlcy5yZWFkVUludDMyTEUoMCkgPT09IENTSTJfTUFHSUMpIHsKICAgICAgICBjc2lWZXJzaW9uID0gMjsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIENTSSBmaWxlIik7CiAgICAgIH0KICAgICAgdGhpcy5taW5TaGlmdCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDQpOwogICAgICB0aGlzLmRlcHRoID0gYnl0ZXMucmVhZEludDMyTEUoOCk7CiAgICAgIHRoaXMubWF4QmluTnVtYmVyID0gKCgxIDw8ICh0aGlzLmRlcHRoICsgMSkgKiAzKSAtIDEpIC8gNzsKICAgICAgY29uc3QgbWF4UmVmTGVuZ3RoID0gMiAqKiAodGhpcy5taW5TaGlmdCArIHRoaXMuZGVwdGggKiAzKTsKICAgICAgY29uc3QgYXV4TGVuZ3RoID0gYnl0ZXMucmVhZEludDMyTEUoMTIpOwogICAgICBjb25zdCBhdXggPSBhdXhMZW5ndGggJiYgYXV4TGVuZ3RoID49IDMwID8gdGhpcy5wYXJzZUF1eERhdGEoYnl0ZXMsIDE2KSA6IHsKICAgICAgICByZWZJZFRvTmFtZTogW10sCiAgICAgICAgcmVmTmFtZVRvSWQ6IHt9LAogICAgICAgIG1ldGFDaGFyOiBudWxsLAogICAgICAgIGNvbHVtbk51bWJlcnM6IHsgcmVmOiAwLCBzdGFydDogMSwgZW5kOiAyIH0sCiAgICAgICAgY29vcmRpbmF0ZVR5cGU6ICJ6ZXJvLWJhc2VkLWhhbGYtb3BlbiIsCiAgICAgICAgZm9ybWF0OiAiZ2VuZXJpYyIKICAgICAgfTsKICAgICAgY29uc3QgcmVmQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRSgxNiArIGF1eExlbmd0aCk7CiAgICAgIGxldCBmaXJzdERhdGFMaW5lOwogICAgICBsZXQgY3Vyck9mZnNldCA9IDE2ICsgYXV4TGVuZ3RoICsgNDsKICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBBcnJheShyZWZDb3VudCkuZmlsbCgwKS5tYXAoKCkgPT4gewogICAgICAgIGNvbnN0IGJpbkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgIGNvbnN0IGJpbkluZGV4ID0ge307CiAgICAgICAgbGV0IHN0YXRzOwogICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmluQ291bnQ7IGogKz0gMSkgewogICAgICAgICAgY29uc3QgYmluID0gYnl0ZXMucmVhZFVJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgaWYgKGJpbiA+IHRoaXMubWF4QmluTnVtYmVyKSB7CiAgICAgICAgICAgIHN0YXRzID0gdGhpcy5wYXJzZVBzZXVkb0JpbihieXRlcywgY3Vyck9mZnNldCArIDQpOwogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQgKyA4ICsgNCArIDE2ICsgMTY7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjb25zdCBsb2Zmc2V0ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgNCk7CiAgICAgICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIGxvZmZzZXQpOwogICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCArIDEyKTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNjsKICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ291bnQpOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNodW5rQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgICAgIGNvbnN0IHUgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgICAgIGNvbnN0IHYgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQgKyA4KTsKICAgICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDE2OwogICAgICAgICAgICAgIGNodW5rc1trXSA9IG5ldyBDaHVuayh1LCB2LCBiaW4pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJpbkluZGV4W2Jpbl0gPSBjaHVua3M7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiB7IGJpbkluZGV4LCBzdGF0cyB9OwogICAgICB9KTsKICAgICAgcmV0dXJuIHsKICAgICAgICAuLi5hdXgsCiAgICAgICAgY3NpOiB0cnVlLAogICAgICAgIHJlZkNvdW50LAogICAgICAgIG1heEJsb2NrU2l6ZTogMSA8PCAxNiwKICAgICAgICBmaXJzdERhdGFMaW5lLAogICAgICAgIGNzaVZlcnNpb24sCiAgICAgICAgaW5kaWNlcywKICAgICAgICBkZXB0aDogdGhpcy5kZXB0aCwKICAgICAgICBtYXhCaW5OdW1iZXI6IHRoaXMubWF4QmluTnVtYmVyLAogICAgICAgIG1heFJlZkxlbmd0aAogICAgICB9OwogICAgfQogICAgcGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIG9mZnNldCkgewogICAgICBjb25zdCBsaW5lQ291bnQgPSBsb25nVG9OdW1iZXIoaW1wb3J0X2xvbmczLmRlZmF1bHQuZnJvbUJ5dGVzTEUoYnl0ZXMuc2xpY2Uob2Zmc2V0ICsgMjgsIG9mZnNldCArIDM2KSwgdHJ1ZSkpOwogICAgICByZXR1cm4geyBsaW5lQ291bnQgfTsKICAgIH0KICAgIGFzeW5jIGJsb2Nrc0ZvclJhbmdlKHJlZk5hbWUsIG1pbiwgbWF4LCBvcHRzID0ge30pIHsKICAgICAgaWYgKG1pbiA8IDApIHsKICAgICAgICBtaW4gPSAwOwogICAgICB9CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBiYSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFiYSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCBvdmVybGFwcGluZ0JpbnMgPSB0aGlzLnJlZzJiaW5zKG1pbiwgbWF4KTsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIG92ZXJsYXBwaW5nQmlucykgewogICAgICAgIGZvciAobGV0IGJpbiA9IHN0YXJ0OyBiaW4gPD0gZW5kOyBiaW4rKykgewogICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHsKICAgICAgICAgICAgY29uc3QgYmluQ2h1bmtzID0gYmEuYmluSW5kZXhbYmluXTsKICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBiaW5DaHVua3MubGVuZ3RoOyArK2MpIHsKICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQ2h1bmsoYmluQ2h1bmtzW2NdLm1pbnYsIGJpbkNodW5rc1tjXS5tYXh2LCBiaW4pKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gb3B0aW1pemVDaHVua3MoY2h1bmtzLCBuZXcgVmlydHVhbE9mZnNldCgwLCAwKSk7CiAgICB9CiAgICByZWcyYmlucyhiZWcsIGVuZCkgewogICAgICBiZWcgLT0gMTsKICAgICAgaWYgKGJlZyA8IDEpIHsKICAgICAgICBiZWcgPSAxOwogICAgICB9CiAgICAgIGlmIChlbmQgPiAyICoqIDUwKSB7CiAgICAgICAgZW5kID0gMiAqKiAzNDsKICAgICAgfQogICAgICBlbmQgLT0gMTsKICAgICAgbGV0IGwgPSAwOwogICAgICBsZXQgdCA9IDA7CiAgICAgIGxldCBzID0gdGhpcy5taW5TaGlmdCArIHRoaXMuZGVwdGggKiAzOwogICAgICBjb25zdCBiaW5zID0gW107CiAgICAgIGZvciAoOyBsIDw9IHRoaXMuZGVwdGg7IHMgLT0gMywgdCArPSBsc2hpZnQoMSwgbCAqIDMpLCBsICs9IDEpIHsKICAgICAgICBjb25zdCBiID0gdCArIHJzaGlmdChiZWcsIHMpOwogICAgICAgIGNvbnN0IGUgPSB0ICsgcnNoaWZ0KGVuZCwgcyk7CiAgICAgICAgaWYgKGUgLSBiICsgYmlucy5sZW5ndGggPiB0aGlzLm1heEJpbk51bWJlcikgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBxdWVyeSAke2JlZ30tJHtlbmR9IGlzIHRvbyBsYXJnZSBmb3IgY3VycmVudCBiaW5uaW5nIHNjaGVtZSAoc2hpZnQgJHt0aGlzLm1pblNoaWZ0fSwgZGVwdGggJHt0aGlzLmRlcHRofSksIHRyeSBhIHNtYWxsZXIgcXVlcnkgb3IgYSBjb2Fyc2VyIGluZGV4IGJpbm5pbmcgc2NoZW1lYCk7CiAgICAgICAgfQogICAgICAgIGJpbnMucHVzaChbYiwgZV0pOwogICAgICB9CiAgICAgIHJldHVybiBiaW5zOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCt0YWJpeEAxLjUuMTEvbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS90YWJpeEluZGV4ZWRGaWxlLmpzCiAgdmFyIGRlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09ICJ1bmRlZmluZWQiID8gbmV3IFRleHREZWNvZGVyKCJ1dGYtOCIpIDogdm9pZCAwOwogIGZ1bmN0aW9uIHRpbWVvdXQodGltZSkgewogICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUpKTsKICB9CiAgdmFyIFRhYml4SW5kZXhlZEZpbGUgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3Rvcih7IHBhdGgsIGZpbGVoYW5kbGUsIHRiaVBhdGgsIHRiaUZpbGVoYW5kbGUsIGNzaVBhdGgsIGNzaUZpbGVoYW5kbGUsIHlpZWxkVGltZSA9IDUwMCwgY2h1bmtTaXplTGltaXQgPSA1ZTcsIHJlbmFtZVJlZlNlcXMgPSAobikgPT4gbiwgY2h1bmtDYWNoZVNpemUgPSA1ICogMiAqKiAyMCB9KSB7CiAgICAgIGlmIChmaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5maWxlaGFuZGxlID0gZmlsZWhhbmRsZTsKICAgICAgfSBlbHNlIGlmIChwYXRoKSB7CiAgICAgICAgdGhpcy5maWxlaGFuZGxlID0gbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChwYXRoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHByb3ZpZGUgZWl0aGVyIGZpbGVoYW5kbGUgb3IgcGF0aCIpOwogICAgICB9CiAgICAgIGlmICh0YmlGaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBUYWJpeEluZGV4KHsKICAgICAgICAgIGZpbGVoYW5kbGU6IHRiaUZpbGVoYW5kbGUsCiAgICAgICAgICByZW5hbWVSZWZTZXFzCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSBpZiAoY3NpRmlsZWhhbmRsZSkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgQ1NJKHsKICAgICAgICAgIGZpbGVoYW5kbGU6IGNzaUZpbGVoYW5kbGUsCiAgICAgICAgICByZW5hbWVSZWZTZXFzCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSBpZiAodGJpUGF0aCkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgVGFiaXhJbmRleCh7CiAgICAgICAgICBmaWxlaGFuZGxlOiBuZXcgaW1wb3J0X2xvY2FsRmlsZS5kZWZhdWx0KHRiaVBhdGgpLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKGNzaVBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IENTSSh7CiAgICAgICAgICBmaWxlaGFuZGxlOiBuZXcgaW1wb3J0X2xvY2FsRmlsZS5kZWZhdWx0KGNzaVBhdGgpLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKHBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IFRhYml4SW5kZXgoewogICAgICAgICAgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChgJHtwYXRofS50YmlgKSwKICAgICAgICAgIHJlbmFtZVJlZlNlcXMKICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHByb3ZpZGUgb25lIG9mIHRiaUZpbGVoYW5kbGUsIHRiaVBhdGgsIGNzaUZpbGVoYW5kbGUsIG9yIGNzaVBhdGgiKTsKICAgICAgfQogICAgICB0aGlzLmNodW5rU2l6ZUxpbWl0ID0gY2h1bmtTaXplTGltaXQ7CiAgICAgIHRoaXMucmVuYW1lUmVmU2VxID0gcmVuYW1lUmVmU2VxczsKICAgICAgdGhpcy55aWVsZFRpbWUgPSB5aWVsZFRpbWU7CiAgICAgIHRoaXMuY2h1bmtDYWNoZSA9IG5ldyBpbXBvcnRfYWJvcnRhYmxlX3Byb21pc2VfY2FjaGUuZGVmYXVsdCh7CiAgICAgICAgY2FjaGU6IG5ldyBpbXBvcnRfcXVpY2tfbHJ1LmRlZmF1bHQoeyBtYXhTaXplOiBNYXRoLmZsb29yKGNodW5rQ2FjaGVTaXplIC8gKDEgPDwgMTYpKSB9KSwKICAgICAgICBmaWxsOiAoYXJncywgc2lnbmFsKSA9PiB0aGlzLnJlYWRDaHVuayhhcmdzLCB7IHNpZ25hbCB9KQogICAgICB9KTsKICAgIH0KICAgIGFzeW5jIGdldExpbmVzKHJlZk5hbWUsIHN0YXJ0LCBlbmQsIG9wdHMpIHsKICAgICAgbGV0IHNpZ25hbDsKICAgICAgbGV0IG9wdGlvbnMgPSB7fTsKICAgICAgbGV0IGNhbGxiYWNrOwogICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibGluZSBjYWxsYmFjayBtdXN0IGJlIHByb3ZpZGVkIik7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgY2FsbGJhY2sgPSBvcHRzOwogICAgICB9IGVsc2UgewogICAgICAgIG9wdGlvbnMgPSBvcHRzOwogICAgICAgIGNhbGxiYWNrID0gb3B0cy5saW5lQ2FsbGJhY2s7CiAgICAgIH0KICAgICAgaWYgKHJlZk5hbWUgPT09IHZvaWQgMCkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIm11c3QgcHJvdmlkZSBhIHJlZmVyZW5jZSBzZXF1ZW5jZSBuYW1lIik7CiAgICAgIH0KICAgICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImxpbmUgY2FsbGJhY2sgbXVzdCBiZSBwcm92aWRlZCIpOwogICAgICB9CiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5pbmRleC5nZXRNZXRhZGF0YShvcHRpb25zKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICBpZiAoIXN0YXJ0KSB7CiAgICAgICAgc3RhcnQgPSAwOwogICAgICB9CiAgICAgIGlmICghZW5kKSB7CiAgICAgICAgZW5kID0gbWV0YWRhdGEubWF4UmVmTGVuZ3RoOwogICAgICB9CiAgICAgIGlmICghKHN0YXJ0IDw9IGVuZCkpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnZhbGlkIHN0YXJ0IGFuZCBlbmQgY29vcmRpbmF0ZXMuIHN0YXJ0IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGVuZCIpOwogICAgICB9CiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGNvbnN0IGNodW5rcyA9IGF3YWl0IHRoaXMuaW5kZXguYmxvY2tzRm9yUmFuZ2UocmVmTmFtZSwgc3RhcnQsIGVuZCwgb3B0aW9ucyk7CiAgICAgIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBjb25zdCBzaXplID0gY2h1bmtzW2ldLmZldGNoZWRTaXplKCk7CiAgICAgICAgaWYgKHNpemUgPiB0aGlzLmNodW5rU2l6ZUxpbWl0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBtdWNoIGRhdGEuIENodW5rIHNpemUgJHtzaXplLnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzIGV4Y2VlZHMgY2h1bmtTaXplTGltaXQgb2YgJHt0aGlzLmNodW5rU2l6ZUxpbWl0LnRvTG9jYWxlU3RyaW5nKCl9LmApOwogICAgICAgIH0KICAgICAgfQogICAgICBsZXQgbGFzdCA9IERhdGUubm93KCk7CiAgICAgIGZvciAobGV0IGNodW5rTnVtID0gMDsgY2h1bmtOdW0gPCBjaHVua3MubGVuZ3RoOyBjaHVua051bSArPSAxKSB7CiAgICAgICAgbGV0IHByZXZpb3VzU3RhcnRDb29yZGluYXRlOwogICAgICAgIGNvbnN0IGMgPSBjaHVua3NbY2h1bmtOdW1dOwogICAgICAgIGNvbnN0IHsgYnVmZmVyLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zIH0gPSBhd2FpdCB0aGlzLmNodW5rQ2FjaGUuZ2V0KGMudG9TdHJpbmcoKSwgYyk7CiAgICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICAgIGxldCBibG9ja1N0YXJ0ID0gMDsKICAgICAgICBsZXQgcG9zID0gMDsKICAgICAgICB3aGlsZSAoYmxvY2tTdGFydCA8IGJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgIGNvbnN0IG4gPSBidWZmZXIuaW5kZXhPZigiXG4iLCBibG9ja1N0YXJ0KTsKICAgICAgICAgIGlmIChuID09PSAtMSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IGIgPSBidWZmZXIuc2xpY2UoYmxvY2tTdGFydCwgbik7CiAgICAgICAgICBjb25zdCBsaW5lID0gKGRlY29kZXIgPT09IG51bGwgfHwgZGVjb2RlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb2Rlci5kZWNvZGUoYikpIHx8IGIudG9TdHJpbmcoKTsKICAgICAgICAgIGlmIChkcG9zaXRpb25zKSB7CiAgICAgICAgICAgIHdoaWxlIChibG9ja1N0YXJ0ICsgYy5taW52LmRhdGFQb3NpdGlvbiA+PSBkcG9zaXRpb25zW3BvcysrXSkgewogICAgICAgICAgICB9CiAgICAgICAgICAgIHBvcy0tOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgeyBzdGFydENvb3JkaW5hdGUsIG92ZXJsYXBzIH0gPSB0aGlzLmNoZWNrTGluZShtZXRhZGF0YSwgcmVmTmFtZSwgc3RhcnQsIGVuZCwgbGluZSk7CiAgICAgICAgICBpZiAocHJldmlvdXNTdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBzdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZSA+IHN0YXJ0Q29vcmRpbmF0ZSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmVzIG5vdCBzb3J0ZWQgYnkgc3RhcnQgY29vcmRpbmF0ZSAoJHtwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZX0gPiAke3N0YXJ0Q29vcmRpbmF0ZX0pLCB0aGlzIGZpbGUgaXMgbm90IHVzYWJsZSB3aXRoIFRhYml4LmApOwogICAgICAgICAgfQogICAgICAgICAgcHJldmlvdXNTdGFydENvb3JkaW5hdGUgPSBzdGFydENvb3JkaW5hdGU7CiAgICAgICAgICBpZiAob3ZlcmxhcHMpIHsKICAgICAgICAgICAgY2FsbGJhY2sobGluZS50cmltKCksIGNwb3NpdGlvbnNbcG9zXSAqICgxIDw8IDgpICsgKGJsb2NrU3RhcnQgLSBkcG9zaXRpb25zW3Bvc10pICsgYy5taW52LmRhdGFQb3NpdGlvbiArIDEpOwogICAgICAgICAgfSBlbHNlIGlmIChzdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBzdGFydENvb3JkaW5hdGUgPj0gZW5kKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLnlpZWxkVGltZSAmJiBsYXN0IC0gRGF0ZS5ub3coKSA+IHRoaXMueWllbGRUaW1lKSB7CiAgICAgICAgICAgIGxhc3QgPSBEYXRlLm5vdygpOwogICAgICAgICAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMSk7CiAgICAgICAgICB9CiAgICAgICAgICBibG9ja1N0YXJ0ID0gbiArIDE7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBhc3luYyBnZXRNZXRhZGF0YShvcHRzID0ge30pIHsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXguZ2V0TWV0YWRhdGEob3B0cyk7CiAgICB9CiAgICBhc3luYyBnZXRIZWFkZXJCdWZmZXIob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgZmlyc3REYXRhTGluZSwgbWV0YUNoYXIsIG1heEJsb2NrU2l6ZSB9ID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YShvcHRzKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChvcHRzLnNpZ25hbCk7CiAgICAgIGNvbnN0IG1heEZldGNoID0gKChmaXJzdERhdGFMaW5lID09PSBudWxsIHx8IGZpcnN0RGF0YUxpbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0RGF0YUxpbmUuYmxvY2tQb3NpdGlvbikgfHwgMCkgKyBtYXhCbG9ja1NpemU7CiAgICAgIGxldCBieXRlcyA9IGF3YWl0IHRoaXMuX3JlYWRSZWdpb24oMCwgbWF4RmV0Y2gsIG9wdHMpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKTsKICAgICAgdHJ5IHsKICAgICAgICBieXRlcyA9IGF3YWl0IHVuemlwKGJ5dGVzKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvciBkZWNvbXByZXNzaW5nIGJsb2NrICR7ZS5jb2RlfSBhdCAwIChsZW5ndGggJHttYXhGZXRjaH0pICR7ZX1gKTsKICAgICAgfQogICAgICBpZiAobWV0YUNoYXIpIHsKICAgICAgICBsZXQgbGFzdE5ld2xpbmUgPSAtMTsKICAgICAgICBjb25zdCBuZXdsaW5lQnl0ZSA9ICJcbiIuY2hhckNvZGVBdCgwKTsKICAgICAgICBjb25zdCBtZXRhQnl0ZSA9IG1ldGFDaGFyLmNoYXJDb2RlQXQoMCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgaWYgKGkgPT09IGxhc3ROZXdsaW5lICsgMSAmJiBieXRlc1tpXSAhPT0gbWV0YUJ5dGUpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYnl0ZXNbaV0gPT09IG5ld2xpbmVCeXRlKSB7CiAgICAgICAgICAgIGxhc3ROZXdsaW5lID0gaTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZSgwLCBsYXN0TmV3bGluZSArIDEpOwogICAgICB9CiAgICAgIHJldHVybiBieXRlczsKICAgIH0KICAgIGFzeW5jIGdldEhlYWRlcihvcHRzID0ge30pIHsKICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB0aGlzLmdldEhlYWRlckJ1ZmZlcihvcHRzKTsKICAgICAgcmV0dXJuIGJ5dGVzLnRvU3RyaW5nKCJ1dGY4Iik7CiAgICB9CiAgICBhc3luYyBnZXRSZWZlcmVuY2VTZXF1ZW5jZU5hbWVzKG9wdHMgPSB7fSkgewogICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEob3B0cyk7CiAgICAgIHJldHVybiBtZXRhZGF0YS5yZWZJZFRvTmFtZTsKICAgIH0KICAgIGNoZWNrTGluZShtZXRhZGF0YSwgcmVnaW9uUmVmTmFtZSwgcmVnaW9uU3RhcnQsIHJlZ2lvbkVuZCwgbGluZSkgewogICAgICBjb25zdCB7IGNvbHVtbk51bWJlcnMsIG1ldGFDaGFyLCBjb29yZGluYXRlVHlwZSwgZm9ybWF0IH0gPSBtZXRhZGF0YTsKICAgICAgaWYgKGxpbmUuY2hhckF0KDApID09PSBtZXRhQ2hhcikgewogICAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9OwogICAgICB9CiAgICAgIGxldCB7IHJlZiwgc3RhcnQsIGVuZCB9ID0gY29sdW1uTnVtYmVyczsKICAgICAgaWYgKCFyZWYpIHsKICAgICAgICByZWYgPSAwOwogICAgICB9CiAgICAgIGlmICghc3RhcnQpIHsKICAgICAgICBzdGFydCA9IDA7CiAgICAgIH0KICAgICAgaWYgKCFlbmQpIHsKICAgICAgICBlbmQgPSAwOwogICAgICB9CiAgICAgIGlmIChmb3JtYXQgPT09ICJWQ0YiKSB7CiAgICAgICAgZW5kID0gODsKICAgICAgfQogICAgICBjb25zdCBtYXhDb2x1bW4gPSBNYXRoLm1heChyZWYsIHN0YXJ0LCBlbmQpOwogICAgICBsZXQgY3VycmVudENvbHVtbk51bWJlciA9IDE7CiAgICAgIGxldCBjdXJyZW50Q29sdW1uU3RhcnQgPSAwOwogICAgICBsZXQgcmVmU2VxID0gIiI7CiAgICAgIGxldCBzdGFydENvb3JkaW5hdGUgPSAtSW5maW5pdHk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5sZW5ndGggKyAxOyBpICs9IDEpIHsKICAgICAgICBpZiAobGluZVtpXSA9PT0gIgkiIHx8IGkgPT09IGxpbmUubGVuZ3RoKSB7CiAgICAgICAgICBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gcmVmKSB7CiAgICAgICAgICAgIGlmICh0aGlzLnJlbmFtZVJlZlNlcShsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSkpICE9PSByZWdpb25SZWZOYW1lKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gc3RhcnQpIHsKICAgICAgICAgICAgc3RhcnRDb29yZGluYXRlID0gcGFyc2VJbnQobGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpLCAxMCk7CiAgICAgICAgICAgIGlmIChjb29yZGluYXRlVHlwZSA9PT0gIjEtYmFzZWQtY2xvc2VkIikgewogICAgICAgICAgICAgIHN0YXJ0Q29vcmRpbmF0ZSAtPSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGFydENvb3JkaW5hdGUgPj0gcmVnaW9uRW5kKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogZmFsc2UgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZW5kID09PSAwIHx8IGVuZCA9PT0gc3RhcnQpIHsKICAgICAgICAgICAgICBpZiAoc3RhcnRDb29yZGluYXRlICsgMSA8PSByZWdpb25TdGFydCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogZmFsc2UgfTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAiVkNGIiAmJiBjdXJyZW50Q29sdW1uTnVtYmVyID09PSA0KSB7CiAgICAgICAgICAgIHJlZlNlcSA9IGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gZW5kKSB7CiAgICAgICAgICAgIGxldCBlbmRDb29yZGluYXRlOwogICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAiVkNGIikgewogICAgICAgICAgICAgIGVuZENvb3JkaW5hdGUgPSB0aGlzLl9nZXRWY2ZFbmQoc3RhcnRDb29yZGluYXRlLCByZWZTZXEsIGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZW5kQ29vcmRpbmF0ZSA9IHBhcnNlSW50KGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSwgMTApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChlbmRDb29yZGluYXRlIDw9IHJlZ2lvblN0YXJ0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGN1cnJlbnRDb2x1bW5TdGFydCA9IGkgKyAxOwogICAgICAgICAgY3VycmVudENvbHVtbk51bWJlciArPSAxOwogICAgICAgICAgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPiBtYXhDb2x1bW4pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHM6IHRydWUgfTsKICAgIH0KICAgIF9nZXRWY2ZFbmQoc3RhcnRDb29yZGluYXRlLCByZWZTZXEsIGluZm8pIHsKICAgICAgbGV0IGVuZENvb3JkaW5hdGUgPSBzdGFydENvb3JkaW5hdGUgKyByZWZTZXEubGVuZ3RoOwogICAgICBjb25zdCBpc1RSQSA9IGluZm8uaW5kZXhPZigiU1ZUWVBFPVRSQSIpICE9PSAtMTsKICAgICAgaWYgKGluZm9bMF0gIT09ICIuIiAmJiAhaXNUUkEpIHsKICAgICAgICBsZXQgcHJldkNoYXIgPSAiOyI7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLmxlbmd0aDsgaiArPSAxKSB7CiAgICAgICAgICBpZiAocHJldkNoYXIgPT09ICI7IiAmJiBpbmZvLnNsaWNlKGosIGogKyA0KSA9PT0gIkVORD0iKSB7CiAgICAgICAgICAgIGxldCB2YWx1ZUVuZCA9IGluZm8uaW5kZXhPZigiOyIsIGopOwogICAgICAgICAgICBpZiAodmFsdWVFbmQgPT09IC0xKSB7CiAgICAgICAgICAgICAgdmFsdWVFbmQgPSBpbmZvLmxlbmd0aDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbmRDb29yZGluYXRlID0gcGFyc2VJbnQoaW5mby5zbGljZShqICsgNCwgdmFsdWVFbmQpLCAxMCk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgcHJldkNoYXIgPSBpbmZvW2pdOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChpc1RSQSkgewogICAgICAgIHJldHVybiBzdGFydENvb3JkaW5hdGUgKyAxOwogICAgICB9CiAgICAgIHJldHVybiBlbmRDb29yZGluYXRlOwogICAgfQogICAgYXN5bmMgbGluZUNvdW50KHJlZk5hbWUsIG9wdHMgPSB7fSkgewogICAgICByZXR1cm4gdGhpcy5pbmRleC5saW5lQ291bnQocmVmTmFtZSwgb3B0cyk7CiAgICB9CiAgICBhc3luYyBfcmVhZFJlZ2lvbihwb3MsIHNpemUsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCBiID0gaW1wb3J0X2J1ZmZlcjcuQnVmZmVyLmFsbG9jKHNpemUpOwogICAgICBjb25zdCB7IGJ5dGVzUmVhZCwgYnVmZmVyIH0gPSBhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZChiLCAwLCBzaXplLCBwb3MsIG9wdHMpOwogICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGJ5dGVzUmVhZCk7CiAgICB9CiAgICBhc3luYyByZWFkQ2h1bmsoYywgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9yZWFkUmVnaW9uKGMubWludi5ibG9ja1Bvc2l0aW9uLCBjLmZldGNoZWRTaXplKCksIG9wdHMpOwogICAgICB0cnkgewogICAgICAgIHJldHVybiB1bnppcENodW5rU2xpY2UoZGF0YSwgYyk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVycm9yIGRlY29tcHJlc3NpbmcgYyAke2MudG9TdHJpbmcoKX0gJHtlfWApOwogICAgICB9CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2dmZkAxLjMuMC9ub2RlX21vZHVsZXMvQGdtb2QvZ2ZmL2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2dmZkAxLjMuMC9ub2RlX21vZHVsZXMvQGdtb2QvZ2ZmL2VzbS9hcGkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9zdHJlYW0gPSBfX3RvTW9kdWxlKHJlcXVpcmVfc3RyZWFtX2Jyb3dzZXJpZnkoKSk7CiAgdmFyIGltcG9ydF9zdHJpbmdfZGVjb2RlciA9IF9fdG9Nb2R1bGUocmVxdWlyZV9zdHJpbmdfZGVjb2RlcigpKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2dmZkAxLjMuMC9ub2RlX21vZHVsZXMvQGdtb2QvZ2ZmL2VzbS9wYXJzZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2dmZkAxLjMuMC9ub2RlX21vZHVsZXMvQGdtb2QvZ2ZmL2VzbS91dGlsLmpzCiAgdmFyIHV0aWxfZXhwb3J0cyA9IHt9OwogIF9fZXhwb3J0KHV0aWxfZXhwb3J0cywgewogICAgZXNjYXBlOiAoKSA9PiBlc2NhcGUsCiAgICBlc2NhcGVDb2x1bW46ICgpID0+IGVzY2FwZUNvbHVtbiwKICAgIGZvcm1hdEF0dHJpYnV0ZXM6ICgpID0+IGZvcm1hdEF0dHJpYnV0ZXMsCiAgICBmb3JtYXRDb21tZW50OiAoKSA9PiBmb3JtYXRDb21tZW50LAogICAgZm9ybWF0RGlyZWN0aXZlOiAoKSA9PiBmb3JtYXREaXJlY3RpdmUsCiAgICBmb3JtYXRGZWF0dXJlOiAoKSA9PiBmb3JtYXRGZWF0dXJlLAogICAgZm9ybWF0SXRlbTogKCkgPT4gZm9ybWF0SXRlbSwKICAgIGZvcm1hdFNlcXVlbmNlOiAoKSA9PiBmb3JtYXRTZXF1ZW5jZSwKICAgIHBhcnNlQXR0cmlidXRlczogKCkgPT4gcGFyc2VBdHRyaWJ1dGVzLAogICAgcGFyc2VEaXJlY3RpdmU6ICgpID0+IHBhcnNlRGlyZWN0aXZlLAogICAgcGFyc2VGZWF0dXJlOiAoKSA9PiBwYXJzZUZlYXR1cmUsCiAgICB1bmVzY2FwZTogKCkgPT4gdW5lc2NhcGUKICB9KTsKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nVmFsKSB7CiAgICByZXR1cm4gc3RyaW5nVmFsLnJlcGxhY2UoLyUoWzAtOUEtRmEtZl17Mn0pL2csIChfbWF0Y2gsIHNlcSkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzZXEsIDE2KSkpOwogIH0KICBmdW5jdGlvbiBfZXNjYXBlKHJlZ2V4LCBzKSB7CiAgICByZXR1cm4gU3RyaW5nKHMpLnJlcGxhY2UocmVnZXgsIChjaCkgPT4gewogICAgICBjb25zdCBoZXggPSBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsICIwIik7CiAgICAgIHJldHVybiBgJSR7aGV4fWA7CiAgICB9KTsKICB9CiAgZnVuY3Rpb24gZXNjYXBlKHJhd1ZhbCkgewogICAgcmV0dXJuIF9lc2NhcGUoL1tcbjtcclx0PSUmLFx4MDAtXHgxZlx4N2YtXHhmZl0vZywgcmF3VmFsKTsKICB9CiAgZnVuY3Rpb24gZXNjYXBlQ29sdW1uKHJhd1ZhbCkgewogICAgcmV0dXJuIF9lc2NhcGUoL1tcblxyXHQlXHgwMC1ceDFmXHg3Zi1ceGZmXS9nLCByYXdWYWwpOwogIH0KICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoYXR0clN0cmluZykgewogICAgaWYgKCEoYXR0clN0cmluZyAmJiBhdHRyU3RyaW5nLmxlbmd0aCkgfHwgYXR0clN0cmluZyA9PT0gIi4iKQogICAgICByZXR1cm4ge307CiAgICBjb25zdCBhdHRycyA9IHt9OwogICAgYXR0clN0cmluZy5yZXBsYWNlKC9ccj9cbiQvLCAiIikuc3BsaXQoIjsiKS5mb3JFYWNoKChhKSA9PiB7CiAgICAgIGNvbnN0IG52ID0gYS5zcGxpdCgiPSIsIDIpOwogICAgICBpZiAoIShudlsxXSAmJiBudlsxXS5sZW5ndGgpKQogICAgICAgIHJldHVybjsKICAgICAgbnZbMF0gPSBudlswXS50cmltKCk7CiAgICAgIGxldCBhcmVjID0gYXR0cnNbbnZbMF0udHJpbSgpXTsKICAgICAgaWYgKCFhcmVjKSB7CiAgICAgICAgYXJlYyA9IFtdOwogICAgICAgIGF0dHJzW252WzBdXSA9IGFyZWM7CiAgICAgIH0KICAgICAgYXJlYy5wdXNoKC4uLm52WzFdLnNwbGl0KCIsIikubWFwKChzKSA9PiBzLnRyaW0oKSkubWFwKHVuZXNjYXBlKSk7CiAgICB9KTsKICAgIHJldHVybiBhdHRyczsKICB9CiAgZnVuY3Rpb24gcGFyc2VGZWF0dXJlKGxpbmUpIHsKICAgIGNvbnN0IGYgPSBsaW5lLnNwbGl0KCIJIikubWFwKChhKSA9PiBhID09PSAiLiIgfHwgYSA9PT0gIiIgPyBudWxsIDogYSk7CiAgICBjb25zdCBwYXJzZWQgPSB7CiAgICAgIHNlcV9pZDogZlswXSAmJiB1bmVzY2FwZShmWzBdKSwKICAgICAgc291cmNlOiBmWzFdICYmIHVuZXNjYXBlKGZbMV0pLAogICAgICB0eXBlOiBmWzJdICYmIHVuZXNjYXBlKGZbMl0pLAogICAgICBzdGFydDogZlszXSA9PT0gbnVsbCA/IG51bGwgOiBwYXJzZUludChmWzNdLCAxMCksCiAgICAgIGVuZDogZls0XSA9PT0gbnVsbCA/IG51bGwgOiBwYXJzZUludChmWzRdLCAxMCksCiAgICAgIHNjb3JlOiBmWzVdID09PSBudWxsID8gbnVsbCA6IHBhcnNlRmxvYXQoZls1XSksCiAgICAgIHN0cmFuZDogZls2XSwKICAgICAgcGhhc2U6IGZbN10sCiAgICAgIGF0dHJpYnV0ZXM6IGZbOF0gPT09IG51bGwgPyBudWxsIDogcGFyc2VBdHRyaWJ1dGVzKGZbOF0pCiAgICB9OwogICAgcmV0dXJuIHBhcnNlZDsKICB9CiAgZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmUobGluZSkgewogICAgY29uc3QgbWF0Y2ggPSAvXlxzKiMjXHMqKFxTKylccyooLiopLy5leGVjKGxpbmUpOwogICAgaWYgKCFtYXRjaCkKICAgICAgcmV0dXJuIG51bGw7CiAgICBjb25zdCBbLCBuYW1lXSA9IG1hdGNoOwogICAgbGV0IFssICwgY29udGVudHNdID0gbWF0Y2g7CiAgICBjb25zdCBwYXJzZWQgPSB7IGRpcmVjdGl2ZTogbmFtZSB9OwogICAgaWYgKGNvbnRlbnRzLmxlbmd0aCkgewogICAgICBjb250ZW50cyA9IGNvbnRlbnRzLnJlcGxhY2UoL1xyP1xuJC8sICIiKTsKICAgICAgcGFyc2VkLnZhbHVlID0gY29udGVudHM7CiAgICB9CiAgICBpZiAobmFtZSA9PT0gInNlcXVlbmNlLXJlZ2lvbiIpIHsKICAgICAgY29uc3QgYyA9IGNvbnRlbnRzLnNwbGl0KC9ccysvLCAzKTsKICAgICAgcmV0dXJuIHsKICAgICAgICAuLi5wYXJzZWQsCiAgICAgICAgc2VxX2lkOiBjWzBdLAogICAgICAgIHN0YXJ0OiBjWzFdICYmIGNbMV0ucmVwbGFjZSgvXEQvZywgIiIpLAogICAgICAgIGVuZDogY1syXSAmJiBjWzJdLnJlcGxhY2UoL1xEL2csICIiKQogICAgICB9OwogICAgfSBlbHNlIGlmIChuYW1lID09PSAiZ2Vub21lLWJ1aWxkIikgewogICAgICBjb25zdCBbc291cmNlLCBidWlsZE5hbWVdID0gY29udGVudHMuc3BsaXQoL1xzKy8sIDIpOwogICAgICByZXR1cm4gewogICAgICAgIC4uLnBhcnNlZCwKICAgICAgICBzb3VyY2UsCiAgICAgICAgYnVpbGROYW1lCiAgICAgIH07CiAgICB9CiAgICByZXR1cm4gcGFyc2VkOwogIH0KICBmdW5jdGlvbiBmb3JtYXRBdHRyaWJ1dGVzKGF0dHJzKSB7CiAgICBjb25zdCBhdHRyT3JkZXIgPSBbXTsKICAgIE9iamVjdC5lbnRyaWVzKGF0dHJzKS5mb3JFYWNoKChbdGFnLCB2YWxdKSA9PiB7CiAgICAgIGlmICghdmFsKQogICAgICAgIHJldHVybjsKICAgICAgbGV0IHZhbHN0cmluZzsKICAgICAgaWYgKHZhbC5oYXNPd25Qcm9wZXJ0eSgidG9TdHJpbmciKSkgewogICAgICAgIHZhbHN0cmluZyA9IGVzY2FwZSh2YWwudG9TdHJpbmcoKSk7CiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7CiAgICAgICAgdmFsc3RyaW5nID0gdmFsLm1hcChlc2NhcGUpLmpvaW4oIiwiKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB2YWxzdHJpbmcgPSBlc2NhcGUodmFsKTsKICAgICAgfQogICAgICBhdHRyT3JkZXIucHVzaChgJHtlc2NhcGUodGFnKX09JHt2YWxzdHJpbmd9YCk7CiAgICB9KTsKICAgIHJldHVybiBhdHRyT3JkZXIubGVuZ3RoID8gYXR0ck9yZGVyLmpvaW4oIjsiKSA6ICIuIjsKICB9CiAgZnVuY3Rpb24gX2Zvcm1hdFNpbmdsZUZlYXR1cmUoZiwgc2VlbkZlYXR1cmUpIHsKICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBmLmF0dHJpYnV0ZXMgPT09IG51bGwgfHwgZi5hdHRyaWJ1dGVzID09PSB2b2lkIDAgPyAiLiIgOiBmb3JtYXRBdHRyaWJ1dGVzKGYuYXR0cmlidXRlcyk7CiAgICBjb25zdCBmaWVsZHMgPSBbCiAgICAgIGYuc2VxX2lkID09PSBudWxsID8gIi4iIDogZXNjYXBlQ29sdW1uKGYuc2VxX2lkKSwKICAgICAgZi5zb3VyY2UgPT09IG51bGwgPyAiLiIgOiBlc2NhcGVDb2x1bW4oZi5zb3VyY2UpLAogICAgICBmLnR5cGUgPT09IG51bGwgPyAiLiIgOiBlc2NhcGVDb2x1bW4oZi50eXBlKSwKICAgICAgZi5zdGFydCA9PT0gbnVsbCA/ICIuIiA6IGVzY2FwZUNvbHVtbihmLnN0YXJ0KSwKICAgICAgZi5lbmQgPT09IG51bGwgPyAiLiIgOiBlc2NhcGVDb2x1bW4oZi5lbmQpLAogICAgICBmLnNjb3JlID09PSBudWxsID8gIi4iIDogZXNjYXBlQ29sdW1uKGYuc2NvcmUpLAogICAgICBmLnN0cmFuZCA9PT0gbnVsbCA/ICIuIiA6IGVzY2FwZUNvbHVtbihmLnN0cmFuZCksCiAgICAgIGYucGhhc2UgPT09IG51bGwgPyAiLiIgOiBlc2NhcGVDb2x1bW4oZi5waGFzZSksCiAgICAgIGF0dHJTdHJpbmcKICAgIF07CiAgICBjb25zdCBmb3JtYXR0ZWRTdHJpbmcgPSBgJHtmaWVsZHMuam9pbigiCSIpfQpgOwogICAgaWYgKHNlZW5GZWF0dXJlW2Zvcm1hdHRlZFN0cmluZ10pIHsKICAgICAgcmV0dXJuICIiOwogICAgfQogICAgc2VlbkZlYXR1cmVbZm9ybWF0dGVkU3RyaW5nXSA9IHRydWU7CiAgICByZXR1cm4gZm9ybWF0dGVkU3RyaW5nOwogIH0KICBmdW5jdGlvbiBfZm9ybWF0RmVhdHVyZShmZWF0dXJlLCBzZWVuRmVhdHVyZSkgewogICAgaWYgKEFycmF5LmlzQXJyYXkoZmVhdHVyZSkpIHsKICAgICAgcmV0dXJuIGZlYXR1cmUubWFwKChmKSA9PiBfZm9ybWF0RmVhdHVyZShmLCBzZWVuRmVhdHVyZSkpLmpvaW4oIiIpOwogICAgfQogICAgY29uc3Qgc3RyaW5ncyA9IFtfZm9ybWF0U2luZ2xlRmVhdHVyZShmZWF0dXJlLCBzZWVuRmVhdHVyZSldOwogICAgaWYgKF9pc0ZlYXR1cmVMaW5lV2l0aFJlZnMoZmVhdHVyZSkpIHsKICAgICAgc3RyaW5ncy5wdXNoKC4uLmZlYXR1cmUuY2hpbGRfZmVhdHVyZXMubWFwKChmKSA9PiBfZm9ybWF0RmVhdHVyZShmLCBzZWVuRmVhdHVyZSkpLCAuLi5mZWF0dXJlLmRlcml2ZWRfZmVhdHVyZXMubWFwKChmKSA9PiBfZm9ybWF0RmVhdHVyZShmLCBzZWVuRmVhdHVyZSkpKTsKICAgIH0KICAgIHJldHVybiBzdHJpbmdzLmpvaW4oIiIpOwogIH0KICBmdW5jdGlvbiBmb3JtYXRGZWF0dXJlKGZlYXR1cmVPckZlYXR1cmVzKSB7CiAgICBjb25zdCBzZWVuID0ge307CiAgICByZXR1cm4gX2Zvcm1hdEZlYXR1cmUoZmVhdHVyZU9yRmVhdHVyZXMsIHNlZW4pOwogIH0KICBmdW5jdGlvbiBmb3JtYXREaXJlY3RpdmUoZGlyZWN0aXZlKSB7CiAgICBsZXQgc3RyID0gYCMjJHtkaXJlY3RpdmUuZGlyZWN0aXZlfWA7CiAgICBpZiAoZGlyZWN0aXZlLnZhbHVlKQogICAgICBzdHIgKz0gYCAke2RpcmVjdGl2ZS52YWx1ZX1gOwogICAgc3RyICs9ICJcbiI7CiAgICByZXR1cm4gc3RyOwogIH0KICBmdW5jdGlvbiBmb3JtYXRDb21tZW50KGNvbW1lbnQpIHsKICAgIHJldHVybiBgIyAke2NvbW1lbnQuY29tbWVudH0KYDsKICB9CiAgZnVuY3Rpb24gZm9ybWF0U2VxdWVuY2Uoc2VxKSB7CiAgICByZXR1cm4gYD4ke3NlcS5pZH0ke3NlcS5kZXNjcmlwdGlvbiA/IGAgJHtzZXEuZGVzY3JpcHRpb259YCA6ICIifQoke3NlcS5zZXF1ZW5jZX0KYDsKICB9CiAgZnVuY3Rpb24gZm9ybWF0SXRlbShpdGVtT3JJdGVtcykgewogICAgZnVuY3Rpb24gZm9ybWF0U2luZ2xlSXRlbShpdGVtKSB7CiAgICAgIGlmICgiYXR0cmlidXRlcyIgaW4gaXRlbSkKICAgICAgICByZXR1cm4gZm9ybWF0RmVhdHVyZShpdGVtKTsKICAgICAgaWYgKCJkaXJlY3RpdmUiIGluIGl0ZW0pCiAgICAgICAgcmV0dXJuIGZvcm1hdERpcmVjdGl2ZShpdGVtKTsKICAgICAgaWYgKCJzZXF1ZW5jZSIgaW4gaXRlbSkKICAgICAgICByZXR1cm4gZm9ybWF0U2VxdWVuY2UoaXRlbSk7CiAgICAgIGlmICgiY29tbWVudCIgaW4gaXRlbSkKICAgICAgICByZXR1cm4gZm9ybWF0Q29tbWVudChpdGVtKTsKICAgICAgcmV0dXJuICIjIChpbnZhbGlkIGl0ZW0gZm91bmQgZHVyaW5nIGZvcm1hdClcbiI7CiAgICB9CiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtT3JJdGVtcykpIHsKICAgICAgcmV0dXJuIGl0ZW1Pckl0ZW1zLm1hcChmb3JtYXRTaW5nbGVJdGVtKTsKICAgIH0KICAgIHJldHVybiBmb3JtYXRTaW5nbGVJdGVtKGl0ZW1Pckl0ZW1zKTsKICB9CiAgZnVuY3Rpb24gX2lzRmVhdHVyZUxpbmVXaXRoUmVmcyhmZWF0dXJlTGluZSkgewogICAgcmV0dXJuIGZlYXR1cmVMaW5lLmNoaWxkX2ZlYXR1cmVzICE9PSB2b2lkIDAgJiYgZmVhdHVyZUxpbmUuZGVyaXZlZF9mZWF0dXJlcyAhPT0gdm9pZCAwOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2dmZkAxLjMuMC9ub2RlX21vZHVsZXMvQGdtb2QvZ2ZmL2VzbS9wYXJzZS5qcwogIHZhciBjb250YWluZXJBdHRyaWJ1dGVzID0gewogICAgUGFyZW50OiAiY2hpbGRfZmVhdHVyZXMiLAogICAgRGVyaXZlc19mcm9tOiAiZGVyaXZlZF9mZWF0dXJlcyIKICB9OwogIHZhciBGQVNUQVBhcnNlciA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKHNlcUNhbGxiYWNrKSB7CiAgICAgIHRoaXMuc2VxQ2FsbGJhY2sgPSBzZXFDYWxsYmFjazsKICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSB2b2lkIDA7CiAgICB9CiAgICBhZGRMaW5lKGxpbmUpIHsKICAgICAgY29uc3QgZGVmTWF0Y2ggPSAvXj5ccyooXFMrKVxzKiguKikvLmV4ZWMobGluZSk7CiAgICAgIGlmIChkZWZNYXRjaCkgewogICAgICAgIHRoaXMuX2ZsdXNoKCk7CiAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSB7IGlkOiBkZWZNYXRjaFsxXSwgc2VxdWVuY2U6ICIiIH07CiAgICAgICAgaWYgKGRlZk1hdGNoWzJdKQogICAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2UuZGVzY3JpcHRpb24gPSBkZWZNYXRjaFsyXS50cmltKCk7CiAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50U2VxdWVuY2UgJiYgL1xTLy50ZXN0KGxpbmUpKSB7CiAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2Uuc2VxdWVuY2UgKz0gbGluZS5yZXBsYWNlKC9ccy9nLCAiIik7CiAgICAgIH0KICAgIH0KICAgIF9mbHVzaCgpIHsKICAgICAgaWYgKHRoaXMuY3VycmVudFNlcXVlbmNlKQogICAgICAgIHRoaXMuc2VxQ2FsbGJhY2sodGhpcy5jdXJyZW50U2VxdWVuY2UpOwogICAgfQogICAgZmluaXNoKCkgewogICAgICB0aGlzLl9mbHVzaCgpOwogICAgfQogIH07CiAgdmFyIFBhcnNlciA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHsKICAgICAgdGhpcy5mYXN0YVBhcnNlciA9IHZvaWQgMDsKICAgICAgdGhpcy5lb2YgPSBmYWxzZTsKICAgICAgdGhpcy5saW5lTnVtYmVyID0gMDsKICAgICAgdGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25Ub3BMZXZlbCA9IFtdOwogICAgICB0aGlzLl91bmRlckNvbnN0cnVjdGlvbkJ5SWQgPSB7fTsKICAgICAgdGhpcy5fY29tcGxldGVkUmVmZXJlbmNlcyA9IHt9OwogICAgICB0aGlzLl91bmRlckNvbnN0cnVjdGlvbk9ycGhhbnMgPSB7fTsKICAgICAgY29uc3QgbnVsbEZ1bmMgPSAoKSA9PiB7CiAgICAgIH07CiAgICAgIHRoaXMuZmVhdHVyZUNhbGxiYWNrID0gYXJncy5mZWF0dXJlQ2FsbGJhY2sgfHwgbnVsbEZ1bmM7CiAgICAgIHRoaXMuZW5kQ2FsbGJhY2sgPSBhcmdzLmVuZENhbGxiYWNrIHx8IG51bGxGdW5jOwogICAgICB0aGlzLmNvbW1lbnRDYWxsYmFjayA9IGFyZ3MuY29tbWVudENhbGxiYWNrIHx8IG51bGxGdW5jOwogICAgICB0aGlzLmVycm9yQ2FsbGJhY2sgPSBhcmdzLmVycm9yQ2FsbGJhY2sgfHwgbnVsbEZ1bmM7CiAgICAgIHRoaXMuZGlyZWN0aXZlQ2FsbGJhY2sgPSBhcmdzLmRpcmVjdGl2ZUNhbGxiYWNrIHx8IG51bGxGdW5jOwogICAgICB0aGlzLnNlcXVlbmNlQ2FsbGJhY2sgPSBhcmdzLnNlcXVlbmNlQ2FsbGJhY2sgfHwgbnVsbEZ1bmM7CiAgICAgIHRoaXMuZGlzYWJsZURlcml2ZXNGcm9tUmVmZXJlbmNlcyA9IGFyZ3MuZGlzYWJsZURlcml2ZXNGcm9tUmVmZXJlbmNlcyB8fCBmYWxzZTsKICAgICAgdGhpcy5idWZmZXJTaXplID0gYXJncy5idWZmZXJTaXplID09PSB2b2lkIDAgPyAxZTMgOiBhcmdzLmJ1ZmZlclNpemU7CiAgICB9CiAgICBhZGRMaW5lKGxpbmUpIHsKICAgICAgaWYgKHRoaXMuZmFzdGFQYXJzZXIpIHsKICAgICAgICB0aGlzLmZhc3RhUGFyc2VyLmFkZExpbmUobGluZSk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGlmICh0aGlzLmVvZikgewogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICB0aGlzLmxpbmVOdW1iZXIgKz0gMTsKICAgICAgaWYgKC9eXHMqW14jXHM+XS8udGVzdChsaW5lKSkgewogICAgICAgIHRoaXMuX2J1ZmZlckxpbmUobGluZSk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGNvbnN0IG1hdGNoID0gL15ccyooIyspKC4qKS8uZXhlYyhsaW5lKTsKICAgICAgaWYgKG1hdGNoKSB7CiAgICAgICAgY29uc3QgWywgaGFzaHNpZ25zXSA9IG1hdGNoOwogICAgICAgIGxldCBbLCAsIGNvbnRlbnRzXSA9IG1hdGNoOwogICAgICAgIGlmIChoYXNoc2lnbnMubGVuZ3RoID09PSAzKSB7CiAgICAgICAgICB0aGlzLl9lbWl0QWxsVW5kZXJDb25zdHJ1Y3Rpb25GZWF0dXJlcygpOwogICAgICAgIH0gZWxzZSBpZiAoaGFzaHNpZ25zLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gcGFyc2VEaXJlY3RpdmUobGluZSk7CiAgICAgICAgICBpZiAoZGlyZWN0aXZlKSB7CiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUuZGlyZWN0aXZlID09PSAiRkFTVEEiKSB7CiAgICAgICAgICAgICAgdGhpcy5fZW1pdEFsbFVuZGVyQ29uc3RydWN0aW9uRmVhdHVyZXMoKTsKICAgICAgICAgICAgICB0aGlzLmVvZiA9IHRydWU7CiAgICAgICAgICAgICAgdGhpcy5mYXN0YVBhcnNlciA9IG5ldyBGQVNUQVBhcnNlcih0aGlzLnNlcXVlbmNlQ2FsbGJhY2spOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRoaXMuX2VtaXRJdGVtKGRpcmVjdGl2ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5yZXBsYWNlKC9ccyovLCAiIik7CiAgICAgICAgICB0aGlzLl9lbWl0SXRlbSh7IGNvbW1lbnQ6IGNvbnRlbnRzIH0pOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmICgvXlxzKiQvLnRlc3QobGluZSkpIHsKICAgICAgfSBlbHNlIGlmICgvXlxzKj4vLnRlc3QobGluZSkpIHsKICAgICAgICB0aGlzLl9lbWl0QWxsVW5kZXJDb25zdHJ1Y3Rpb25GZWF0dXJlcygpOwogICAgICAgIHRoaXMuZW9mID0gdHJ1ZTsKICAgICAgICB0aGlzLmZhc3RhUGFyc2VyID0gbmV3IEZBU1RBUGFyc2VyKHRoaXMuc2VxdWVuY2VDYWxsYmFjayk7CiAgICAgICAgdGhpcy5mYXN0YVBhcnNlci5hZGRMaW5lKGxpbmUpOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IGVyckxpbmUgPSBsaW5lLnJlcGxhY2UoL1xyP1xuPyQvZywgIiIpOwogICAgICAgIHRocm93IG5ldyBFcnJvcihgR0ZGMyBwYXJzZSBlcnJvci4gIENhbm5vdCBwYXJzZSAnJHtlcnJMaW5lfScuYCk7CiAgICAgIH0KICAgIH0KICAgIGZpbmlzaCgpIHsKICAgICAgdGhpcy5fZW1pdEFsbFVuZGVyQ29uc3RydWN0aW9uRmVhdHVyZXMoKTsKICAgICAgaWYgKHRoaXMuZmFzdGFQYXJzZXIpCiAgICAgICAgdGhpcy5mYXN0YVBhcnNlci5maW5pc2goKTsKICAgICAgdGhpcy5lbmRDYWxsYmFjaygpOwogICAgfQogICAgX2VtaXRJdGVtKGkpIHsKICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaSkpCiAgICAgICAgdGhpcy5mZWF0dXJlQ2FsbGJhY2soaSk7CiAgICAgIGVsc2UgaWYgKCJkaXJlY3RpdmUiIGluIGkpCiAgICAgICAgdGhpcy5kaXJlY3RpdmVDYWxsYmFjayhpKTsKICAgICAgZWxzZSBpZiAoImNvbW1lbnQiIGluIGkpCiAgICAgICAgdGhpcy5jb21tZW50Q2FsbGJhY2soaSk7CiAgICB9CiAgICBfZW5mb3JjZUJ1ZmZlclNpemVMaW1pdChhZGRpdGlvbmFsSXRlbUNvdW50ID0gMCkgewogICAgICBjb25zdCBfdW5idWZmZXJJdGVtID0gKGl0ZW0pID0+IHsKICAgICAgICBpZiAoaXRlbSAmJiBBcnJheS5pc0FycmF5KGl0ZW0pICYmIGl0ZW1bMF0uYXR0cmlidXRlcyAmJiBpdGVtWzBdLmF0dHJpYnV0ZXMuSUQgJiYgaXRlbVswXS5hdHRyaWJ1dGVzLklEWzBdKSB7CiAgICAgICAgICBjb25zdCBpZHMgPSBpdGVtWzBdLmF0dHJpYnV0ZXMuSUQ7CiAgICAgICAgICBpZHMuZm9yRWFjaCgoaWQpID0+IHsKICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uQnlJZFtpZF07CiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb21wbGV0ZWRSZWZlcmVuY2VzW2lkXTsKICAgICAgICAgIH0pOwogICAgICAgICAgaXRlbS5mb3JFYWNoKChpKSA9PiB7CiAgICAgICAgICAgIGlmIChpLmNoaWxkX2ZlYXR1cmVzKQogICAgICAgICAgICAgIGkuY2hpbGRfZmVhdHVyZXMuZm9yRWFjaCgoYykgPT4gX3VuYnVmZmVySXRlbShjKSk7CiAgICAgICAgICAgIGlmIChpLmRlcml2ZWRfZmVhdHVyZXMpCiAgICAgICAgICAgICAgaS5kZXJpdmVkX2ZlYXR1cmVzLmZvckVhY2goKGQpID0+IF91bmJ1ZmZlckl0ZW0oZCkpOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9OwogICAgICB3aGlsZSAodGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25Ub3BMZXZlbC5sZW5ndGggKyBhZGRpdGlvbmFsSXRlbUNvdW50ID4gdGhpcy5idWZmZXJTaXplKSB7CiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uVG9wTGV2ZWwuc2hpZnQoKTsKICAgICAgICBpZiAoaXRlbSkgewogICAgICAgICAgdGhpcy5fZW1pdEl0ZW0oaXRlbSk7CiAgICAgICAgICBfdW5idWZmZXJJdGVtKGl0ZW0pOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgX2VtaXRBbGxVbmRlckNvbnN0cnVjdGlvbkZlYXR1cmVzKCkgewogICAgICB0aGlzLl91bmRlckNvbnN0cnVjdGlvblRvcExldmVsLmZvckVhY2godGhpcy5fZW1pdEl0ZW0uYmluZCh0aGlzKSk7CiAgICAgIHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uVG9wTGV2ZWwgPSBbXTsKICAgICAgdGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25CeUlkID0ge307CiAgICAgIHRoaXMuX2NvbXBsZXRlZFJlZmVyZW5jZXMgPSB7fTsKICAgICAgaWYgKEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyh0aGlzLl91bmRlckNvbnN0cnVjdGlvbk9ycGhhbnMpKS5sZW5ndGgpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNvbWUgZmVhdHVyZXMgcmVmZXJlbmNlIG90aGVyIGZlYXR1cmVzIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBmaWxlIChvciBpbiB0aGUgc2FtZSAnIyMjJyBzY29wZSkuICR7T2JqZWN0LmtleXModGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25PcnBoYW5zKX1gKTsKICAgICAgfQogICAgfQogICAgX2J1ZmZlckxpbmUobGluZSkgewogICAgICB2YXIgX2EsIF9iLCBfYzsKICAgICAgY29uc3QgcmF3RmVhdHVyZUxpbmUgPSBwYXJzZUZlYXR1cmUobGluZSk7CiAgICAgIGNvbnN0IGZlYXR1cmVMaW5lID0gewogICAgICAgIC4uLnJhd0ZlYXR1cmVMaW5lLAogICAgICAgIGNoaWxkX2ZlYXR1cmVzOiBbXSwKICAgICAgICBkZXJpdmVkX2ZlYXR1cmVzOiBbXQogICAgICB9OwogICAgICBjb25zdCBpZHMgPSAoKF9hID0gZmVhdHVyZUxpbmUuYXR0cmlidXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLklEKSB8fCBbXTsKICAgICAgY29uc3QgcGFyZW50cyA9ICgoX2IgPSBmZWF0dXJlTGluZS5hdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuUGFyZW50KSB8fCBbXTsKICAgICAgY29uc3QgZGVyaXZlcyA9IHRoaXMuZGlzYWJsZURlcml2ZXNGcm9tUmVmZXJlbmNlcyA/IFtdIDogKChfYyA9IGZlYXR1cmVMaW5lLmF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5EZXJpdmVzX2Zyb20pIHx8IFtdOwogICAgICBpZiAoIWlkcy5sZW5ndGggJiYgIXBhcmVudHMubGVuZ3RoICYmICFkZXJpdmVzLmxlbmd0aCkgewogICAgICAgIHRoaXMuX2VtaXRJdGVtKFtmZWF0dXJlTGluZV0pOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBsZXQgZmVhdHVyZSA9IHZvaWQgMDsKICAgICAgaWRzLmZvckVhY2goKGlkKSA9PiB7CiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLl91bmRlckNvbnN0cnVjdGlvbkJ5SWRbaWRdOwogICAgICAgIGlmIChleGlzdGluZykgewogICAgICAgICAgaWYgKGV4aXN0aW5nW2V4aXN0aW5nLmxlbmd0aCAtIDFdLnR5cGUgIT09IGZlYXR1cmVMaW5lLnR5cGUpIHsKICAgICAgICAgICAgdGhpcy5fcGFyc2VFcnJvcihgbXVsdGktbGluZSBmZWF0dXJlICIke2lkfSIgaGFzIGluY29uc2lzdGVudCB0eXBlczogIiR7ZmVhdHVyZUxpbmUudHlwZX0iLCAiJHtleGlzdGluZ1tleGlzdGluZy5sZW5ndGggLSAxXS50eXBlfSJgKTsKICAgICAgICAgIH0KICAgICAgICAgIGV4aXN0aW5nLnB1c2goZmVhdHVyZUxpbmUpOwogICAgICAgICAgZmVhdHVyZSA9IGV4aXN0aW5nOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBmZWF0dXJlID0gW2ZlYXR1cmVMaW5lXTsKICAgICAgICAgIHRoaXMuX2VuZm9yY2VCdWZmZXJTaXplTGltaXQoMSk7CiAgICAgICAgICBpZiAoIXBhcmVudHMubGVuZ3RoICYmICFkZXJpdmVzLmxlbmd0aCkgewogICAgICAgICAgICB0aGlzLl91bmRlckNvbnN0cnVjdGlvblRvcExldmVsLnB1c2goZmVhdHVyZSk7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLl91bmRlckNvbnN0cnVjdGlvbkJ5SWRbaWRdID0gZmVhdHVyZTsKICAgICAgICAgIHRoaXMuX3Jlc29sdmVSZWZlcmVuY2VzVG8oZmVhdHVyZSwgaWQpOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHRoaXMuX3Jlc29sdmVSZWZlcmVuY2VzRnJvbShmZWF0dXJlIHx8IFtmZWF0dXJlTGluZV0sIHsgUGFyZW50OiBwYXJlbnRzLCBEZXJpdmVzX2Zyb206IGRlcml2ZXMgfSwgaWRzKTsKICAgIH0KICAgIF9yZXNvbHZlUmVmZXJlbmNlc1RvKGZlYXR1cmUsIGlkKSB7CiAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSB0aGlzLl91bmRlckNvbnN0cnVjdGlvbk9ycGhhbnNbaWRdOwogICAgICBpZiAoIXJlZmVyZW5jZXMpCiAgICAgICAgcmV0dXJuOwogICAgICBmZWF0dXJlLmZvckVhY2goKGxvYykgPT4gewogICAgICAgIGxvYy5jaGlsZF9mZWF0dXJlcy5wdXNoKC4uLnJlZmVyZW5jZXMuUGFyZW50KTsKICAgICAgfSk7CiAgICAgIGZlYXR1cmUuZm9yRWFjaCgobG9jKSA9PiB7CiAgICAgICAgbG9jLmRlcml2ZWRfZmVhdHVyZXMucHVzaCguLi5yZWZlcmVuY2VzLkRlcml2ZXNfZnJvbSk7CiAgICAgIH0pOwogICAgICBkZWxldGUgdGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25PcnBoYW5zW2lkXTsKICAgIH0KICAgIF9wYXJzZUVycm9yKG1lc3NhZ2UpIHsKICAgICAgdGhpcy5lb2YgPSB0cnVlOwogICAgICB0aGlzLmVycm9yQ2FsbGJhY2soYCR7dGhpcy5saW5lTnVtYmVyfTogJHttZXNzYWdlfWApOwogICAgfQogICAgX3Jlc29sdmVSZWZlcmVuY2VzRnJvbShmZWF0dXJlLCByZWZlcmVuY2VzLCBpZHMpIHsKICAgICAgZnVuY3Rpb24gcG9zdFNldChvYmosIHNsb3QxLCBzbG90MikgewogICAgICAgIGxldCBzdWJPYmogPSBvYmpbc2xvdDFdOwogICAgICAgIGlmICghc3ViT2JqKSB7CiAgICAgICAgICBzdWJPYmogPSB7fTsKICAgICAgICAgIG9ialtzbG90MV0gPSBzdWJPYmo7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHJldHVyblZhbCA9IHN1Yk9ialtzbG90Ml0gfHwgZmFsc2U7CiAgICAgICAgc3ViT2JqW3Nsb3QyXSA9IHRydWU7CiAgICAgICAgcmV0dXJuIHJldHVyblZhbDsKICAgICAgfQogICAgICByZWZlcmVuY2VzLlBhcmVudC5mb3JFYWNoKCh0b0lkKSA9PiB7CiAgICAgICAgY29uc3Qgb3RoZXJGZWF0dXJlID0gdGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25CeUlkW3RvSWRdOwogICAgICAgIGlmIChvdGhlckZlYXR1cmUpIHsKICAgICAgICAgIGNvbnN0IHBuYW1lID0gY29udGFpbmVyQXR0cmlidXRlcy5QYXJlbnQ7CiAgICAgICAgICBpZiAoIWlkcy5maWx0ZXIoKGlkKSA9PiBwb3N0U2V0KHRoaXMuX2NvbXBsZXRlZFJlZmVyZW5jZXMsIGlkLCBgUGFyZW50LCR7dG9JZH1gKSkubGVuZ3RoKSB7CiAgICAgICAgICAgIG90aGVyRmVhdHVyZS5mb3JFYWNoKChsb2NhdGlvbikgPT4gewogICAgICAgICAgICAgIGxvY2F0aW9uW3BuYW1lXS5wdXNoKGZlYXR1cmUpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgbGV0IHJlZiA9IHRoaXMuX3VuZGVyQ29uc3RydWN0aW9uT3JwaGFuc1t0b0lkXTsKICAgICAgICAgIGlmICghcmVmKSB7CiAgICAgICAgICAgIHJlZiA9IHsKICAgICAgICAgICAgICBQYXJlbnQ6IFtdLAogICAgICAgICAgICAgIERlcml2ZXNfZnJvbTogW10KICAgICAgICAgICAgfTsKICAgICAgICAgICAgdGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25PcnBoYW5zW3RvSWRdID0gcmVmOwogICAgICAgICAgfQogICAgICAgICAgcmVmLlBhcmVudC5wdXNoKGZlYXR1cmUpOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHJlZmVyZW5jZXMuRGVyaXZlc19mcm9tLmZvckVhY2goKHRvSWQpID0+IHsKICAgICAgICBjb25zdCBvdGhlckZlYXR1cmUgPSB0aGlzLl91bmRlckNvbnN0cnVjdGlvbkJ5SWRbdG9JZF07CiAgICAgICAgaWYgKG90aGVyRmVhdHVyZSkgewogICAgICAgICAgY29uc3QgcG5hbWUgPSBjb250YWluZXJBdHRyaWJ1dGVzLkRlcml2ZXNfZnJvbTsKICAgICAgICAgIGlmICghaWRzLmZpbHRlcigoaWQpID0+IHBvc3RTZXQodGhpcy5fY29tcGxldGVkUmVmZXJlbmNlcywgaWQsIGBEZXJpdmVzX2Zyb20sJHt0b0lkfWApKS5sZW5ndGgpIHsKICAgICAgICAgICAgb3RoZXJGZWF0dXJlLmZvckVhY2goKGxvY2F0aW9uKSA9PiB7CiAgICAgICAgICAgICAgbG9jYXRpb25bcG5hbWVdLnB1c2goZmVhdHVyZSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBsZXQgcmVmID0gdGhpcy5fdW5kZXJDb25zdHJ1Y3Rpb25PcnBoYW5zW3RvSWRdOwogICAgICAgICAgaWYgKCFyZWYpIHsKICAgICAgICAgICAgcmVmID0gewogICAgICAgICAgICAgIFBhcmVudDogW10sCiAgICAgICAgICAgICAgRGVyaXZlc19mcm9tOiBbXQogICAgICAgICAgICB9OwogICAgICAgICAgICB0aGlzLl91bmRlckNvbnN0cnVjdGlvbk9ycGhhbnNbdG9JZF0gPSByZWY7CiAgICAgICAgICB9CiAgICAgICAgICByZWYuRGVyaXZlc19mcm9tLnB1c2goZmVhdHVyZSk7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrZ2ZmQDEuMy4wL25vZGVfbW9kdWxlcy9AZ21vZC9nZmYvZXNtL2FwaS5qcwogIGZ1bmN0aW9uIF9jYWxsYmFjayhjYWxsYmFjaykgewogICAgaWYgKHByb2Nlc3MgJiYgcHJvY2Vzcy5uZXh0VGljaykKICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7CiAgICBlbHNlCiAgICAgIGNhbGxiYWNrKCk7CiAgfQogIGZ1bmN0aW9uIF9wcm9jZXNzUGFyc2VPcHRpb25zKG9wdGlvbnMpIHsKICAgIGNvbnN0IG91dCA9IHsKICAgICAgZW5jb2Rpbmc6ICJ1dGY4IiwKICAgICAgcGFyc2VGZWF0dXJlczogdHJ1ZSwKICAgICAgcGFyc2VEaXJlY3RpdmVzOiBmYWxzZSwKICAgICAgcGFyc2VTZXF1ZW5jZXM6IHRydWUsCiAgICAgIHBhcnNlQ29tbWVudHM6IGZhbHNlLAogICAgICBidWZmZXJTaXplOiAxZTMsCiAgICAgIGRpc2FibGVEZXJpdmVzRnJvbVJlZmVyZW5jZXM6IGZhbHNlLAogICAgICAuLi5vcHRpb25zCiAgICB9OwogICAgaWYgKG9wdGlvbnMucGFyc2VBbGwpIHsKICAgICAgb3V0LnBhcnNlRmVhdHVyZXMgPSB0cnVlOwogICAgICBvdXQucGFyc2VEaXJlY3RpdmVzID0gdHJ1ZTsKICAgICAgb3V0LnBhcnNlQ29tbWVudHMgPSB0cnVlOwogICAgICBvdXQucGFyc2VTZXF1ZW5jZXMgPSB0cnVlOwogICAgfQogICAgcmV0dXJuIG91dDsKICB9CiAgdmFyIEdGRlRyYW5zZm9ybSA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X3N0cmVhbS5UcmFuc2Zvcm0gewogICAgY29uc3RydWN0b3IoaW5wdXRPcHRpb25zID0ge30pIHsKICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pOwogICAgICB0aGlzLnRleHRCdWZmZXIgPSAiIjsKICAgICAgY29uc3Qgb3B0aW9ucyA9IF9wcm9jZXNzUGFyc2VPcHRpb25zKGlucHV0T3B0aW9ucyk7CiAgICAgIHRoaXMuZW5jb2RpbmcgPSBpbnB1dE9wdGlvbnMuZW5jb2RpbmcgfHwgInV0ZjgiOwogICAgICB0aGlzLmRlY29kZXIgPSBuZXcgaW1wb3J0X3N0cmluZ19kZWNvZGVyLlN0cmluZ0RlY29kZXIoKTsKICAgICAgY29uc3QgcHVzaCA9IHRoaXMucHVzaC5iaW5kKHRoaXMpOwogICAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIoewogICAgICAgIGZlYXR1cmVDYWxsYmFjazogb3B0aW9ucy5wYXJzZUZlYXR1cmVzID8gcHVzaCA6IHZvaWQgMCwKICAgICAgICBkaXJlY3RpdmVDYWxsYmFjazogb3B0aW9ucy5wYXJzZURpcmVjdGl2ZXMgPyBwdXNoIDogdm9pZCAwLAogICAgICAgIGNvbW1lbnRDYWxsYmFjazogb3B0aW9ucy5wYXJzZUNvbW1lbnRzID8gcHVzaCA6IHZvaWQgMCwKICAgICAgICBzZXF1ZW5jZUNhbGxiYWNrOiBvcHRpb25zLnBhcnNlU2VxdWVuY2VzID8gcHVzaCA6IHZvaWQgMCwKICAgICAgICBlcnJvckNhbGxiYWNrOiAoZXJyKSA9PiB0aGlzLmVtaXQoImVycm9yIiwgZXJyKSwKICAgICAgICBidWZmZXJTaXplOiBvcHRpb25zLmJ1ZmZlclNpemUsCiAgICAgICAgZGlzYWJsZURlcml2ZXNGcm9tUmVmZXJlbmNlczogb3B0aW9ucy5kaXNhYmxlRGVyaXZlc0Zyb21SZWZlcmVuY2VzCiAgICAgIH0pOwogICAgfQogICAgX2FkZExpbmUoZGF0YSkgewogICAgICBpZiAoZGF0YSkgewogICAgICAgIHRoaXMucGFyc2VyLmFkZExpbmUoZGF0YSk7CiAgICAgIH0KICAgIH0KICAgIF9uZXh0VGV4dChidWZmZXIpIHsKICAgICAgY29uc3QgcGllY2VzID0gKHRoaXMudGV4dEJ1ZmZlciArIGJ1ZmZlcikuc3BsaXQoL1xyP1xuLyk7CiAgICAgIHRoaXMudGV4dEJ1ZmZlciA9IHBpZWNlcy5wb3AoKSB8fCAiIjsKICAgICAgcGllY2VzLmZvckVhY2goKHBpZWNlKSA9PiB0aGlzLl9hZGRMaW5lKHBpZWNlKSk7CiAgICB9CiAgICBfdHJhbnNmb3JtKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7CiAgICAgIHRoaXMuX25leHRUZXh0KHRoaXMuZGVjb2Rlci53cml0ZShjaHVuaykpOwogICAgICBfY2FsbGJhY2soY2FsbGJhY2spOwogICAgfQogICAgX2ZsdXNoKGNhbGxiYWNrKSB7CiAgICAgIGlmICh0aGlzLmRlY29kZXIuZW5kKQogICAgICAgIHRoaXMuX25leHRUZXh0KHRoaXMuZGVjb2Rlci5lbmQoKSk7CiAgICAgIGlmICh0aGlzLnRleHRCdWZmZXIgIT0gbnVsbCkKICAgICAgICB0aGlzLl9hZGRMaW5lKHRoaXMudGV4dEJ1ZmZlcik7CiAgICAgIHRoaXMucGFyc2VyLmZpbmlzaCgpOwogICAgICBfY2FsbGJhY2soY2FsbGJhY2spOwogICAgfQogIH07CiAgZnVuY3Rpb24gcGFyc2VTdHJlYW0ob3B0aW9ucyA9IHt9KSB7CiAgICByZXR1cm4gbmV3IEdGRlRyYW5zZm9ybShvcHRpb25zKTsKICB9CiAgZnVuY3Rpb24gcGFyc2VTdHJpbmdTeW5jKHN0ciwgaW5wdXRPcHRpb25zID0ge30pIHsKICAgIGlmICghc3RyKQogICAgICByZXR1cm4gW107CiAgICBjb25zdCBvcHRpb25zID0gX3Byb2Nlc3NQYXJzZU9wdGlvbnMoaW5wdXRPcHRpb25zKTsKICAgIGNvbnN0IGl0ZW1zID0gW107CiAgICBjb25zdCBwdXNoID0gaXRlbXMucHVzaC5iaW5kKGl0ZW1zKTsKICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoewogICAgICBmZWF0dXJlQ2FsbGJhY2s6IG9wdGlvbnMucGFyc2VGZWF0dXJlcyA/IHB1c2ggOiB2b2lkIDAsCiAgICAgIGRpcmVjdGl2ZUNhbGxiYWNrOiBvcHRpb25zLnBhcnNlRGlyZWN0aXZlcyA/IHB1c2ggOiB2b2lkIDAsCiAgICAgIGNvbW1lbnRDYWxsYmFjazogb3B0aW9ucy5wYXJzZUNvbW1lbnRzID8gcHVzaCA6IHZvaWQgMCwKICAgICAgc2VxdWVuY2VDYWxsYmFjazogb3B0aW9ucy5wYXJzZVNlcXVlbmNlcyA/IHB1c2ggOiB2b2lkIDAsCiAgICAgIGRpc2FibGVEZXJpdmVzRnJvbVJlZmVyZW5jZXM6IG9wdGlvbnMuZGlzYWJsZURlcml2ZXNGcm9tUmVmZXJlbmNlcyB8fCBmYWxzZSwKICAgICAgYnVmZmVyU2l6ZTogSW5maW5pdHksCiAgICAgIGVycm9yQ2FsbGJhY2s6IChlcnIpID0+IHsKICAgICAgICB0aHJvdyBlcnI7CiAgICAgIH0KICAgIH0pOwogICAgc3RyLnNwbGl0KC9ccj9cbi8pLmZvckVhY2gocGFyc2VyLmFkZExpbmUuYmluZChwYXJzZXIpKTsKICAgIHBhcnNlci5maW5pc2goKTsKICAgIHJldHVybiBpdGVtczsKICB9CiAgZnVuY3Rpb24gZm9ybWF0U3luYyhpdGVtcykgewogICAgY29uc3Qgb3RoZXIgPSBbXTsKICAgIGNvbnN0IHNlcXVlbmNlcyA9IFtdOwogICAgaXRlbXMuZm9yRWFjaCgoaSkgPT4gewogICAgICBpZiAoInNlcXVlbmNlIiBpbiBpKQogICAgICAgIHNlcXVlbmNlcy5wdXNoKGkpOwogICAgICBlbHNlCiAgICAgICAgb3RoZXIucHVzaChpKTsKICAgIH0pOwogICAgbGV0IHN0ciA9IG90aGVyLm1hcChmb3JtYXRJdGVtKS5qb2luKCIiKTsKICAgIGlmIChzZXF1ZW5jZXMubGVuZ3RoKSB7CiAgICAgIHN0ciArPSAiIyNGQVNUQVxuIjsKICAgICAgc3RyICs9IHNlcXVlbmNlcy5tYXAoZm9ybWF0U2VxdWVuY2UpLmpvaW4oIiIpOwogICAgfQogICAgcmV0dXJuIHN0cjsKICB9CiAgdmFyIEZvcm1hdHRpbmdUcmFuc2Zvcm0gPSBjbGFzcyBleHRlbmRzIGltcG9ydF9zdHJlYW0uVHJhbnNmb3JtIHsKICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkgewogICAgICBzdXBlcihPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgb2JqZWN0TW9kZTogdHJ1ZSB9KSk7CiAgICAgIHRoaXMubGluZXNTaW5jZUxhc3RTeW5jTWFyayA9IDA7CiAgICAgIHRoaXMuaGF2ZVdlRW1pdHRlZERhdGEgPSBmYWxzZTsKICAgICAgdGhpcy5mYXN0YU1vZGUgPSBmYWxzZTsKICAgICAgdGhpcy5taW5MaW5lc0JldHdlZW5TeW5jTWFya3MgPSBvcHRpb25zLm1pblN5bmNMaW5lcyB8fCAxMDA7CiAgICAgIHRoaXMuaW5zZXJ0VmVyc2lvbkRpcmVjdGl2ZSA9IG9wdGlvbnMuaW5zZXJ0VmVyc2lvbkRpcmVjdGl2ZSB8fCBmYWxzZTsKICAgIH0KICAgIF90cmFuc2Zvcm0oY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHsKICAgICAgbGV0IHN0cjsKICAgICAgaWYgKCF0aGlzLmhhdmVXZUVtaXR0ZWREYXRhICYmIHRoaXMuaW5zZXJ0VmVyc2lvbkRpcmVjdGl2ZSkgewogICAgICAgIGNvbnN0IHRoaXNDaHVuayA9IEFycmF5LmlzQXJyYXkoY2h1bmspID8gY2h1bmtbMF0gOiBjaHVuazsKICAgICAgICBpZiAoImRpcmVjdGl2ZSIgaW4gdGhpc0NodW5rKSB7CiAgICAgICAgICBpZiAodGhpc0NodW5rLmRpcmVjdGl2ZSAhPT0gImdmZi12ZXJzaW9uIikgewogICAgICAgICAgICB0aGlzLnB1c2goIiMjZ2ZmLXZlcnNpb24gM1xuIik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmICgic2VxdWVuY2UiIGluIGNodW5rICYmICF0aGlzLmZhc3RhTW9kZSkgewogICAgICAgIHRoaXMucHVzaCgiIyNGQVNUQVxuIik7CiAgICAgICAgdGhpcy5mYXN0YU1vZGUgPSB0cnVlOwogICAgICB9CiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNodW5rKSkKICAgICAgICBzdHIgPSBjaHVuay5tYXAoZm9ybWF0SXRlbSkuam9pbigiIik7CiAgICAgIGVsc2UKICAgICAgICBzdHIgPSBmb3JtYXRJdGVtKGNodW5rKTsKICAgICAgdGhpcy5wdXNoKHN0cik7CiAgICAgIGlmICh0aGlzLmxpbmVzU2luY2VMYXN0U3luY01hcmsgPj0gdGhpcy5taW5MaW5lc0JldHdlZW5TeW5jTWFya3MpIHsKICAgICAgICB0aGlzLnB1c2goIiMjI1xuIik7CiAgICAgICAgdGhpcy5saW5lc1NpbmNlTGFzdFN5bmNNYXJrID0gMDsKICAgICAgfSBlbHNlIHsKICAgICAgICBsZXQgY291bnQgPSAwOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICBpZiAoc3RyW2ldID09PSAiXG4iKQogICAgICAgICAgICBjb3VudCArPSAxOwogICAgICAgIH0KICAgICAgICB0aGlzLmxpbmVzU2luY2VMYXN0U3luY01hcmsgKz0gY291bnQ7CiAgICAgIH0KICAgICAgdGhpcy5oYXZlV2VFbWl0dGVkRGF0YSA9IHRydWU7CiAgICAgIF9jYWxsYmFjayhjYWxsYmFjayk7CiAgICB9CiAgfTsKICBmdW5jdGlvbiBmb3JtYXRTdHJlYW0ob3B0aW9ucyA9IHt9KSB7CiAgICByZXR1cm4gbmV3IEZvcm1hdHRpbmdUcmFuc2Zvcm0ob3B0aW9ucyk7CiAgfQogIGZ1bmN0aW9uIGZvcm1hdEZpbGUoc3RyZWFtLCB3cml0ZVN0cmVhbSwgb3B0aW9ucyA9IHt9KSB7CiAgICBjb25zdCBuZXdPcHRpb25zID0gewogICAgICBpbnNlcnRWZXJzaW9uRGlyZWN0aXZlOiB0cnVlLAogICAgICAuLi5vcHRpb25zCiAgICB9OwogICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsKICAgICAgc3RyZWFtLnBpcGUobmV3IEZvcm1hdHRpbmdUcmFuc2Zvcm0obmV3T3B0aW9ucykpLm9uKCJlbmQiLCAoKSA9PiByZXNvbHZlKG51bGwpKS5vbigiZXJyb3IiLCByZWplY3QpLnBpcGUod3JpdGVTdHJlYW0pOwogICAgfSk7CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrZ2ZmQDEuMy4wL25vZGVfbW9kdWxlcy9AZ21vZC9nZmYvZXNtL2luZGV4LmpzCiAgdmFyIGVzbV9kZWZhdWx0ID0gewogICAgcGFyc2VTdHJlYW0sCiAgICBwYXJzZVN0cmluZ1N5bmMsCiAgICBmb3JtYXRTeW5jLAogICAgZm9ybWF0U3RyZWFtLAogICAgZm9ybWF0RmlsZSwKICAgIHV0aWw6IHV0aWxfZXhwb3J0cwogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL3dvcmtlci5tanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF93b3JrZXIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfd29ya2VyKCkpOwogIHZhciBleHBvc2UgPSBpbXBvcnRfd29ya2VyLmRlZmF1bHQuZXhwb3NlOwogIHZhciByZWdpc3RlclNlcmlhbGl6ZXIgPSBpbXBvcnRfd29ya2VyLmRlZmF1bHQucmVnaXN0ZXJTZXJpYWxpemVyOwogIHZhciBUcmFuc2ZlciA9IGltcG9ydF93b3JrZXIuZGVmYXVsdC5UcmFuc2ZlcjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbG9kYXNoLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gIm9iamVjdCIgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7CiAgdmFyIGZyZWVHbG9iYWxfZGVmYXVsdCA9IGZyZWVHbG9iYWw7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzCiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gIm9iamVjdCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7CiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsX2RlZmF1bHQgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oInJldHVybiB0aGlzIikoKTsKICB2YXIgcm9vdF9kZWZhdWx0ID0gcm9vdDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcwogIHZhciBTeW1ib2wyID0gcm9vdF9kZWZhdWx0LlN5bWJvbDsKICB2YXIgU3ltYm9sX2RlZmF1bHQgPSBTeW1ib2wyOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7CiAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7CiAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7CiAgdmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sX2RlZmF1bHQgPyBTeW1ib2xfZGVmYXVsdC50b1N0cmluZ1RhZyA6IHZvaWQgMDsKICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHsKICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSwgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddOwogICAgdHJ5IHsKICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdm9pZCAwOwogICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlOwogICAgfSBjYXRjaCAoZSkgewogICAgfQogICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpOwogICAgaWYgKHVubWFza2VkKSB7CiAgICAgIGlmIChpc093bikgewogICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZzsKICAgICAgfSBlbHNlIHsKICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgZ2V0UmF3VGFnX2RlZmF1bHQgPSBnZXRSYXdUYWc7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8yID0gT2JqZWN0LnByb3RvdHlwZTsKICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcyID0gb2JqZWN0UHJvdG8yLnRvU3RyaW5nOwogIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7CiAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcyLmNhbGwodmFsdWUpOwogIH0KICB2YXIgb2JqZWN0VG9TdHJpbmdfZGVmYXVsdCA9IG9iamVjdFRvU3RyaW5nOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcwogIHZhciBudWxsVGFnID0gIltvYmplY3QgTnVsbF0iOwogIHZhciB1bmRlZmluZWRUYWcgPSAiW29iamVjdCBVbmRlZmluZWRdIjsKICB2YXIgc3ltVG9TdHJpbmdUYWcyID0gU3ltYm9sX2RlZmF1bHQgPyBTeW1ib2xfZGVmYXVsdC50b1N0cmluZ1RhZyA6IHZvaWQgMDsKICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7CiAgICBpZiAodmFsdWUgPT0gbnVsbCkgewogICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7CiAgICB9CiAgICByZXR1cm4gc3ltVG9TdHJpbmdUYWcyICYmIHN5bVRvU3RyaW5nVGFnMiBpbiBPYmplY3QodmFsdWUpID8gZ2V0UmF3VGFnX2RlZmF1bHQodmFsdWUpIDogb2JqZWN0VG9TdHJpbmdfZGVmYXVsdCh2YWx1ZSk7CiAgfQogIHZhciBiYXNlR2V0VGFnX2RlZmF1bHQgPSBiYXNlR2V0VGFnOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7CiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gIm9iamVjdCI7CiAgfQogIHZhciBpc09iamVjdExpa2VfZGVmYXVsdCA9IGlzT2JqZWN0TGlrZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNTeW1ib2wuanMKICB2YXIgc3ltYm9sVGFnID0gIltvYmplY3QgU3ltYm9sXSI7CiAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHsKICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gInN5bWJvbCIgfHwgaXNPYmplY3RMaWtlX2RlZmF1bHQodmFsdWUpICYmIGJhc2VHZXRUYWdfZGVmYXVsdCh2YWx1ZSkgPT0gc3ltYm9sVGFnOwogIH0KICB2YXIgaXNTeW1ib2xfZGVmYXVsdCA9IGlzU3ltYm9sOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlNYXAuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7CiAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7CiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkgewogICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGFycmF5TWFwX2RlZmF1bHQgPSBhcnJheU1hcDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7CiAgdmFyIGlzQXJyYXlfZGVmYXVsdCA9IGlzQXJyYXk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvSW50ZWdlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9GaW5pdGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvTnVtYmVyLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRyaW0uanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190cmltbWVkRW5kSW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIHJlV2hpdGVzcGFjZSA9IC9ccy87CiAgZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykgewogICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDsKICAgIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkgewogICAgfQogICAgcmV0dXJuIGluZGV4OwogIH0KICB2YXIgdHJpbW1lZEVuZEluZGV4X2RlZmF1bHQgPSB0cmltbWVkRW5kSW5kZXg7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVHJpbS5qcwogIHZhciByZVRyaW1TdGFydCA9IC9eXHMrLzsKICBmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHsKICAgIHJldHVybiBzdHJpbmcgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4X2RlZmF1bHQoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICIiKSA6IHN0cmluZzsKICB9CiAgdmFyIGJhc2VUcmltX2RlZmF1bHQgPSBiYXNlVHJpbTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHsKICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gIm9iamVjdCIgfHwgdHlwZSA9PSAiZnVuY3Rpb24iKTsKICB9CiAgdmFyIGlzT2JqZWN0X2RlZmF1bHQgPSBpc09iamVjdDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9OdW1iZXIuanMKICB2YXIgTkFOID0gMCAvIDA7CiAgdmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTsKICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTsKICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTsKICB2YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7CiAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHsKICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gIm51bWJlciIpIHsKICAgICAgcmV0dXJuIHZhbHVlOwogICAgfQogICAgaWYgKGlzU3ltYm9sX2RlZmF1bHQodmFsdWUpKSB7CiAgICAgIHJldHVybiBOQU47CiAgICB9CiAgICBpZiAoaXNPYmplY3RfZGVmYXVsdCh2YWx1ZSkpIHsKICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gImZ1bmN0aW9uIiA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlOwogICAgICB2YWx1ZSA9IGlzT2JqZWN0X2RlZmF1bHQob3RoZXIpID8gb3RoZXIgKyAiIiA6IG90aGVyOwogICAgfQogICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAic3RyaW5nIikgewogICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTsKICAgIH0KICAgIHZhbHVlID0gYmFzZVRyaW1fZGVmYXVsdCh2YWx1ZSk7CiAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpOwogICAgcmV0dXJuIGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOCkgOiByZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlOwogIH0KICB2YXIgdG9OdW1iZXJfZGVmYXVsdCA9IHRvTnVtYmVyOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qcwogIHZhciBJTkZJTklUWSA9IDEgLyAwOwogIHZhciBNQVhfSU5URUdFUiA9IDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MjsKICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkgewogICAgaWYgKCF2YWx1ZSkgewogICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7CiAgICB9CiAgICB2YWx1ZSA9IHRvTnVtYmVyX2RlZmF1bHQodmFsdWUpOwogICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7CiAgICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gLTEgOiAxOwogICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSOwogICAgfQogICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDsKICB9CiAgdmFyIHRvRmluaXRlX2RlZmF1bHQgPSB0b0Zpbml0ZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9JbnRlZ2VyLmpzCiAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7CiAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGVfZGVmYXVsdCh2YWx1ZSksIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7CiAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyByZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQgOiAwOwogIH0KICB2YXIgdG9JbnRlZ2VyX2RlZmF1bHQgPSB0b0ludGVnZXI7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGFzeW5jVGFnID0gIltvYmplY3QgQXN5bmNGdW5jdGlvbl0iOwogIHZhciBmdW5jVGFnID0gIltvYmplY3QgRnVuY3Rpb25dIjsKICB2YXIgZ2VuVGFnID0gIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIjsKICB2YXIgcHJveHlUYWcgPSAiW29iamVjdCBQcm94eV0iOwogIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHsKICAgIGlmICghaXNPYmplY3RfZGVmYXVsdCh2YWx1ZSkpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgdmFyIHRhZyA9IGJhc2VHZXRUYWdfZGVmYXVsdCh2YWx1ZSk7CiAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnOwogIH0KICB2YXIgaXNGdW5jdGlvbl9kZWZhdWx0ID0gaXNGdW5jdGlvbjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkgewogICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7CiAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07CiAgICB9CiAgICByZXR1cm4gYXJyYXk7CiAgfQogIHZhciBjb3B5QXJyYXlfZGVmYXVsdCA9IGNvcHlBcnJheTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxOwogIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxkKikkLzsKICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHsKICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoOwogICAgcmV0dXJuICEhbGVuZ3RoICYmICh0eXBlID09ICJudW1iZXIiIHx8IHR5cGUgIT0gInN5bWJvbCIgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTsKICB9CiAgdmFyIGlzSW5kZXhfZGVmYXVsdCA9IGlzSW5kZXg7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikgewogICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyOwogIH0KICB2YXIgZXFfZGVmYXVsdCA9IGVxOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0xlbmd0aC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgTUFYX1NBRkVfSU5URUdFUjIgPSA5MDA3MTk5MjU0NzQwOTkxOwogIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7CiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICJudW1iZXIiICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjI7CiAgfQogIHZhciBpc0xlbmd0aF9kZWZhdWx0ID0gaXNMZW5ndGg7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzCiAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHsKICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoX2RlZmF1bHQodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbl9kZWZhdWx0KHZhbHVlKTsKICB9CiAgdmFyIGlzQXJyYXlMaWtlX2RlZmF1bHQgPSBpc0FycmF5TGlrZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSXRlcmF0ZWVDYWxsLmpzCiAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHsKICAgIGlmICghaXNPYmplY3RfZGVmYXVsdChvYmplY3QpKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4OwogICAgaWYgKHR5cGUgPT0gIm51bWJlciIgPyBpc0FycmF5TGlrZV9kZWZhdWx0KG9iamVjdCkgJiYgaXNJbmRleF9kZWZhdWx0KGluZGV4LCBvYmplY3QubGVuZ3RoKSA6IHR5cGUgPT0gInN0cmluZyIgJiYgaW5kZXggaW4gb2JqZWN0KSB7CiAgICAgIHJldHVybiBlcV9kZWZhdWx0KG9iamVjdFtpbmRleF0sIHZhbHVlKTsKICAgIH0KICAgIHJldHVybiBmYWxzZTsKICB9CiAgdmFyIGlzSXRlcmF0ZWVDYWxsX2RlZmF1bHQgPSBpc0l0ZXJhdGVlQ2FsbDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzUHJvdG90eXBlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBvYmplY3RQcm90bzMgPSBPYmplY3QucHJvdG90eXBlOwogIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7CiAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLCBwcm90byA9IHR5cGVvZiBDdG9yID09ICJmdW5jdGlvbiIgJiYgQ3Rvci5wcm90b3R5cGUgfHwgb2JqZWN0UHJvdG8zOwogICAgcmV0dXJuIHZhbHVlID09PSBwcm90bzsKICB9CiAgdmFyIGlzUHJvdG90eXBlX2RlZmF1bHQgPSBpc1Byb3RvdHlwZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7CiAgICB2YXIgaW5kZXggPSAtMSwgcmVzdWx0ID0gQXJyYXkobik7CiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHsKICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBiYXNlVGltZXNfZGVmYXVsdCA9IGJhc2VUaW1lczsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGFyZ3NUYWcgPSAiW29iamVjdCBBcmd1bWVudHNdIjsKICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHsKICAgIHJldHVybiBpc09iamVjdExpa2VfZGVmYXVsdCh2YWx1ZSkgJiYgYmFzZUdldFRhZ19kZWZhdWx0KHZhbHVlKSA9PSBhcmdzVGFnOwogIH0KICB2YXIgYmFzZUlzQXJndW1lbnRzX2RlZmF1bHQgPSBiYXNlSXNBcmd1bWVudHM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzCiAgdmFyIG9iamVjdFByb3RvNCA9IE9iamVjdC5wcm90b3R5cGU7CiAgdmFyIGhhc093blByb3BlcnR5MiA9IG9iamVjdFByb3RvNC5oYXNPd25Qcm9wZXJ0eTsKICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90bzQucHJvcGVydHlJc0VudW1lcmFibGU7CiAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzX2RlZmF1bHQoZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gYXJndW1lbnRzOwogIH0oKSkgPyBiYXNlSXNBcmd1bWVudHNfZGVmYXVsdCA6IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICByZXR1cm4gaXNPYmplY3RMaWtlX2RlZmF1bHQodmFsdWUpICYmIGhhc093blByb3BlcnR5Mi5jYWxsKHZhbHVlLCAiY2FsbGVlIikgJiYgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICJjYWxsZWUiKTsKICB9OwogIHZhciBpc0FyZ3VtZW50c19kZWZhdWx0ID0gaXNBcmd1bWVudHM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gc3R1YkZhbHNlKCkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KICB2YXIgc3R1YkZhbHNlX2RlZmF1bHQgPSBzdHViRmFsc2U7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzCiAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gIm9iamVjdCIgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzOwogIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAib2JqZWN0IiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7CiAgdmFyIEJ1ZmZlcjkgPSBtb2R1bGVFeHBvcnRzID8gcm9vdF9kZWZhdWx0LkJ1ZmZlciA6IHZvaWQgMDsKICB2YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXI5ID8gQnVmZmVyOS5pc0J1ZmZlciA6IHZvaWQgMDsKICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2VfZGVmYXVsdDsKICB2YXIgaXNCdWZmZXJfZGVmYXVsdCA9IGlzQnVmZmVyOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBhcmdzVGFnMiA9ICJbb2JqZWN0IEFyZ3VtZW50c10iOwogIHZhciBhcnJheVRhZyA9ICJbb2JqZWN0IEFycmF5XSI7CiAgdmFyIGJvb2xUYWcgPSAiW29iamVjdCBCb29sZWFuXSI7CiAgdmFyIGRhdGVUYWcgPSAiW29iamVjdCBEYXRlXSI7CiAgdmFyIGVycm9yVGFnID0gIltvYmplY3QgRXJyb3JdIjsKICB2YXIgZnVuY1RhZzIgPSAiW29iamVjdCBGdW5jdGlvbl0iOwogIHZhciBtYXBUYWcgPSAiW29iamVjdCBNYXBdIjsKICB2YXIgbnVtYmVyVGFnID0gIltvYmplY3QgTnVtYmVyXSI7CiAgdmFyIG9iamVjdFRhZyA9ICJbb2JqZWN0IE9iamVjdF0iOwogIHZhciByZWdleHBUYWcgPSAiW29iamVjdCBSZWdFeHBdIjsKICB2YXIgc2V0VGFnID0gIltvYmplY3QgU2V0XSI7CiAgdmFyIHN0cmluZ1RhZyA9ICJbb2JqZWN0IFN0cmluZ10iOwogIHZhciB3ZWFrTWFwVGFnID0gIltvYmplY3QgV2Vha01hcF0iOwogIHZhciBhcnJheUJ1ZmZlclRhZyA9ICJbb2JqZWN0IEFycmF5QnVmZmVyXSI7CiAgdmFyIGRhdGFWaWV3VGFnID0gIltvYmplY3QgRGF0YVZpZXddIjsKICB2YXIgZmxvYXQzMlRhZyA9ICJbb2JqZWN0IEZsb2F0MzJBcnJheV0iOwogIHZhciBmbG9hdDY0VGFnID0gIltvYmplY3QgRmxvYXQ2NEFycmF5XSI7CiAgdmFyIGludDhUYWcgPSAiW29iamVjdCBJbnQ4QXJyYXldIjsKICB2YXIgaW50MTZUYWcgPSAiW29iamVjdCBJbnQxNkFycmF5XSI7CiAgdmFyIGludDMyVGFnID0gIltvYmplY3QgSW50MzJBcnJheV0iOwogIHZhciB1aW50OFRhZyA9ICJbb2JqZWN0IFVpbnQ4QXJyYXldIjsKICB2YXIgdWludDhDbGFtcGVkVGFnID0gIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIjsKICB2YXIgdWludDE2VGFnID0gIltvYmplY3QgVWludDE2QXJyYXldIjsKICB2YXIgdWludDMyVGFnID0gIltvYmplY3QgVWludDMyQXJyYXldIjsKICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTsKICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlOwogIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWcyXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnMl0gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlOwogIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHsKICAgIHJldHVybiBpc09iamVjdExpa2VfZGVmYXVsdCh2YWx1ZSkgJiYgaXNMZW5ndGhfZGVmYXVsdCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZ19kZWZhdWx0KHZhbHVlKV07CiAgfQogIHZhciBiYXNlSXNUeXBlZEFycmF5X2RlZmF1bHQgPSBiYXNlSXNUeXBlZEFycmF5OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7CiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHsKICAgICAgcmV0dXJuIGZ1bmModmFsdWUpOwogICAgfTsKICB9CiAgdmFyIGJhc2VVbmFyeV9kZWZhdWx0ID0gYmFzZVVuYXJ5OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGZyZWVFeHBvcnRzMiA9IHR5cGVvZiBleHBvcnRzID09ICJvYmplY3QiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKICB2YXIgZnJlZU1vZHVsZTIgPSBmcmVlRXhwb3J0czIgJiYgdHlwZW9mIG1vZHVsZSA9PSAib2JqZWN0IiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CiAgdmFyIG1vZHVsZUV4cG9ydHMyID0gZnJlZU1vZHVsZTIgJiYgZnJlZU1vZHVsZTIuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMyOwogIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMyICYmIGZyZWVHbG9iYWxfZGVmYXVsdC5wcm9jZXNzOwogIHZhciBub2RlVXRpbCA9IGZ1bmN0aW9uKCkgewogICAgdHJ5IHsKICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZTIgJiYgZnJlZU1vZHVsZTIucmVxdWlyZSAmJiBmcmVlTW9kdWxlMi5yZXF1aXJlKCJ1dGlsIikudHlwZXM7CiAgICAgIGlmICh0eXBlcykgewogICAgICAgIHJldHVybiB0eXBlczsKICAgICAgfQogICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCJ1dGlsIik7CiAgICB9IGNhdGNoIChlKSB7CiAgICB9CiAgfSgpOwogIHZhciBub2RlVXRpbF9kZWZhdWx0ID0gbm9kZVV0aWw7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcwogIHZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWxfZGVmYXVsdCAmJiBub2RlVXRpbF9kZWZhdWx0LmlzVHlwZWRBcnJheTsKICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeV9kZWZhdWx0KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheV9kZWZhdWx0OwogIHZhciBpc1R5cGVkQXJyYXlfZGVmYXVsdCA9IGlzVHlwZWRBcnJheTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMKICB2YXIgb2JqZWN0UHJvdG81ID0gT2JqZWN0LnByb3RvdHlwZTsKICB2YXIgaGFzT3duUHJvcGVydHkzID0gb2JqZWN0UHJvdG81Lmhhc093blByb3BlcnR5OwogIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkgewogICAgdmFyIGlzQXJyID0gaXNBcnJheV9kZWZhdWx0KHZhbHVlKSwgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHNfZGVmYXVsdCh2YWx1ZSksIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXJfZGVmYXVsdCh2YWx1ZSksIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXlfZGVmYXVsdCh2YWx1ZSksIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSwgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXNfZGVmYXVsdCh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSwgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsKICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgewogICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eTMuY2FsbCh2YWx1ZSwga2V5KSkgJiYgIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICJsZW5ndGgiIHx8IGlzQnVmZiAmJiAoa2V5ID09ICJvZmZzZXQiIHx8IGtleSA9PSAicGFyZW50IikgfHwgaXNUeXBlICYmIChrZXkgPT0gImJ1ZmZlciIgfHwga2V5ID09ICJieXRlTGVuZ3RoIiB8fCBrZXkgPT0gImJ5dGVPZmZzZXQiKSB8fCBpc0luZGV4X2RlZmF1bHQoa2V5LCBsZW5ndGgpKSkpIHsKICAgICAgICByZXN1bHQucHVzaChrZXkpOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgYXJyYXlMaWtlS2V5c19kZWZhdWx0ID0gYXJyYXlMaWtlS2V5czsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHsKICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHsKICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpOwogICAgfTsKICB9CiAgdmFyIG92ZXJBcmdfZGVmYXVsdCA9IG92ZXJBcmc7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzCiAgdmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnX2RlZmF1bHQoT2JqZWN0LmtleXMsIE9iamVjdCk7CiAgdmFyIG5hdGl2ZUtleXNfZGVmYXVsdCA9IG5hdGl2ZUtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcwogIHZhciBvYmplY3RQcm90bzYgPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eTQgPSBvYmplY3RQcm90bzYuaGFzT3duUHJvcGVydHk7CiAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7CiAgICBpZiAoIWlzUHJvdG90eXBlX2RlZmF1bHQob2JqZWN0KSkgewogICAgICByZXR1cm4gbmF0aXZlS2V5c19kZWZhdWx0KG9iamVjdCk7CiAgICB9CiAgICB2YXIgcmVzdWx0ID0gW107CiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHsKICAgICAgaWYgKGhhc093blByb3BlcnR5NC5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gImNvbnN0cnVjdG9yIikgewogICAgICAgIHJlc3VsdC5wdXNoKGtleSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBiYXNlS2V5c19kZWZhdWx0ID0gYmFzZUtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMKICBmdW5jdGlvbiBrZXlzKG9iamVjdCkgewogICAgcmV0dXJuIGlzQXJyYXlMaWtlX2RlZmF1bHQob2JqZWN0KSA/IGFycmF5TGlrZUtleXNfZGVmYXVsdChvYmplY3QpIDogYmFzZUtleXNfZGVmYXVsdChvYmplY3QpOwogIH0KICB2YXIga2V5c19kZWZhdWx0ID0ga2V5czsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDbGFtcC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHsKICAgIGlmIChudW1iZXIgPT09IG51bWJlcikgewogICAgICBpZiAodXBwZXIgIT09IHZvaWQgMCkgewogICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyOwogICAgICB9CiAgICAgIGlmIChsb3dlciAhPT0gdm9pZCAwKSB7CiAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBudW1iZXI7CiAgfQogIHZhciBiYXNlQ2xhbXBfZGVmYXVsdCA9IGJhc2VDbGFtcDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVZhbHVlcy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHsKICAgIHJldHVybiBhcnJheU1hcF9kZWZhdWx0KHByb3BzLCBmdW5jdGlvbihrZXkpIHsKICAgICAgcmV0dXJuIG9iamVjdFtrZXldOwogICAgfSk7CiAgfQogIHZhciBiYXNlVmFsdWVzX2RlZmF1bHQgPSBiYXNlVmFsdWVzOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMKICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7CiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXNfZGVmYXVsdChvYmplY3QsIGtleXNfZGVmYXVsdChvYmplY3QpKTsKICB9CiAgdmFyIHZhbHVlc19kZWZhdWx0ID0gdmFsdWVzOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJhbmRvbS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yOwogIHZhciBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTsKICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikgewogICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTsKICB9CiAgdmFyIGJhc2VSYW5kb21fZGVmYXVsdCA9IGJhc2VSYW5kb207CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NhbXBsZVNpemUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNhbXBsZVNpemUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaHVmZmxlU2VsZi5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkgewogICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTsKICAgIHNpemUgPSBzaXplID09PSB2b2lkIDAgPyBsZW5ndGggOiBzaXplOwogICAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7CiAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbV9kZWZhdWx0KGluZGV4LCBsYXN0SW5kZXgpLCB2YWx1ZSA9IGFycmF5W3JhbmRdOwogICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTsKICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7CiAgICB9CiAgICBhcnJheS5sZW5ndGggPSBzaXplOwogICAgcmV0dXJuIGFycmF5OwogIH0KICB2YXIgc2h1ZmZsZVNlbGZfZGVmYXVsdCA9IHNodWZmbGVTZWxmOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTYW1wbGVTaXplLmpzCiAgZnVuY3Rpb24gYXJyYXlTYW1wbGVTaXplKGFycmF5LCBuKSB7CiAgICByZXR1cm4gc2h1ZmZsZVNlbGZfZGVmYXVsdChjb3B5QXJyYXlfZGVmYXVsdChhcnJheSksIGJhc2VDbGFtcF9kZWZhdWx0KG4sIDAsIGFycmF5Lmxlbmd0aCkpOwogIH0KICB2YXIgYXJyYXlTYW1wbGVTaXplX2RlZmF1bHQgPSBhcnJheVNhbXBsZVNpemU7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2FtcGxlU2l6ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7CiAgICB2YXIgYXJyYXkgPSB2YWx1ZXNfZGVmYXVsdChjb2xsZWN0aW9uKTsKICAgIHJldHVybiBzaHVmZmxlU2VsZl9kZWZhdWx0KGFycmF5LCBiYXNlQ2xhbXBfZGVmYXVsdChuLCAwLCBhcnJheS5sZW5ndGgpKTsKICB9CiAgdmFyIGJhc2VTYW1wbGVTaXplX2RlZmF1bHQgPSBiYXNlU2FtcGxlU2l6ZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc2FtcGxlU2l6ZS5qcwogIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHsKICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsX2RlZmF1bHQoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdm9pZCAwKSB7CiAgICAgIG4gPSAxOwogICAgfSBlbHNlIHsKICAgICAgbiA9IHRvSW50ZWdlcl9kZWZhdWx0KG4pOwogICAgfQogICAgdmFyIGZ1bmMgPSBpc0FycmF5X2RlZmF1bHQoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemVfZGVmYXVsdCA6IGJhc2VTYW1wbGVTaXplX2RlZmF1bHQ7CiAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuKTsKICB9CiAgdmFyIHNhbXBsZVNpemVfZGVmYXVsdCA9IHNhbXBsZVNpemU7CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL3V0aWxzLnRzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vZDMtYXJyYXlAMi4xMi4xL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvaW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9kMy1hcnJheUAyLjEyLjEvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9hc2NlbmRpbmcuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYXNjZW5kaW5nX2RlZmF1bHQoYSwgYikgewogICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2QzLWFycmF5QDIuMTIuMS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdG9yLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJpc2VjdG9yX2RlZmF1bHQoZikgewogICAgbGV0IGRlbHRhID0gZjsKICAgIGxldCBjb21wYXJlID0gZjsKICAgIGlmIChmLmxlbmd0aCA9PT0gMSkgewogICAgICBkZWx0YSA9IChkLCB4KSA9PiBmKGQpIC0geDsKICAgICAgY29tcGFyZSA9IGFzY2VuZGluZ0NvbXBhcmF0b3IoZik7CiAgICB9CiAgICBmdW5jdGlvbiBsZWZ0KGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIHdoaWxlIChsbyA8IGhpKSB7CiAgICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTsKICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkKICAgICAgICAgIGxvID0gbWlkICsgMTsKICAgICAgICBlbHNlCiAgICAgICAgICBoaSA9IG1pZDsKICAgICAgfQogICAgICByZXR1cm4gbG87CiAgICB9CiAgICBmdW5jdGlvbiByaWdodChhLCB4LCBsbywgaGkpIHsKICAgICAgaWYgKGxvID09IG51bGwpCiAgICAgICAgbG8gPSAwOwogICAgICBpZiAoaGkgPT0gbnVsbCkKICAgICAgICBoaSA9IGEubGVuZ3RoOwogICAgICB3aGlsZSAobG8gPCBoaSkgewogICAgICAgIGNvbnN0IG1pZCA9IGxvICsgaGkgPj4+IDE7CiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApCiAgICAgICAgICBoaSA9IG1pZDsKICAgICAgICBlbHNlCiAgICAgICAgICBsbyA9IG1pZCArIDE7CiAgICAgIH0KICAgICAgcmV0dXJuIGxvOwogICAgfQogICAgZnVuY3Rpb24gY2VudGVyKGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIGNvbnN0IGkgPSBsZWZ0KGEsIHgsIGxvLCBoaSAtIDEpOwogICAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTsKICAgIH0KICAgIHJldHVybiB7IGxlZnQsIGNlbnRlciwgcmlnaHQgfTsKICB9CiAgZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7CiAgICByZXR1cm4gKGQsIHgpID0+IGFzY2VuZGluZ19kZWZhdWx0KGYoZCksIHgpOwogIH0KCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdXRpbHMudHMKICB2YXIgRGF0YVNvdXJjZSA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKGZpbGUsIGNocm9tU2l6ZXMsIG9wdGlvbnMpIHsKICAgICAgdGhpcy5maWxlID0gZmlsZTsKICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsKICAgICAgdGhpcy5jaHJvbUluZm8gPSBzaXplc1RvQ2hyb21JbmZvKGNocm9tU2l6ZXMpOwogICAgICB0aGlzLnRpbGVzZXRJbmZvID0gdGlsZXNldEluZm9Gcm9tQ2hyb21JbmZvKHRoaXMuY2hyb21JbmZvKTsKICAgIH0KICAgIGNocm9tSW5mbzsKICAgIHRpbGVzZXRJbmZvOwogIH07CiAgdmFyIGNocm9tSW5mb0Jpc2VjdG9yID0gYmlzZWN0b3JfZGVmYXVsdCgoZCkgPT4gZC5wb3MpLmxlZnQ7CiAgdmFyIGNoclRvQWJzID0gKGNocm9tLCBjaHJvbVBvcywgY2hyb21JbmZvKSA9PiBjaHJvbUluZm8uY2hyUG9zaXRpb25zW2Nocm9tXS5wb3MgKyBjaHJvbVBvczsKICB2YXIgYWJzVG9DaHIgPSAoYWJzUG9zaXRpb24sIGNocm9tSW5mbykgPT4gewogICAgaWYgKCFjaHJvbUluZm8gfHwgIWNocm9tSW5mby5jdW1Qb3NpdGlvbnMgfHwgIWNocm9tSW5mby5jdW1Qb3NpdGlvbnMubGVuZ3RoKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgbGV0IGluc2VydFBvaW50ID0gY2hyb21JbmZvQmlzZWN0b3IoY2hyb21JbmZvLmN1bVBvc2l0aW9ucywgYWJzUG9zaXRpb24pOwogICAgY29uc3QgbGFzdENociA9IGNocm9tSW5mby5jdW1Qb3NpdGlvbnNbY2hyb21JbmZvLmN1bVBvc2l0aW9ucy5sZW5ndGggLSAxXS5jaHI7CiAgICBjb25zdCBsYXN0TGVuZ3RoID0gY2hyb21JbmZvLmNocm9tTGVuZ3Roc1tsYXN0Q2hyXTsKICAgIGluc2VydFBvaW50IC09IGluc2VydFBvaW50ID4gMCAmJiAxOwogICAgbGV0IGNoclBvc2l0aW9uID0gTWF0aC5mbG9vcihhYnNQb3NpdGlvbiAtIGNocm9tSW5mby5jdW1Qb3NpdGlvbnNbaW5zZXJ0UG9pbnRdLnBvcyk7CiAgICBsZXQgb2Zmc2V0ID0gMDsKICAgIGlmIChjaHJQb3NpdGlvbiA8IDApIHsKICAgICAgb2Zmc2V0ID0gY2hyUG9zaXRpb24gLSAxOwogICAgICBjaHJQb3NpdGlvbiA9IDE7CiAgICB9CiAgICBpZiAoaW5zZXJ0UG9pbnQgPT09IGNocm9tSW5mby5jdW1Qb3NpdGlvbnMubGVuZ3RoIC0gMSAmJiBjaHJQb3NpdGlvbiA+IGxhc3RMZW5ndGgpIHsKICAgICAgb2Zmc2V0ID0gY2hyUG9zaXRpb24gLSBsYXN0TGVuZ3RoOwogICAgICBjaHJQb3NpdGlvbiA9IGxhc3RMZW5ndGg7CiAgICB9CiAgICByZXR1cm4gW2Nocm9tSW5mby5jdW1Qb3NpdGlvbnNbaW5zZXJ0UG9pbnRdLmNociwgY2hyUG9zaXRpb24sIG9mZnNldCwgaW5zZXJ0UG9pbnRdOwogIH07CiAgZnVuY3Rpb24gdGlsZXNldEluZm9Gcm9tQ2hyb21JbmZvKGNocm9tSW5mbywgdGlsZVNpemUgPSAxMDI0KSB7CiAgICByZXR1cm4gewogICAgICB0aWxlX3NpemU6IHRpbGVTaXplLAogICAgICBiaW5zX3Blcl9kaW1lbnNpb246IHRpbGVTaXplLAogICAgICBtYXhfem9vbTogTWF0aC5jZWlsKE1hdGgubG9nKGNocm9tSW5mby50b3RhbExlbmd0aCAvIHRpbGVTaXplKSAvIE1hdGgubG9nKDIpKSwKICAgICAgbWF4X3dpZHRoOiBjaHJvbUluZm8udG90YWxMZW5ndGgsCiAgICAgIG1pbl9wb3M6IFswXSwKICAgICAgbWF4X3BvczogW2Nocm9tSW5mby50b3RhbExlbmd0aF0KICAgIH07CiAgfQogIGZ1bmN0aW9uIHNpemVzVG9DaHJvbUluZm8oc2l6ZXMpIHsKICAgIGNvbnN0IGluZm8gPSB7CiAgICAgIGN1bVBvc2l0aW9uczogW10sCiAgICAgIGNocm9tTGVuZ3Roczoge30sCiAgICAgIGNoclBvc2l0aW9uczoge30sCiAgICAgIHRvdGFsTGVuZ3RoOiAwCiAgICB9OwogICAgc2l6ZXMuZm9yRWFjaCgoW2NociwgbGVuZ3RoXSwgaSkgPT4gewogICAgICBjb25zdCBjaHJQb3NpdGlvbiA9IHsgaWQ6IGksIGNociwgcG9zOiBpbmZvLnRvdGFsTGVuZ3RoIH07CiAgICAgIGluZm8uY2hyUG9zaXRpb25zW2Nocl0gPSBjaHJQb3NpdGlvbjsKICAgICAgaW5mby5jaHJvbUxlbmd0aHNbY2hyXSA9IGxlbmd0aDsKICAgICAgaW5mby5jdW1Qb3NpdGlvbnMucHVzaChjaHJQb3NpdGlvbik7CiAgICAgIGluZm8udG90YWxMZW5ndGggKz0gbGVuZ3RoOwogICAgfSk7CiAgICByZXR1cm4gewogICAgICAuLi5pbmZvLAogICAgICBhYnNUb0NocjogKGFic1BvcykgPT4gaW5mby5jaHJQb3NpdGlvbnMgPyBhYnNUb0NocihhYnNQb3MsIGluZm8pIDogbnVsbCwKICAgICAgY2hyVG9BYnM6IChbY2hyTmFtZSwgY2hyUG9zXSkgPT4gaW5mby5jaHJQb3NpdGlvbnMgPyBjaHJUb0FicyhjaHJOYW1lLCBjaHJQb3MsIGluZm8pIDogbnVsbAogICAgfTsKICB9CiAgdmFyIFJlbW90ZUZpbGUyID0gY2xhc3MgZXh0ZW5kcyBSZW1vdGVGaWxlIHsKICAgIHJlYWQgPSBhc3luYyAoYnVmZmVyLCBvZmZzZXQgPSAwLCBsZW5ndGgsIHBvc2l0aW9uID0gMCwgb3B0cyA9IHt9KSA9PiB7CiAgICAgIGNvbnN0IHsgaGVhZGVycyA9IHt9LCBzaWduYWwsIG92ZXJyaWRlcyA9IHt9IH0gPSBvcHRzOwogICAgICBpZiAobGVuZ3RoIDwgSW5maW5pdHkpIHsKICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LSR7cG9zaXRpb24gKyBsZW5ndGh9YDsKICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IEluZmluaXR5ICYmIHBvc2l0aW9uICE9PSAwKSB7CiAgICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS1gOwogICAgICB9CiAgICAgIGNvbnN0IGFyZ3MgPSB7CiAgICAgICAgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLAogICAgICAgIC4uLm92ZXJyaWRlcywKICAgICAgICBoZWFkZXJzOiB7CiAgICAgICAgICAuLi5oZWFkZXJzLAogICAgICAgICAgLi4ub3ZlcnJpZGVzLmhlYWRlcnMsCiAgICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMuaGVhZGVycwogICAgICAgIH0sCiAgICAgICAgbWV0aG9kOiAiR0VUIiwKICAgICAgICByZWRpcmVjdDogImZvbGxvdyIsCiAgICAgICAgbW9kZTogImNvcnMiLAogICAgICAgIHNpZ25hbAogICAgICB9OwogICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godGhpcy51cmwsIGFyZ3MpOwogICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICR7dGhpcy51cmx9YCk7CiAgICAgIH0KICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7CiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJGcm9tUmVzcG9uc2UocmVzcG9uc2UpOwogICAgICAgIGNvbnN0IGJ5dGVzQ29waWVkID0gcmVzcG9uc2VEYXRhLmNvcHkoYnVmZmVyLCBvZmZzZXQsIDAsIE1hdGgubWluKGxlbmd0aCwgcmVzcG9uc2VEYXRhLmxlbmd0aCkpOwogICAgICAgIGNvbnN0IHJlcyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCJjb250ZW50LXJhbmdlIik7CiAgICAgICAgY29uc3Qgc2l6ZU1hdGNoID0gL1wvKFxkKykkLy5leGVjKHJlcyB8fCAiIik7CiAgICAgICAgaWYgKHNpemVNYXRjaCAmJiBzaXplTWF0Y2hbMV0pIHsKICAgICAgICAgIHRoaXMuX3N0YXQgPSB7IHNpemU6IHBhcnNlSW50KHNpemVNYXRjaFsxXSwgMTApIH07CiAgICAgICAgfQogICAgICAgIHJldHVybiB7IGJ5dGVzUmVhZDogYnl0ZXNDb3BpZWQsIGJ1ZmZlciB9OwogICAgICB9CiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKTsKICAgIH07CiAgfTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvZ2ZmL3V0aWxzLnRzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGlzR0ZGM0ZlYXR1cmUoZW50cnkpIHsKICAgIHJldHVybiBBcnJheS5pc0FycmF5KGVudHJ5KTsKICB9CiAgZnVuY3Rpb24gbWFrZVJhbmRvbVNvcnRlZEFycmF5KG4sIG1heFZhbHVlKSB7CiAgICBjb25zdCByYW5kb21BcnJheSA9IFtdOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHsKICAgICAgY29uc3QgcmFuZG9tTnVtYmVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heFZhbHVlICsgMSkpOwogICAgICByYW5kb21BcnJheS5wdXNoKHJhbmRvbU51bWJlcik7CiAgICB9CiAgICBjb25zdCBzb3J0ZWQgPSByYW5kb21BcnJheS5zb3J0KChhLCBiKSA9PiBhIC0gYik7CiAgICByZXR1cm4gWy4uLm5ldyBTZXQoc29ydGVkKV07CiAgfQoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy9nZmYvZ2ZmLXdvcmtlci50cz93b3JrZXImaW5saW5lP3dvcmtlcl9maWxlCiAgdmFyIEdmZkZpbGUgPSBjbGFzcyB7CiAgICAjdWlkOwogICAgdGJpOwogICAgI25fZmVhdHVyZXM7CiAgICBjb25zdHJ1Y3Rvcih0YmksIHVpZCkgewogICAgICB0aGlzLnRiaSA9IHRiaTsKICAgICAgdGhpcy4jdWlkID0gdWlkOwogICAgfQogICAgc3RhdGljIGZyb21VcmwodXJsLCBpbmRleFVybCwgdWlkLCB1cmxGZXRjaE9wdGlvbnMsIGluZGV4VXJsRmV0Y2hPcHRpb25zKSB7CiAgICAgIGNvbnN0IHRiaSA9IG5ldyBUYWJpeEluZGV4ZWRGaWxlKHsKICAgICAgICBmaWxlaGFuZGxlOiBuZXcgUmVtb3RlRmlsZTIodXJsLCB7IG92ZXJyaWRlczogdXJsRmV0Y2hPcHRpb25zIH0pLAogICAgICAgIHRiaUZpbGVoYW5kbGU6IG5ldyBSZW1vdGVGaWxlMihpbmRleFVybCwgeyBvdmVycmlkZXM6IGluZGV4VXJsRmV0Y2hPcHRpb25zIH0pCiAgICAgIH0pOwogICAgICByZXR1cm4gbmV3IEdmZkZpbGUodGJpLCB1aWQpOwogICAgfQogICAgYXN5bmMgI2dldE51bWJlckZlYXR1cmVzKCkgewogICAgICBpZiAoIXRoaXMuI25fZmVhdHVyZXMpIHsKICAgICAgICBjb25zdCBzb3VyY2UgPSBkYXRhU291cmNlcy5nZXQodGhpcy4jdWlkKTsKICAgICAgICBjb25zdCB7IGN1bVBvc2l0aW9ucyB9ID0gc291cmNlLmNocm9tSW5mbzsKICAgICAgICBjb25zdCBjb3VudFByb21pc2VzID0gW107CiAgICAgICAgZm9yIChjb25zdCBjdW1Qb3Mgb2YgY3VtUG9zaXRpb25zKSB7CiAgICAgICAgICBjb25zdCBjaHJvbU5hbWUgPSBjdW1Qb3MuY2hyOwogICAgICAgICAgY291bnRQcm9taXNlcy5wdXNoKHRoaXMudGJpLmxpbmVDb3VudChjaHJvbU5hbWUpKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgY291bnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoY291bnRQcm9taXNlcyk7CiAgICAgICAgY29uc3QgdG90YWxfY291bnRzID0gY291bnRzLnJlZHVjZSgoYWNjLCBjdXIpID0+IGFjYyArIGN1ciwgMCk7CiAgICAgICAgdGhpcy4jbl9mZWF0dXJlcyA9IHRvdGFsX2NvdW50czsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy4jbl9mZWF0dXJlczsKICAgIH0KICAgICNnZXRMaW5lUHJvbWlzZXMobWluWCwgbWF4WCkgewogICAgICBjb25zdCBzb3VyY2UgPSBkYXRhU291cmNlcy5nZXQodGhpcy4jdWlkKTsKICAgICAgbGV0IGN1ck1pblggPSBtaW5YOwogICAgICBjb25zdCB7IGNocm9tTGVuZ3RocywgY3VtUG9zaXRpb25zIH0gPSBzb3VyY2UuY2hyb21JbmZvOwogICAgICBjb25zdCBsaW5lUHJvbWlzZXMgPSBbXTsKICAgICAgY29uc3QgTUFYX0ZFQVRVUkVTID0gNWU1OwogICAgICBjb25zdCBNQVhfV0lORE9XID0gNGU2OwogICAgICBpZiAodGhpcy4jbl9mZWF0dXJlcyAmJiB0aGlzLiNuX2ZlYXR1cmVzID4gTUFYX0ZFQVRVUkVTICYmIG1heFggLSBtaW5YID4gTUFYX1dJTkRPVykgewogICAgICAgIGNvbnN0IGRpZmYgPSBtYXhYIC0gbWluWDsKICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gNWU0OwogICAgICAgIGNvbnN0IG5fc2FtcGxlcyA9IDEwMDsKICAgICAgICBjb25zdCB0b3RhbEJpbnMgPSBNYXRoLmZsb29yKGRpZmYgLyB3aW5kb3dTaXplKTsKICAgICAgICBjb25zdCBzZWxlY3RlZEJpbnMgPSBtYWtlUmFuZG9tU29ydGVkQXJyYXkobl9zYW1wbGVzLCB0b3RhbEJpbnMpOwogICAgICAgIGNvbnN0IGJpbkxpbmVzID0gc2VsZWN0ZWRCaW5zLm1hcCgoYmluKSA9PiB7CiAgICAgICAgICBjb25zdCBiaW5TdGFydCA9IG1pblggKyBiaW4gKiB3aW5kb3dTaXplOwogICAgICAgICAgY29uc3QgYmluRW5kID0gYmluU3RhcnQgKyB3aW5kb3dTaXplOwogICAgICAgICAgcmV0dXJuIHRoaXMuI2dldExpbmVQcm9taXNlcyhiaW5TdGFydCwgYmluRW5kKTsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gYmluTGluZXMuZmxhdCgpOwogICAgICB9CiAgICAgIGZvciAoY29uc3QgY3VtUG9zIG9mIGN1bVBvc2l0aW9ucykgewogICAgICAgIGNvbnN0IGNocm9tTmFtZSA9IGN1bVBvcy5jaHI7CiAgICAgICAgY29uc3QgY2hyb21TdGFydCA9IGN1bVBvcy5wb3M7CiAgICAgICAgY29uc3QgY2hyb21FbmQgPSBjdW1Qb3MucG9zICsgY2hyb21MZW5ndGhzW2Nocm9tTmFtZV07CiAgICAgICAgbGV0IHN0YXJ0UG9zLCBlbmRQb3M7CiAgICAgICAgaWYgKGNocm9tU3RhcnQgPiBjdXJNaW5YIHx8IGN1ck1pblggPj0gY2hyb21FbmQpIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgICBjb25zdCBsaW5lUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7CiAgICAgICAgICBjb25zdCBsaW5lcyA9IFtdOwogICAgICAgICAgY29uc3QgbGluZUNhbGxiYWNrID0gKGxpbmUpID0+IHsKICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTsKICAgICAgICAgIH07CiAgICAgICAgICBpZiAobWF4WCA+IGNocm9tRW5kKSB7CiAgICAgICAgICAgIHN0YXJ0UG9zID0gY3VyTWluWCAtIGNocm9tU3RhcnQ7CiAgICAgICAgICAgIGVuZFBvcyA9IGNocm9tRW5kIC0gY2hyb21TdGFydDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN0YXJ0UG9zID0gTWF0aC5mbG9vcihjdXJNaW5YIC0gY2hyb21TdGFydCk7CiAgICAgICAgICAgIGVuZFBvcyA9IE1hdGguY2VpbChtYXhYIC0gY2hyb21TdGFydCk7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLnRiaS5nZXRMaW5lcyhjaHJvbU5hbWUsIHN0YXJ0UG9zLCBlbmRQb3MsIGxpbmVDYWxsYmFjaykudGhlbigoKSA9PiB7CiAgICAgICAgICAgIHJlc29sdmUobGluZXMpOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgICAgbGluZVByb21pc2VzLnB1c2gobGluZVByb21pc2UpOwogICAgICAgIGlmIChtYXhYIDw9IGNocm9tRW5kKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgY3VyTWluWCA9IGNocm9tRW5kOwogICAgICB9CiAgICAgIHJldHVybiBsaW5lUHJvbWlzZXM7CiAgICB9CiAgICBhc3luYyBnZXRUaWxlRGF0YShtaW5YLCBtYXhYKSB7CiAgICAgIGNvbnN0IHNvdXJjZSA9IGRhdGFTb3VyY2VzLmdldCh0aGlzLiN1aWQpOwogICAgICBjb25zdCBzYW1wbGVMZW5ndGggPSBzb3VyY2Uub3B0aW9ucy5zYW1wbGVMZW5ndGg7CiAgICAgIGNvbnN0IGF0dHJpYnV0ZXNUb0ZpZWxkcyA9IHNvdXJjZS5vcHRpb25zLmF0dHJpYnV0ZXNUb0ZpZWxkczsKICAgICAgYXdhaXQgdGhpcy4jZ2V0TnVtYmVyRmVhdHVyZXMoKTsKICAgICAgZnVuY3Rpb24gZmlsdGVyTGluZXMobGluZXMpIHsKICAgICAgICBjb25zdCBub25DaGlsZExpbmVzID0gbGluZXMuZmlsdGVyKChsaW5lKSA9PiB7CiAgICAgICAgICBjb25zdCBsaW5lQ29sdW1ucyA9IGxpbmUuc3BsaXQoIgkiKTsKICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBsaW5lQ29sdW1uc1s4XTsKICAgICAgICAgIHJldHVybiAhYXR0cmlidXRlcy5pbmNsdWRlcygiUGFyZW50PSIpOwogICAgICAgIH0pOwogICAgICAgIHJldHVybiBzYW1wbGVTaXplX2RlZmF1bHQobm9uQ2hpbGRMaW5lcywgc2FtcGxlTGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwYXJzZWRMaW5lc1RvVGlsZXMocGFyc2VkKSB7CiAgICAgICAgbGV0IHRpbGVzMiA9IFtdOwogICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBwYXJzZWQpIHsKICAgICAgICAgIGlmIChpc0dGRjNGZWF0dXJlKGxpbmUpKSB7CiAgICAgICAgICAgIGZvciAoY29uc3QgZmVhdHVyZSBvZiBsaW5lKSB7CiAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuc2VxX2lkICYmIGZlYXR1cmUuc3RhcnQpCiAgICAgICAgICAgICAgICBmZWF0dXJlLnN0YXJ0ID0gc291cmNlLmNocm9tSW5mby5jaHJUb0FicyhbZmVhdHVyZS5zZXFfaWQsIGZlYXR1cmUuc3RhcnRdKTsKICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5zZXFfaWQgJiYgZmVhdHVyZS5lbmQpCiAgICAgICAgICAgICAgICBmZWF0dXJlLmVuZCA9IHNvdXJjZS5jaHJvbUluZm8uY2hyVG9BYnMoW2ZlYXR1cmUuc2VxX2lkLCBmZWF0dXJlLmVuZF0pOwogICAgICAgICAgICAgIHRpbGVzMi5wdXNoKGZlYXR1cmUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChhdHRyaWJ1dGVzVG9GaWVsZHMpIHsKICAgICAgICAgIHRpbGVzMiA9IHRpbGVzMi5tYXAoKHRpbGUyKSA9PiB7CiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aWxlMi5hdHRyaWJ1dGVzOwogICAgICAgICAgICBjb25zdCBjbGVhbkF0dCA9IHt9OwogICAgICAgICAgICBhdHRyaWJ1dGVzVG9GaWVsZHMuZm9yRWFjaCgoYXR0TWFwKSA9PiB7CiAgICAgICAgICAgICAgY29uc3QgYXR0TmFtZSA9IGF0dE1hcC5hdHRyaWJ1dGU7CiAgICAgICAgICAgICAgY29uc3QgYXR0RGVmYXVsdCA9IGF0dE1hcC5kZWZhdWx0VmFsdWU7CiAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgPT0gbnVsbCB8fCAhKGF0dE5hbWUgaW4gYXR0cmlidXRlcykgfHwgIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlc1thdHROYW1lXSkpCiAgICAgICAgICAgICAgICBjbGVhbkF0dFthdHROYW1lXSA9IGF0dERlZmF1bHQ7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBjb25zdCBhdHRWYWwgPSBhdHRyaWJ1dGVzW2F0dE5hbWVdOwogICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0VmFsKSkgewogICAgICAgICAgICAgICAgICBjbGVhbkF0dFthdHROYW1lXSA9IGF0dFZhbC5sZW5ndGggPT0gMSA/IGF0dFZhbFswXSA6IGF0dFZhbC5qb2luKCIsIik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgcmV0dXJuIHsgLi4udGlsZTIsIC4uLmNsZWFuQXR0IH07CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRpbGVzMjsKICAgICAgfQogICAgICBjb25zdCBsaW5lUHJvbWlzZXMgPSB0aGlzLiNnZXRMaW5lUHJvbWlzZXMobWluWCwgbWF4WCk7CiAgICAgIGNvbnN0IGFsbExpbmVzID0gKGF3YWl0IFByb21pc2UuYWxsKGxpbmVQcm9taXNlcykpLmZsYXQoKTsKICAgICAgbGV0IGxpbmVzVG9QYXJzZSA9IFtdOwogICAgICBpZiAoYWxsTGluZXMubGVuZ3RoID4gc2FtcGxlTGVuZ3RoKSB7CiAgICAgICAgbGluZXNUb1BhcnNlID0gZmlsdGVyTGluZXMoYWxsTGluZXMpOwogICAgICB9IGVsc2UgewogICAgICAgIGxpbmVzVG9QYXJzZSA9IGFsbExpbmVzOwogICAgICB9CiAgICAgIGNvbnN0IHBhcnNlT3B0aW9ucyA9IHsKICAgICAgICBkaXNhYmxlRGVyaXZlc0Zyb21SZWZlcmVuY2VzOiB0cnVlLAogICAgICAgIHBhcnNlRmVhdHVyZXM6IHRydWUsCiAgICAgICAgcGFyc2VDb21tZW50czogZmFsc2UsCiAgICAgICAgcGFyc2VEaXJlY3RpdmVzOiBmYWxzZSwKICAgICAgICBwYXJzZVNlcXVlbmNlczogZmFsc2UKICAgICAgfTsKICAgICAgY29uc3QgcGFyc2VkTGluZXMgPSBlc21fZGVmYXVsdC5wYXJzZVN0cmluZ1N5bmMobGluZXNUb1BhcnNlLmpvaW4oIlxuIiksIHBhcnNlT3B0aW9ucyk7CiAgICAgIGNvbnN0IHRpbGVzID0gcGFyc2VkTGluZXNUb1RpbGVzKHBhcnNlZExpbmVzKTsKICAgICAgcmV0dXJuIHRpbGVzOwogICAgfQogIH07CiAgdmFyIGdmZkZpbGVzID0gbmV3IE1hcCgpOwogIHZhciB0aWxlVmFsdWVzID0ge307CiAgdmFyIGRhdGFTb3VyY2VzID0gbmV3IE1hcCgpOwogIGZ1bmN0aW9uIGluaXQodWlkLCBiZWQsIGNocm9tU2l6ZXMsIG9wdGlvbnMgPSB7fSkgewogICAgbGV0IGdmZkZpbGUgPSBnZmZGaWxlcy5nZXQoYmVkLnVybCk7CiAgICBpZiAoIWdmZkZpbGUpIHsKICAgICAgZ2ZmRmlsZSA9IEdmZkZpbGUuZnJvbVVybChiZWQudXJsLCBiZWQuaW5kZXhVcmwsIHVpZCwgb3B0aW9ucy51cmxGZXRjaE9wdGlvbnMsIG9wdGlvbnMuaW5kZXhVcmxGZXRjaE9wdGlvbnMpOwogICAgfQogICAgY29uc3QgZGF0YVNvdXJjZSA9IG5ldyBEYXRhU291cmNlKGdmZkZpbGUsIGNocm9tU2l6ZXMsIHsKICAgICAgc2FtcGxlTGVuZ3RoOiAxZTMsCiAgICAgIC4uLm9wdGlvbnMKICAgIH0pOwogICAgZGF0YVNvdXJjZXMuc2V0KHVpZCwgZGF0YVNvdXJjZSk7CiAgfQogIHZhciB0aWxlc2V0SW5mbyA9ICh1aWQpID0+IHsKICAgIHJldHVybiBkYXRhU291cmNlcy5nZXQodWlkKS50aWxlc2V0SW5mbzsKICB9OwogIHZhciB0aWxlID0gYXN5bmMgKHVpZCwgeiwgeCkgPT4gewogICAgY29uc3Qgc291cmNlID0gZGF0YVNvdXJjZXMuZ2V0KHVpZCk7CiAgICBjb25zdCBDQUNIRV9LRVkgPSBgJHt1aWR9LiR7en0uJHt4fWA7CiAgICB0aWxlVmFsdWVzW0NBQ0hFX0tFWV0gPSBbXTsKICAgIGNvbnN0IHRpbGVXaWR0aCA9ICtzb3VyY2UudGlsZXNldEluZm8ubWF4X3dpZHRoIC8gMiAqKiArejsKICAgIGNvbnN0IG1pblggPSBzb3VyY2UudGlsZXNldEluZm8ubWluX3Bvc1swXSArIHggKiB0aWxlV2lkdGg7CiAgICBjb25zdCBtYXhYID0gc291cmNlLnRpbGVzZXRJbmZvLm1pbl9wb3NbMF0gKyAoeCArIDEpICogdGlsZVdpZHRoOwogICAgdGlsZVZhbHVlc1tDQUNIRV9LRVldID0gYXdhaXQgc291cmNlLmZpbGUuZ2V0VGlsZURhdGEobWluWCwgbWF4WCk7CiAgICByZXR1cm4gW107CiAgfTsKICB2YXIgZmV0Y2hUaWxlc0RlYm91bmNlZCA9IGFzeW5jICh1aWQsIHRpbGVJZHMpID0+IHsKICAgIGNvbnN0IHRpbGVzID0ge307CiAgICBjb25zdCB2YWxpZFRpbGVJZHMgPSBbXTsKICAgIGNvbnN0IHRpbGVQcm9taXNlcyA9IFtdOwogICAgZm9yIChjb25zdCB0aWxlSWQgb2YgdGlsZUlkcykgewogICAgICBjb25zdCBwYXJ0cyA9IHRpbGVJZC5zcGxpdCgiLiIpOwogICAgICBjb25zdCB6ID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTsKICAgICAgY29uc3QgeCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7CiAgICAgIGlmIChOdW1iZXIuaXNOYU4oeCkgfHwgTnVtYmVyLmlzTmFOKHopKSB7CiAgICAgICAgY29uc29sZS53YXJuKCJJbnZhbGlkIHRpbGUgem9vbSBvciBwb3NpdGlvbjoiLCB6LCB4KTsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICB2YWxpZFRpbGVJZHMucHVzaCh0aWxlSWQpOwogICAgICB0aWxlUHJvbWlzZXMucHVzaCh0aWxlKHVpZCwgeiwgeCkpOwogICAgfQogICAgcmV0dXJuIFByb21pc2UuYWxsKHRpbGVQcm9taXNlcykudGhlbigodmFsdWVzMikgPT4gewogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlczIubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCB2YWxpZFRpbGVJZCA9IHZhbGlkVGlsZUlkc1tpXTsKICAgICAgICB0aWxlc1t2YWxpZFRpbGVJZF0gPSB7IHRpbGVQb3NpdGlvbklkOiB2YWxpZFRpbGVJZCB9OwogICAgICB9CiAgICAgIHJldHVybiB0aWxlczsKICAgIH0pOwogIH07CiAgdmFyIGdldFRhYnVsYXJEYXRhID0gKHVpZCwgdGlsZUlkcykgPT4gewogICAgY29uc3QgZGF0YSA9IFtdOwogICAgdGlsZUlkcy5mb3JFYWNoKCh0aWxlSWQpID0+IHsKICAgICAgY29uc3QgcGFydHMgPSB0aWxlSWQuc3BsaXQoIi4iKTsKICAgICAgY29uc3QgeiA9IHBhcnNlSW50KHBhcnRzWzBdLCAxMCk7CiAgICAgIGNvbnN0IHggPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOwogICAgICBjb25zdCB0aWxlVmFsdWUgPSB0aWxlVmFsdWVzW2Ake3VpZH0uJHt6fS4ke3h9YF07CiAgICAgIGlmICghdGlsZVZhbHVlKSB7CiAgICAgICAgY29uc29sZS53YXJuKGBObyB0aWxlIGRhdGEgY29uc3RydWN0ZWQgKCR7dGlsZUlkfSlgKTsKICAgICAgfQogICAgICBkYXRhLnB1c2godGlsZVZhbHVlKTsKICAgIH0pOwogICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LnZhbHVlcyhkYXRhKS5mbGF0KCk7CiAgICBjb25zdCBidWZmZXIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkob3V0cHV0KSkuYnVmZmVyOwogICAgcmV0dXJuIFRyYW5zZmVyKGJ1ZmZlciwgW2J1ZmZlcl0pOwogIH07CiAgdmFyIHRpbGVGdW5jdGlvbnMgPSB7CiAgICBpbml0LAogICAgdGlsZXNldEluZm8sCiAgICBmZXRjaFRpbGVzRGVib3VuY2VkLAogICAgdGlsZSwKICAgIGdldFRhYnVsYXJEYXRhCiAgfTsKICBleHBvc2UodGlsZUZ1bmN0aW9ucyk7Cn0pKCk7Ci8qIQogKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci4KICoKICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz4KICogQGxpY2Vuc2UgIE1JVAogKi8KLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi8KLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovCi8qKgogKiBAbGljZW5zZQogKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+CiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz0iZXMiIC1vIC4vYAogKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+CiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT4KICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT4KICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzCiAqLwo=";
const blob$1 = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs$1)], { type: "text/javascript;charset=utf-8" });
function Worker$2() {
  const objURL = blob$1 && (window.URL || window.webkitURL).createObjectURL(blob$1);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs$1, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const DEBOUNCE_TIME$1 = 200;
class GffDataFetcher {
  constructor(HGC, config2) {
    __publicField(this, "dataConfig", {});
    // required for higlass
    __publicField(this, "uid");
    __publicField(this, "prevRequestTime");
    __publicField(this, "track");
    __publicField(this, "toFetch");
    __publicField(this, "fetchTimeout");
    __publicField(this, "worker");
    this.uid = HGC.libraries.slugid.nice();
    this.prevRequestTime = 0;
    this.toFetch = /* @__PURE__ */ new Set();
    const { url, indexUrl, assembly, ...options } = config2;
    this.worker = spawn(new Worker$2()).then(async (worker) => {
      const chromSizes = Object.entries(computeChromSizes(assembly).size);
      await worker.init(this.uid, { url, indexUrl }, chromSizes, options);
      return worker;
    });
  }
  /*
   * Collect Tileset Information, such as tile size and genomic positions
   */
  async tilesetInfo(callback) {
    (await this.worker).tilesetInfo(this.uid).then(callback);
  }
  fetchTilesDebounced(receivedTiles, tileIds) {
    this.track.drawLoadingCue();
    tileIds.forEach((tileId) => this.toFetch.add(tileId));
    if (this.fetchTimeout) {
      clearTimeout(this.fetchTimeout);
    }
    this.fetchTimeout = setTimeout(() => {
      this.sendFetch(receivedTiles, [...this.toFetch]);
      this.toFetch.clear();
    }, DEBOUNCE_TIME$1);
  }
  async sendFetch(receivedTiles, tileIds) {
    (await this.worker).fetchTilesDebounced(this.uid, tileIds).then(receivedTiles);
  }
  async getTabularData(tileIds) {
    const buf = await (await this.worker).getTabularData(this.uid, tileIds);
    const parsed = JSON.parse(new TextDecoder().decode(buf));
    return parsed;
  }
}
__publicField(GffDataFetcher, "config", { type: "gff" });
const encodedJs = "KCgpID0+IHsKICB2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlOwogIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgdmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwogIHZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzOwogIHZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CiAgdmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogIHZhciBfX2VzbSA9IChmbiwgcmVzKSA9PiBmdW5jdGlvbiBfX2luaXQoKSB7CiAgICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltPYmplY3Qua2V5cyhmbilbMF1dKShmbiA9IDApKSwgcmVzOwogIH07CiAgdmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkgewogICAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbT2JqZWN0LmtleXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7CiAgfTsKICB2YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHsKICAgIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7CiAgICBmb3IgKHZhciBuYW1lIGluIGFsbCkKICAgICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTsKICB9OwogIHZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4gewogICAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09ICJvYmplY3QiIHx8IHR5cGVvZiBtb2R1bGUyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSkKICAgICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09ICJkZWZhdWx0IikKICAgICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7CiAgICB9CiAgICByZXR1cm4gdGFyZ2V0OwogIH07CiAgdmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4gewogICAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgImRlZmF1bHQiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiAiZGVmYXVsdCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTsKICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vYmFzZTY0LWpzQDEuNS4xL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMKICB2YXIgcmVxdWlyZV9iYXNlNjRfanMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYmFzZTY0LWpzQDEuNS4xL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBleHBvcnRzMi5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDsKICAgICAgZXhwb3J0czIudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheTsKICAgICAgZXhwb3J0czIuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXk7CiAgICAgIHZhciBsb29rdXAgPSBbXTsKICAgICAgdmFyIHJldkxvb2t1cCA9IFtdOwogICAgICB2YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICJ1bmRlZmluZWQiID8gVWludDhBcnJheSA6IEFycmF5OwogICAgICB2YXIgY29kZSA9ICJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIjsKICAgICAgZm9yIChpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkgewogICAgICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07CiAgICAgICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpOwogICAgICB9CiAgICAgIHZhciBpOwogICAgICB2YXIgbGVuOwogICAgICByZXZMb29rdXBbIi0iLmNoYXJDb2RlQXQoMCldID0gNjI7CiAgICAgIHJldkxvb2t1cFsiXyIuY2hhckNvZGVBdCgwKV0gPSA2MzsKICAgICAgZnVuY3Rpb24gZ2V0TGVucyhiNjQpIHsKICAgICAgICB2YXIgbGVuMiA9IGI2NC5sZW5ndGg7CiAgICAgICAgaWYgKGxlbjIgJSA0ID4gMCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Iik7CiAgICAgICAgfQogICAgICAgIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCI9Iik7CiAgICAgICAgaWYgKHZhbGlkTGVuID09PSAtMSkKICAgICAgICAgIHZhbGlkTGVuID0gbGVuMjsKICAgICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlbjIgPyAwIDogNCAtIHZhbGlkTGVuICUgNDsKICAgICAgICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGgoYjY0KSB7CiAgICAgICAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7CiAgICAgICAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTsKICAgICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTsKICAgICAgICByZXR1cm4gKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikgewogICAgICAgIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdG9CeXRlQXJyYXkoYjY0KSB7CiAgICAgICAgdmFyIHRtcDsKICAgICAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTsKICAgICAgICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdOwogICAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdOwogICAgICAgIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpOwogICAgICAgIHZhciBjdXJCeXRlID0gMDsKICAgICAgICB2YXIgbGVuMiA9IHBsYWNlSG9sZGVyc0xlbiA+IDAgPyB2YWxpZExlbiAtIDQgOiB2YWxpZExlbjsKICAgICAgICB2YXIgaTI7CiAgICAgICAgZm9yIChpMiA9IDA7IGkyIDwgbGVuMjsgaTIgKz0gNCkgewogICAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMTggfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPDwgMTIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAyKV0gPDwgNiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDMpXTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDE2ICYgMjU1OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1OwogICAgICAgIH0KICAgICAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7CiAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldID4+IDQ7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkgewogICAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMTAgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPDwgNCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA+PiAyOwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gYXJyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pIHsKICAgICAgICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDYzXSArIGxvb2t1cFtudW0gPj4gMTIgJiA2M10gKyBsb29rdXBbbnVtID4+IDYgJiA2M10gKyBsb29rdXBbbnVtICYgNjNdOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVuY29kZUNodW5rKHVpbnQ4LCBzdGFydCwgZW5kKSB7CiAgICAgICAgdmFyIHRtcDsKICAgICAgICB2YXIgb3V0cHV0ID0gW107CiAgICAgICAgZm9yICh2YXIgaTIgPSBzdGFydDsgaTIgPCBlbmQ7IGkyICs9IDMpIHsKICAgICAgICAgIHRtcCA9ICh1aW50OFtpMl0gPDwgMTYgJiAxNjcxMTY4MCkgKyAodWludDhbaTIgKyAxXSA8PCA4ICYgNjUyODApICsgKHVpbnQ4W2kyICsgMl0gJiAyNTUpOwogICAgICAgICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oIiIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21CeXRlQXJyYXkodWludDgpIHsKICAgICAgICB2YXIgdG1wOwogICAgICAgIHZhciBsZW4yID0gdWludDgubGVuZ3RoOwogICAgICAgIHZhciBleHRyYUJ5dGVzID0gbGVuMiAlIDM7CiAgICAgICAgdmFyIHBhcnRzID0gW107CiAgICAgICAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7CiAgICAgICAgZm9yICh2YXIgaTIgPSAwLCBsZW4yMiA9IGxlbjIgLSBleHRyYUJ5dGVzOyBpMiA8IGxlbjIyOyBpMiArPSBtYXhDaHVua0xlbmd0aCkgewogICAgICAgICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaTIsIGkyICsgbWF4Q2h1bmtMZW5ndGggPiBsZW4yMiA/IGxlbjIyIDogaTIgKyBtYXhDaHVua0xlbmd0aCkpOwogICAgICAgIH0KICAgICAgICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkgewogICAgICAgICAgdG1wID0gdWludDhbbGVuMiAtIDFdOwogICAgICAgICAgcGFydHMucHVzaChsb29rdXBbdG1wID4+IDJdICsgbG9va3VwW3RtcCA8PCA0ICYgNjNdICsgIj09Iik7CiAgICAgICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7CiAgICAgICAgICB0bXAgPSAodWludDhbbGVuMiAtIDJdIDw8IDgpICsgdWludDhbbGVuMiAtIDFdOwogICAgICAgICAgcGFydHMucHVzaChsb29rdXBbdG1wID4+IDEwXSArIGxvb2t1cFt0bXAgPj4gNCAmIDYzXSArIGxvb2t1cFt0bXAgPDwgMiAmIDYzXSArICI9Iik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCIiKTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vaWVlZTc1NEAxLjIuMS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcwogIHZhciByZXF1aXJlX2llZWU3NTQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vaWVlZTc1NEAxLjIuMS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBleHBvcnRzMi5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogICAgICAgIHZhciBlLCBtOwogICAgICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxOwogICAgICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwogICAgICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTsKICAgICAgICB2YXIgbkJpdHMgPSAtNzsKICAgICAgICB2YXIgaSA9IGlzTEUgPyBuQnl0ZXMgLSAxIDogMDsKICAgICAgICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7CiAgICAgICAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07CiAgICAgICAgaSArPSBkOwogICAgICAgIGUgPSBzICYgKDEgPDwgLW5CaXRzKSAtIDE7CiAgICAgICAgcyA+Pj0gLW5CaXRzOwogICAgICAgIG5CaXRzICs9IGVMZW47CiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkgewogICAgICAgIH0KICAgICAgICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxOwogICAgICAgIGUgPj49IC1uQml0czsKICAgICAgICBuQml0cyArPSBtTGVuOwogICAgICAgIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgaWYgKGUgPT09IDApIHsKICAgICAgICAgIGUgPSAxIC0gZUJpYXM7CiAgICAgICAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7CiAgICAgICAgICByZXR1cm4gbSA/IE5hTiA6IChzID8gLTEgOiAxKSAqIEluZmluaXR5OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pOwogICAgICAgICAgZSA9IGUgLSBlQmlhczsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKICAgICAgICB2YXIgZSwgbSwgYzsKICAgICAgICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTsKICAgICAgICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTsKICAgICAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7CiAgICAgICAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDA7CiAgICAgICAgdmFyIGkgPSBpc0xFID8gMCA6IG5CeXRlcyAtIDE7CiAgICAgICAgdmFyIGQgPSBpc0xFID8gMSA6IC0xOwogICAgICAgIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDsKICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTsKICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkgewogICAgICAgICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwOwogICAgICAgICAgZSA9IGVNYXg7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTsKICAgICAgICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHsKICAgICAgICAgICAgZS0tOwogICAgICAgICAgICBjICo9IDI7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZSArIGVCaWFzID49IDEpIHsKICAgICAgICAgICAgdmFsdWUgKz0gcnQgLyBjOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHZhbHVlICogYyA+PSAyKSB7CiAgICAgICAgICAgIGUrKzsKICAgICAgICAgICAgYyAvPSAyOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7CiAgICAgICAgICAgIG0gPSAwOwogICAgICAgICAgICBlID0gZU1heDsKICAgICAgICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHsKICAgICAgICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pOwogICAgICAgICAgICBlID0gZSArIGVCaWFzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pOwogICAgICAgICAgICBlID0gMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDI1NSwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIGUgPSBlIDw8IG1MZW4gfCBtOwogICAgICAgIGVMZW4gKz0gbUxlbjsKICAgICAgICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAyNTUsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkgewogICAgICAgIH0KICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9idWZmZXJANi4wLjMvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcwogIHZhciByZXF1aXJlX2J1ZmZlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9idWZmZXJANi4wLjMvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBiYXNlNjQgPSByZXF1aXJlX2Jhc2U2NF9qcygpOwogICAgICB2YXIgaWVlZTc1NCA9IHJlcXVpcmVfaWVlZTc1NCgpOwogICAgICB2YXIgY3VzdG9tSW5zcGVjdFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICJmdW5jdGlvbiIgJiYgdHlwZW9mIFN5bWJvbFsiZm9yIl0gPT09ICJmdW5jdGlvbiIgPyBTeW1ib2xbImZvciJdKCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSIpIDogbnVsbDsKICAgICAgZXhwb3J0czIuQnVmZmVyID0gQnVmZmVyMTA7CiAgICAgIGV4cG9ydHMyLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyOwogICAgICBleHBvcnRzMi5JTlNQRUNUX01BWF9CWVRFUyA9IDUwOwogICAgICB2YXIgS19NQVhfTEVOR1RIID0gMjE0NzQ4MzY0NzsKICAgICAgZXhwb3J0czIua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSDsKICAgICAgQnVmZmVyMTAuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KCk7CiAgICAgIGlmICghQnVmZmVyMTAuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4iKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpIHsKICAgICAgICB0cnkgewogICAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSk7CiAgICAgICAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIDQyOwogICAgICAgICAgfSB9OwogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSk7CiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90byk7CiAgICAgICAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MjsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIxMC5wcm90b3R5cGUsICJwYXJlbnQiLCB7CiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcih0aGlzKSkKICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyMTAucHJvdG90eXBlLCAib2Zmc2V0IiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIodGhpcykpCiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0OwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihsZW5ndGgpIHsKICAgICAgICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlICInICsgbGVuZ3RoICsgJyIgaXMgaW52YWxpZCBmb3Igb3B0aW9uICJzaXplIicpOwogICAgICAgIH0KICAgICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpOwogICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlcjEwLnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBCdWZmZXIxMChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAibnVtYmVyIikgewogICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInN0cmluZyIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucG9vbFNpemUgPSA4MTkyOwogICAgICBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAic3RyaW5nIikgewogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpOwogICAgICAgIH0KICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpOwogICAgICAgIH0KICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgIiArIHR5cGVvZiB2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHwgdmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gInVuZGVmaW5lZCIgJiYgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fCB2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAidmFsdWUiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpOwogICAgICAgIH0KICAgICAgICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKCk7CiAgICAgICAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpOwogICAgICAgIGlmIChiKQogICAgICAgICAgcmV0dXJuIGI7CiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICJ1bmRlZmluZWQiICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyMTAuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCJzdHJpbmciKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgIiArIHR5cGVvZiB2YWx1ZSk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAuZnJvbSA9IGZ1bmN0aW9uKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgfTsKICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlcjEwLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpOwogICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyMTAsIFVpbnQ4QXJyYXkpOwogICAgICBmdW5jdGlvbiBhc3NlcnRTaXplKHNpemUpIHsKICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcic2l6ZSIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpOwogICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgIicgKyBzaXplICsgJyIgaXMgaW52YWxpZCBmb3Igb3B0aW9uICJzaXplIicpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykgewogICAgICAgIGFzc2VydFNpemUoc2l6ZSk7CiAgICAgICAgaWYgKHNpemUgPD0gMCkgewogICAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKTsKICAgICAgICB9CiAgICAgICAgaWYgKGZpbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gInN0cmluZyIgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZykgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5hbGxvYyA9IGZ1bmN0aW9uKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSkgewogICAgICAgIGFzc2VydFNpemUoc2l6ZSk7CiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbihzaXplKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbihzaXplKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIiB8fCBlbmNvZGluZyA9PT0gIiIpIHsKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIH0KICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDsKICAgICAgICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7CiAgICAgICAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpOwogICAgICAgIGlmIChhY3R1YWwgIT09IGxlbmd0aCkgewogICAgICAgICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUFycmF5TGlrZShhcnJheSkgewogICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDsKICAgICAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQXJyYXlWaWV3KGFycmF5VmlldykgewogICAgICAgIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHsKICAgICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpOwogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignIm9mZnNldCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7CiAgICAgICAgfQogICAgICAgIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcibGVuZ3RoIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTsKICAgICAgICB9CiAgICAgICAgbGV0IGJ1ZjsKICAgICAgICBpZiAoYnl0ZU9mZnNldCA9PT0gdm9pZCAwICYmIGxlbmd0aCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSk7CiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyMTAucHJvdG90eXBlKTsKICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqKSB7CiAgICAgICAgaWYgKEJ1ZmZlcjEwLmlzQnVmZmVyKG9iaikpIHsKICAgICAgICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwOwogICAgICAgICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbik7CiAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgICAgfQogICAgICAgICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pOwogICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai5sZW5ndGggIT09IHZvaWQgMCkgewogICAgICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAibnVtYmVyIiB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkgewogICAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai50eXBlID09PSAiQnVmZmVyIiAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja2VkKGxlbmd0aCkgewogICAgICAgIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweCIgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgIiBieXRlcyIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbGVuZ3RoIHwgMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBTbG93QnVmZmVyKGxlbmd0aCkgewogICAgICAgIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjEwLmFsbG9jKCtsZW5ndGgpOwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIyKGIpIHsKICAgICAgICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmIGIgIT09IEJ1ZmZlcjEwLnByb3RvdHlwZTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikgewogICAgICAgIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKQogICAgICAgICAgYSA9IEJ1ZmZlcjEwLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aCk7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpCiAgICAgICAgICBiID0gQnVmZmVyMTAuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKTsKICAgICAgICBpZiAoIUJ1ZmZlcjEwLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIxMC5pc0J1ZmZlcihiKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJidWYxIiwgImJ1ZjIiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyk7CiAgICAgICAgfQogICAgICAgIGlmIChhID09PSBiKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbGV0IHggPSBhLmxlbmd0aDsKICAgICAgICBsZXQgeSA9IGIubGVuZ3RoOwogICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkgewogICAgICAgICAgICB4ID0gYVtpXTsKICAgICAgICAgICAgeSA9IGJbaV07CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoeCA8IHkpCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKHkgPCB4KQogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nKGVuY29kaW5nKSB7CiAgICAgICAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHsKICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgIGNhc2UgInV0Zi04IjoKICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgIGNhc2UgImxhdGluMSI6CiAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfTsKICAgICAgQnVmZmVyMTAuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KGxpc3QsIGxlbmd0aCkgewogICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpOwogICAgICAgIH0KICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDApIHsKICAgICAgICAgIHJldHVybiBCdWZmZXIxMC5hbGxvYygwKTsKICAgICAgICB9CiAgICAgICAgbGV0IGk7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBsZW5ndGggPSAwOwogICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIxMC5hbGxvY1Vuc2FmZShsZW5ndGgpOwogICAgICAgIGxldCBwb3MgPSAwOwogICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBsZXQgYnVmID0gbGlzdFtpXTsKICAgICAgICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHsKICAgICAgICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7CiAgICAgICAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcihidWYpKQogICAgICAgICAgICAgICAgYnVmID0gQnVmZmVyMTAuZnJvbShidWYpOwogICAgICAgICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChidWZmZXIsIGJ1ZiwgcG9zKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmICghQnVmZmVyMTAuaXNCdWZmZXIoYnVmKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBidWYuY29weShidWZmZXIsIHBvcyk7CiAgICAgICAgICB9CiAgICAgICAgICBwb3MgKz0gYnVmLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZmZlcjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKEJ1ZmZlcjEwLmlzQnVmZmVyKHN0cmluZykpIHsKICAgICAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkgewogICAgICAgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHN0cmluZyAhPT0gInN0cmluZyIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAic3RyaW5nIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGg7CiAgICAgICAgY29uc3QgbXVzdE1hdGNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlOwogICAgICAgIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlOwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgc3dpdGNoIChlbmNvZGluZykgewogICAgICAgICAgICBjYXNlICJhc2NpaSI6CiAgICAgICAgICAgIGNhc2UgImxhdGluMSI6CiAgICAgICAgICAgIGNhc2UgImJpbmFyeSI6CiAgICAgICAgICAgICAgcmV0dXJuIGxlbjsKICAgICAgICAgICAgY2FzZSAidXRmOCI6CiAgICAgICAgICAgIGNhc2UgInV0Zi04IjoKICAgICAgICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuIGxlbiAqIDI7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMTsKICAgICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpIHsKICAgICAgICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbmNvZGluZyA9ICgiIiArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgQnVmZmVyMTAuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7CiAgICAgIGZ1bmN0aW9uIHNsb3dUb1N0cmluZyhlbmNvZGluZywgc3RhcnQsIGVuZCkgewogICAgICAgIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlOwogICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwIHx8IHN0YXJ0IDwgMCkgewogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkgewogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kID09PSB2b2lkIDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kIDw9IDApIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgZW5kID4+Pj0gMDsKICAgICAgICBzdGFydCA+Pj49IDA7CiAgICAgICAgaWYgKGVuZCA8PSBzdGFydCkgewogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIH0KICAgICAgICBpZiAoIWVuY29kaW5nKQogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgIiIpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTsKICAgICAgZnVuY3Rpb24gc3dhcChiLCBuLCBtKSB7CiAgICAgICAgY29uc3QgaSA9IGJbbl07CiAgICAgICAgYltuXSA9IGJbbV07CiAgICAgICAgYlttXSA9IGk7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNigpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuICUgMiAhPT0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzIik7CiAgICAgICAgfQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHsKICAgICAgICAgIHN3YXAodGhpcywgaSwgaSArIDEpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMigpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuICUgNCAhPT0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzIik7CiAgICAgICAgfQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHsKICAgICAgICAgIHN3YXAodGhpcywgaSwgaSArIDMpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCgpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuICUgOCAhPT0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzIik7CiAgICAgICAgfQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHsKICAgICAgICAgIHN3YXAodGhpcywgaSwgaSArIDcpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKTsKICAgICAgICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlcjEwLnByb3RvdHlwZS50b1N0cmluZzsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhiKSB7CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcihiKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIiKTsKICAgICAgICBpZiAodGhpcyA9PT0gYikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHJldHVybiBCdWZmZXIxMC5jb21wYXJlKHRoaXMsIGIpID09PSAwOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7CiAgICAgICAgbGV0IHN0ciA9ICIiOwogICAgICAgIGNvbnN0IG1heCA9IGV4cG9ydHMyLklOU1BFQ1RfTUFYX0JZVEVTOwogICAgICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoImhleCIsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICIkMSAiKS50cmltKCk7CiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KQogICAgICAgICAgc3RyICs9ICIgLi4uICI7CiAgICAgICAgcmV0dXJuICI8QnVmZmVyICIgKyBzdHIgKyAiPiI7CiAgICAgIH07CiAgICAgIGlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7CiAgICAgICAgQnVmZmVyMTAucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyMTAucHJvdG90eXBlLmluc3BlY3Q7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkgewogICAgICAgICAgdGFyZ2V0ID0gQnVmZmVyMTAuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgaWYgKCFCdWZmZXIxMC5pc0J1ZmZlcih0YXJnZXQpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInRhcmdldCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHRhcmdldCk7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgewogICAgICAgICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPT09IHZvaWQgMCkgewogICAgICAgICAgdGhpc1N0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNFbmQgPT09IHZvaWQgMCkgewogICAgICAgICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJvdXQgb2YgcmFuZ2UgaW5kZXgiKTsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkgewogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPj0gZW5kKSB7CiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICB9CiAgICAgICAgc3RhcnQgPj4+PSAwOwogICAgICAgIGVuZCA+Pj49IDA7CiAgICAgICAgdGhpc1N0YXJ0ID4+Pj0gMDsKICAgICAgICB0aGlzRW5kID4+Pj0gMDsKICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0KQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0OwogICAgICAgIGxldCB5ID0gZW5kIC0gc3RhcnQ7CiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSk7CiAgICAgICAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7CiAgICAgICAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHsKICAgICAgICAgICAgeCA9IHRoaXNDb3B5W2ldOwogICAgICAgICAgICB5ID0gdGFyZ2V0Q29weVtpXTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh4IDwgeSkKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAoeSA8IHgpCiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICByZXR1cm4gMDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAyMTQ3NDgzNjQ3KSB7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gMjE0NzQ4MzY0NzsKICAgICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMjE0NzQ4MzY0OCkgewogICAgICAgICAgYnl0ZU9mZnNldCA9IC0yMTQ3NDgzNjQ4OwogICAgICAgIH0KICAgICAgICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQ7CiAgICAgICAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IGJ1ZmZlci5sZW5ndGggLSAxOwogICAgICAgIH0KICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDApCiAgICAgICAgICBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgewogICAgICAgICAgaWYgKGRpcikKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkgewogICAgICAgICAgaWYgKGRpcikKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IDA7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICB2YWwgPSBCdWZmZXIxMC5mcm9tKHZhbCwgZW5jb2RpbmcpOwogICAgICAgIH0KICAgICAgICBpZiAoQnVmZmVyMTAuaXNCdWZmZXIodmFsKSkgewogICAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAibnVtYmVyIikgewogICAgICAgICAgdmFsID0gdmFsICYgMjU1OwogICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgIGlmIChkaXIpIHsKICAgICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7CiAgICAgICAgfQogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlciIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikgewogICAgICAgIGxldCBpbmRleFNpemUgPSAxOwogICAgICAgIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoOwogICAgICAgIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoOwogICAgICAgIGlmIChlbmNvZGluZyAhPT0gdm9pZCAwKSB7CiAgICAgICAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gInVjczIiIHx8IGVuY29kaW5nID09PSAidWNzLTIiIHx8IGVuY29kaW5nID09PSAidXRmMTZsZSIgfHwgZW5jb2RpbmcgPT09ICJ1dGYtMTZsZSIpIHsKICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGluZGV4U2l6ZSA9IDI7CiAgICAgICAgICAgIGFyckxlbmd0aCAvPSAyOwogICAgICAgICAgICB2YWxMZW5ndGggLz0gMjsKICAgICAgICAgICAgYnl0ZU9mZnNldCAvPSAyOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiByZWFkKGJ1ZiwgaTIpIHsKICAgICAgICAgIGlmIChpbmRleFNpemUgPT09IDEpIHsKICAgICAgICAgICAgcmV0dXJuIGJ1ZltpMl07CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpMiAqIGluZGV4U2l6ZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGxldCBpOwogICAgICAgIGlmIChkaXIpIHsKICAgICAgICAgIGxldCBmb3VuZEluZGV4ID0gLTE7CiAgICAgICAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkgewogICAgICAgICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkKICAgICAgICAgICAgICAgIGZvdW5kSW5kZXggPSBpOwogICAgICAgICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkKICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkKICAgICAgICAgICAgICAgIGkgLT0gaSAtIGZvdW5kSW5kZXg7CiAgICAgICAgICAgICAgZm91bmRJbmRleCA9IC0xOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKQogICAgICAgICAgICBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoOwogICAgICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHsKICAgICAgICAgICAgbGV0IGZvdW5kID0gdHJ1ZTsKICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykgewogICAgICAgICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHsKICAgICAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGZvdW5kKQogICAgICAgICAgICAgIHJldHVybiBpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXModmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogICAgICAgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKTsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogICAgICAgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGhleFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7CiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldDsKICAgICAgICBpZiAoIWxlbmd0aCkgewogICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTsKICAgICAgICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHsKICAgICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoOwogICAgICAgIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7CiAgICAgICAgICBsZW5ndGggPSBzdHJMZW4gLyAyOwogICAgICAgIH0KICAgICAgICBsZXQgaTsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7CiAgICAgICAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkKICAgICAgICAgICAgcmV0dXJuIGk7CiAgICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7CiAgICAgICAgfQogICAgICAgIHJldHVybiBpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBiYXNlNjRXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHVjczJXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykgewogICAgICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgewogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIG9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IHZvaWQgMCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgZW5jb2RpbmcgPSBvZmZzZXQ7CiAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIG9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7CiAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkgewogICAgICAgICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDA7CiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKQogICAgICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7CiAgICAgICAgICAgIGxlbmd0aCA9IHZvaWQgMDsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCIpOwogICAgICAgIH0KICAgICAgICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDsKICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDAgfHwgbGVuZ3RoID4gcmVtYWluaW5nKQogICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nOwogICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzIik7CiAgICAgICAgfQogICAgICAgIGlmICghZW5jb2RpbmcpCiAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAidWNzMiI6CiAgICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICAgIGNhc2UgInV0Zi0xNmxlIjoKICAgICAgICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkKICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIgKyBlbmNvZGluZyk7CiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAoIiIgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICB0eXBlOiAiQnVmZmVyIiwKICAgICAgICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKQogICAgICAgIH07CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJhc2U2NFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHsKICAgICAgICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmOFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7CiAgICAgICAgY29uc3QgcmVzID0gW107CiAgICAgICAgbGV0IGkgPSBzdGFydDsKICAgICAgICB3aGlsZSAoaSA8IGVuZCkgewogICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldOwogICAgICAgICAgbGV0IGNvZGVQb2ludCA9IG51bGw7CiAgICAgICAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IGZpcnN0Qnl0ZSA+IDIzOSA/IDQgOiBmaXJzdEJ5dGUgPiAyMjMgPyAzIDogZmlyc3RCeXRlID4gMTkxID8gMiA6IDE7CiAgICAgICAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7CiAgICAgICAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkgewogICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAxMjgpIHsKICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07CiAgICAgICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAzMSkgPDwgNiB8IHNlY29uZEJ5dGUgJiA2MzsKICAgICAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAxMjcpIHsKICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07CiAgICAgICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKHRoaXJkQnl0ZSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDE1KSA8PCAxMiB8IChzZWNvbmRCeXRlICYgNjMpIDw8IDYgfCB0aGlyZEJ5dGUgJiA2MzsKICAgICAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAyMDQ3ICYmICh0ZW1wQ29kZVBvaW50IDwgNTUyOTYgfHwgdGVtcENvZGVQb2ludCA+IDU3MzQzKSkgewogICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwogICAgICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTsKICAgICAgICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdOwogICAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmICh0aGlyZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKGZvdXJ0aEJ5dGUgJiAxOTIpID09PSAxMjgpIHsKICAgICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTggfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCAxMiB8ICh0aGlyZEJ5dGUgJiA2MykgPDwgNiB8IGZvdXJ0aEJ5dGUgJiA2MzsKICAgICAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiA2NTUzNSAmJiB0ZW1wQ29kZVBvaW50IDwgMTExNDExMikgewogICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkgewogICAgICAgICAgICBjb2RlUG9pbnQgPSA2NTUzMzsKICAgICAgICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDY1NTM1KSB7CiAgICAgICAgICAgIGNvZGVQb2ludCAtPSA2NTUzNjsKICAgICAgICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDEwMjMgfCA1NTI5Nik7CiAgICAgICAgICAgIGNvZGVQb2ludCA9IDU2MzIwIHwgY29kZVBvaW50ICYgMTAyMzsKICAgICAgICAgIH0KICAgICAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7CiAgICAgICAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKTsKICAgICAgfQogICAgICB2YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSA0MDk2OwogICAgICBmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoY29kZVBvaW50cykgewogICAgICAgIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoOwogICAgICAgIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHsKICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cyk7CiAgICAgICAgfQogICAgICAgIGxldCByZXMgPSAiIjsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHsKICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBsZXQgcmV0ID0gIiI7CiAgICAgICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTsKICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMTI3KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBsYXRpbjFTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBsZXQgcmV0ID0gIiI7CiAgICAgICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTsKICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBoZXhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBjb25zdCBsZW4gPSBidWYubGVuZ3RoOwogICAgICAgIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKQogICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKQogICAgICAgICAgZW5kID0gbGVuOwogICAgICAgIGxldCBvdXQgPSAiIjsKICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkgewogICAgICAgICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG91dDsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGYxNmxlU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCk7CiAgICAgICAgbGV0IHJlcyA9ICIiOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7CiAgICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkgewogICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoOwogICAgICAgIHN0YXJ0ID0gfn5zdGFydDsKICAgICAgICBlbmQgPSBlbmQgPT09IHZvaWQgMCA/IGxlbiA6IH5+ZW5kOwogICAgICAgIGlmIChzdGFydCA8IDApIHsKICAgICAgICAgIHN0YXJ0ICs9IGxlbjsKICAgICAgICAgIGlmIChzdGFydCA8IDApCiAgICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7CiAgICAgICAgICBzdGFydCA9IGxlbjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8IDApIHsKICAgICAgICAgIGVuZCArPSBsZW47CiAgICAgICAgICBpZiAoZW5kIDwgMCkKICAgICAgICAgICAgZW5kID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGVuZCA+IGxlbikgewogICAgICAgICAgZW5kID0gbGVuOwogICAgICAgIH0KICAgICAgICBpZiAoZW5kIDwgc3RhcnQpCiAgICAgICAgICBlbmQgPSBzdGFydDsKICAgICAgICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpOwogICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlcjEwLnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIG5ld0J1ZjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gY2hlY2tPZmZzZXQob2Zmc2V0LCBleHQsIGxlbmd0aCkgewogICAgICAgIGlmIChvZmZzZXQgJSAxICE9PSAwIHx8IG9mZnNldCA8IDApCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigib2Zmc2V0IGlzIG5vdCB1aW50Iik7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoIik7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVaW50TEUgPSBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldF07CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnRCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoMl07CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgd2hpbGUgKGJ5dGVMZW5ndGgyID4gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aDJdICogbXVsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnQ4ID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnQxNkxFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnQxNkJFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIDw8IDggfCB0aGlzW29mZnNldCArIDFdOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnQzMkxFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpICsgdGhpc1tvZmZzZXQgKyAzXSAqIDE2Nzc3MjE2OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZFVpbnQzMkJFID0gQnVmZmVyMTAucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdICogMTY3NzcyMTYgKyAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM10pOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxvID0gZmlyc3QgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNDsKICAgICAgICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyBsYXN0ICogMiAqKiAyNDsKICAgICAgICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpOwogICAgICB9KTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUob2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddOwogICAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpOwogICAgICAgIH0KICAgICAgICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF07CiAgICAgICAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIGxhc3Q7CiAgICAgICAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldF07CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsOwogICAgICAgIH0KICAgICAgICBtdWwgKj0gMTI4OwogICAgICAgIGlmICh2YWwgPj0gbXVsKQogICAgICAgICAgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMik7CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMjsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldOwogICAgICAgIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7CiAgICAgICAgfQogICAgICAgIG11bCAqPSAxMjg7CiAgICAgICAgaWYgKHZhbCA+PSBtdWwpCiAgICAgICAgICB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKTsKICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTsKICAgICAgICBpZiAoISh0aGlzW29mZnNldF0gJiAxMjgpKQogICAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XTsKICAgICAgICByZXR1cm4gKDI1NSAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODsKICAgICAgICByZXR1cm4gdmFsICYgMzI3NjggPyB2YWwgfCA0Mjk0OTAxNzYwIDogdmFsOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgdGhpc1tvZmZzZXRdIDw8IDg7CiAgICAgICAgcmV0dXJuIHZhbCAmIDMyNzY4ID8gdmFsIHwgNDI5NDkwMTc2MCA6IHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYgfCB0aGlzW29mZnNldCArIDNdIDw8IDI0OwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIDw8IDI0IHwgdGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM107CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gKyB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICsgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgKyAobGFzdCA8PCAyNCk7CiAgICAgICAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChmaXJzdCArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdOwogICAgICAgIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyBsYXN0KTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOCk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGNoZWNrSW50KGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikgewogICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIoYnVmKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJidWZmZXIiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTsKICAgICAgICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignInZhbHVlIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgIH0KICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludExFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpIC0gMTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBtYXhCeXRlcywgMCk7CiAgICAgICAgfQogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgLyBtdWwgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludEJFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpIC0gMTsKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBtYXhCeXRlcywgMCk7CiAgICAgICAgfQogICAgICAgIGxldCBpID0gYnl0ZUxlbmd0aDIgLSAxOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgLyBtdWwgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludDggPSBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDI1NSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCA2NTUzNSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9IEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgNjU1MzUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVWludDMyTEUgPSBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDQyOTQ5NjcyOTUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID0gQnVmZmVyMTAucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCA0Mjk0OTY3Mjk1LCAwKTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBmdW5jdGlvbiB3cnRCaWdVSW50NjRMRShidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7CiAgICAgICAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KTsKICAgICAgICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIHJldHVybiBvZmZzZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gd3J0QmlnVUludDY0QkUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkgewogICAgICAgIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNyk7CiAgICAgICAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0ICsgN10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDZdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyA1XSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgNF0gPSBsbzsKICAgICAgICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCArIDNdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyAyXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgMV0gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldF0gPSBoaTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgODsKICAgICAgfQogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCIweGZmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCIweGZmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyIC0gMSk7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbGltaXQgLSAxLCAtbGltaXQpOwogICAgICAgIH0KICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IHN1YiA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHsKICAgICAgICAgICAgc3ViID0gMTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMiAtIDEpOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMiAtIDE7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IHN1YiA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7CiAgICAgICAgICAgIHN1YiA9IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsID4+IDApIC0gc3ViICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDEyNywgLTEyOCk7CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHZhbHVlID0gMjU1ICsgdmFsdWUgKyAxOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAxOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAzMjc2NywgLTMyNzY4KTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDMyNzY3LCAtMzI3NjgpOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyMTAucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMjE0NzQ4MzY0NywgLTIxNDc0ODM2NDgpOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDE2OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KTsKICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgdmFsdWUgPSA0Mjk0OTY3Mjk1ICsgdmFsdWUgKyAxOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiAyNDsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDE2OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoIjB4ODAwMDAwMDAwMDAwMDAwMCIpLCBCaWdJbnQoIjB4N2ZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoIjB4ODAwMDAwMDAwMDAwMDAwMCIpLCBCaWdJbnQoIjB4N2ZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICAgICAgICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgICBpZiAob2Zmc2V0IDwgMCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzNDAyODIzNDY2Mzg1Mjg4NmUyMiwgLTM0MDI4MjM0NjYzODUyODg2ZTIyKTsKICAgICAgICB9CiAgICAgICAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpOwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMTc5NzY5MzEzNDg2MjMxNTdlMjkyLCAtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKTsKICAgICAgICB9CiAgICAgICAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpOwogICAgICAgIHJldHVybiBvZmZzZXQgKyA4OwogICAgICB9CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXIxMC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkgewogICAgICAgIGlmICghQnVmZmVyMTAuaXNCdWZmZXIodGFyZ2V0KSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlciIpOwogICAgICAgIGlmICghc3RhcnQpCiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKQogICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpCiAgICAgICAgICB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7CiAgICAgICAgaWYgKCF0YXJnZXRTdGFydCkKICAgICAgICAgIHRhcmdldFN0YXJ0ID0gMDsKICAgICAgICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkKICAgICAgICAgIGVuZCA9IHN0YXJ0OwogICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcyIpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICAgIGlmIChlbmQgPCAwKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzIik7CiAgICAgICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKQogICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7CiAgICAgICAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDsKICAgICAgICB9CiAgICAgICAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnQ7CiAgICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwodGFyZ2V0LCB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLCB0YXJnZXRTdGFydCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBsZW47CiAgICAgIH07CiAgICAgIEJ1ZmZlcjEwLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBlbmNvZGluZyA9IHN0YXJ0OwogICAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAic3RyaW5nIikgewogICAgICAgICAgICBlbmNvZGluZyA9IGVuZDsKICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHZvaWQgMCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmciKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICJzdHJpbmciICYmICFCdWZmZXIxMC5pc0VuY29kaW5nKGVuY29kaW5nKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHsKICAgICAgICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApOwogICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1dGY4IiAmJiBjb2RlIDwgMTI4IHx8IGVuY29kaW5nID09PSAibGF0aW4xIikgewogICAgICAgICAgICAgIHZhbCA9IGNvZGU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICB2YWwgPSB2YWwgJiAyNTU7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAiYm9vbGVhbiIpIHsKICAgICAgICAgIHZhbCA9IE51bWJlcih2YWwpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJPdXQgb2YgcmFuZ2UgaW5kZXgiKTsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8PSBzdGFydCkgewogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIHN0YXJ0ID0gc3RhcnQgPj4+IDA7CiAgICAgICAgZW5kID0gZW5kID09PSB2b2lkIDAgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMDsKICAgICAgICBpZiAoIXZhbCkKICAgICAgICAgIHZhbCA9IDA7CiAgICAgICAgbGV0IGk7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICAgIHRoaXNbaV0gPSB2YWw7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyMTAuaXNCdWZmZXIodmFsKSA/IHZhbCA6IEJ1ZmZlcjEwLmZyb20odmFsLCBlbmNvZGluZyk7CiAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7CiAgICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIHZhbCArICciIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50ICJ2YWx1ZSInKTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7CiAgICAgICAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgdmFyIGVycm9ycyA9IHt9OwogICAgICBmdW5jdGlvbiBFKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkgewogICAgICAgIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7CiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgICAgc3VwZXIoKTsKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJtZXNzYWdlIiwgewogICAgICAgICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksCiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICAgIH0pOwogICAgICAgICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYDsKICAgICAgICAgICAgdGhpcy5zdGFjazsKICAgICAgICAgICAgZGVsZXRlIHRoaXMubmFtZTsKICAgICAgICAgIH0KICAgICAgICAgIGdldCBjb2RlKCkgewogICAgICAgICAgICByZXR1cm4gc3ltOwogICAgICAgICAgfQogICAgICAgICAgc2V0IGNvZGUodmFsdWUpIHsKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJjb2RlIiwgewogICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgICAgICAgIHZhbHVlLAogICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgICAgdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0KICAgICAgRSgiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTIiwgZnVuY3Rpb24obmFtZSkgewogICAgICAgIGlmIChuYW1lKSB7CiAgICAgICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuICJBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzIjsKICAgICAgfSwgUmFuZ2VFcnJvcik7CiAgICAgIEUoIkVSUl9JTlZBTElEX0FSR19UWVBFIiwgZnVuY3Rpb24obmFtZSwgYWN0dWFsKSB7CiAgICAgICAgcmV0dXJuIGBUaGUgIiR7bmFtZX0iIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7CiAgICAgIH0sIFR5cGVFcnJvcik7CiAgICAgIEUoIkVSUl9PVVRfT0ZfUkFOR0UiLCBmdW5jdGlvbihzdHIsIHJhbmdlLCBpbnB1dCkgewogICAgICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mICIke3N0cn0iIGlzIG91dCBvZiByYW5nZS5gOwogICAgICAgIGxldCByZWNlaXZlZCA9IGlucHV0OwogICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7CiAgICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gImJpZ2ludCIpIHsKICAgICAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KTsKICAgICAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHsKICAgICAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpOwogICAgICAgICAgfQogICAgICAgICAgcmVjZWl2ZWQgKz0gIm4iOwogICAgICAgIH0KICAgICAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWA7CiAgICAgICAgcmV0dXJuIG1zZzsKICAgICAgfSwgUmFuZ2VFcnJvcik7CiAgICAgIGZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvcih2YWwpIHsKICAgICAgICBsZXQgcmVzID0gIiI7CiAgICAgICAgbGV0IGkgPSB2YWwubGVuZ3RoOwogICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAiLSIgPyAxIDogMDsKICAgICAgICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykgewogICAgICAgICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMikgewogICAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgIm9mZnNldCIpOwogICAgICAgIGlmIChidWZbb2Zmc2V0XSA9PT0gdm9pZCAwIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoMl0gPT09IHZvaWQgMCkgewogICAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGgyICsgMSkpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgyKSB7CiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7CiAgICAgICAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gImJpZ2ludCIgPyAibiIgOiAiIjsKICAgICAgICAgIGxldCByYW5nZTsKICAgICAgICAgIGlmIChieXRlTGVuZ3RoMiA+IDMpIHsKICAgICAgICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkgewogICAgICAgICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4fSR7bn1gOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aDIgKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogJHsoYnl0ZUxlbmd0aDIgKyAxKSAqIDggLSAxfSR7bn1gOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YDsKICAgICAgICAgIH0KICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgidmFsdWUiLCByYW5nZSwgdmFsdWUpOwogICAgICAgIH0KICAgICAgICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aDIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCBuYW1lKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgIm51bWJlciIsIHZhbHVlKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYm91bmRzRXJyb3IodmFsdWUsIGxlbmd0aCwgdHlwZSkgewogICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHsKICAgICAgICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKTsKICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICJvZmZzZXQiLCAiYW4gaW50ZWdlciIsIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKCk7CiAgICAgICAgfQogICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICJvZmZzZXQiLCBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLCB2YWx1ZSk7CiAgICAgIH0KICAgICAgdmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZzsKICAgICAgZnVuY3Rpb24gYmFzZTY0Y2xlYW4oc3RyKSB7CiAgICAgICAgc3RyID0gc3RyLnNwbGl0KCI9IilbMF07CiAgICAgICAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAiIik7CiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCAyKQogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkgewogICAgICAgICAgc3RyID0gc3RyICsgIj0iOwogICAgICAgIH0KICAgICAgICByZXR1cm4gc3RyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cmluZywgdW5pdHMpIHsKICAgICAgICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5OwogICAgICAgIGxldCBjb2RlUG9pbnQ7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7CiAgICAgICAgY29uc3QgYnl0ZXMgPSBbXTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTsKICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiA1NTI5NSAmJiBjb2RlUG9pbnQgPCA1NzM0NCkgewogICAgICAgICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHsKICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gNTYzMTkpIHsKICAgICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkgewogICAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpOwogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDU2MzIwKSB7CiAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50OwogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gNTUyOTYgPDwgMTAgfCBjb2RlUG9pbnQgLSA1NjMyMCkgKyA2NTUzNjsKICAgICAgICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgIH0KICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsOwogICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDEyOCkgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAyMDQ4KSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiA2IHwgMTkyLCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDY1NTM2KSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAxMiB8IDIyNCwgY29kZVBvaW50ID4+IDYgJiA2MyB8IDEyOCwgY29kZVBvaW50ICYgNjMgfCAxMjgpOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAxMTE0MTEyKSB7CiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAxOCB8IDI0MCwgY29kZVBvaW50ID4+IDEyICYgNjMgfCAxMjgsIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb2RlIHBvaW50Iik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlczsKICAgICAgfQogICAgICBmdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7CiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMjU1KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhzdHIsIHVuaXRzKSB7CiAgICAgICAgbGV0IGMsIGhpLCBsbzsKICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBbXTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkgewogICAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgICAgICAgaGkgPSBjID4+IDg7CiAgICAgICAgICBsbyA9IGMgJSAyNTY7CiAgICAgICAgICBieXRlQXJyYXkucHVzaChsbyk7CiAgICAgICAgICBieXRlQXJyYXkucHVzaChoaSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlQXJyYXk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhzdHIpIHsKICAgICAgICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJsaXRCdWZmZXIoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgbGV0IGk7CiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICBpZiAoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoIHx8IGkgPj0gc3JjLmxlbmd0aCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGlzSW5zdGFuY2Uob2JqLCB0eXBlKSB7CiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHwgb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG51bWJlcklzTmFOKG9iaikgewogICAgICAgIHJldHVybiBvYmogIT09IG9iajsKICAgICAgfQogICAgICB2YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IGZ1bmN0aW9uKCkgewogICAgICAgIGNvbnN0IGFscGhhYmV0ID0gIjAxMjM0NTY3ODlhYmNkZWYiOwogICAgICAgIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1Nik7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7CiAgICAgICAgICBjb25zdCBpMTYgPSBpICogMTY7CiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHsKICAgICAgICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFibGU7CiAgICAgIH0oKTsKICAgICAgZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kKGZuKSB7CiAgICAgICAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICJ1bmRlZmluZWQiID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQoKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJCaWdJbnQgbm90IHN1cHBvcnRlZCIpOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIHNyYy9hbGlhcy9idWZmZXItc2hpbS5qcwogIHZhciBpbXBvcnRfYnVmZmVyOwogIHZhciBpbml0X2J1ZmZlcl9zaGltID0gX19lc20oewogICAgInNyYy9hbGlhcy9idWZmZXItc2hpbS5qcyIoKSB7CiAgICAgIGltcG9ydF9idWZmZXIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsQDEuNy41L25vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9janMtcG9ueWZpbGwuanMKICB2YXIgcmVxdWlyZV9janNfcG9ueWZpbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsQDEuNy41L25vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9janMtcG9ueWZpbGwuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgewogICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgewogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07CiAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7CiAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7CiAgICAgICAgICBpZiAoInZhbHVlIiBpbiBkZXNjcmlwdG9yKQogICAgICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgewogICAgICAgIGlmIChwcm90b1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsKICAgICAgICBpZiAoc3RhdGljUHJvcHMpCiAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOwogICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgInByb3RvdHlwZSIsIHsKICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZQogICAgICAgIH0pOwogICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsKICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICJmdW5jdGlvbiIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7CiAgICAgICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsICJwcm90b3R5cGUiLCB7CiAgICAgICAgICB3cml0YWJsZTogZmFsc2UKICAgICAgICB9KTsKICAgICAgICBpZiAoc3VwZXJDbGFzcykKICAgICAgICAgIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsKICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mMihvMikgewogICAgICAgICAgcmV0dXJuIG8yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobzIpOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgewogICAgICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YyKG8yLCBwMikgewogICAgICAgICAgbzIuX19wcm90b19fID0gcDI7CiAgICAgICAgICByZXR1cm4gbzI7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHRyeSB7CiAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkgewogICAgICAgICAgfSkpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYyKSB7CiAgICAgICAgaWYgKHNlbGYyID09PSB2b2lkIDApIHsKICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzZWxmMjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmMiwgY2FsbCkgewogICAgICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIGNhbGwgPT09ICJmdW5jdGlvbiIpKSB7CiAgICAgICAgICByZXR1cm4gY2FsbDsKICAgICAgICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWQiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZjIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7CiAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgewogICAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7CiAgICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgewogICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOwogICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgewogICAgICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7CiAgICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsKICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqZWN0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9nZXQoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSAidW5kZWZpbmVkIiAmJiBSZWZsZWN0LmdldCkgewogICAgICAgICAgX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQyKHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7CiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmICghYmFzZSkKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7CiAgICAgICAgICAgIGlmIChkZXNjLmdldCkgewogICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlOwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICB2YXIgRW1pdHRlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBFbWl0dGVyMigpIHsKICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyMik7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgImxpc3RlbmVycyIsIHsKICAgICAgICAgICAgdmFsdWU6IHt9LAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIyLCBbewogICAgICAgICAga2V5OiAiYWRkRXZlbnRMaXN0ZW5lciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgewogICAgICAgICAgICBpZiAoISh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgewogICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7CiAgICAgICAgICAgICAgY2FsbGJhY2ssCiAgICAgICAgICAgICAgb3B0aW9ucwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJyZW1vdmVFdmVudExpc3RlbmVyIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW3R5cGVdOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIGlmIChzdGFja1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spIHsKICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmICghKGV2ZW50LnR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdOwogICAgICAgICAgICB2YXIgc3RhY2tUb0NhbGwgPSBzdGFjay5zbGljZSgpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrVG9DYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHN0YWNrVG9DYWxsW2ldOwogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vcHRpb25zICYmIGxpc3RlbmVyLm9wdGlvbnMub25jZSkgewogICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGxpc3RlbmVyLmNhbGxiYWNrKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gRW1pdHRlcjI7CiAgICAgIH0oKTsKICAgICAgdmFyIEFib3J0U2lnbmFsID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9FbWl0dGVyKSB7CiAgICAgICAgX2luaGVyaXRzKEFib3J0U2lnbmFsMiwgX0VtaXR0ZXIpOwogICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWJvcnRTaWduYWwyKTsKICAgICAgICBmdW5jdGlvbiBBYm9ydFNpZ25hbDIoKSB7CiAgICAgICAgICB2YXIgX3RoaXM7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRTaWduYWwyKTsKICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7CiAgICAgICAgICBpZiAoIV90aGlzLmxpc3RlbmVycykgewogICAgICAgICAgICBFbWl0dGVyLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOwogICAgICAgICAgfQogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAiYWJvcnRlZCIsIHsKICAgICAgICAgICAgdmFsdWU6IGZhbHNlLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgIm9uYWJvcnQiLCB7CiAgICAgICAgICAgIHZhbHVlOiBudWxsLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgInJlYXNvbiIsIHsKICAgICAgICAgICAgdmFsdWU6IHZvaWQgMCwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gX3RoaXM7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhBYm9ydFNpZ25hbDIsIFt7CiAgICAgICAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIHJldHVybiAiW29iamVjdCBBYm9ydFNpZ25hbF0iOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImRpc3BhdGNoRXZlbnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHsKICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICJhYm9ydCIpIHsKICAgICAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlOwogICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbmFib3J0ID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgICAgICB0aGlzLm9uYWJvcnQuY2FsbCh0aGlzLCBldmVudCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEFib3J0U2lnbmFsMi5wcm90b3R5cGUpLCAiZGlzcGF0Y2hFdmVudCIsIHRoaXMpLmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gQWJvcnRTaWduYWwyOwogICAgICB9KEVtaXR0ZXIpOwogICAgICB2YXIgQWJvcnRDb250cm9sbGVyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkgewogICAgICAgIGZ1bmN0aW9uIEFib3J0Q29udHJvbGxlcjIoKSB7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRDb250cm9sbGVyMik7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgInNpZ25hbCIsIHsKICAgICAgICAgICAgdmFsdWU6IG5ldyBBYm9ydFNpZ25hbCgpLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgX2NyZWF0ZUNsYXNzKEFib3J0Q29udHJvbGxlcjIsIFt7CiAgICAgICAgICBrZXk6ICJhYm9ydCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7CiAgICAgICAgICAgIHZhciBldmVudDsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBldmVudCA9IG5ldyBFdmVudCgiYWJvcnQiKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7CiAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTsKICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9ICJhYm9ydCI7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCJFdmVudCIpOwogICAgICAgICAgICAgICAgICBldmVudC5pbml0RXZlbnQoImFib3J0IiwgZmFsc2UsIGZhbHNlKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZXZlbnQgPSB7CiAgICAgICAgICAgICAgICAgIHR5cGU6ICJhYm9ydCIsCiAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLAogICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZQogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHNpZ25hbFJlYXNvbiA9IHJlYXNvbjsKICAgICAgICAgICAgaWYgKHNpZ25hbFJlYXNvbiA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbiA9IG5ldyBFcnJvcigiVGhpcyBvcGVyYXRpb24gd2FzIGFib3J0ZWQiKTsKICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbi5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRE9NRXhjZXB0aW9uKCJzaWduYWwgaXMgYWJvcnRlZCB3aXRob3V0IHJlYXNvbiIpOwogICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgICAgIHNpZ25hbFJlYXNvbiA9IG5ldyBFcnJvcigiVGhpcyBvcGVyYXRpb24gd2FzIGFib3J0ZWQiKTsKICAgICAgICAgICAgICAgICAgc2lnbmFsUmVhc29uLm5hbWUgPSAiQWJvcnRFcnJvciI7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlYXNvbiA9IHNpZ25hbFJlYXNvbjsKICAgICAgICAgICAgdGhpcy5zaWduYWwuZGlzcGF0Y2hFdmVudChldmVudCk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAidG9TdHJpbmciLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gIltvYmplY3QgQWJvcnRDb250cm9sbGVyXSI7CiAgICAgICAgICB9CiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBBYm9ydENvbnRyb2xsZXIyOwogICAgICB9KCk7CiAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAidW5kZWZpbmVkIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHsKICAgICAgICBBYm9ydENvbnRyb2xsZXIucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAiQWJvcnRDb250cm9sbGVyIjsKICAgICAgICBBYm9ydFNpZ25hbC5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICJBYm9ydFNpZ25hbCI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9seWZpbGxOZWVkZWQoc2VsZjIpIHsKICAgICAgICBpZiAoc2VsZjIuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCkgewogICAgICAgICAgY29uc29sZS5sb2coIl9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEw9dHJ1ZSBpcyBzZXQsIHdpbGwgZm9yY2UgaW5zdGFsbCBwb2x5ZmlsbCIpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0eXBlb2Ygc2VsZjIuUmVxdWVzdCA9PT0gImZ1bmN0aW9uIiAmJiAhc2VsZjIuUmVxdWVzdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoInNpZ25hbCIpIHx8ICFzZWxmMi5BYm9ydENvbnRyb2xsZXI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYWJvcnRhYmxlRmV0Y2hEZWNvcmF0b3IocGF0Y2hUYXJnZXRzKSB7CiAgICAgICAgaWYgKHR5cGVvZiBwYXRjaFRhcmdldHMgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHBhdGNoVGFyZ2V0cyA9IHsKICAgICAgICAgICAgZmV0Y2g6IHBhdGNoVGFyZ2V0cwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgdmFyIF9wYXRjaFRhcmdldHMgPSBwYXRjaFRhcmdldHMsIGZldGNoID0gX3BhdGNoVGFyZ2V0cy5mZXRjaCwgX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cy5SZXF1ZXN0LCBOYXRpdmVSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID09PSB2b2lkIDAgPyBmZXRjaC5SZXF1ZXN0IDogX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0LCBOYXRpdmVBYm9ydENvbnRyb2xsZXIgPSBfcGF0Y2hUYXJnZXRzLkFib3J0Q29udHJvbGxlciwgX3BhdGNoVGFyZ2V0cyRfX0ZPUkNFID0gX3BhdGNoVGFyZ2V0cy5fX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMLCBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMID0gX3BhdGNoVGFyZ2V0cyRfX0ZPUkNFID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wYXRjaFRhcmdldHMkX19GT1JDRTsKICAgICAgICBpZiAoIXBvbHlmaWxsTmVlZGVkKHsKICAgICAgICAgIGZldGNoLAogICAgICAgICAgUmVxdWVzdDogTmF0aXZlUmVxdWVzdCwKICAgICAgICAgIEFib3J0Q29udHJvbGxlcjogTmF0aXZlQWJvcnRDb250cm9sbGVyLAogICAgICAgICAgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTAogICAgICAgIH0pKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBmZXRjaCwKICAgICAgICAgICAgUmVxdWVzdAogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgdmFyIFJlcXVlc3QgPSBOYXRpdmVSZXF1ZXN0OwogICAgICAgIGlmIChSZXF1ZXN0ICYmICFSZXF1ZXN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgic2lnbmFsIikgfHwgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCkgewogICAgICAgICAgUmVxdWVzdCA9IGZ1bmN0aW9uIFJlcXVlc3QyKGlucHV0LCBpbml0MikgewogICAgICAgICAgICB2YXIgc2lnbmFsOwogICAgICAgICAgICBpZiAoaW5pdDIgJiYgaW5pdDIuc2lnbmFsKSB7CiAgICAgICAgICAgICAgc2lnbmFsID0gaW5pdDIuc2lnbmFsOwogICAgICAgICAgICAgIGRlbGV0ZSBpbml0Mi5zaWduYWw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgTmF0aXZlUmVxdWVzdChpbnB1dCwgaW5pdDIpOwogICAgICAgICAgICBpZiAoc2lnbmFsKSB7CiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVlc3QsICJzaWduYWwiLCB7CiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsCiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICAgIHZhbHVlOiBzaWduYWwKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVxdWVzdDsKICAgICAgICAgIH07CiAgICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZSA9IE5hdGl2ZVJlcXVlc3QucHJvdG90eXBlOwogICAgICAgIH0KICAgICAgICB2YXIgcmVhbEZldGNoID0gZmV0Y2g7CiAgICAgICAgdmFyIGFib3J0YWJsZUZldGNoID0gZnVuY3Rpb24gYWJvcnRhYmxlRmV0Y2gyKGlucHV0LCBpbml0MikgewogICAgICAgICAgdmFyIHNpZ25hbCA9IFJlcXVlc3QgJiYgUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgPyBpbnB1dC5zaWduYWwgOiBpbml0MiA/IGluaXQyLnNpZ25hbCA6IHZvaWQgMDsKICAgICAgICAgIGlmIChzaWduYWwpIHsKICAgICAgICAgICAgdmFyIGFib3J0RXJyb3I7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgYWJvcnRFcnJvciA9IG5ldyBET01FeGNlcHRpb24oIkFib3J0ZWQiLCAiQWJvcnRFcnJvciIpOwogICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICBhYm9ydEVycm9yID0gbmV3IEVycm9yKCJBYm9ydGVkIik7CiAgICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgY2FuY2VsbGF0aW9uID0gbmV3IFByb21pc2UoZnVuY3Rpb24oXywgcmVqZWN0KSB7CiAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGFib3J0RXJyb3IpOwogICAgICAgICAgICAgIH0sIHsKICAgICAgICAgICAgICAgIG9uY2U6IHRydWUKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGlmIChpbml0MiAmJiBpbml0Mi5zaWduYWwpIHsKICAgICAgICAgICAgICBkZWxldGUgaW5pdDIuc2lnbmFsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvbiwgcmVhbEZldGNoKGlucHV0LCBpbml0MildKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZWFsRmV0Y2goaW5wdXQsIGluaXQyKTsKICAgICAgICB9OwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBmZXRjaDogYWJvcnRhYmxlRmV0Y2gsCiAgICAgICAgICBSZXF1ZXN0CiAgICAgICAgfTsKICAgICAgfQogICAgICBleHBvcnRzMi5BYm9ydENvbnRyb2xsZXIgPSBBYm9ydENvbnRyb2xsZXI7CiAgICAgIGV4cG9ydHMyLkFib3J0U2lnbmFsID0gQWJvcnRTaWduYWw7CiAgICAgIGV4cG9ydHMyLmFib3J0YWJsZUZldGNoID0gYWJvcnRhYmxlRmV0Y2hEZWNvcmF0b3I7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL2Fib3J0Y29udHJvbGxlci1wb255ZmlsbC5qcwogIHZhciByZXF1aXJlX2Fib3J0Y29udHJvbGxlcl9wb255ZmlsbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL2Fib3J0Y29udHJvbGxlci1wb255ZmlsbC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5BYm9ydFNpZ25hbCA9IGV4cG9ydHMyLkFib3J0Q29udHJvbGxlciA9IHZvaWQgMDsKICAgICAgdmFyIGNqc19wb255ZmlsbF8xID0gcmVxdWlyZV9janNfcG9ueWZpbGwoKTsKICAgICAgdmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiBzZWxmOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiB3aW5kb3c7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgcmV0dXJuIGdsb2JhbDsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QiKTsKICAgICAgfTsKICAgICAgdmFyIEFib3J0Q29udHJvbGxlciA9IHR5cGVvZiBnZXRHbG9iYWwoKS5BYm9ydENvbnRyb2xsZXIgPT09ICJ1bmRlZmluZWQiID8gY2pzX3BvbnlmaWxsXzEuQWJvcnRDb250cm9sbGVyIDogZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyOwogICAgICBleHBvcnRzMi5BYm9ydENvbnRyb2xsZXIgPSBBYm9ydENvbnRyb2xsZXI7CiAgICAgIHZhciBBYm9ydFNpZ25hbCA9IHR5cGVvZiBnZXRHbG9iYWwoKS5BYm9ydENvbnRyb2xsZXIgPT09ICJ1bmRlZmluZWQiID8gY2pzX3BvbnlmaWxsXzEuQWJvcnRTaWduYWwgOiBnZXRHbG9iYWwoKS5BYm9ydFNpZ25hbDsKICAgICAgZXhwb3J0czIuQWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWdncmVnYXRlQWJvcnRDb250cm9sbGVyLmpzCiAgdmFyIHJlcXVpcmVfQWdncmVnYXRlQWJvcnRDb250cm9sbGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWdncmVnYXRlQWJvcnRDb250cm9sbGVyLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBhYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGxfMSA9IHJlcXVpcmVfYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsKCk7CiAgICAgIHZhciBOdWxsU2lnbmFsID0gY2xhc3MgewogICAgICB9OwogICAgICB2YXIgQWdncmVnYXRlQWJvcnRDb250cm9sbGVyID0gY2xhc3MgewogICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgdGhpcy5zaWduYWxzID0gbmV3IFNldCgpOwogICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsXzEuQWJvcnRDb250cm9sbGVyKCk7CiAgICAgICAgfQogICAgICAgIGFkZFNpZ25hbChzaWduYWwgPSBuZXcgTnVsbFNpZ25hbCgpKSB7CiAgICAgICAgICBpZiAodGhpcy5zaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNhbm5vdCBhZGQgYSBzaWduYWwsIGFscmVhZHkgYWJvcnRlZCEiKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuc2lnbmFscy5hZGQoc2lnbmFsKTsKICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICB0aGlzLmhhbmRsZUFib3J0ZWQoc2lnbmFsKTsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsICgpID0+IHsKICAgICAgICAgICAgICB0aGlzLmhhbmRsZUFib3J0ZWQoc2lnbmFsKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGhhbmRsZUFib3J0ZWQoc2lnbmFsKSB7CiAgICAgICAgICB0aGlzLnNpZ25hbHMuZGVsZXRlKHNpZ25hbCk7CiAgICAgICAgICBpZiAodGhpcy5zaWduYWxzLnNpemUgPT09IDApIHsKICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZ2V0IHNpZ25hbCgpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWw7CiAgICAgICAgfQogICAgICAgIGFib3J0KCkgewogICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZUAxLjUuMC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyLmpzCiAgdmFyIHJlcXVpcmVfQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYWJvcnRhYmxlLXByb21pc2UtY2FjaGVAMS41LjAvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlci5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIgPSBjbGFzcyB7CiAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBTZXQoKTsKICAgICAgICB9CiAgICAgICAgYWRkQ2FsbGJhY2soY2FsbGJhY2sgPSAoKSA9PiB7CiAgICAgICAgfSkgewogICAgICAgICAgdGhpcy5jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTsKICAgICAgICAgIGNhbGxiYWNrKHRoaXMuY3VycmVudE1lc3NhZ2UpOwogICAgICAgIH0KICAgICAgICBjYWxsYmFjayhtZXNzYWdlKSB7CiAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlID0gbWVzc2FnZTsKICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goKGVsdCkgPT4gewogICAgICAgICAgICBlbHQobWVzc2FnZSk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWJvcnRhYmxlUHJvbWlzZUNhY2hlLmpzCiAgdmFyIHJlcXVpcmVfQWJvcnRhYmxlUHJvbWlzZUNhY2hlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWJvcnRhYmxlUHJvbWlzZUNhY2hlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IGV4cG9ydHMyICYmIGV4cG9ydHMyLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbihtb2QpIHsKICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyAiZGVmYXVsdCI6IG1vZCB9OwogICAgICB9OwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xID0gcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwoKTsKICAgICAgdmFyIEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfQWdncmVnYXRlQWJvcnRDb250cm9sbGVyKCkpOwogICAgICB2YXIgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyKCkpOwogICAgICB2YXIgQWJvcnRhYmxlUHJvbWlzZUNhY2hlMiA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3Rvcih7IGZpbGwsIGNhY2hlIH0pIHsKICAgICAgICAgIGlmICh0eXBlb2YgZmlsbCAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBmaWxsIGZ1bmN0aW9uIik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGNhY2hlICE9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBjYWNoZSBvYmplY3QiKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgY2FjaGUuZ2V0ICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBjYWNoZS5zZXQgIT09ICJmdW5jdGlvbiIgfHwgdHlwZW9mIGNhY2hlLmRlbGV0ZSAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJjYWNoZSBtdXN0IGltcGxlbWVudCBnZXQoa2V5KSwgc2V0KGtleSwgdmFsKSwgYW5kIGFuZCBkZWxldGUoa2V5KSIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlOwogICAgICAgICAgdGhpcy5maWxsQ2FsbGJhY2sgPSBmaWxsOwogICAgICAgIH0KICAgICAgICBzdGF0aWMgaXNBYm9ydEV4Y2VwdGlvbihleGNlcHRpb24pIHsKICAgICAgICAgIHJldHVybiBleGNlcHRpb24ubmFtZSA9PT0gIkFib3J0RXJyb3IiIHx8IGV4Y2VwdGlvbi5jb2RlID09PSAiRVJSX0FCT1JURUQiIHx8IGV4Y2VwdGlvbi5tZXNzYWdlID09PSAiQWJvcnRFcnJvcjogYWJvcnRlZCIgfHwgZXhjZXB0aW9uLm1lc3NhZ2UgPT09ICJFcnJvcjogYWJvcnRlZCI7CiAgICAgICAgfQogICAgICAgIGV2aWN0KGtleSwgZW50cnkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmdldChrZXkpID09PSBlbnRyeSkgewogICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmaWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgY29uc3QgYWJvcnRlciA9IG5ldyBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXJfMS5kZWZhdWx0KCk7CiAgICAgICAgICBjb25zdCBzdGF0dXNSZXBvcnRlciA9IG5ldyBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcl8xLmRlZmF1bHQoKTsKICAgICAgICAgIHN0YXR1c1JlcG9ydGVyLmFkZENhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgIGNvbnN0IG5ld0VudHJ5ID0gewogICAgICAgICAgICBhYm9ydGVyLAogICAgICAgICAgICBwcm9taXNlOiB0aGlzLmZpbGxDYWxsYmFjayhkYXRhLCBhYm9ydGVyLnNpZ25hbCwgKG1lc3NhZ2UpID0+IHsKICAgICAgICAgICAgICBzdGF0dXNSZXBvcnRlci5jYWxsYmFjayhtZXNzYWdlKTsKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIHNldHRsZWQ6IGZhbHNlLAogICAgICAgICAgICBzdGF0dXNSZXBvcnRlciwKICAgICAgICAgICAgZ2V0IGFib3J0ZWQoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWJvcnRlci5zaWduYWwuYWJvcnRlZDsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIG5ld0VudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICBuZXdFbnRyeS5hYm9ydGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsICgpID0+IHsKICAgICAgICAgICAgaWYgKCFuZXdFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgdGhpcy5ldmljdChrZXksIG5ld0VudHJ5KTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBuZXdFbnRyeS5wcm9taXNlLnRoZW4oKCkgPT4gewogICAgICAgICAgICBuZXdFbnRyeS5zZXR0bGVkID0gdHJ1ZTsKICAgICAgICAgIH0sICgpID0+IHsKICAgICAgICAgICAgbmV3RW50cnkuc2V0dGxlZCA9IHRydWU7CiAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4gewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpOwogICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgfSk7CiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIG5ld0VudHJ5KTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGNoZWNrU2luZ2xlUHJvbWlzZShwcm9taXNlLCBzaWduYWwpIHsKICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrRm9yU2luZ2xlQWJvcnQoKSB7CiAgICAgICAgICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcigiYWJvcnRlZCIpLCB7IGNvZGU6ICJFUlJfQUJPUlRFRCIgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4gewogICAgICAgICAgICBjaGVja0ZvclNpbmdsZUFib3J0KCk7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgICB9LCAoZXJyb3IpID0+IHsKICAgICAgICAgICAgY2hlY2tGb3JTaW5nbGVBYm9ydCgpOwogICAgICAgICAgICB0aHJvdyBlcnJvcjsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBoYXMoa2V5KSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KTsKICAgICAgICB9CiAgICAgICAgZ2V0KGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjaykgewogICAgICAgICAgaWYgKCFzaWduYWwgJiYgZGF0YSBpbnN0YW5jZW9mIGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xLkFib3J0U2lnbmFsKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoInNlY29uZCBnZXQgYXJndW1lbnQgYXBwZWFycyB0byBiZSBhbiBBYm9ydFNpZ25hbCwgcGVyaGFwcyB5b3UgbWVhbnQgdG8gcGFzcyBgbnVsbGAgZm9yIHRoZSBmaWxsIGRhdGE/Iik7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIGlmIChjYWNoZUVudHJ5KSB7CiAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LmFib3J0ZWQgJiYgIWNhY2hlRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBjYWNoZUVudHJ5KTsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCBkYXRhLCBzaWduYWwsIHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkucHJvbWlzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYWNoZUVudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICAgIGNhY2hlRW50cnkuc3RhdHVzUmVwb3J0ZXIuYWRkQ2FsbGJhY2soc3RhdHVzQ2FsbGJhY2spOwogICAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UoY2FjaGVFbnRyeS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5maWxsKGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UodGhpcy5jYWNoZS5nZXQoa2V5KS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgIH0KICAgICAgICBkZWxldGUoa2V5KSB7CiAgICAgICAgICBjb25zdCBjYWNoZWRFbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICBpZiAoY2FjaGVkRW50cnkpIHsKICAgICAgICAgICAgaWYgKCFjYWNoZWRFbnRyeS5zZXR0bGVkKSB7CiAgICAgICAgICAgICAgY2FjaGVkRW50cnkuYWJvcnRlci5hYm9ydCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNsZWFyKCkgewogICAgICAgICAgY29uc3Qga2V5SXRlciA9IHRoaXMuY2FjaGUua2V5cygpOwogICAgICAgICAgbGV0IGRlbGV0ZUNvdW50ID0gMDsKICAgICAgICAgIGZvciAobGV0IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpOyAhcmVzdWx0LmRvbmU7IHJlc3VsdCA9IGtleUl0ZXIubmV4dCgpKSB7CiAgICAgICAgICAgIHRoaXMuZGVsZXRlKHJlc3VsdC52YWx1ZSk7CiAgICAgICAgICAgIGRlbGV0ZUNvdW50ICs9IDE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZGVsZXRlQ291bnQ7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlQDEuNS4wL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vaW5kZXguanMKICB2YXIgcmVxdWlyZV9lc20gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vYWJvcnRhYmxlLXByb21pc2UtY2FjaGVAMS41LjAvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9pbmRleC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfX2ltcG9ydERlZmF1bHQgPSBleHBvcnRzMiAmJiBleHBvcnRzMi5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgImRlZmF1bHQiOiBtb2QgfTsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBBYm9ydGFibGVQcm9taXNlQ2FjaGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX0Fib3J0YWJsZVByb21pc2VDYWNoZSgpKTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IEFib3J0YWJsZVByb21pc2VDYWNoZV8xLmRlZmF1bHQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9xdWljay1scnVANC4wLjEvbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcwogIHZhciByZXF1aXJlX3F1aWNrX2xydSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9xdWljay1scnVANC4wLjEvbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBRdWlja0xSVSA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHsKICAgICAgICAgIGlmICghKG9wdGlvbnMubWF4U2l6ZSAmJiBvcHRpb25zLm1heFNpemUgPiAwKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJgbWF4U2l6ZWAgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5tYXhTaXplID0gb3B0aW9ucy5tYXhTaXplOwogICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICAgIHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICB9CiAgICAgICAgX3NldChrZXksIHZhbHVlKSB7CiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTsKICAgICAgICAgIHRoaXMuX3NpemUrKzsKICAgICAgICAgIGlmICh0aGlzLl9zaXplID49IHRoaXMubWF4U2l6ZSkgewogICAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICAgICAgdGhpcy5vbGRDYWNoZSA9IHRoaXMuY2FjaGU7CiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdldChrZXkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm9sZENhY2hlLmdldChrZXkpOwogICAgICAgICAgICB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIGhhcyhrZXkpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmhhcyhrZXkpIHx8IHRoaXMub2xkQ2FjaGUuaGFzKGtleSk7CiAgICAgICAgfQogICAgICAgIHBlZWsoa2V5KSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLm9sZENhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkZWxldGUoa2V5KSB7CiAgICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTsKICAgICAgICAgIGlmIChkZWxldGVkKSB7CiAgICAgICAgICAgIHRoaXMuX3NpemUtLTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpIHx8IGRlbGV0ZWQ7CiAgICAgICAgfQogICAgICAgIGNsZWFyKCkgewogICAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpOwogICAgICAgICAgdGhpcy5vbGRDYWNoZS5jbGVhcigpOwogICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICAgICAgfQogICAgICAgICprZXlzKCkgewogICAgICAgICAgZm9yIChjb25zdCBba2V5XSBvZiB0aGlzKSB7CiAgICAgICAgICAgIHlpZWxkIGtleTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgKnZhbHVlcygpIHsKICAgICAgICAgIGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMpIHsKICAgICAgICAgICAgeWllbGQgdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7CiAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkgewogICAgICAgICAgICBjb25zdCBba2V5XSA9IGl0ZW07CiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZ2V0IHNpemUoKSB7CiAgICAgICAgICBsZXQgb2xkQ2FjaGVTaXplID0gMDsKICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMub2xkQ2FjaGUua2V5cygpKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICAgIG9sZENhY2hlU2l6ZSsrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSArIG9sZENhY2hlU2l6ZTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFF1aWNrTFJVOwogICAgfQogIH0pOwoKICAvLyAoZGlzYWJsZWQpOm5vZGVfbW9kdWxlcy8ucG5wbS9nZW5lcmljLWZpbGVoYW5kbGVAMy4xLjEvbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vbG9jYWxGaWxlCiAgdmFyIHJlcXVpcmVfbG9jYWxGaWxlID0gX19jb21tb25KUyh7CiAgICAiKGRpc2FibGVkKTpub2RlX21vZHVsZXMvLnBucG0vZ2VuZXJpYy1maWxlaGFuZGxlQDMuMS4xL25vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZXNtL2xvY2FsRmlsZSIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMKICB2YXIgcmVxdWlyZV9jb21tb24gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBUWVBFRF9PSyA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgVWludDE2QXJyYXkgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBJbnQzMkFycmF5ICE9PSAidW5kZWZpbmVkIjsKICAgICAgZnVuY3Rpb24gX2hhcyhvYmosIGtleSkgewogICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmFzc2lnbiA9IGZ1bmN0aW9uKG9iaikgewogICAgICAgIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgICAgICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHsKICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7CiAgICAgICAgICBpZiAoIXNvdXJjZSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAib2JqZWN0IikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICJtdXN0IGJlIG5vbi1vYmplY3QiKTsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7CiAgICAgICAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHsKICAgICAgICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9iajsKICAgICAgfTsKICAgICAgZXhwb3J0czIuc2hyaW5rQnVmID0gZnVuY3Rpb24oYnVmLCBzaXplKSB7CiAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsKICAgICAgICAgIHJldHVybiBidWY7CiAgICAgICAgfQogICAgICAgIGlmIChidWYuc3ViYXJyYXkpIHsKICAgICAgICAgIHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7CiAgICAgICAgfQogICAgICAgIGJ1Zi5sZW5ndGggPSBzaXplOwogICAgICAgIHJldHVybiBidWY7CiAgICAgIH07CiAgICAgIHZhciBmblR5cGVkID0gewogICAgICAgIGFycmF5U2V0OiBmdW5jdGlvbihkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2ZmcykgewogICAgICAgICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7CiAgICAgICAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpOwogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uKGNodW5rcykgewogICAgICAgICAgdmFyIGksIGwsIGxlbiwgcG9zLCBjaHVuaywgcmVzdWx0OwogICAgICAgICAgbGVuID0gMDsKICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTsKICAgICAgICAgIHBvcyA9IDA7CiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICBjaHVuayA9IGNodW5rc1tpXTsKICAgICAgICAgICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTsKICAgICAgICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgZm5VbnR5cGVkID0gewogICAgICAgIGFycmF5U2V0OiBmdW5jdGlvbihkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2ZmcykgewogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihjaHVua3MpIHsKICAgICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGNodW5rcyk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5zZXRUeXBlZCA9IGZ1bmN0aW9uKG9uKSB7CiAgICAgICAgaWYgKG9uKSB7CiAgICAgICAgICBleHBvcnRzMi5CdWY4ID0gVWludDhBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjE2ID0gVWludDE2QXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5CdWYzMiA9IEludDMyQXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5hc3NpZ24oZXhwb3J0czIsIGZuVHlwZWQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBleHBvcnRzMi5CdWY4ID0gQXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5CdWYxNiA9IEFycmF5OwogICAgICAgICAgZXhwb3J0czIuQnVmMzIgPSBBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLmFzc2lnbihleHBvcnRzMiwgZm5VbnR5cGVkKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLnNldFR5cGVkKFRZUEVEX09LKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzCiAgdmFyIHJlcXVpcmVfdHJlZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgWl9GSVhFRCA9IDQ7CiAgICAgIHZhciBaX0JJTkFSWSA9IDA7CiAgICAgIHZhciBaX1RFWFQgPSAxOwogICAgICB2YXIgWl9VTktOT1dOID0gMjsKICAgICAgZnVuY3Rpb24gemVybyhidWYpIHsKICAgICAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICB3aGlsZSAoLS1sZW4gPj0gMCkgewogICAgICAgICAgYnVmW2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgU1RPUkVEX0JMT0NLID0gMDsKICAgICAgdmFyIFNUQVRJQ19UUkVFUyA9IDE7CiAgICAgIHZhciBEWU5fVFJFRVMgPSAyOwogICAgICB2YXIgTUlOX01BVENIID0gMzsKICAgICAgdmFyIE1BWF9NQVRDSCA9IDI1ODsKICAgICAgdmFyIExFTkdUSF9DT0RFUyA9IDI5OwogICAgICB2YXIgTElURVJBTFMgPSAyNTY7CiAgICAgIHZhciBMX0NPREVTID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTOwogICAgICB2YXIgRF9DT0RFUyA9IDMwOwogICAgICB2YXIgQkxfQ09ERVMgPSAxOTsKICAgICAgdmFyIEhFQVBfU0laRSA9IDIgKiBMX0NPREVTICsgMTsKICAgICAgdmFyIE1BWF9CSVRTID0gMTU7CiAgICAgIHZhciBCdWZfc2l6ZSA9IDE2OwogICAgICB2YXIgTUFYX0JMX0JJVFMgPSA3OwogICAgICB2YXIgRU5EX0JMT0NLID0gMjU2OwogICAgICB2YXIgUkVQXzNfNiA9IDE2OwogICAgICB2YXIgUkVQWl8zXzEwID0gMTc7CiAgICAgIHZhciBSRVBaXzExXzEzOCA9IDE4OwogICAgICB2YXIgZXh0cmFfbGJpdHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMF07CiAgICAgIHZhciBleHRyYV9kYml0cyA9IFswLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTNdOwogICAgICB2YXIgZXh0cmFfYmxiaXRzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDIsIDMsIDddOwogICAgICB2YXIgYmxfb3JkZXIgPSBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV07CiAgICAgIHZhciBESVNUX0NPREVfTEVOID0gNTEyOwogICAgICB2YXIgc3RhdGljX2x0cmVlID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTsKICAgICAgemVybyhzdGF0aWNfbHRyZWUpOwogICAgICB2YXIgc3RhdGljX2R0cmVlID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTsKICAgICAgemVybyhzdGF0aWNfZHRyZWUpOwogICAgICB2YXIgX2Rpc3RfY29kZSA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTsKICAgICAgemVybyhfZGlzdF9jb2RlKTsKICAgICAgdmFyIF9sZW5ndGhfY29kZSA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTsKICAgICAgemVybyhfbGVuZ3RoX2NvZGUpOwogICAgICB2YXIgYmFzZV9sZW5ndGggPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTsKICAgICAgemVybyhiYXNlX2xlbmd0aCk7CiAgICAgIHZhciBiYXNlX2Rpc3QgPSBuZXcgQXJyYXkoRF9DT0RFUyk7CiAgICAgIHplcm8oYmFzZV9kaXN0KTsKICAgICAgZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7CiAgICAgICAgdGhpcy5zdGF0aWNfdHJlZSA9IHN0YXRpY190cmVlOwogICAgICAgIHRoaXMuZXh0cmFfYml0cyA9IGV4dHJhX2JpdHM7CiAgICAgICAgdGhpcy5leHRyYV9iYXNlID0gZXh0cmFfYmFzZTsKICAgICAgICB0aGlzLmVsZW1zID0gZWxlbXM7CiAgICAgICAgdGhpcy5tYXhfbGVuZ3RoID0gbWF4X2xlbmd0aDsKICAgICAgICB0aGlzLmhhc19zdHJlZSA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDsKICAgICAgfQogICAgICB2YXIgc3RhdGljX2xfZGVzYzsKICAgICAgdmFyIHN0YXRpY19kX2Rlc2M7CiAgICAgIHZhciBzdGF0aWNfYmxfZGVzYzsKICAgICAgZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykgewogICAgICAgIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsKICAgICAgICB0aGlzLm1heF9jb2RlID0gMDsKICAgICAgICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkX2NvZGUoZGlzdCkgewogICAgICAgIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwdXRfc2hvcnQocywgdykgewogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gdyAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHcgPj4+IDggJiAyNTU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHsKICAgICAgICBpZiAocy5iaV92YWxpZCA+IEJ1Zl9zaXplIC0gbGVuZ3RoKSB7CiAgICAgICAgICBzLmJpX2J1ZiB8PSB2YWx1ZSA8PCBzLmJpX3ZhbGlkICYgNjU1MzU7CiAgICAgICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICAgICAgcy5iaV9idWYgPSB2YWx1ZSA+PiBCdWZfc2l6ZSAtIHMuYmlfdmFsaWQ7CiAgICAgICAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzLmJpX2J1ZiB8PSB2YWx1ZSA8PCBzLmJpX3ZhbGlkICYgNjU1MzU7CiAgICAgICAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHsKICAgICAgICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0sIHRyZWVbYyAqIDIgKyAxXSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHsKICAgICAgICB2YXIgcmVzID0gMDsKICAgICAgICBkbyB7CiAgICAgICAgICByZXMgfD0gY29kZSAmIDE7CiAgICAgICAgICBjb2RlID4+Pj0gMTsKICAgICAgICAgIHJlcyA8PD0gMTsKICAgICAgICB9IHdoaWxlICgtLWxlbiA+IDApOwogICAgICAgIHJldHVybiByZXMgPj4+IDE7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmlfZmx1c2gocykgewogICAgICAgIGlmIChzLmJpX3ZhbGlkID09PSAxNikgewogICAgICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgICAgICAgIHMuYmlfYnVmID0gMDsKICAgICAgICAgIHMuYmlfdmFsaWQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7CiAgICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMjU1OwogICAgICAgICAgcy5iaV9idWYgPj49IDg7CiAgICAgICAgICBzLmJpX3ZhbGlkIC09IDg7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYykgewogICAgICAgIHZhciB0cmVlID0gZGVzYy5keW5fdHJlZTsKICAgICAgICB2YXIgbWF4X2NvZGUgPSBkZXNjLm1heF9jb2RlOwogICAgICAgIHZhciBzdHJlZSA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlOwogICAgICAgIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7CiAgICAgICAgdmFyIGV4dHJhID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0czsKICAgICAgICB2YXIgYmFzZSA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7CiAgICAgICAgdmFyIG1heF9sZW5ndGggPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoOwogICAgICAgIHZhciBoOwogICAgICAgIHZhciBuLCBtOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciB4Yml0czsKICAgICAgICB2YXIgZjsKICAgICAgICB2YXIgb3ZlcmZsb3cgPSAwOwogICAgICAgIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykgewogICAgICAgICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7CiAgICAgICAgfQogICAgICAgIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdID0gMDsKICAgICAgICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7CiAgICAgICAgICBuID0gcy5oZWFwW2hdOwogICAgICAgICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdICogMiArIDFdICsgMTsKICAgICAgICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkgewogICAgICAgICAgICBiaXRzID0gbWF4X2xlbmd0aDsKICAgICAgICAgICAgb3ZlcmZsb3crKzsKICAgICAgICAgIH0KICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IGJpdHM7CiAgICAgICAgICBpZiAobiA+IG1heF9jb2RlKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgcy5ibF9jb3VudFtiaXRzXSsrOwogICAgICAgICAgeGJpdHMgPSAwOwogICAgICAgICAgaWYgKG4gPj0gYmFzZSkgewogICAgICAgICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTsKICAgICAgICAgIH0KICAgICAgICAgIGYgPSB0cmVlW24gKiAyXTsKICAgICAgICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7CiAgICAgICAgICBpZiAoaGFzX3N0cmVlKSB7CiAgICAgICAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0gKyB4Yml0cyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChvdmVyZmxvdyA9PT0gMCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBkbyB7CiAgICAgICAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7CiAgICAgICAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgewogICAgICAgICAgICBiaXRzLS07CiAgICAgICAgICB9CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdLS07CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOwogICAgICAgICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tOwogICAgICAgICAgb3ZlcmZsb3cgLT0gMjsKICAgICAgICB9IHdoaWxlIChvdmVyZmxvdyA+IDApOwogICAgICAgIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkgewogICAgICAgICAgbiA9IHMuYmxfY291bnRbYml0c107CiAgICAgICAgICB3aGlsZSAobiAhPT0gMCkgewogICAgICAgICAgICBtID0gcy5oZWFwWy0taF07CiAgICAgICAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodHJlZVttICogMiArIDFdICE9PSBiaXRzKSB7CiAgICAgICAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdKSAqIHRyZWVbbSAqIDJdOwogICAgICAgICAgICAgIHRyZWVbbSAqIDIgKyAxXSA9IGJpdHM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbi0tOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KSB7CiAgICAgICAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOwogICAgICAgIHZhciBjb2RlID0gMDsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHsKICAgICAgICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSBjb2RlICsgYmxfY291bnRbYml0cyAtIDFdIDw8IDE7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykgewogICAgICAgICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXTsKICAgICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICB0cmVlW24gKiAyXSA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIGxlbmd0aDsKICAgICAgICB2YXIgY29kZTsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsKICAgICAgICBsZW5ndGggPSAwOwogICAgICAgIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHsKICAgICAgICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoOwogICAgICAgICAgZm9yIChuID0gMDsgbiA8IDEgPDwgZXh0cmFfbGJpdHNbY29kZV07IG4rKykgewogICAgICAgICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTsKICAgICAgICBkaXN0ID0gMDsKICAgICAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykgewogICAgICAgICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDsKICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAxIDw8IGV4dHJhX2RiaXRzW2NvZGVdOyBuKyspIHsKICAgICAgICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZGlzdCA+Pj0gNzsKICAgICAgICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykgewogICAgICAgICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3OwogICAgICAgICAgZm9yIChuID0gMDsgbiA8IDEgPDwgZXh0cmFfZGJpdHNbY29kZV0gLSA3OyBuKyspIHsKICAgICAgICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7CiAgICAgICAgICBibF9jb3VudFtiaXRzXSA9IDA7CiAgICAgICAgfQogICAgICAgIG4gPSAwOwogICAgICAgIHdoaWxlIChuIDw9IDE0MykgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA4OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbOF0rKzsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKG4gPD0gMjU1KSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDk7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs5XSsrOwogICAgICAgIH0KICAgICAgICB3aGlsZSAobiA8PSAyNzkpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gNzsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzddKys7CiAgICAgICAgfQogICAgICAgIHdoaWxlIChuIDw9IDI4NykgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA4OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbOF0rKzsKICAgICAgICB9CiAgICAgICAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTsKICAgICAgICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXSA9IDU7CiAgICAgICAgICBzdGF0aWNfZHRyZWVbbiAqIDJdID0gYmlfcmV2ZXJzZShuLCA1KTsKICAgICAgICB9CiAgICAgICAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTsKICAgICAgICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsIERfQ09ERVMsIE1BWF9CSVRTKTsKICAgICAgICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzLmR5bl9sdHJlZVtuICogMl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzLmR5bl9kdHJlZVtuICogMl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgewogICAgICAgICAgcy5ibF90cmVlW24gKiAyXSA9IDA7CiAgICAgICAgfQogICAgICAgIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdID0gMTsKICAgICAgICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwOwogICAgICAgIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJpX3dpbmR1cChzKSB7CiAgICAgICAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7CiAgICAgICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICAgIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHsKICAgICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7CiAgICAgICAgfQogICAgICAgIHMuYmlfYnVmID0gMDsKICAgICAgICBzLmJpX3ZhbGlkID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpIHsKICAgICAgICBiaV93aW5kdXAocyk7CiAgICAgICAgaWYgKGhlYWRlcikgewogICAgICAgICAgcHV0X3Nob3J0KHMsIGxlbik7CiAgICAgICAgICBwdXRfc2hvcnQocywgfmxlbik7CiAgICAgICAgfQogICAgICAgIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTsKICAgICAgICBzLnBlbmRpbmcgKz0gbGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHsKICAgICAgICB2YXIgX24yID0gbiAqIDI7CiAgICAgICAgdmFyIF9tMiA9IG0gKiAyOwogICAgICAgIHJldHVybiB0cmVlW19uMl0gPCB0cmVlW19tMl0gfHwgdHJlZVtfbjJdID09PSB0cmVlW19tMl0gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKSB7CiAgICAgICAgdmFyIHYgPSBzLmhlYXBba107CiAgICAgICAgdmFyIGogPSBrIDw8IDE7CiAgICAgICAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikgewogICAgICAgICAgaWYgKGogPCBzLmhlYXBfbGVuICYmIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgewogICAgICAgICAgICBqKys7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdOwogICAgICAgICAgayA9IGo7CiAgICAgICAgICBqIDw8PSAxOwogICAgICAgIH0KICAgICAgICBzLmhlYXBba10gPSB2OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSkgewogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBsYzsKICAgICAgICB2YXIgbHggPSAwOwogICAgICAgIHZhciBjb2RlOwogICAgICAgIHZhciBleHRyYTsKICAgICAgICBpZiAocy5sYXN0X2xpdCAhPT0gMCkgewogICAgICAgICAgZG8gewogICAgICAgICAgICBkaXN0ID0gcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4IHwgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV07CiAgICAgICAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdOwogICAgICAgICAgICBseCsrOwogICAgICAgICAgICBpZiAoZGlzdCA9PT0gMCkgewogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdOwogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7CiAgICAgICAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTsKICAgICAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHsKICAgICAgICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdOwogICAgICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGRpc3QtLTsKICAgICAgICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpOwogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7CiAgICAgICAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTsKICAgICAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHsKICAgICAgICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdOwogICAgICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7CiAgICAgICAgfQogICAgICAgIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpIHsKICAgICAgICB2YXIgdHJlZSA9IGRlc2MuZHluX3RyZWU7CiAgICAgICAgdmFyIHN0cmVlID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7CiAgICAgICAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTsKICAgICAgICB2YXIgZWxlbXMgPSBkZXNjLnN0YXRfZGVzYy5lbGVtczsKICAgICAgICB2YXIgbiwgbTsKICAgICAgICB2YXIgbWF4X2NvZGUgPSAtMTsKICAgICAgICB2YXIgbm9kZTsKICAgICAgICBzLmhlYXBfbGVuID0gMDsKICAgICAgICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFOwogICAgICAgIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7CiAgICAgICAgICBpZiAodHJlZVtuICogMl0gIT09IDApIHsKICAgICAgICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47CiAgICAgICAgICAgIHMuZGVwdGhbbl0gPSAwOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdHJlZVtuICogMiArIDFdID0gMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7CiAgICAgICAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMDsKICAgICAgICAgIHRyZWVbbm9kZSAqIDJdID0gMTsKICAgICAgICAgIHMuZGVwdGhbbm9kZV0gPSAwOwogICAgICAgICAgcy5vcHRfbGVuLS07CiAgICAgICAgICBpZiAoaGFzX3N0cmVlKSB7CiAgICAgICAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7CiAgICAgICAgZm9yIChuID0gcy5oZWFwX2xlbiA+PiAxOyBuID49IDE7IG4tLSkgewogICAgICAgICAgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsKICAgICAgICB9CiAgICAgICAgbm9kZSA9IGVsZW1zOwogICAgICAgIGRvIHsKICAgICAgICAgIG4gPSBzLmhlYXBbMV07CiAgICAgICAgICBzLmhlYXBbMV0gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTsKICAgICAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgMSk7CiAgICAgICAgICBtID0gcy5oZWFwWzFdOwogICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOwogICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtOwogICAgICAgICAgdHJlZVtub2RlICogMl0gPSB0cmVlW24gKiAyXSArIHRyZWVbbSAqIDJdOwogICAgICAgICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxOwogICAgICAgICAgdHJlZVtuICogMiArIDFdID0gdHJlZVttICogMiArIDFdID0gbm9kZTsKICAgICAgICAgIHMuaGVhcFsxXSA9IG5vZGUrKzsKICAgICAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgMSk7CiAgICAgICAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTsKICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxXTsKICAgICAgICBnZW5fYml0bGVuKHMsIGRlc2MpOwogICAgICAgIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIHByZXZsZW4gPSAtMTsKICAgICAgICB2YXIgY3VybGVuOwogICAgICAgIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOwogICAgICAgIHZhciBjb3VudCA9IDA7CiAgICAgICAgdmFyIG1heF9jb3VudCA9IDc7CiAgICAgICAgdmFyIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgfQogICAgICAgIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0gPSA2NTUzNTsKICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgICAgIGN1cmxlbiA9IG5leHRsZW47CiAgICAgICAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdOwogICAgICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkgewogICAgICAgICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0gKz0gY291bnQ7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkgewogICAgICAgICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7CiAgICAgICAgICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdKys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXSsrOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkgewogICAgICAgICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0rKzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdKys7CiAgICAgICAgICB9CiAgICAgICAgICBjb3VudCA9IDA7CiAgICAgICAgICBwcmV2bGVuID0gY3VybGVuOwogICAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNjsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDc7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSkgewogICAgICAgIHZhciBuOwogICAgICAgIHZhciBwcmV2bGVuID0gLTE7CiAgICAgICAgdmFyIGN1cmxlbjsKICAgICAgICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXTsKICAgICAgICB2YXIgY291bnQgPSAwOwogICAgICAgIHZhciBtYXhfY291bnQgPSA3OwogICAgICAgIHZhciBtaW5fY291bnQgPSA0OwogICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgICAgIGN1cmxlbiA9IG5leHRsZW47CiAgICAgICAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdOwogICAgICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkgewogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsKICAgICAgICAgICAgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkgewogICAgICAgICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsKICAgICAgICAgICAgICBjb3VudC0tOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpOwogICAgICAgICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHsKICAgICAgICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTsKICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTsKICAgICAgICAgIH0KICAgICAgICAgIGNvdW50ID0gMDsKICAgICAgICAgIHByZXZsZW4gPSBjdXJsZW47CiAgICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBtYXhfY291bnQgPSA2OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNzsKICAgICAgICAgICAgbWluX2NvdW50ID0gNDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7CiAgICAgICAgdmFyIG1heF9ibGluZGV4OwogICAgICAgIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpOwogICAgICAgIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpOwogICAgICAgIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTsKICAgICAgICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7CiAgICAgICAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXSAhPT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDsKICAgICAgICByZXR1cm4gbWF4X2JsaW5kZXg7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpIHsKICAgICAgICB2YXIgcmFuazsKICAgICAgICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsKICAgICAgICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgNSk7CiAgICAgICAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCA0KTsKICAgICAgICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7CiAgICAgICAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLCAzKTsKICAgICAgICB9CiAgICAgICAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsKICAgICAgICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykgewogICAgICAgIHZhciBibGFja19tYXNrID0gNDA5MzYyNDQ0NzsKICAgICAgICB2YXIgbjsKICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7CiAgICAgICAgICBpZiAoYmxhY2tfbWFzayAmIDEgJiYgcy5keW5fbHRyZWVbbiAqIDJdICE9PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBaX0JJTkFSWTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXSAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdICE9PSAwIHx8IHMuZHluX2x0cmVlWzEzICogMl0gIT09IDApIHsKICAgICAgICAgIHJldHVybiBaX1RFWFQ7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykgewogICAgICAgICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXSAhPT0gMCkgewogICAgICAgICAgICByZXR1cm4gWl9URVhUOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gWl9CSU5BUlk7CiAgICAgIH0KICAgICAgdmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTsKICAgICAgZnVuY3Rpb24gX3RyX2luaXQocykgewogICAgICAgIGlmICghc3RhdGljX2luaXRfZG9uZSkgewogICAgICAgICAgdHJfc3RhdGljX2luaXQoKTsKICAgICAgICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlOwogICAgICAgIH0KICAgICAgICBzLmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7CiAgICAgICAgcy5kX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpOwogICAgICAgIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTsKICAgICAgICBzLmJpX2J1ZiA9IDA7CiAgICAgICAgcy5iaV92YWxpZCA9IDA7CiAgICAgICAgaW5pdF9ibG9jayhzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgewogICAgICAgIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICAgIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfYWxpZ24ocykgewogICAgICAgIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7CiAgICAgICAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTsKICAgICAgICBiaV9mbHVzaChzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSB7CiAgICAgICAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsKICAgICAgICB2YXIgbWF4X2JsaW5kZXggPSAwOwogICAgICAgIGlmIChzLmxldmVsID4gMCkgewogICAgICAgICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikgewogICAgICAgICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTsKICAgICAgICAgIH0KICAgICAgICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpOwogICAgICAgICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7CiAgICAgICAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7CiAgICAgICAgICBvcHRfbGVuYiA9IHMub3B0X2xlbiArIDMgKyA3ID4+PiAzOwogICAgICAgICAgc3RhdGljX2xlbmIgPSBzLnN0YXRpY19sZW4gKyAzICsgNyA+Pj4gMzsKICAgICAgICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgewogICAgICAgICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7CiAgICAgICAgfQogICAgICAgIGlmIChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYiAmJiBidWYgIT09IC0xKSB7CiAgICAgICAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7CiAgICAgICAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikgewogICAgICAgICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7CiAgICAgICAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICAgICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7CiAgICAgICAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpOwogICAgICAgIH0KICAgICAgICBpbml0X2Jsb2NrKHMpOwogICAgICAgIGlmIChsYXN0KSB7CiAgICAgICAgICBiaV93aW5kdXAocyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYykgewogICAgICAgIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSA9IGRpc3QgPj4+IDggJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDI1NTsKICAgICAgICBzLmxhc3RfbGl0Kys7CiAgICAgICAgaWYgKGRpc3QgPT09IDApIHsKICAgICAgICAgIHMuZHluX2x0cmVlW2xjICogMl0rKzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcy5tYXRjaGVzKys7CiAgICAgICAgICBkaXN0LS07CiAgICAgICAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXSsrOwogICAgICAgICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0rKzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxOwogICAgICB9CiAgICAgIGV4cG9ydHMyLl90cl9pbml0ID0gX3RyX2luaXQ7CiAgICAgIGV4cG9ydHMyLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrOwogICAgICBleHBvcnRzMi5fdHJfZmx1c2hfYmxvY2sgPSBfdHJfZmx1c2hfYmxvY2s7CiAgICAgIGV4cG9ydHMyLl90cl90YWxseSA9IF90cl90YWxseTsKICAgICAgZXhwb3J0czIuX3RyX2FsaWduID0gX3RyX2FsaWduOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcwogIHZhciByZXF1aXJlX2FkbGVyMzIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHsKICAgICAgICB2YXIgczEgPSBhZGxlciAmIDY1NTM1IHwgMCwgczIgPSBhZGxlciA+Pj4gMTYgJiA2NTUzNSB8IDAsIG4gPSAwOwogICAgICAgIHdoaWxlIChsZW4gIT09IDApIHsKICAgICAgICAgIG4gPSBsZW4gPiAyZTMgPyAyZTMgOiBsZW47CiAgICAgICAgICBsZW4gLT0gbjsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgczEgPSBzMSArIGJ1Zltwb3MrK10gfCAwOwogICAgICAgICAgICBzMiA9IHMyICsgczEgfCAwOwogICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgIHMxICU9IDY1NTIxOwogICAgICAgICAgczIgJT0gNjU1MjE7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzMSB8IHMyIDw8IDE2IHwgMDsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBhZGxlcjMyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMKICB2YXIgcmVxdWlyZV9jcmMzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIG1ha2VUYWJsZSgpIHsKICAgICAgICB2YXIgYywgdGFibGUgPSBbXTsKICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7CiAgICAgICAgICBjID0gbjsKICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7CiAgICAgICAgICAgIGMgPSBjICYgMSA/IDM5ODgyOTIzODQgXiBjID4+PiAxIDogYyA+Pj4gMTsKICAgICAgICAgIH0KICAgICAgICAgIHRhYmxlW25dID0gYzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhYmxlOwogICAgICB9CiAgICAgIHZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpOwogICAgICBmdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHsKICAgICAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47CiAgICAgICAgY3JjIF49IC0xOwogICAgICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykgewogICAgICAgICAgY3JjID0gY3JjID4+PiA4IF4gdFsoY3JjIF4gYnVmW2ldKSAmIDI1NV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBjcmMgXiAtMTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBjcmMzMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzCiAgdmFyIHJlcXVpcmVfbWVzc2FnZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7CiAgICAgICAgMjogIm5lZWQgZGljdGlvbmFyeSIsCiAgICAgICAgMTogInN0cmVhbSBlbmQiLAogICAgICAgIDA6ICIiLAogICAgICAgICItMSI6ICJmaWxlIGVycm9yIiwKICAgICAgICAiLTIiOiAic3RyZWFtIGVycm9yIiwKICAgICAgICAiLTMiOiAiZGF0YSBlcnJvciIsCiAgICAgICAgIi00IjogImluc3VmZmljaWVudCBtZW1vcnkiLAogICAgICAgICItNSI6ICJidWZmZXIgZXJyb3IiLAogICAgICAgICItNiI6ICJpbmNvbXBhdGlibGUgdmVyc2lvbiIKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMKICB2YXIgcmVxdWlyZV9kZWZsYXRlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgdHJlZXMgPSByZXF1aXJlX3RyZWVzKCk7CiAgICAgIHZhciBhZGxlcjMyID0gcmVxdWlyZV9hZGxlcjMyKCk7CiAgICAgIHZhciBjcmMzMiA9IHJlcXVpcmVfY3JjMzIoKTsKICAgICAgdmFyIG1zZyA9IHJlcXVpcmVfbWVzc2FnZXMoKTsKICAgICAgdmFyIFpfTk9fRkxVU0ggPSAwOwogICAgICB2YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTsKICAgICAgdmFyIFpfRlVMTF9GTFVTSCA9IDM7CiAgICAgIHZhciBaX0ZJTklTSCA9IDQ7CiAgICAgIHZhciBaX0JMT0NLID0gNTsKICAgICAgdmFyIFpfT0sgPSAwOwogICAgICB2YXIgWl9TVFJFQU1fRU5EID0gMTsKICAgICAgdmFyIFpfU1RSRUFNX0VSUk9SID0gLTI7CiAgICAgIHZhciBaX0RBVEFfRVJST1IgPSAtMzsKICAgICAgdmFyIFpfQlVGX0VSUk9SID0gLTU7CiAgICAgIHZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTsKICAgICAgdmFyIFpfRklMVEVSRUQgPSAxOwogICAgICB2YXIgWl9IVUZGTUFOX09OTFkgPSAyOwogICAgICB2YXIgWl9STEUgPSAzOwogICAgICB2YXIgWl9GSVhFRCA9IDQ7CiAgICAgIHZhciBaX0RFRkFVTFRfU1RSQVRFR1kgPSAwOwogICAgICB2YXIgWl9VTktOT1dOID0gMjsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICB2YXIgTUFYX01FTV9MRVZFTCA9IDk7CiAgICAgIHZhciBNQVhfV0JJVFMgPSAxNTsKICAgICAgdmFyIERFRl9NRU1fTEVWRUwgPSA4OwogICAgICB2YXIgTEVOR1RIX0NPREVTID0gMjk7CiAgICAgIHZhciBMSVRFUkFMUyA9IDI1NjsKICAgICAgdmFyIExfQ09ERVMgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7CiAgICAgIHZhciBEX0NPREVTID0gMzA7CiAgICAgIHZhciBCTF9DT0RFUyA9IDE5OwogICAgICB2YXIgSEVBUF9TSVpFID0gMiAqIExfQ09ERVMgKyAxOwogICAgICB2YXIgTUFYX0JJVFMgPSAxNTsKICAgICAgdmFyIE1JTl9NQVRDSCA9IDM7CiAgICAgIHZhciBNQVhfTUFUQ0ggPSAyNTg7CiAgICAgIHZhciBNSU5fTE9PS0FIRUFEID0gTUFYX01BVENIICsgTUlOX01BVENIICsgMTsKICAgICAgdmFyIFBSRVNFVF9ESUNUID0gMzI7CiAgICAgIHZhciBJTklUX1NUQVRFID0gNDI7CiAgICAgIHZhciBFWFRSQV9TVEFURSA9IDY5OwogICAgICB2YXIgTkFNRV9TVEFURSA9IDczOwogICAgICB2YXIgQ09NTUVOVF9TVEFURSA9IDkxOwogICAgICB2YXIgSENSQ19TVEFURSA9IDEwMzsKICAgICAgdmFyIEJVU1lfU1RBVEUgPSAxMTM7CiAgICAgIHZhciBGSU5JU0hfU1RBVEUgPSA2NjY7CiAgICAgIHZhciBCU19ORUVEX01PUkUgPSAxOwogICAgICB2YXIgQlNfQkxPQ0tfRE9ORSA9IDI7CiAgICAgIHZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7CiAgICAgIHZhciBCU19GSU5JU0hfRE9ORSA9IDQ7CiAgICAgIHZhciBPU19DT0RFID0gMzsKICAgICAgZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkgewogICAgICAgIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07CiAgICAgICAgcmV0dXJuIGVycm9yQ29kZTsKICAgICAgfQogICAgICBmdW5jdGlvbiByYW5rKGYpIHsKICAgICAgICByZXR1cm4gKGYgPDwgMSkgLSAoZiA+IDQgPyA5IDogMCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gemVybyhidWYpIHsKICAgICAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICB3aGlsZSAoLS1sZW4gPj0gMCkgewogICAgICAgICAgYnVmW2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHsKICAgICAgICB2YXIgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgdmFyIGxlbiA9IHMucGVuZGluZzsKICAgICAgICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHsKICAgICAgICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIH0KICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpOwogICAgICAgIHN0cm0ubmV4dF9vdXQgKz0gbGVuOwogICAgICAgIHMucGVuZGluZ19vdXQgKz0gbGVuOwogICAgICAgIHN0cm0udG90YWxfb3V0ICs9IGxlbjsKICAgICAgICBzdHJtLmF2YWlsX291dCAtPSBsZW47CiAgICAgICAgcy5wZW5kaW5nIC09IGxlbjsKICAgICAgICBpZiAocy5wZW5kaW5nID09PSAwKSB7CiAgICAgICAgICBzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7CiAgICAgICAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0OwogICAgICAgIGZsdXNoX3BlbmRpbmcocy5zdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgPj4+IDggJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMjU1OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHsKICAgICAgICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBpZiAobGVuID4gc2l6ZSkgewogICAgICAgICAgbGVuID0gc2l6ZTsKICAgICAgICB9CiAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIHN0cm0uYXZhaWxfaW4gLT0gbGVuOwogICAgICAgIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTsKICAgICAgICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpOwogICAgICAgIH0gZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTsKICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X2luICs9IGxlbjsKICAgICAgICBzdHJtLnRvdGFsX2luICs9IGxlbjsKICAgICAgICByZXR1cm4gbGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7CiAgICAgICAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsKICAgICAgICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgdmFyIG1hdGNoOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsKICAgICAgICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsKICAgICAgICB2YXIgbGltaXQgPSBzLnN0cnN0YXJ0ID4gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEID8gcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMDsKICAgICAgICB2YXIgX3dpbiA9IHMud2luZG93OwogICAgICAgIHZhciB3bWFzayA9IHMud19tYXNrOwogICAgICAgIHZhciBwcmV2ID0gcy5wcmV2OwogICAgICAgIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIOwogICAgICAgIHZhciBzY2FuX2VuZDEgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdOwogICAgICAgIHZhciBzY2FuX2VuZCA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTsKICAgICAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHsKICAgICAgICAgIGNoYWluX2xlbmd0aCA+Pj0gMjsKICAgICAgICB9CiAgICAgICAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgewogICAgICAgICAgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOwogICAgICAgIH0KICAgICAgICBkbyB7CiAgICAgICAgICBtYXRjaCA9IGN1cl9tYXRjaDsKICAgICAgICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICE9PSBzY2FuX2VuZCB8fCBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8IF93aW5bbWF0Y2hdICE9PSBfd2luW3NjYW5dIHx8IF93aW5bKyttYXRjaF0gIT09IF93aW5bc2NhbiArIDFdKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgc2NhbiArPSAyOwogICAgICAgICAgbWF0Y2grKzsKICAgICAgICAgIGRvIHsKICAgICAgICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgc2NhbiA8IHN0cmVuZCk7CiAgICAgICAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7CiAgICAgICAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIOwogICAgICAgICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7CiAgICAgICAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7CiAgICAgICAgICAgIGJlc3RfbGVuID0gbGVuOwogICAgICAgICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBzY2FuX2VuZDEgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdOwogICAgICAgICAgICBzY2FuX2VuZCA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTsKICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApOwogICAgICAgIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkgewogICAgICAgICAgcmV0dXJuIGJlc3RfbGVuOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcy5sb29rYWhlYWQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmlsbF93aW5kb3cocykgewogICAgICAgIHZhciBfd19zaXplID0gcy53X3NpemU7CiAgICAgICAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjsKICAgICAgICBkbyB7CiAgICAgICAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDsKICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7CiAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7CiAgICAgICAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTsKICAgICAgICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplOwogICAgICAgICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7CiAgICAgICAgICAgIG4gPSBzLmhhc2hfc2l6ZTsKICAgICAgICAgICAgcCA9IG47CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBtID0gcy5oZWFkWy0tcF07CiAgICAgICAgICAgICAgcy5oZWFkW3BdID0gbSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwOwogICAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgICBuID0gX3dfc2l6ZTsKICAgICAgICAgICAgcCA9IG47CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBtID0gcy5wcmV2Wy0tcF07CiAgICAgICAgICAgICAgcy5wcmV2W3BdID0gbSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwOwogICAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgICBtb3JlICs9IF93X3NpemU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7CiAgICAgICAgICBzLmxvb2thaGVhZCArPSBuOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDsKICAgICAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7CiAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyOwogICAgICAgICAgICAgIHN0cisrOwogICAgICAgICAgICAgIHMuaW5zZXJ0LS07CiAgICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIG1heF9ibG9ja19zaXplID0gNjU1MzU7CiAgICAgICAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkgewogICAgICAgICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1OwogICAgICAgIH0KICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkOwogICAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTsKICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7CiAgICAgICAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDsKICAgICAgICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHsKICAgICAgICB2YXIgaGFzaF9oZWFkOwogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaGFzaF9oZWFkID0gMDsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaGFzaF9oZWFkICE9PSAwICYmIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTsKICAgICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdOwogICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGhhc2hfaGVhZDsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIHZhciBtYXhfaW5zZXJ0OwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGhhc2hfaGVhZCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgfQogICAgICAgICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDsKICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgIGlmIChoYXNoX2hlYWQgIT09IDAgJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiYgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7CiAgICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2KSkgewogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHsKICAgICAgICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7CiAgICAgICAgICAgIHMucHJldl9sZW5ndGggLT0gMjsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkgewogICAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7CiAgICAgICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7CiAgICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkgewogICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7CiAgICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkgewogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgdmFyIHByZXY7CiAgICAgICAgdmFyIHNjYW4sIHN0cmVuZDsKICAgICAgICB2YXIgX3dpbiA9IHMud2luZG93OwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHsKICAgICAgICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxOwogICAgICAgICAgICBwcmV2ID0gX3dpbltzY2FuXTsKICAgICAgICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7CiAgICAgICAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBzY2FuIDwgc3RyZW5kKTsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTsKICAgICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkgewogICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTsKICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHsKICAgICAgICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7CiAgICAgICAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5OwogICAgICAgIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDsKICAgICAgICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjsKICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jOwogICAgICB9CiAgICAgIHZhciBjb25maWd1cmF0aW9uX3RhYmxlOwogICAgICBjb25maWd1cmF0aW9uX3RhYmxlID0gWwogICAgICAgIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLAogICAgICAgIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLAogICAgICAgIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLAogICAgICAgIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KQogICAgICBdOwogICAgICBmdW5jdGlvbiBsbV9pbml0KHMpIHsKICAgICAgICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplOwogICAgICAgIHplcm8ocy5oZWFkKTsKICAgICAgICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTsKICAgICAgICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoOwogICAgICAgIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7CiAgICAgICAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47CiAgICAgICAgcy5zdHJzdGFydCA9IDA7CiAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICBzLmluc19oID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7CiAgICAgICAgdGhpcy5zdHJtID0gbnVsbDsKICAgICAgICB0aGlzLnN0YXR1cyA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7CiAgICAgICAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsKICAgICAgICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICB0aGlzLnBlbmRpbmcgPSAwOwogICAgICAgIHRoaXMud3JhcCA9IDA7CiAgICAgICAgdGhpcy5nemhlYWQgPSBudWxsOwogICAgICAgIHRoaXMuZ3ppbmRleCA9IDA7CiAgICAgICAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOwogICAgICAgIHRoaXMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgIHRoaXMud19zaXplID0gMDsKICAgICAgICB0aGlzLndfYml0cyA9IDA7CiAgICAgICAgdGhpcy53X21hc2sgPSAwOwogICAgICAgIHRoaXMud2luZG93ID0gbnVsbDsKICAgICAgICB0aGlzLndpbmRvd19zaXplID0gMDsKICAgICAgICB0aGlzLnByZXYgPSBudWxsOwogICAgICAgIHRoaXMuaGVhZCA9IG51bGw7CiAgICAgICAgdGhpcy5pbnNfaCA9IDA7CiAgICAgICAgdGhpcy5oYXNoX3NpemUgPSAwOwogICAgICAgIHRoaXMuaGFzaF9iaXRzID0gMDsKICAgICAgICB0aGlzLmhhc2hfbWFzayA9IDA7CiAgICAgICAgdGhpcy5oYXNoX3NoaWZ0ID0gMDsKICAgICAgICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5wcmV2X21hdGNoID0gMDsKICAgICAgICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgdGhpcy5zdHJzdGFydCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9zdGFydCA9IDA7CiAgICAgICAgdGhpcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHRoaXMucHJldl9sZW5ndGggPSAwOwogICAgICAgIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5sZXZlbCA9IDA7CiAgICAgICAgdGhpcy5zdHJhdGVneSA9IDA7CiAgICAgICAgdGhpcy5nb29kX21hdGNoID0gMDsKICAgICAgICB0aGlzLm5pY2VfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMuZHluX2x0cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpOwogICAgICAgIHRoaXMuZHluX2R0cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7CiAgICAgICAgdGhpcy5ibF90cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpOwogICAgICAgIHplcm8odGhpcy5keW5fbHRyZWUpOwogICAgICAgIHplcm8odGhpcy5keW5fZHRyZWUpOwogICAgICAgIHplcm8odGhpcy5ibF90cmVlKTsKICAgICAgICB0aGlzLmxfZGVzYyA9IG51bGw7CiAgICAgICAgdGhpcy5kX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuYmxfZGVzYyA9IG51bGw7CiAgICAgICAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpOwogICAgICAgIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOwogICAgICAgIHplcm8odGhpcy5oZWFwKTsKICAgICAgICB0aGlzLmhlYXBfbGVuID0gMDsKICAgICAgICB0aGlzLmhlYXBfbWF4ID0gMDsKICAgICAgICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7CiAgICAgICAgemVybyh0aGlzLmRlcHRoKTsKICAgICAgICB0aGlzLmxfYnVmID0gMDsKICAgICAgICB0aGlzLmxpdF9idWZzaXplID0gMDsKICAgICAgICB0aGlzLmxhc3RfbGl0ID0gMDsKICAgICAgICB0aGlzLmRfYnVmID0gMDsKICAgICAgICB0aGlzLm9wdF9sZW4gPSAwOwogICAgICAgIHRoaXMuc3RhdGljX2xlbiA9IDA7CiAgICAgICAgdGhpcy5tYXRjaGVzID0gMDsKICAgICAgICB0aGlzLmluc2VydCA9IDA7CiAgICAgICAgdGhpcy5iaV9idWYgPSAwOwogICAgICAgIHRoaXMuYmlfdmFsaWQgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkgewogICAgICAgIHZhciBzOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7CiAgICAgICAgfQogICAgICAgIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7CiAgICAgICAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047CiAgICAgICAgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgcy5wZW5kaW5nID0gMDsKICAgICAgICBzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICBpZiAocy53cmFwIDwgMCkgewogICAgICAgICAgcy53cmFwID0gLXMud3JhcDsKICAgICAgICB9CiAgICAgICAgcy5zdGF0dXMgPSBzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURTsKICAgICAgICBzdHJtLmFkbGVyID0gcy53cmFwID09PSAyID8gMCA6IDE7CiAgICAgICAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDsKICAgICAgICB0cmVlcy5fdHJfaW5pdChzKTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkgewogICAgICAgIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pOwogICAgICAgIGlmIChyZXQgPT09IFpfT0spIHsKICAgICAgICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHsKICAgICAgICBpZiAoIXN0cm0pIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgdmFyIHdyYXAgPSAxOwogICAgICAgIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7CiAgICAgICAgICBsZXZlbCA9IDY7CiAgICAgICAgfQogICAgICAgIGlmICh3aW5kb3dCaXRzIDwgMCkgewogICAgICAgICAgd3JhcCA9IDA7CiAgICAgICAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHsKICAgICAgICAgIHdyYXAgPSAyOwogICAgICAgICAgd2luZG93Qml0cyAtPSAxNjsKICAgICAgICB9CiAgICAgICAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8IHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8IHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyA9PT0gOCkgewogICAgICAgICAgd2luZG93Qml0cyA9IDk7CiAgICAgICAgfQogICAgICAgIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpOwogICAgICAgIHN0cm0uc3RhdGUgPSBzOwogICAgICAgIHMuc3RybSA9IHN0cm07CiAgICAgICAgcy53cmFwID0gd3JhcDsKICAgICAgICBzLmd6aGVhZCA9IG51bGw7CiAgICAgICAgcy53X2JpdHMgPSB3aW5kb3dCaXRzOwogICAgICAgIHMud19zaXplID0gMSA8PCBzLndfYml0czsKICAgICAgICBzLndfbWFzayA9IHMud19zaXplIC0gMTsKICAgICAgICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNzsKICAgICAgICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7CiAgICAgICAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7CiAgICAgICAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpOwogICAgICAgIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTsKICAgICAgICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpOwogICAgICAgIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7CiAgICAgICAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgbWVtTGV2ZWwgKyA2OwogICAgICAgIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0OwogICAgICAgIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpOwogICAgICAgIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTsKICAgICAgICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7CiAgICAgICAgcy5sZXZlbCA9IGxldmVsOwogICAgICAgIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTsKICAgICAgICBzLm1ldGhvZCA9IG1ldGhvZDsKICAgICAgICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7CiAgICAgICAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHsKICAgICAgICB2YXIgb2xkX2ZsdXNoLCBzOwogICAgICAgIHZhciBiZWcsIHZhbDsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkgewogICAgICAgICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmICghc3RybS5vdXRwdXQgfHwgIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBzdHJtLmF2YWlsX291dCA9PT0gMCA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzLnN0cm0gPSBzdHJtOwogICAgICAgIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDsKICAgICAgICBzLmxhc3RfZmx1c2ggPSBmbHVzaDsKICAgICAgICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLndyYXAgPT09IDIpIHsKICAgICAgICAgICAgc3RybS5hZGxlciA9IDA7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDMxKTsKICAgICAgICAgICAgcHV0X2J5dGUocywgMTM5KTsKICAgICAgICAgICAgcHV0X2J5dGUocywgOCk7CiAgICAgICAgICAgIGlmICghcy5nemhlYWQpIHsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6IHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgPyA0IDogMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICsgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgKyAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICsgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICsgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiA4ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lID4+IDE2ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lID4+IDI0ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6IHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgPyA0IDogMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAyNTUpOwogICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDI1NSk7CiAgICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcy5nemluZGV4ID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YXIgaGVhZGVyID0gWl9ERUZMQVRFRCArIChzLndfYml0cyAtIDggPDwgNCkgPDwgODsKICAgICAgICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7CiAgICAgICAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwOwogICAgICAgICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxOwogICAgICAgICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDI7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGhlYWRlciB8PSBsZXZlbF9mbGFncyA8PCA2OwogICAgICAgICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgewogICAgICAgICAgICAgIGhlYWRlciB8PSBQUkVTRVRfRElDVDsKICAgICAgICAgICAgfQogICAgICAgICAgICBoZWFkZXIgKz0gMzEgLSBoZWFkZXIgJSAzMTsKICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpOwogICAgICAgICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgewogICAgICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTsKICAgICAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgNjU1MzUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSAxOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEpIHsKICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDY1NTM1KSkgewogICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMjU1KTsKICAgICAgICAgICAgICBzLmd6aW5kZXgrKzsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkgewogICAgICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLm5hbWUpIHsKICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgICAgdmFsID0gMTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkgewogICAgICAgICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDI1NTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFsID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgdmFsKTsKICAgICAgICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTsKICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodmFsID09PSAwKSB7CiAgICAgICAgICAgICAgcy5nemluZGV4ID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQuY29tbWVudCkgewogICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgICB2YWwgPSAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMjU1OwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB2YWwgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwdXRfYnl0ZShzLCB2YWwpOwogICAgICAgICAgICB9IHdoaWxlICh2YWwgIT09IDApOwogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYykgewogICAgICAgICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiA4ICYgMjU1KTsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMucGVuZGluZyAhPT0gMCkgewogICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpOwogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHwgZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkgewogICAgICAgICAgdmFyIGJzdGF0ZSA9IHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6IHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDogY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKTsKICAgICAgICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkgewogICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHsKICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHsKICAgICAgICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsKICAgICAgICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTsKICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkgewogICAgICAgICAgICAgICAgemVybyhzLmhlYWQpOwogICAgICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICAgICAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7CiAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICB9CiAgICAgICAgaWYgKHMud3JhcCA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRU5EOwogICAgICAgIH0KICAgICAgICBpZiAocy53cmFwID09PSAyKSB7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gOCAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDE2ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gMjQgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luID4+IDggJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiA+PiAxNiAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luID4+IDI0ICYgMjU1KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpOwogICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDY1NTM1KTsKICAgICAgICB9CiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICBpZiAocy53cmFwID4gMCkgewogICAgICAgICAgcy53cmFwID0gLXMud3JhcDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7CiAgICAgICAgdmFyIHN0YXR1czsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJiBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJiBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiYgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJiBzdGF0dXMgIT09IEZJTklTSF9TVEFURSkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7CiAgICAgICAgfQogICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkgewogICAgICAgIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7CiAgICAgICAgdmFyIHM7CiAgICAgICAgdmFyIHN0ciwgbjsKICAgICAgICB2YXIgd3JhcDsKICAgICAgICB2YXIgYXZhaWw7CiAgICAgICAgdmFyIG5leHQ7CiAgICAgICAgdmFyIGlucHV0OwogICAgICAgIHZhciB0bXBEaWN0OwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzID0gc3RybS5zdGF0ZTsKICAgICAgICB3cmFwID0gcy53cmFwOwogICAgICAgIGlmICh3cmFwID09PSAyIHx8IHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUgfHwgcy5sb29rYWhlYWQpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgaWYgKHdyYXAgPT09IDEpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApOwogICAgICAgIH0KICAgICAgICBzLndyYXAgPSAwOwogICAgICAgIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7CiAgICAgICAgICBpZiAod3JhcCA9PT0gMCkgewogICAgICAgICAgICB6ZXJvKHMuaGVhZCk7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgICAgfQogICAgICAgICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTsKICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApOwogICAgICAgICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7CiAgICAgICAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7CiAgICAgICAgfQogICAgICAgIGF2YWlsID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDsKICAgICAgICBzdHJtLm5leHRfaW4gPSAwOwogICAgICAgIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5OwogICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgIHN0ciA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyOwogICAgICAgICAgICBzdHIrKzsKICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICBzLnN0cnN0YXJ0ID0gc3RyOwogICAgICAgICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgfQogICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7CiAgICAgICAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDsKICAgICAgICBzLmxvb2thaGVhZCA9IDA7CiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICBzdHJtLmlucHV0ID0gaW5wdXQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGF2YWlsOwogICAgICAgIHMud3JhcCA9IHdyYXA7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZXhwb3J0czIuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDsKICAgICAgZXhwb3J0czIuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyOwogICAgICBleHBvcnRzMi5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwOwogICAgICBleHBvcnRzMi5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjsKICAgICAgZXhwb3J0czIuZGVmbGF0ZSA9IGRlZmxhdGU7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kOwogICAgICBleHBvcnRzMi5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5OwogICAgICBleHBvcnRzMi5kZWZsYXRlSW5mbyA9ICJwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpIjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzCiAgdmFyIHJlcXVpcmVfc3RyaW5ncyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBTVFJfQVBQTFlfT0sgPSB0cnVlOwogICAgICB2YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7CiAgICAgIHRyeSB7CiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbMF0pOwogICAgICB9IGNhdGNoIChfXykgewogICAgICAgIFNUUl9BUFBMWV9PSyA9IGZhbHNlOwogICAgICB9CiAgICAgIHRyeSB7CiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7CiAgICAgIH0gY2F0Y2ggKF9fKSB7CiAgICAgICAgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOwogICAgICB9CiAgICAgIHZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7CiAgICAgIGZvciAocSA9IDA7IHEgPCAyNTY7IHErKykgewogICAgICAgIF91dGY4bGVuW3FdID0gcSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMTsKICAgICAgfQogICAgICB2YXIgcTsKICAgICAgX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOwogICAgICBleHBvcnRzMi5zdHJpbmcyYnVmID0gZnVuY3Rpb24oc3RyKSB7CiAgICAgICAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7CiAgICAgICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykgewogICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTsKICAgICAgICAgIGlmICgoYyAmIDY0NTEyKSA9PT0gNTUyOTYgJiYgbV9wb3MgKyAxIDwgc3RyX2xlbikgewogICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7CiAgICAgICAgICAgIGlmICgoYzIgJiA2NDUxMikgPT09IDU2MzIwKSB7CiAgICAgICAgICAgICAgYyA9IDY1NTM2ICsgKGMgLSA1NTI5NiA8PCAxMCkgKyAoYzIgLSA1NjMyMCk7CiAgICAgICAgICAgICAgbV9wb3MrKzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgYnVmX2xlbiArPSBjIDwgMTI4ID8gMSA6IGMgPCAyMDQ4ID8gMiA6IGMgPCA2NTUzNiA/IDMgOiA0OwogICAgICAgIH0KICAgICAgICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTsKICAgICAgICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7CiAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpOwogICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5NiAmJiBtX3BvcyArIDEgPCBzdHJfbGVuKSB7CiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTsKICAgICAgICAgICAgaWYgKChjMiAmIDY0NTEyKSA9PT0gNTYzMjApIHsKICAgICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAtIDU1Mjk2IDw8IDEwKSArIChjMiAtIDU2MzIwKTsKICAgICAgICAgICAgICBtX3BvcysrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYyA8IDEyOCkgewogICAgICAgICAgICBidWZbaSsrXSA9IGM7CiAgICAgICAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTkyIHwgYyA+Pj4gNjsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjICYgNjM7CiAgICAgICAgICB9IGVsc2UgaWYgKGMgPCA2NTUzNikgewogICAgICAgICAgICBidWZbaSsrXSA9IDIyNCB8IGMgPj4+IDEyOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgPj4+IDYgJiA2MzsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjICYgNjM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBidWZbaSsrXSA9IDI0MCB8IGMgPj4+IDE4OwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgPj4+IDEyICYgNjM7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gNiAmIDYzOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikgewogICAgICAgIGlmIChsZW4gPCA2NTUzNCkgewogICAgICAgICAgaWYgKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LIHx8ICFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSB7CiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQogICAgICBleHBvcnRzMi5idWYyYmluc3RyaW5nID0gZnVuY3Rpb24oYnVmKSB7CiAgICAgICAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTsKICAgICAgfTsKICAgICAgZXhwb3J0czIuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uKHN0cikgewogICAgICAgIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTsKICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgZXhwb3J0czIuYnVmMnN0cmluZyA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7CiAgICAgICAgdmFyIGksIG91dCwgYywgY19sZW47CiAgICAgICAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoOwogICAgICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTsKICAgICAgICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOyApIHsKICAgICAgICAgIGMgPSBidWZbaSsrXTsKICAgICAgICAgIGlmIChjIDwgMTI4KSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTsKICAgICAgICAgIGlmIChjX2xlbiA+IDQpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gNjU1MzM7CiAgICAgICAgICAgIGkgKz0gY19sZW4gLSAxOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAzMSA6IGNfbGVuID09PSAzID8gMTUgOiA3OwogICAgICAgICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7CiAgICAgICAgICAgIGMgPSBjIDw8IDYgfCBidWZbaSsrXSAmIDYzOwogICAgICAgICAgICBjX2xlbi0tOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGNfbGVuID4gMSkgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA2NTUzMzsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYyA8IDY1NTM2KSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjIC09IDY1NTM2OwogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA1NTI5NiB8IGMgPj4gMTAgJiAxMDIzOwogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA1NjMyMCB8IGMgJiAxMDIzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTsKICAgICAgfTsKICAgICAgZXhwb3J0czIudXRmOGJvcmRlciA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7CiAgICAgICAgdmFyIHBvczsKICAgICAgICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDsKICAgICAgICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgewogICAgICAgICAgbWF4ID0gYnVmLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgcG9zID0gbWF4IC0gMTsKICAgICAgICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICBwb3MtLTsKICAgICAgICB9CiAgICAgICAgaWYgKHBvcyA8IDApIHsKICAgICAgICAgIHJldHVybiBtYXg7CiAgICAgICAgfQogICAgICAgIGlmIChwb3MgPT09IDApIHsKICAgICAgICAgIHJldHVybiBtYXg7CiAgICAgICAgfQogICAgICAgIHJldHVybiBwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXggPyBwb3MgOiBtYXg7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzCiAgdmFyIHJlcXVpcmVfenN0cmVhbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gWlN0cmVhbSgpIHsKICAgICAgICB0aGlzLmlucHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfaW4gPSAwOwogICAgICAgIHRoaXMuYXZhaWxfaW4gPSAwOwogICAgICAgIHRoaXMudG90YWxfaW4gPSAwOwogICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfb3V0ID0gMDsKICAgICAgICB0aGlzLmF2YWlsX291dCA9IDA7CiAgICAgICAgdGhpcy50b3RhbF9vdXQgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7CiAgICAgICAgdGhpcy5kYXRhX3R5cGUgPSAyOwogICAgICAgIHRoaXMuYWRsZXIgPSAwOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFpTdHJlYW07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcwogIHZhciByZXF1aXJlX2RlZmxhdGUyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmVfZGVmbGF0ZSgpOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgc3RyaW5ncyA9IHJlcXVpcmVfc3RyaW5ncygpOwogICAgICB2YXIgbXNnID0gcmVxdWlyZV9tZXNzYWdlcygpOwogICAgICB2YXIgWlN0cmVhbSA9IHJlcXVpcmVfenN0cmVhbSgpOwogICAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICB2YXIgWl9OT19GTFVTSCA9IDA7CiAgICAgIHZhciBaX0ZJTklTSCA9IDQ7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX1NZTkNfRkxVU0gyID0gMjsKICAgICAgdmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xOwogICAgICB2YXIgWl9ERUZBVUxUX1NUUkFURUdZID0gMDsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICBmdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpCiAgICAgICAgICByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7CiAgICAgICAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHsKICAgICAgICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sCiAgICAgICAgICBtZXRob2Q6IFpfREVGTEFURUQsCiAgICAgICAgICBjaHVua1NpemU6IDE2Mzg0LAogICAgICAgICAgd2luZG93Qml0czogMTUsCiAgICAgICAgICBtZW1MZXZlbDogOCwKICAgICAgICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksCiAgICAgICAgICB0bzogIiIKICAgICAgICB9LCBvcHRpb25zIHx8IHt9KTsKICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zOwogICAgICAgIGlmIChvcHQucmF3ICYmIG9wdC53aW5kb3dCaXRzID4gMCkgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIGlmIChvcHQuZ3ppcCAmJiBvcHQud2luZG93Qml0cyA+IDAgJiYgb3B0LndpbmRvd0JpdHMgPCAxNikgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7CiAgICAgICAgfQogICAgICAgIHRoaXMuZXJyID0gMDsKICAgICAgICB0aGlzLm1zZyA9ICIiOwogICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7CiAgICAgICAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIodGhpcy5zdHJtLCBvcHQubGV2ZWwsIG9wdC5tZXRob2QsIG9wdC53aW5kb3dCaXRzLCBvcHQubWVtTGV2ZWwsIG9wdC5zdHJhdGVneSk7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC5oZWFkZXIpIHsKICAgICAgICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7CiAgICAgICAgfQogICAgICAgIGlmIChvcHQuZGljdGlvbmFyeSkgewogICAgICAgICAgdmFyIGRpY3Q7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpOwogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlOwogICAgICAgIH0KICAgICAgfQogICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBzdGF0dXMsIF9tb2RlOwogICAgICAgIGlmICh0aGlzLmVuZGVkKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIF9tb2RlID0gbW9kZSA9PT0gfn5tb2RlID8gbW9kZSA6IG1vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7CiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAic3RyaW5nIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTsKICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RybS5pbnB1dCA9IGRhdGE7CiAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9pbiA9IDA7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoOwogICAgICAgIGRvIHsKICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7CiAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSAwOwogICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9tb2RlKTsKICAgICAgICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHsKICAgICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIMikpIHsKICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IFpfU1RSRUFNX0VORCk7CiAgICAgICAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkgewogICAgICAgICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTsKICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSzsKICAgICAgICB9CiAgICAgICAgaWYgKF9tb2RlID09PSBaX1NZTkNfRkxVU0gyKSB7CiAgICAgICAgICB0aGlzLm9uRW5kKFpfT0spOwogICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9OwogICAgICBEZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihjaHVuaykgewogICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspOwogICAgICB9OwogICAgICBEZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHN0YXR1cykgewogICAgICAgIGlmIChzdGF0dXMgPT09IFpfT0spIHsKICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbigiIik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuZXJyID0gc3RhdHVzOwogICAgICAgIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZzsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykgewogICAgICAgIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpOwogICAgICAgIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpOwogICAgICAgIGlmIChkZWZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IGRlZmxhdG9yLm1zZyB8fCBtc2dbZGVmbGF0b3IuZXJyXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5yYXcgPSB0cnVlOwogICAgICAgIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5nemlwID0gdHJ1ZTsKICAgICAgICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuRGVmbGF0ZSA9IERlZmxhdGU7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGUgPSBkZWZsYXRlOwogICAgICBleHBvcnRzMi5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdzsKICAgICAgZXhwb3J0czIuZ3ppcCA9IGd6aXA7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzCiAgdmFyIHJlcXVpcmVfaW5mZmFzdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIEJBRCA9IDMwOwogICAgICB2YXIgVFlQRSA9IDEyOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgdmFyIF9pbjsKICAgICAgICB2YXIgbGFzdDsKICAgICAgICB2YXIgX291dDsKICAgICAgICB2YXIgYmVnOwogICAgICAgIHZhciBlbmQ7CiAgICAgICAgdmFyIGRtYXg7CiAgICAgICAgdmFyIHdzaXplOwogICAgICAgIHZhciB3aGF2ZTsKICAgICAgICB2YXIgd25leHQ7CiAgICAgICAgdmFyIHNfd2luZG93OwogICAgICAgIHZhciBob2xkOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciBsY29kZTsKICAgICAgICB2YXIgZGNvZGU7CiAgICAgICAgdmFyIGxtYXNrOwogICAgICAgIHZhciBkbWFzazsKICAgICAgICB2YXIgaGVyZTsKICAgICAgICB2YXIgb3A7CiAgICAgICAgdmFyIGxlbjsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgZnJvbTsKICAgICAgICB2YXIgZnJvbV9zb3VyY2U7CiAgICAgICAgdmFyIGlucHV0LCBvdXRwdXQ7CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIF9pbiA9IHN0cm0ubmV4dF9pbjsKICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7CiAgICAgICAgX291dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7CiAgICAgICAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTsKICAgICAgICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTsKICAgICAgICBkbWF4ID0gc3RhdGUuZG1heDsKICAgICAgICB3c2l6ZSA9IHN0YXRlLndzaXplOwogICAgICAgIHdoYXZlID0gc3RhdGUud2hhdmU7CiAgICAgICAgd25leHQgPSBzdGF0ZS53bmV4dDsKICAgICAgICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdzsKICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7CiAgICAgICAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTsKICAgICAgICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTsKICAgICAgICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7CiAgICAgICAgdG9wOgogICAgICAgICAgZG8gewogICAgICAgICAgICBpZiAoYml0cyA8IDE1KSB7CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107CiAgICAgICAgICAgIGRvbGVuOgogICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcCAmIDE2KSB7CiAgICAgICAgICAgICAgICAgIGxlbiA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgb3AgJj0gMTU7CiAgICAgICAgICAgICAgICAgIGlmIChvcCkgewogICAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGxlbiArPSBob2xkICYgKDEgPDwgb3ApIC0gMTsKICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IDE1KSB7CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107CiAgICAgICAgICAgICAgICAgIGRvZGlzdDoKICAgICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCAmIDE2KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgICAgICAgIG9wICY9IDE1OwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKDEgPDwgb3ApIC0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93OwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3bmV4dCA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wIC09IHduZXh0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IDM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSAzOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgNjU1MzUpICsgKGhvbGQgJiAoMSA8PCBvcCkgLSAxKV07CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgY29kZSI7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDY1NTM1KSArIChob2xkICYgKDEgPDwgb3ApIC0gMSldOwogICAgICAgICAgICAgICAgICBjb250aW51ZSBkb2xlbjsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AgJiAzMikgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTsKICAgICAgICBsZW4gPSBiaXRzID4+IDM7CiAgICAgICAgX2luIC09IGxlbjsKICAgICAgICBiaXRzIC09IGxlbiA8PCAzOwogICAgICAgIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxOwogICAgICAgIHN0cm0ubmV4dF9pbiA9IF9pbjsKICAgICAgICBzdHJtLm5leHRfb3V0ID0gX291dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpOwogICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKTsKICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICByZXR1cm47CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcwogIHZhciByZXF1aXJlX2luZnRyZWVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIE1BWEJJVFMgPSAxNTsKICAgICAgdmFyIEVOT1VHSF9MRU5TID0gODUyOwogICAgICB2YXIgRU5PVUdIX0RJU1RTID0gNTkyOwogICAgICB2YXIgQ09ERVMgPSAwOwogICAgICB2YXIgTEVOUyA9IDE7CiAgICAgIHZhciBESVNUUyA9IDI7CiAgICAgIHZhciBsYmFzZSA9IFsKICAgICAgICAzLAogICAgICAgIDQsCiAgICAgICAgNSwKICAgICAgICA2LAogICAgICAgIDcsCiAgICAgICAgOCwKICAgICAgICA5LAogICAgICAgIDEwLAogICAgICAgIDExLAogICAgICAgIDEzLAogICAgICAgIDE1LAogICAgICAgIDE3LAogICAgICAgIDE5LAogICAgICAgIDIzLAogICAgICAgIDI3LAogICAgICAgIDMxLAogICAgICAgIDM1LAogICAgICAgIDQzLAogICAgICAgIDUxLAogICAgICAgIDU5LAogICAgICAgIDY3LAogICAgICAgIDgzLAogICAgICAgIDk5LAogICAgICAgIDExNSwKICAgICAgICAxMzEsCiAgICAgICAgMTYzLAogICAgICAgIDE5NSwKICAgICAgICAyMjcsCiAgICAgICAgMjU4LAogICAgICAgIDAsCiAgICAgICAgMAogICAgICBdOwogICAgICB2YXIgbGV4dCA9IFsKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAxNiwKICAgICAgICA3MiwKICAgICAgICA3OAogICAgICBdOwogICAgICB2YXIgZGJhc2UgPSBbCiAgICAgICAgMSwKICAgICAgICAyLAogICAgICAgIDMsCiAgICAgICAgNCwKICAgICAgICA1LAogICAgICAgIDcsCiAgICAgICAgOSwKICAgICAgICAxMywKICAgICAgICAxNywKICAgICAgICAyNSwKICAgICAgICAzMywKICAgICAgICA0OSwKICAgICAgICA2NSwKICAgICAgICA5NywKICAgICAgICAxMjksCiAgICAgICAgMTkzLAogICAgICAgIDI1NywKICAgICAgICAzODUsCiAgICAgICAgNTEzLAogICAgICAgIDc2OSwKICAgICAgICAxMDI1LAogICAgICAgIDE1MzcsCiAgICAgICAgMjA0OSwKICAgICAgICAzMDczLAogICAgICAgIDQwOTcsCiAgICAgICAgNjE0NSwKICAgICAgICA4MTkzLAogICAgICAgIDEyMjg5LAogICAgICAgIDE2Mzg1LAogICAgICAgIDI0NTc3LAogICAgICAgIDAsCiAgICAgICAgMAogICAgICBdOwogICAgICB2YXIgZGV4dCA9IFsKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNiwKICAgICAgICAxNywKICAgICAgICAxNywKICAgICAgICAxOCwKICAgICAgICAxOCwKICAgICAgICAxOSwKICAgICAgICAxOSwKICAgICAgICAyMCwKICAgICAgICAyMCwKICAgICAgICAyMSwKICAgICAgICAyMSwKICAgICAgICAyMiwKICAgICAgICAyMiwKICAgICAgICAyMywKICAgICAgICAyMywKICAgICAgICAyNCwKICAgICAgICAyNCwKICAgICAgICAyNSwKICAgICAgICAyNSwKICAgICAgICAyNiwKICAgICAgICAyNiwKICAgICAgICAyNywKICAgICAgICAyNywKICAgICAgICAyOCwKICAgICAgICAyOCwKICAgICAgICAyOSwKICAgICAgICAyOSwKICAgICAgICA2NCwKICAgICAgICA2NAogICAgICBdOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpIHsKICAgICAgICB2YXIgYml0cyA9IG9wdHMuYml0czsKICAgICAgICB2YXIgbGVuID0gMDsKICAgICAgICB2YXIgc3ltID0gMDsKICAgICAgICB2YXIgbWluID0gMCwgbWF4ID0gMDsKICAgICAgICB2YXIgcm9vdDIgPSAwOwogICAgICAgIHZhciBjdXJyID0gMDsKICAgICAgICB2YXIgZHJvcCA9IDA7CiAgICAgICAgdmFyIGxlZnQgPSAwOwogICAgICAgIHZhciB1c2VkID0gMDsKICAgICAgICB2YXIgaHVmZiA9IDA7CiAgICAgICAgdmFyIGluY3I7CiAgICAgICAgdmFyIGZpbGw7CiAgICAgICAgdmFyIGxvdzsKICAgICAgICB2YXIgbWFzazsKICAgICAgICB2YXIgbmV4dDsKICAgICAgICB2YXIgYmFzZSA9IG51bGw7CiAgICAgICAgdmFyIGJhc2VfaW5kZXggPSAwOwogICAgICAgIHZhciBlbmQ7CiAgICAgICAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsKICAgICAgICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7CiAgICAgICAgdmFyIGV4dHJhID0gbnVsbDsKICAgICAgICB2YXIgZXh0cmFfaW5kZXggPSAwOwogICAgICAgIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOwogICAgICAgIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7CiAgICAgICAgICBjb3VudFtsZW5dID0gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHsKICAgICAgICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7CiAgICAgICAgfQogICAgICAgIHJvb3QyID0gYml0czsKICAgICAgICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkgewogICAgICAgICAgaWYgKGNvdW50W21heF0gIT09IDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChyb290MiA+IG1heCkgewogICAgICAgICAgcm9vdDIgPSBtYXg7CiAgICAgICAgfQogICAgICAgIGlmIChtYXggPT09IDApIHsKICAgICAgICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gMSA8PCAyNCB8IDY0IDw8IDE2IHwgMDsKICAgICAgICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gMSA8PCAyNCB8IDY0IDw8IDE2IHwgMDsKICAgICAgICAgIG9wdHMuYml0cyA9IDE7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7CiAgICAgICAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHJvb3QyIDwgbWluKSB7CiAgICAgICAgICByb290MiA9IG1pbjsKICAgICAgICB9CiAgICAgICAgbGVmdCA9IDE7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgICBsZWZ0IC09IGNvdW50W2xlbl07CiAgICAgICAgICBpZiAobGVmdCA8IDApIHsKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgb2Zmc1sxXSA9IDA7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykgewogICAgICAgICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07CiAgICAgICAgfQogICAgICAgIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7CiAgICAgICAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkgewogICAgICAgICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlID09PSBDT0RFUykgewogICAgICAgICAgYmFzZSA9IGV4dHJhID0gd29yazsKICAgICAgICAgIGVuZCA9IDE5OwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykgewogICAgICAgICAgYmFzZSA9IGxiYXNlOwogICAgICAgICAgYmFzZV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBleHRyYSA9IGxleHQ7CiAgICAgICAgICBleHRyYV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBlbmQgPSAyNTY7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJhc2UgPSBkYmFzZTsKICAgICAgICAgIGV4dHJhID0gZGV4dDsKICAgICAgICAgIGVuZCA9IC0xOwogICAgICAgIH0KICAgICAgICBodWZmID0gMDsKICAgICAgICBzeW0gPSAwOwogICAgICAgIGxlbiA9IG1pbjsKICAgICAgICBuZXh0ID0gdGFibGVfaW5kZXg7CiAgICAgICAgY3VyciA9IHJvb3QyOwogICAgICAgIGRyb3AgPSAwOwogICAgICAgIGxvdyA9IC0xOwogICAgICAgIHVzZWQgPSAxIDw8IHJvb3QyOwogICAgICAgIG1hc2sgPSB1c2VkIC0gMTsKICAgICAgICBpZiAodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMgfHwgdHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykgewogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgfQogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDsKICAgICAgICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHsKICAgICAgICAgICAgaGVyZV9vcCA9IDA7CiAgICAgICAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dOwogICAgICAgICAgfSBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHsKICAgICAgICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7CiAgICAgICAgICAgIGhlcmVfdmFsID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIGluY3IgPSAxIDw8IGxlbiAtIGRyb3A7CiAgICAgICAgICBmaWxsID0gMSA8PCBjdXJyOwogICAgICAgICAgbWluID0gZmlsbDsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgZmlsbCAtPSBpbmNyOwogICAgICAgICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IGhlcmVfYml0cyA8PCAyNCB8IGhlcmVfb3AgPDwgMTYgfCBoZXJlX3ZhbCB8IDA7CiAgICAgICAgICB9IHdoaWxlIChmaWxsICE9PSAwKTsKICAgICAgICAgIGluY3IgPSAxIDw8IGxlbiAtIDE7CiAgICAgICAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHsKICAgICAgICAgICAgaW5jciA+Pj0gMTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChpbmNyICE9PSAwKSB7CiAgICAgICAgICAgIGh1ZmYgJj0gaW5jciAtIDE7CiAgICAgICAgICAgIGh1ZmYgKz0gaW5jcjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGh1ZmYgPSAwOwogICAgICAgICAgfQogICAgICAgICAgc3ltKys7CiAgICAgICAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7CiAgICAgICAgICAgIGlmIChsZW4gPT09IG1heCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAobGVuID4gcm9vdDIgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7CiAgICAgICAgICAgIGlmIChkcm9wID09PSAwKSB7CiAgICAgICAgICAgICAgZHJvcCA9IHJvb3QyOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG5leHQgKz0gbWluOwogICAgICAgICAgICBjdXJyID0gbGVuIC0gZHJvcDsKICAgICAgICAgICAgbGVmdCA9IDEgPDwgY3VycjsKICAgICAgICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7CiAgICAgICAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07CiAgICAgICAgICAgICAgaWYgKGxlZnQgPD0gMCkgewogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGN1cnIrKzsKICAgICAgICAgICAgICBsZWZ0IDw8PSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHVzZWQgKz0gMSA8PCBjdXJyOwogICAgICAgICAgICBpZiAodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMgfHwgdHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykgewogICAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrOwogICAgICAgICAgICB0YWJsZVtsb3ddID0gcm9vdDIgPDwgMjQgfCBjdXJyIDw8IDE2IHwgbmV4dCAtIHRhYmxlX2luZGV4IHwgMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGh1ZmYgIT09IDApIHsKICAgICAgICAgIHRhYmxlW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3AgPDwgMjQgfCA2NCA8PCAxNiB8IDA7CiAgICAgICAgfQogICAgICAgIG9wdHMuYml0cyA9IHJvb3QyOwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcwogIHZhciByZXF1aXJlX2luZmxhdGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBhZGxlcjMyID0gcmVxdWlyZV9hZGxlcjMyKCk7CiAgICAgIHZhciBjcmMzMiA9IHJlcXVpcmVfY3JjMzIoKTsKICAgICAgdmFyIGluZmxhdGVfZmFzdCA9IHJlcXVpcmVfaW5mZmFzdCgpOwogICAgICB2YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmVfaW5mdHJlZXMoKTsKICAgICAgdmFyIENPREVTID0gMDsKICAgICAgdmFyIExFTlMgPSAxOwogICAgICB2YXIgRElTVFMgPSAyOwogICAgICB2YXIgWl9GSU5JU0ggPSA0OwogICAgICB2YXIgWl9CTE9DSyA9IDU7CiAgICAgIHZhciBaX1RSRUVTID0gNjsKICAgICAgdmFyIFpfT0sgPSAwOwogICAgICB2YXIgWl9TVFJFQU1fRU5EID0gMTsKICAgICAgdmFyIFpfTkVFRF9ESUNUID0gMjsKICAgICAgdmFyIFpfU1RSRUFNX0VSUk9SID0gLTI7CiAgICAgIHZhciBaX0RBVEFfRVJST1IgPSAtMzsKICAgICAgdmFyIFpfTUVNX0VSUk9SID0gLTQ7CiAgICAgIHZhciBaX0JVRl9FUlJPUiA9IC01OwogICAgICB2YXIgWl9ERUZMQVRFRCA9IDg7CiAgICAgIHZhciBIRUFEID0gMTsKICAgICAgdmFyIEZMQUdTID0gMjsKICAgICAgdmFyIFRJTUUgPSAzOwogICAgICB2YXIgT1MgPSA0OwogICAgICB2YXIgRVhMRU4gPSA1OwogICAgICB2YXIgRVhUUkEgPSA2OwogICAgICB2YXIgTkFNRSA9IDc7CiAgICAgIHZhciBDT01NRU5UID0gODsKICAgICAgdmFyIEhDUkMgPSA5OwogICAgICB2YXIgRElDVElEID0gMTA7CiAgICAgIHZhciBESUNUID0gMTE7CiAgICAgIHZhciBUWVBFID0gMTI7CiAgICAgIHZhciBUWVBFRE8gPSAxMzsKICAgICAgdmFyIFNUT1JFRCA9IDE0OwogICAgICB2YXIgQ09QWV8gPSAxNTsKICAgICAgdmFyIENPUFkgPSAxNjsKICAgICAgdmFyIFRBQkxFID0gMTc7CiAgICAgIHZhciBMRU5MRU5TID0gMTg7CiAgICAgIHZhciBDT0RFTEVOUyA9IDE5OwogICAgICB2YXIgTEVOXyA9IDIwOwogICAgICB2YXIgTEVOID0gMjE7CiAgICAgIHZhciBMRU5FWFQgPSAyMjsKICAgICAgdmFyIERJU1QgPSAyMzsKICAgICAgdmFyIERJU1RFWFQgPSAyNDsKICAgICAgdmFyIE1BVENIID0gMjU7CiAgICAgIHZhciBMSVQgPSAyNjsKICAgICAgdmFyIENIRUNLID0gMjc7CiAgICAgIHZhciBMRU5HVEggPSAyODsKICAgICAgdmFyIERPTkUgPSAyOTsKICAgICAgdmFyIEJBRCA9IDMwOwogICAgICB2YXIgTUVNID0gMzE7CiAgICAgIHZhciBTWU5DID0gMzI7CiAgICAgIHZhciBFTk9VR0hfTEVOUyA9IDg1MjsKICAgICAgdmFyIEVOT1VHSF9ESVNUUyA9IDU5MjsKICAgICAgdmFyIE1BWF9XQklUUyA9IDE1OwogICAgICB2YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTOwogICAgICBmdW5jdGlvbiB6c3dhcDMyKHEpIHsKICAgICAgICByZXR1cm4gKHEgPj4+IDI0ICYgMjU1KSArIChxID4+PiA4ICYgNjUyODApICsgKChxICYgNjUyODApIDw8IDgpICsgKChxICYgMjU1KSA8PCAyNCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkgewogICAgICAgIHRoaXMubW9kZSA9IDA7CiAgICAgICAgdGhpcy5sYXN0ID0gZmFsc2U7CiAgICAgICAgdGhpcy53cmFwID0gMDsKICAgICAgICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7CiAgICAgICAgdGhpcy5mbGFncyA9IDA7CiAgICAgICAgdGhpcy5kbWF4ID0gMDsKICAgICAgICB0aGlzLmNoZWNrID0gMDsKICAgICAgICB0aGlzLnRvdGFsID0gMDsKICAgICAgICB0aGlzLmhlYWQgPSBudWxsOwogICAgICAgIHRoaXMud2JpdHMgPSAwOwogICAgICAgIHRoaXMud3NpemUgPSAwOwogICAgICAgIHRoaXMud2hhdmUgPSAwOwogICAgICAgIHRoaXMud25leHQgPSAwOwogICAgICAgIHRoaXMud2luZG93ID0gbnVsbDsKICAgICAgICB0aGlzLmhvbGQgPSAwOwogICAgICAgIHRoaXMuYml0cyA9IDA7CiAgICAgICAgdGhpcy5sZW5ndGggPSAwOwogICAgICAgIHRoaXMub2Zmc2V0ID0gMDsKICAgICAgICB0aGlzLmV4dHJhID0gMDsKICAgICAgICB0aGlzLmxlbmNvZGUgPSBudWxsOwogICAgICAgIHRoaXMuZGlzdGNvZGUgPSBudWxsOwogICAgICAgIHRoaXMubGVuYml0cyA9IDA7CiAgICAgICAgdGhpcy5kaXN0Yml0cyA9IDA7CiAgICAgICAgdGhpcy5uY29kZSA9IDA7CiAgICAgICAgdGhpcy5ubGVuID0gMDsKICAgICAgICB0aGlzLm5kaXN0ID0gMDsKICAgICAgICB0aGlzLmhhdmUgPSAwOwogICAgICAgIHRoaXMubmV4dCA9IG51bGw7CiAgICAgICAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7CiAgICAgICAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7CiAgICAgICAgdGhpcy5sZW5keW4gPSBudWxsOwogICAgICAgIHRoaXMuZGlzdGR5biA9IG51bGw7CiAgICAgICAgdGhpcy5zYW5lID0gMDsKICAgICAgICB0aGlzLmJhY2sgPSAwOwogICAgICAgIHRoaXMud2FzID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7CiAgICAgICAgc3RybS5tc2cgPSAiIjsKICAgICAgICBpZiAoc3RhdGUud3JhcCkgewogICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5tb2RlID0gSEVBRDsKICAgICAgICBzdGF0ZS5sYXN0ID0gMDsKICAgICAgICBzdGF0ZS5oYXZlZGljdCA9IDA7CiAgICAgICAgc3RhdGUuZG1heCA9IDMyNzY4OwogICAgICAgIHN0YXRlLmhlYWQgPSBudWxsOwogICAgICAgIHN0YXRlLmhvbGQgPSAwOwogICAgICAgIHN0YXRlLmJpdHMgPSAwOwogICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpOwogICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpOwogICAgICAgIHN0YXRlLnNhbmUgPSAxOwogICAgICAgIHN0YXRlLmJhY2sgPSAtMTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIHN0YXRlLndzaXplID0gMDsKICAgICAgICBzdGF0ZS53aGF2ZSA9IDA7CiAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykgewogICAgICAgIHZhciB3cmFwOwogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmICh3aW5kb3dCaXRzIDwgMCkgewogICAgICAgICAgd3JhcCA9IDA7CiAgICAgICAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7CiAgICAgICAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7CiAgICAgICAgICAgIHdpbmRvd0JpdHMgJj0gMTU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG51bGw7CiAgICAgICAgfQogICAgICAgIHN0YXRlLndyYXAgPSB3cmFwOwogICAgICAgIHN0YXRlLndiaXRzID0gd2luZG93Qml0czsKICAgICAgICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7CiAgICAgICAgdmFyIHJldDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpOwogICAgICAgIHN0cm0uc3RhdGUgPSBzdGF0ZTsKICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7CiAgICAgICAgaWYgKHJldCAhPT0gWl9PSykgewogICAgICAgICAgc3RybS5zdGF0ZSA9IG51bGw7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkgewogICAgICAgIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTsKICAgICAgfQogICAgICB2YXIgdmlyZ2luID0gdHJ1ZTsKICAgICAgdmFyIGxlbmZpeDsKICAgICAgdmFyIGRpc3RmaXg7CiAgICAgIGZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7CiAgICAgICAgaWYgKHZpcmdpbikgewogICAgICAgICAgdmFyIHN5bTsKICAgICAgICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpOwogICAgICAgICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7CiAgICAgICAgICBzeW0gPSAwOwogICAgICAgICAgd2hpbGUgKHN5bSA8IDE0NCkgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMjU2KSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gOTsKICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzeW0gPCAyODApIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA3OwogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKHN5bSA8IDI4OCkgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7CiAgICAgICAgICB9CiAgICAgICAgICBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7CiAgICAgICAgICBzeW0gPSAwOwogICAgICAgICAgd2hpbGUgKHN5bSA8IDMyKSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gNTsKICAgICAgICAgIH0KICAgICAgICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7CiAgICAgICAgICB2aXJnaW4gPSBmYWxzZTsKICAgICAgICB9CiAgICAgICAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDsKICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTsKICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7CiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA1OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkgewogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkgewogICAgICAgICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzOwogICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgc3RhdGUud2hhdmUgPSAwOwogICAgICAgICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpOwogICAgICAgIH0KICAgICAgICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkgewogICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7CiAgICAgICAgICBzdGF0ZS53bmV4dCA9IDA7CiAgICAgICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDsKICAgICAgICAgIGlmIChkaXN0ID4gY29weSkgewogICAgICAgICAgICBkaXN0ID0gY29weTsKICAgICAgICAgIH0KICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7CiAgICAgICAgICBjb3B5IC09IGRpc3Q7CiAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7CiAgICAgICAgICAgIHN0YXRlLnduZXh0ID0gY29weTsKICAgICAgICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7CiAgICAgICAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsKICAgICAgICAgICAgICBzdGF0ZS53bmV4dCA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsKICAgICAgICAgICAgICBzdGF0ZS53aGF2ZSArPSBkaXN0OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgdmFyIGlucHV0LCBvdXRwdXQ7CiAgICAgICAgdmFyIG5leHQ7CiAgICAgICAgdmFyIHB1dDsKICAgICAgICB2YXIgaGF2ZSwgbGVmdDsKICAgICAgICB2YXIgaG9sZDsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgX2luLCBfb3V0OwogICAgICAgIHZhciBjb3B5OwogICAgICAgIHZhciBmcm9tOwogICAgICAgIHZhciBmcm9tX3NvdXJjZTsKICAgICAgICB2YXIgaGVyZSA9IDA7CiAgICAgICAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7CiAgICAgICAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7CiAgICAgICAgdmFyIGxlbjsKICAgICAgICB2YXIgcmV0OwogICAgICAgIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7CiAgICAgICAgdmFyIG9wdHM7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIG9yZGVyID0gWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHwgIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87CiAgICAgICAgfQogICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7CiAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luOwogICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzOwogICAgICAgIF9pbiA9IGhhdmU7CiAgICAgICAgX291dCA9IGxlZnQ7CiAgICAgICAgcmV0ID0gWl9PSzsKICAgICAgICBpbmZfbGVhdmU6CiAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7CiAgICAgICAgICAgICAgY2FzZSBIRUFEOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwICYgMiAmJiBob2xkID09PSAzNTYxNSkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IDA7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmZsYWdzID0gMDsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICgoKGhvbGQgJiAyNTUpIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGhlYWRlciBjaGVjayI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChob2xkICYgMTUpICE9PSBaX0RFRkxBVEVEKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNDsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNDsKICAgICAgICAgICAgICAgIGxlbiA9IChob2xkICYgMTUpICsgODsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCB3aW5kb3cgc2l6ZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuOwogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgNTEyID8gRElDVElEIDogVFlQRTsKICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIEZMQUdTOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7CiAgICAgICAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMjU1KSAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTczNDQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAidW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSBob2xkID4+IDggJiAxOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7CiAgICAgICAgICAgICAgY2FzZSBUSU1FOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsyXSA9IGhvbGQgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzNdID0gaG9sZCA+Pj4gMjQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBPUzsKICAgICAgICAgICAgICBjYXNlIE9TOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSBob2xkID4+IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47CiAgICAgICAgICAgICAgY2FzZSBFWExFTjoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDEwMjQpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBOwogICAgICAgICAgICAgIGNhc2UgRVhUUkE6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAxMDI0KSB7CiAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBoYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUuaGVhZC5leHRyYSwgaW5wdXQsIG5leHQsIGNvcHksIGxlbik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTsKICAgICAgICAgICAgICBjYXNlIE5BTUU6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAyMDQ4KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNvcHkgPSAwOwogICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmIHN0YXRlLmxlbmd0aCA8IDY1NTM2KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDsKICAgICAgICAgICAgICBjYXNlIENPTU1FTlQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA0MDk2KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNvcHkgPSAwOwogICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmIHN0YXRlLmxlbmd0aCA8IDY1NTM2KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDOwogICAgICAgICAgICAgIGNhc2UgSENSQzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgNjU1MzUpKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaGVhZGVyIGNyYyBtaXNtYXRjaCI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSBzdGF0ZS5mbGFncyA+PiA5ICYgMTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgRElDVElEOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpOwogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESUNUOwogICAgICAgICAgICAgIGNhc2UgRElDVDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlOwogICAgICAgICAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICAgICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDE7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICBjYXNlIFRZUEU6CiAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhc2UgVFlQRURPOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxhc3QgPSBob2xkICYgMTsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAxOwogICAgICAgICAgICAgICAgYml0cyAtPSAxOwogICAgICAgICAgICAgICAgc3dpdGNoIChob2xkICYgMykgewogICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsKICAgICAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYmxvY2sgdHlwZSI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBTVE9SRUQ6CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7CiAgICAgICAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKGhvbGQgJiA2NTUzNSkgIT09IChob2xkID4+PiAxNiBeIDY1NTM1KSkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgNjU1MzU7CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfOwogICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjYXNlIENPUFlfOgogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7CiAgICAgICAgICAgICAgY2FzZSBDT1BZOgogICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBoYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBsZWZ0OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBsZWZ0IC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIHB1dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgVEFCTEU6CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDMxKSArIDI1NzsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA1OwogICAgICAgICAgICAgICAgYml0cyAtPSA1OwogICAgICAgICAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDMxKSArIDE7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNTsKICAgICAgICAgICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAxNSkgKyA0OwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDQ7CiAgICAgICAgICAgICAgICBiaXRzIC09IDQ7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5oYXZlID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TOwogICAgICAgICAgICAgIGNhc2UgTEVOTEVOUzoKICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gaG9sZCAmIDc7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAzOwogICAgICAgICAgICAgICAgICBiaXRzIC09IDM7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3OwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9OwogICAgICAgICAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0czsKICAgICAgICAgICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5oYXZlID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUzsKICAgICAgICAgICAgICBjYXNlIENPREVMRU5TOgogICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHsKICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyOwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiOwogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdOwogICAgICAgICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDMpOwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IDI7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzOwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgNyk7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMzsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gMzsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7CiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgbGVuID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMTI3KTsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA3OwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSA3OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiOwogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5OwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9OwogICAgICAgICAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2OwogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluOwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7CiAgICAgICAgICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0czsKICAgICAgICAgICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZXMgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsKICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY2FzZSBMRU5fOgogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgICAgICBjYXNlIExFTjoKICAgICAgICAgICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0OwogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgICAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7CiAgICAgICAgICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgICAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICAgICAgICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICAgICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgICAgICAgICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gMDsKICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKDEgPDwgc3RhdGUubGVuYml0cykgLSAxXTsKICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMjQwKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wOwogICAgICAgICAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArICgoaG9sZCAmICgxIDw8IGxhc3RfYml0cyArIGxhc3Rfb3ApIC0gMSkgPj4gbGFzdF9iaXRzKV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChsYXN0X2JpdHMgKyBoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0czsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikgewogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYgNjQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7CiAgICAgICAgICAgICAgY2FzZSBMRU5FWFQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgbiA9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKDEgPDwgc3RhdGUuZXh0cmEpIC0gMTsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7CiAgICAgICAgICAgICAgY2FzZSBESVNUOgogICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKGhlcmVfb3AgJiAyNDApID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7CiAgICAgICAgICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArICgoaG9sZCAmICgxIDw8IGxhc3RfYml0cyArIGxhc3Rfb3ApIC0gMSkgPj4gbGFzdF9iaXRzKV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChsYXN0X2JpdHMgKyBoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0czsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUOwogICAgICAgICAgICAgIGNhc2UgRElTVEVYVDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5leHRyYSkgewogICAgICAgICAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoMSA8PCBzdGF0ZS5leHRyYSkgLSAxOwogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIOwogICAgICAgICAgICAgIGNhc2UgTUFUQ0g6CiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0OwogICAgICAgICAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDsKICAgICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gbGVmdDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGxlZnQgLT0gY29weTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU47CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIExJVDoKICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICBsZWZ0LS07CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBDSEVDSzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIF9vdXQgLT0gbGVmdDsKICAgICAgICAgICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDsKICAgICAgICAgICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDsKICAgICAgICAgICAgICAgICAgaWYgKF9vdXQpIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSBzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBfb3V0ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbmNvcnJlY3QgZGF0YSBjaGVjayI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIOwogICAgICAgICAgICAgIGNhc2UgTEVOR1RIOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDQyOTQ5NjcyOTUpKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGxlbmd0aCBjaGVjayI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTsKICAgICAgICAgICAgICBjYXNlIERPTkU6CiAgICAgICAgICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7CiAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgY2FzZSBCQUQ6CiAgICAgICAgICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7CiAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgY2FzZSBNRU06CiAgICAgICAgICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAgICAgICAgICAgY2FzZSBTWU5DOgogICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0OwogICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlOwogICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgIGlmIChzdGF0ZS53c2l6ZSB8fCBfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkgewogICAgICAgICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkgewogICAgICAgICAgICBzdGF0ZS5tb2RlID0gTUVNOwogICAgICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIF9pbiAtPSBzdHJtLmF2YWlsX2luOwogICAgICAgIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgc3RybS50b3RhbF9pbiArPSBfaW47CiAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDsKICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0OwogICAgICAgIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCk7CiAgICAgICAgfQogICAgICAgIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgKyAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApOwogICAgICAgIGlmICgoX2luID09PSAwICYmIF9vdXQgPT09IDAgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHsKICAgICAgICAgIHJldCA9IFpfQlVGX0VSUk9SOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkgewogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS53aW5kb3cpIHsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG51bGw7CiAgICAgICAgfQogICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmhlYWQgPSBoZWFkOwogICAgICAgIGhlYWQuZG9uZSA9IGZhbHNlOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHsKICAgICAgICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoOwogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICB2YXIgZGljdGlkOwogICAgICAgIHZhciByZXQ7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7CiAgICAgICAgICBkaWN0aWQgPSAxOwogICAgICAgICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApOwogICAgICAgICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHsKICAgICAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpOwogICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBNRU07CiAgICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmhhdmVkaWN0ID0gMTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBleHBvcnRzMi5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyOwogICAgICBleHBvcnRzMi5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyOwogICAgICBleHBvcnRzMi5pbmZsYXRlID0gaW5mbGF0ZTsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyOwogICAgICBleHBvcnRzMi5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5OwogICAgICBleHBvcnRzMi5pbmZsYXRlSW5mbyA9ICJwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpIjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcwogIHZhciByZXF1aXJlX2NvbnN0YW50cyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSB7CiAgICAgICAgWl9OT19GTFVTSDogMCwKICAgICAgICBaX1BBUlRJQUxfRkxVU0g6IDEsCiAgICAgICAgWl9TWU5DX0ZMVVNIOiAyLAogICAgICAgIFpfRlVMTF9GTFVTSDogMywKICAgICAgICBaX0ZJTklTSDogNCwKICAgICAgICBaX0JMT0NLOiA1LAogICAgICAgIFpfVFJFRVM6IDYsCiAgICAgICAgWl9PSzogMCwKICAgICAgICBaX1NUUkVBTV9FTkQ6IDEsCiAgICAgICAgWl9ORUVEX0RJQ1Q6IDIsCiAgICAgICAgWl9FUlJOTzogLTEsCiAgICAgICAgWl9TVFJFQU1fRVJST1I6IC0yLAogICAgICAgIFpfREFUQV9FUlJPUjogLTMsCiAgICAgICAgWl9CVUZfRVJST1I6IC01LAogICAgICAgIFpfTk9fQ09NUFJFU1NJT046IDAsCiAgICAgICAgWl9CRVNUX1NQRUVEOiAxLAogICAgICAgIFpfQkVTVF9DT01QUkVTU0lPTjogOSwKICAgICAgICBaX0RFRkFVTFRfQ09NUFJFU1NJT046IC0xLAogICAgICAgIFpfRklMVEVSRUQ6IDEsCiAgICAgICAgWl9IVUZGTUFOX09OTFk6IDIsCiAgICAgICAgWl9STEU6IDMsCiAgICAgICAgWl9GSVhFRDogNCwKICAgICAgICBaX0RFRkFVTFRfU1RSQVRFR1k6IDAsCiAgICAgICAgWl9CSU5BUlk6IDAsCiAgICAgICAgWl9URVhUOiAxLAogICAgICAgIFpfVU5LTk9XTjogMiwKICAgICAgICBaX0RFRkxBVEVEOiA4CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcwogIHZhciByZXF1aXJlX2d6aGVhZGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gR1poZWFkZXIoKSB7CiAgICAgICAgdGhpcy50ZXh0ID0gMDsKICAgICAgICB0aGlzLnRpbWUgPSAwOwogICAgICAgIHRoaXMueGZsYWdzID0gMDsKICAgICAgICB0aGlzLm9zID0gMDsKICAgICAgICB0aGlzLmV4dHJhID0gbnVsbDsKICAgICAgICB0aGlzLmV4dHJhX2xlbiA9IDA7CiAgICAgICAgdGhpcy5uYW1lID0gIiI7CiAgICAgICAgdGhpcy5jb21tZW50ID0gIiI7CiAgICAgICAgdGhpcy5oY3JjID0gMDsKICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBHWmhlYWRlcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfaW5mbGF0ZTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZV9pbmZsYXRlKCk7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBzdHJpbmdzID0gcmVxdWlyZV9zdHJpbmdzKCk7CiAgICAgIHZhciBjID0gcmVxdWlyZV9jb25zdGFudHMoKTsKICAgICAgdmFyIG1zZyA9IHJlcXVpcmVfbWVzc2FnZXMoKTsKICAgICAgdmFyIFpTdHJlYW0gPSByZXF1aXJlX3pzdHJlYW0oKTsKICAgICAgdmFyIEdaaGVhZGVyID0gcmVxdWlyZV9nemhlYWRlcigpOwogICAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICBmdW5jdGlvbiBJbmZsYXRlMihvcHRpb25zKSB7CiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUyKSkKICAgICAgICAgIHJldHVybiBuZXcgSW5mbGF0ZTIob3B0aW9ucyk7CiAgICAgICAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHsKICAgICAgICAgIGNodW5rU2l6ZTogMTYzODQsCiAgICAgICAgICB3aW5kb3dCaXRzOiAwLAogICAgICAgICAgdG86ICIiCiAgICAgICAgfSwgb3B0aW9ucyB8fCB7fSk7CiAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0aW9uczsKICAgICAgICBpZiAob3B0LnJhdyAmJiBvcHQud2luZG93Qml0cyA+PSAwICYmIG9wdC53aW5kb3dCaXRzIDwgMTYpIHsKICAgICAgICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzOwogICAgICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7CiAgICAgICAgICAgIG9wdC53aW5kb3dCaXRzID0gLTE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAob3B0LndpbmRvd0JpdHMgPj0gMCAmJiBvcHQud2luZG93Qml0cyA8IDE2ICYmICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyArPSAzMjsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID4gMTUgJiYgb3B0LndpbmRvd0JpdHMgPCA0OCkgewogICAgICAgICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkgewogICAgICAgICAgICBvcHQud2luZG93Qml0cyB8PSAxNTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5lcnIgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTsKICAgICAgICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICB2YXIgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0Mih0aGlzLnN0cm0sIG9wdC53aW5kb3dCaXRzKTsKICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7CiAgICAgICAgfQogICAgICAgIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7CiAgICAgICAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7CiAgICAgICAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKG9wdC5yYXcpIHsKICAgICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIEluZmxhdGUyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7CiAgICAgICAgdmFyIHN0YXR1cywgX21vZGU7CiAgICAgICAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7CiAgICAgICAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTsKICAgICAgICBpZiAodGhpcy5lbmRlZCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBfbW9kZSA9IG1vZGUgPT09IH5+bW9kZSA/IG1vZGUgOiBtb2RlID09PSB0cnVlID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSDsKICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpOwogICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gIltvYmplY3QgQXJyYXlCdWZmZXJdIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gZGF0YTsKICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X2luID0gMDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7CiAgICAgICAgZG8gewogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTsKICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IDA7CiAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplOwogICAgICAgICAgfQogICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsKICAgICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkgewogICAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0aW9uYXJ5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkgewogICAgICAgICAgICBzdGF0dXMgPSBjLlpfT0s7CiAgICAgICAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7CiAgICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLm5leHRfb3V0KSB7CiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpIHsKICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7CiAgICAgICAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7CiAgICAgICAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTsKICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsOwogICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsOwogICAgICAgICAgICAgICAgaWYgKHRhaWwpIHsKICAgICAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7CiAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHsKICAgICAgICAgIF9tb2RlID0gYy5aX0ZJTklTSDsKICAgICAgICB9CiAgICAgICAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pOwogICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHsKICAgICAgICAgIHRoaXMub25FbmQoYy5aX09LKTsKICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfTsKICAgICAgSW5mbGF0ZTIucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGNodW5rKSB7CiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7CiAgICAgIH07CiAgICAgIEluZmxhdGUyLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHN0YXR1cykgewogICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9PSykgewogICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCIiKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5lcnIgPSBzdGF0dXM7CiAgICAgICAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnOwogICAgICB9OwogICAgICBmdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUyKG9wdGlvbnMpOwogICAgICAgIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpOwogICAgICAgIGlmIChpbmZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IGluZmxhdG9yLm1zZyB8fCBtc2dbaW5mbGF0b3IuZXJyXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5yYXcgPSB0cnVlOwogICAgICAgIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTsKICAgICAgfQogICAgICBleHBvcnRzMi5JbmZsYXRlID0gSW5mbGF0ZTI7CiAgICAgIGV4cG9ydHMyLmluZmxhdGUgPSBpbmZsYXRlOwogICAgICBleHBvcnRzMi5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdzsKICAgICAgZXhwb3J0czIudW5nemlwID0gaW5mbGF0ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfcGFrbyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBhc3NpZ24gPSByZXF1aXJlX2NvbW1vbigpLmFzc2lnbjsKICAgICAgdmFyIGRlZmxhdGUgPSByZXF1aXJlX2RlZmxhdGUyKCk7CiAgICAgIHZhciBpbmZsYXRlID0gcmVxdWlyZV9pbmZsYXRlMigpOwogICAgICB2YXIgY29uc3RhbnRzID0gcmVxdWlyZV9jb25zdGFudHMoKTsKICAgICAgdmFyIHBha28gPSB7fTsKICAgICAgYXNzaWduKHBha28sIGRlZmxhdGUsIGluZmxhdGUsIGNvbnN0YW50cyk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHBha287CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb25nQDQuMC4wL25vZGVfbW9kdWxlcy9sb25nL3NyYy9sb25nLmpzCiAgdmFyIHJlcXVpcmVfbG9uZyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9sb25nQDQuMC4wL25vZGVfbW9kdWxlcy9sb25nL3NyYy9sb25nLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IExvbmc0OwogICAgICB2YXIgd2FzbSA9IG51bGw7CiAgICAgIHRyeSB7CiAgICAgICAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFsKICAgICAgICAgIDAsCiAgICAgICAgICA5NywKICAgICAgICAgIDExNSwKICAgICAgICAgIDEwOSwKICAgICAgICAgIDEsCiAgICAgICAgICAwLAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAxLAogICAgICAgICAgMTMsCiAgICAgICAgICAyLAogICAgICAgICAgOTYsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNywKICAgICAgICAgIDk2LAogICAgICAgICAgNCwKICAgICAgICAgIDEyNywKICAgICAgICAgIDEyNywKICAgICAgICAgIDEyNywKICAgICAgICAgIDEyNywKICAgICAgICAgIDEsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAzLAogICAgICAgICAgNywKICAgICAgICAgIDYsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICA2LAogICAgICAgICAgNiwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxLAogICAgICAgICAgNjUsCiAgICAgICAgICAwLAogICAgICAgICAgMTEsCiAgICAgICAgICA3LAogICAgICAgICAgNTAsCiAgICAgICAgICA2LAogICAgICAgICAgMywKICAgICAgICAgIDEwOSwKICAgICAgICAgIDExNywKICAgICAgICAgIDEwOCwKICAgICAgICAgIDAsCiAgICAgICAgICAxLAogICAgICAgICAgNSwKICAgICAgICAgIDEwMCwKICAgICAgICAgIDEwNSwKICAgICAgICAgIDExOCwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE1LAogICAgICAgICAgMCwKICAgICAgICAgIDIsCiAgICAgICAgICA1LAogICAgICAgICAgMTAwLAogICAgICAgICAgMTA1LAogICAgICAgICAgMTE4LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMTcsCiAgICAgICAgICAwLAogICAgICAgICAgMywKICAgICAgICAgIDUsCiAgICAgICAgICAxMTQsCiAgICAgICAgICAxMDEsCiAgICAgICAgICAxMDksCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNSwKICAgICAgICAgIDAsCiAgICAgICAgICA0LAogICAgICAgICAgNSwKICAgICAgICAgIDExNCwKICAgICAgICAgIDEwMSwKICAgICAgICAgIDEwOSwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE3LAogICAgICAgICAgMCwKICAgICAgICAgIDUsCiAgICAgICAgICA4LAogICAgICAgICAgMTAzLAogICAgICAgICAgMTAxLAogICAgICAgICAgMTE2LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMDQsCiAgICAgICAgICAxMDUsCiAgICAgICAgICAxMDMsCiAgICAgICAgICAxMDQsCiAgICAgICAgICAwLAogICAgICAgICAgMCwKICAgICAgICAgIDEwLAogICAgICAgICAgMTkxLAogICAgICAgICAgMSwKICAgICAgICAgIDYsCiAgICAgICAgICA0LAogICAgICAgICAgMCwKICAgICAgICAgIDM1LAogICAgICAgICAgMCwKICAgICAgICAgIDExLAogICAgICAgICAgMzYsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDMyLAogICAgICAgICAgMCwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMSwKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAzMiwKICAgICAgICAgIDIsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDMsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMTI2LAogICAgICAgICAgMzQsCiAgICAgICAgICA0LAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNSwKICAgICAgICAgIDE2NywKICAgICAgICAgIDM2LAogICAgICAgICAgMCwKICAgICAgICAgIDMyLAogICAgICAgICAgNCwKICAgICAgICAgIDE2NywKICAgICAgICAgIDExLAogICAgICAgICAgMzYsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDMyLAogICAgICAgICAgMCwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMSwKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAzMiwKICAgICAgICAgIDIsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDMsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMTI3LAogICAgICAgICAgMzQsCiAgICAgICAgICA0LAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNSwKICAgICAgICAgIDE2NywKICAgICAgICAgIDM2LAogICAgICAgICAgMCwKICAgICAgICAgIDMyLAogICAgICAgICAgNCwKICAgICAgICAgIDE2NywKICAgICAgICAgIDExLAogICAgICAgICAgMzYsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDMyLAogICAgICAgICAgMCwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMSwKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAzMiwKICAgICAgICAgIDIsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDMsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMTI4LAogICAgICAgICAgMzQsCiAgICAgICAgICA0LAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNSwKICAgICAgICAgIDE2NywKICAgICAgICAgIDM2LAogICAgICAgICAgMCwKICAgICAgICAgIDMyLAogICAgICAgICAgNCwKICAgICAgICAgIDE2NywKICAgICAgICAgIDExLAogICAgICAgICAgMzYsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDMyLAogICAgICAgICAgMCwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMSwKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAzMiwKICAgICAgICAgIDIsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDMsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMTI5LAogICAgICAgICAgMzQsCiAgICAgICAgICA0LAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNSwKICAgICAgICAgIDE2NywKICAgICAgICAgIDM2LAogICAgICAgICAgMCwKICAgICAgICAgIDMyLAogICAgICAgICAgNCwKICAgICAgICAgIDE2NywKICAgICAgICAgIDExLAogICAgICAgICAgMzYsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDMyLAogICAgICAgICAgMCwKICAgICAgICAgIDE3MywKICAgICAgICAgIDMyLAogICAgICAgICAgMSwKICAgICAgICAgIDE3MywKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzQsCiAgICAgICAgICAxMzIsCiAgICAgICAgICAzMiwKICAgICAgICAgIDIsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDMsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMTMwLAogICAgICAgICAgMzQsCiAgICAgICAgICA0LAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNSwKICAgICAgICAgIDE2NywKICAgICAgICAgIDM2LAogICAgICAgICAgMCwKICAgICAgICAgIDMyLAogICAgICAgICAgNCwKICAgICAgICAgIDE2NywKICAgICAgICAgIDExCiAgICAgICAgXSkpLCB7fSkuZXhwb3J0czsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICB9CiAgICAgIGZ1bmN0aW9uIExvbmc0KGxvdywgaGlnaCwgdW5zaWduZWQpIHsKICAgICAgICB0aGlzLmxvdyA9IGxvdyB8IDA7CiAgICAgICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7CiAgICAgICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgICAgIH0KICAgICAgTG9uZzQucHJvdG90eXBlLl9faXNMb25nX187CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nNC5wcm90b3R5cGUsICJfX2lzTG9uZ19fIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZnVuY3Rpb24gaXNMb25nKG9iaikgewogICAgICAgIHJldHVybiAob2JqICYmIG9ialsiX19pc0xvbmdfXyJdKSA9PT0gdHJ1ZTsKICAgICAgfQogICAgICBMb25nNC5pc0xvbmcgPSBpc0xvbmc7CiAgICAgIHZhciBJTlRfQ0FDSEUgPSB7fTsKICAgICAgdmFyIFVJTlRfQ0FDSEUgPSB7fTsKICAgICAgZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHsKICAgICAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlOwogICAgICAgIGlmICh1bnNpZ25lZCkgewogICAgICAgICAgdmFsdWUgPj4+PSAwOwogICAgICAgICAgaWYgKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikgewogICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTsKICAgICAgICAgICAgaWYgKGNhY2hlZE9iaikKICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqOwogICAgICAgICAgfQogICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7CiAgICAgICAgICBpZiAoY2FjaGUpCiAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFsdWUgfD0gMDsKICAgICAgICAgIGlmIChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHsKICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTsKICAgICAgICAgICAgaWYgKGNhY2hlZE9iaikKICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqOwogICAgICAgICAgfQogICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpOwogICAgICAgICAgaWYgKGNhY2hlKQogICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbUludCA9IGZyb21JbnQ7CiAgICAgIGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7CiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkKICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTzsKICAgICAgICBpZiAodW5zaWduZWQpIHsKICAgICAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgICAgIHJldHVybiBVWkVSTzsKICAgICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTCkKICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTCkKICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsKICAgICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpCiAgICAgICAgICAgIHJldHVybiBNQVhfVkFMVUU7CiAgICAgICAgfQogICAgICAgIGlmICh2YWx1ZSA8IDApCiAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHModmFsdWUgJSBUV09fUFdSXzMyX0RCTCB8IDAsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwgfCAwLCB1bnNpZ25lZCk7CiAgICAgIH0KICAgICAgTG9uZzQuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7CiAgICAgIGZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkgewogICAgICAgIHJldHVybiBuZXcgTG9uZzQobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nNC5mcm9tQml0cyA9IGZyb21CaXRzOwogICAgICB2YXIgcG93X2RibCA9IE1hdGgucG93OwogICAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7CiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApCiAgICAgICAgICB0aHJvdyBFcnJvcigiZW1wdHkgc3RyaW5nIik7CiAgICAgICAgaWYgKHN0ciA9PT0gIk5hTiIgfHwgc3RyID09PSAiSW5maW5pdHkiIHx8IHN0ciA9PT0gIitJbmZpbml0eSIgfHwgc3RyID09PSAiLUluZmluaXR5IikKICAgICAgICAgIHJldHVybiBaRVJPOwogICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICByYWRpeCA9IHVuc2lnbmVkLCB1bnNpZ25lZCA9IGZhbHNlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgICAgICAgfQogICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7CiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KQogICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgICAgICB2YXIgcDsKICAgICAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZigiLSIpKSA+IDApCiAgICAgICAgICB0aHJvdyBFcnJvcigiaW50ZXJpb3IgaHlwaGVuIik7CiAgICAgICAgZWxzZSBpZiAocCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTsKICAgICAgICB9CiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpOwogICAgICAgIHZhciByZXN1bHQgPSBaRVJPOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7CiAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSwgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpOwogICAgICAgICAgaWYgKHNpemUgPCA4KSB7CiAgICAgICAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpOwogICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpOwogICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQogICAgICBMb25nNC5mcm9tU3RyaW5nID0gZnJvbVN0cmluZzsKICAgICAgZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHsKICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpCiAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTsKICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gInN0cmluZyIpCiAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gImJvb2xlYW4iID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpOwogICAgICB9CiAgICAgIExvbmc0LmZyb21WYWx1ZSA9IGZyb21WYWx1ZTsKICAgICAgdmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjsKICAgICAgdmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDsKICAgICAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDsKICAgICAgdmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDsKICAgICAgdmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyOwogICAgICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpOwogICAgICB2YXIgWkVSTyA9IGZyb21JbnQoMCk7CiAgICAgIExvbmc0LlpFUk8gPSBaRVJPOwogICAgICB2YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpOwogICAgICBMb25nNC5VWkVSTyA9IFVaRVJPOwogICAgICB2YXIgT05FID0gZnJvbUludCgxKTsKICAgICAgTG9uZzQuT05FID0gT05FOwogICAgICB2YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7CiAgICAgIExvbmc0LlVPTkUgPSBVT05FOwogICAgICB2YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpOwogICAgICBMb25nNC5ORUdfT05FID0gTkVHX09ORTsKICAgICAgdmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDQyOTQ5NjcyOTUgfCAwLCAyMTQ3NDgzNjQ3IHwgMCwgZmFsc2UpOwogICAgICBMb25nNC5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7CiAgICAgIHZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cyg0Mjk0OTY3Mjk1IHwgMCwgNDI5NDk2NzI5NSB8IDAsIHRydWUpOwogICAgICBMb25nNC5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7CiAgICAgIHZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAyMTQ3NDgzNjQ4IHwgMCwgZmFsc2UpOwogICAgICBMb25nNC5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7CiAgICAgIHZhciBMb25nUHJvdG90eXBlID0gTG9uZzQucHJvdG90eXBlOwogICAgICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIyKCkgewogICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKQogICAgICAgICAgcmV0dXJuICh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkgewogICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7CiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KQogICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigicmFkaXgiKTsKICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiAiMCI7CiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7CiAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSwgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSwgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7CiAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTsKICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICByZXR1cm4gIi0iICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7CiAgICAgICAgfQogICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSwgcmVtID0gdGhpczsKICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLCBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpOwogICAgICAgICAgcmVtID0gcmVtRGl2OwogICAgICAgICAgaWYgKHJlbS5pc1plcm8oKSkKICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpCiAgICAgICAgICAgICAgZGlnaXRzID0gIjAiICsgZGlnaXRzOwogICAgICAgICAgICByZXN1bHQgPSAiIiArIGRpZ2l0cyArIHJlc3VsdDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkgewogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHsKICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7CiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7CiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7CiAgICAgICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKQogICAgICAgICAgaWYgKCh2YWwgJiAxIDw8IGJpdCkgIT0gMCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvOwogICAgICBMb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkgewogICAgICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkgewogICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7CiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHsKICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzOwogICAgICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikgewogICAgICAgIHJldHVybiAhdGhpcy5lcShvdGhlcik7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUubmUgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFsczsKICAgICAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPCAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjsKICAgICAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHsKICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA8PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID4gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47CiAgICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPj0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpOwogICAgICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZykKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpCiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTsKICAgICAgICByZXR1cm4gb3RoZXIuaGlnaCA+Pj4gMCA+IHRoaXMuaGlnaCA+Pj4gMCB8fCBvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDAgPyAtMSA6IDE7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTsKICAgICAgTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSkKICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7CiAgICAgIExvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkgewogICAgICAgIGlmICghaXNMb25nKGFkZGVuZCkpCiAgICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTsKICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2OwogICAgICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjsKICAgICAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDY1NTM1OwogICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgICAgIGMwMCArPSBhMDAgKyBiMDA7CiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7CiAgICAgICAgYzAwICY9IDY1NTM1OwogICAgICAgIGMxNiArPSBhMTYgKyBiMTY7CiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICAgICAgYzE2ICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMzIgKyBiMzI7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGM0OCArPSBhNDggKyBiNDg7CiAgICAgICAgYzQ4ICY9IDY1NTM1OwogICAgICAgIHJldHVybiBmcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7CiAgICAgICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpCiAgICAgICAgICBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpOwogICAgICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0OwogICAgICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikgewogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIFpFUk87CiAgICAgICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpCiAgICAgICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpOwogICAgICAgIGlmICh3YXNtKSB7CiAgICAgICAgICB2YXIgbG93ID0gd2FzbS5tdWwodGhpcy5sb3csIHRoaXMuaGlnaCwgbXVsdGlwbGllci5sb3csIG11bHRpcGxpZXIuaGlnaCk7CiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiBaRVJPOwogICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpCiAgICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTzsKICAgICAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87CiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpOwogICAgICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7CiAgICAgICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSkKICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7CiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDsKICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjsKICAgICAgICBjMDAgJj0gNjU1MzU7CiAgICAgICAgYzE2ICs9IGExNiAqIGIwMDsKICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjsKICAgICAgICBjMTYgJj0gNjU1MzU7CiAgICAgICAgYzE2ICs9IGEwMCAqIGIxNjsKICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjsKICAgICAgICBjMTYgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGExNiAqIGIxNjsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGEwMCAqIGIzMjsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODsKICAgICAgICBjNDggJj0gNjU1MzU7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5OwogICAgICBMb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7CiAgICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpCiAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpOwogICAgICAgIGlmIChkaXZpc29yLmlzWmVybygpKQogICAgICAgICAgdGhyb3cgRXJyb3IoImRpdmlzaW9uIGJ5IHplcm8iKTsKICAgICAgICBpZiAod2FzbSkgewogICAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA9PT0gLTIxNDc0ODM2NDggJiYgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLmRpdl91IDogd2FzbS5kaXZfcykodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7CiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgICAgIHZhciBhcHByb3gsIHJlbSwgcmVzOwogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkgewogICAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkgewogICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpCiAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsKICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgICAgIHJldHVybiBPTkU7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpOwogICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7CiAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7CiAgICAgICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpOwogICAgICAgICAgICAgICAgcmV0dXJuIHJlczsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKQogICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTzsKICAgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpOwogICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7CiAgICAgICAgICByZXMgPSBaRVJPOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpCiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTsKICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKQogICAgICAgICAgICByZXR1cm4gVVpFUk87CiAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKQogICAgICAgICAgICByZXR1cm4gVU9ORTsKICAgICAgICAgIHJlcyA9IFVaRVJPOwogICAgICAgIH0KICAgICAgICByZW0gPSB0aGlzOwogICAgICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7CiAgICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7CiAgICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLCBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLCBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7CiAgICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkgewogICAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7CiAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpCiAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTsKICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTsKICAgICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTsKICAgICAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikgewogICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKQogICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTsKICAgICAgICBpZiAod2FzbSkgewogICAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5yZW1fdSA6IHdhc20ucmVtX3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87CiAgICAgIExvbmdQcm90b3R5cGUucmVtID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87CiAgICAgIExvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkgewogICAgICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikgewogICAgICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykgewogICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgdGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gMzIgLSBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICBlbHNlCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgbnVtQml0cyAtIDMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSkKICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMikKICAgICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICBlbHNlCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IG51bUJpdHMgLSAzMiwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykgewogICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIG51bUJpdHMgJj0gNjM7CiAgICAgICAgaWYgKG51bUJpdHMgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIHsKICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoOwogICAgICAgICAgaWYgKG51bUJpdHMgPCAzMikgewogICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7CiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhsb3cgPj4+IG51bUJpdHMgfCBoaWdoIDw8IDMyIC0gbnVtQml0cywgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKQogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiBudW1CaXRzIC0gMzIsIDAsIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7CiAgICAgIExvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICAgICAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkgewogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7CiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMobGUpIHsKICAgICAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7CiAgICAgICAgdmFyIGhpID0gdGhpcy5oaWdoLCBsbyA9IHRoaXMubG93OwogICAgICAgIHJldHVybiBbCiAgICAgICAgICBsbyAmIDI1NSwKICAgICAgICAgIGxvID4+PiA4ICYgMjU1LAogICAgICAgICAgbG8gPj4+IDE2ICYgMjU1LAogICAgICAgICAgbG8gPj4+IDI0LAogICAgICAgICAgaGkgJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGhpID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGhpID4+PiAyNAogICAgICAgIF07CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkgewogICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgaGkgPj4+IDI0LAogICAgICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgICAgICBoaSAmIDI1NSwKICAgICAgICAgIGxvID4+PiAyNCwKICAgICAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGxvID4+PiA4ICYgMjU1LAogICAgICAgICAgbG8gJiAyNTUKICAgICAgICBdOwogICAgICB9OwogICAgICBMb25nNC5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMyKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHsKICAgICAgICByZXR1cm4gbGUgPyBMb25nNC5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZzQuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZzQuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmc0KGJ5dGVzWzBdIHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbM10gPDwgMjQsIGJ5dGVzWzRdIHwgYnl0ZXNbNV0gPDwgOCB8IGJ5dGVzWzZdIDw8IDE2IHwgYnl0ZXNbN10gPDwgMjQsIHVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZzQuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmc0KGJ5dGVzWzRdIDw8IDI0IHwgYnl0ZXNbNV0gPDwgMTYgfCBieXRlc1s2XSA8PCA4IHwgYnl0ZXNbN10sIGJ5dGVzWzBdIDw8IDI0IHwgYnl0ZXNbMV0gPDwgMTYgfCBieXRlc1syXSA8PCA4IHwgYnl0ZXNbM10sIHVuc2lnbmVkKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2lzLW9ic2VydmFibGVAMi4xLjAvbm9kZV9tb2R1bGVzL2lzLW9ic2VydmFibGUvaW5kZXguanMKICB2YXIgcmVxdWlyZV9pc19vYnNlcnZhYmxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL2lzLW9ic2VydmFibGVAMi4xLjAvbm9kZV9tb2R1bGVzL2lzLW9ic2VydmFibGUvaW5kZXguanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSAodmFsdWUpID0+IHsKICAgICAgICBpZiAoIXZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgU3ltYm9sLm9ic2VydmFibGUgPT09ICJzeW1ib2wiICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wub2JzZXJ2YWJsZV0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVbU3ltYm9sLm9ic2VydmFibGVdKCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsdWVbIkBAb2JzZXJ2YWJsZSJdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlWyJAQG9ic2VydmFibGUiXSgpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc2VyaWFsaXplcnMuanMKICB2YXIgcmVxdWlyZV9zZXJpYWxpemVycyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc2VyaWFsaXplcnMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuRGVmYXVsdFNlcmlhbGl6ZXIgPSBleHBvcnRzMi5leHRlbmRTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICBmdW5jdGlvbiBleHRlbmRTZXJpYWxpemVyKGV4dGVuZCwgaW1wbGVtZW50YXRpb24pIHsKICAgICAgICBjb25zdCBmYWxsYmFja0Rlc2VyaWFsaXplciA9IGV4dGVuZC5kZXNlcmlhbGl6ZS5iaW5kKGV4dGVuZCk7CiAgICAgICAgY29uc3QgZmFsbGJhY2tTZXJpYWxpemVyID0gZXh0ZW5kLnNlcmlhbGl6ZS5iaW5kKGV4dGVuZCk7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uLmRlc2VyaWFsaXplKG1lc3NhZ2UsIGZhbGxiYWNrRGVzZXJpYWxpemVyKTsKICAgICAgICAgIH0sCiAgICAgICAgICBzZXJpYWxpemUoaW5wdXQpIHsKICAgICAgICAgICAgcmV0dXJuIGltcGxlbWVudGF0aW9uLnNlcmlhbGl6ZShpbnB1dCwgZmFsbGJhY2tTZXJpYWxpemVyKTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICAgIGV4cG9ydHMyLmV4dGVuZFNlcmlhbGl6ZXIgPSBleHRlbmRTZXJpYWxpemVyOwogICAgICB2YXIgRGVmYXVsdEVycm9yU2VyaWFsaXplciA9IHsKICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihFcnJvcihtZXNzYWdlLm1lc3NhZ2UpLCB7CiAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSwKICAgICAgICAgICAgc3RhY2s6IG1lc3NhZ2Uuc3RhY2sKICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICAgc2VyaWFsaXplKGVycm9yKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBfX2Vycm9yX21hcmtlcjogIiQkZXJyb3IiLAogICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLAogICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lLAogICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2sKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgaXNTZXJpYWxpemVkRXJyb3IgPSAodGhpbmcpID0+IHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgIl9fZXJyb3JfbWFya2VyIiBpbiB0aGluZyAmJiB0aGluZy5fX2Vycm9yX21hcmtlciA9PT0gIiQkZXJyb3IiOwogICAgICBleHBvcnRzMi5EZWZhdWx0U2VyaWFsaXplciA9IHsKICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkRXJyb3IobWVzc2FnZSkpIHsKICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIuZGVzZXJpYWxpemUobWVzc2FnZSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gbWVzc2FnZTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHNlcmlhbGl6ZShpbnB1dCkgewogICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRXJyb3IpIHsKICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIuc2VyaWFsaXplKGlucHV0KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBpbnB1dDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvY29tbW9uLmpzCiAgdmFyIHJlcXVpcmVfY29tbW9uMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvY29tbW9uLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLnNlcmlhbGl6ZSA9IGV4cG9ydHMyLmRlc2VyaWFsaXplID0gZXhwb3J0czIucmVnaXN0ZXJTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICB2YXIgc2VyaWFsaXplcnNfMSA9IHJlcXVpcmVfc2VyaWFsaXplcnMoKTsKICAgICAgdmFyIHJlZ2lzdGVyZWRTZXJpYWxpemVyID0gc2VyaWFsaXplcnNfMS5EZWZhdWx0U2VyaWFsaXplcjsKICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJTZXJpYWxpemVyMihzZXJpYWxpemVyKSB7CiAgICAgICAgcmVnaXN0ZXJlZFNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc18xLmV4dGVuZFNlcmlhbGl6ZXIocmVnaXN0ZXJlZFNlcmlhbGl6ZXIsIHNlcmlhbGl6ZXIpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLnJlZ2lzdGVyU2VyaWFsaXplciA9IHJlZ2lzdGVyU2VyaWFsaXplcjI7CiAgICAgIGZ1bmN0aW9uIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUobWVzc2FnZSk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTsKICAgICAgZnVuY3Rpb24gc2VyaWFsaXplKGlucHV0KSB7CiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRTZXJpYWxpemVyLnNlcmlhbGl6ZShpbnB1dCk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuc2VyaWFsaXplID0gc2VyaWFsaXplOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3N5bWJvbHMuanMKICB2YXIgcmVxdWlyZV9zeW1ib2xzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zeW1ib2xzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLiR3b3JrZXIgPSBleHBvcnRzMi4kdHJhbnNmZXJhYmxlID0gZXhwb3J0czIuJHRlcm1pbmF0ZSA9IGV4cG9ydHMyLiRldmVudHMgPSBleHBvcnRzMi4kZXJyb3JzID0gdm9pZCAwOwogICAgICBleHBvcnRzMi4kZXJyb3JzID0gU3ltYm9sKCJ0aHJlYWQuZXJyb3JzIik7CiAgICAgIGV4cG9ydHMyLiRldmVudHMgPSBTeW1ib2woInRocmVhZC5ldmVudHMiKTsKICAgICAgZXhwb3J0czIuJHRlcm1pbmF0ZSA9IFN5bWJvbCgidGhyZWFkLnRlcm1pbmF0ZSIpOwogICAgICBleHBvcnRzMi4kdHJhbnNmZXJhYmxlID0gU3ltYm9sKCJ0aHJlYWQudHJhbnNmZXJhYmxlIik7CiAgICAgIGV4cG9ydHMyLiR3b3JrZXIgPSBTeW1ib2woInRocmVhZC53b3JrZXIiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90cmFuc2ZlcmFibGUuanMKICB2YXIgcmVxdWlyZV90cmFuc2ZlcmFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3RyYW5zZmVyYWJsZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5UcmFuc2ZlciA9IGV4cG9ydHMyLmlzVHJhbnNmZXJEZXNjcmlwdG9yID0gdm9pZCAwOwogICAgICB2YXIgc3ltYm9sc18xID0gcmVxdWlyZV9zeW1ib2xzKCk7CiAgICAgIGZ1bmN0aW9uIGlzVHJhbnNmZXJhYmxlKHRoaW5nKSB7CiAgICAgICAgaWYgKCF0aGluZyB8fCB0eXBlb2YgdGhpbmcgIT09ICJvYmplY3QiKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGlzVHJhbnNmZXJEZXNjcmlwdG9yKHRoaW5nKSB7CiAgICAgICAgcmV0dXJuIHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgdGhpbmdbc3ltYm9sc18xLiR0cmFuc2ZlcmFibGVdOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmlzVHJhbnNmZXJEZXNjcmlwdG9yID0gaXNUcmFuc2ZlckRlc2NyaXB0b3I7CiAgICAgIGZ1bmN0aW9uIFRyYW5zZmVyMihwYXlsb2FkLCB0cmFuc2ZlcmFibGVzKSB7CiAgICAgICAgaWYgKCF0cmFuc2ZlcmFibGVzKSB7CiAgICAgICAgICBpZiAoIWlzVHJhbnNmZXJhYmxlKHBheWxvYWQpKQogICAgICAgICAgICB0aHJvdyBFcnJvcigpOwogICAgICAgICAgdHJhbnNmZXJhYmxlcyA9IFtwYXlsb2FkXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIFtzeW1ib2xzXzEuJHRyYW5zZmVyYWJsZV06IHRydWUsCiAgICAgICAgICBzZW5kOiBwYXlsb2FkLAogICAgICAgICAgdHJhbnNmZXJhYmxlcwogICAgICAgIH07CiAgICAgIH0KICAgICAgZXhwb3J0czIuVHJhbnNmZXIgPSBUcmFuc2ZlcjI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHlwZXMvbWVzc2FnZXMuanMKICB2YXIgcmVxdWlyZV9tZXNzYWdlczIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3R5cGVzL21lc3NhZ2VzLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLldvcmtlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuTWFzdGVyTWVzc2FnZVR5cGUgPSB2b2lkIDA7CiAgICAgIHZhciBNYXN0ZXJNZXNzYWdlVHlwZTsKICAgICAgKGZ1bmN0aW9uKE1hc3Rlck1lc3NhZ2VUeXBlMikgewogICAgICAgIE1hc3Rlck1lc3NhZ2VUeXBlMlsiY2FuY2VsIl0gPSAiY2FuY2VsIjsKICAgICAgICBNYXN0ZXJNZXNzYWdlVHlwZTJbInJ1biJdID0gInJ1biI7CiAgICAgIH0pKE1hc3Rlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuTWFzdGVyTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMyLk1hc3Rlck1lc3NhZ2VUeXBlID0ge30pKTsKICAgICAgdmFyIFdvcmtlck1lc3NhZ2VUeXBlOwogICAgICAoZnVuY3Rpb24oV29ya2VyTWVzc2FnZVR5cGUyKSB7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJlcnJvciJdID0gImVycm9yIjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbImluaXQiXSA9ICJpbml0IjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbInJlc3VsdCJdID0gInJlc3VsdCI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJydW5uaW5nIl0gPSAicnVubmluZyI7CiAgICAgICAgV29ya2VyTWVzc2FnZVR5cGUyWyJ1bmNhdWdodEVycm9yIl0gPSAidW5jYXVnaHRFcnJvciI7CiAgICAgIH0pKFdvcmtlck1lc3NhZ2VUeXBlID0gZXhwb3J0czIuV29ya2VyTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMyLldvcmtlck1lc3NhZ2VUeXBlID0ge30pKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZHNAMS43LjAvbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW1wbGVtZW50YXRpb24uYnJvd3Nlci5qcwogIHZhciByZXF1aXJlX2ltcGxlbWVudGF0aW9uX2Jyb3dzZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbXBsZW1lbnRhdGlvbi5icm93c2VyLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBpc1dvcmtlclJ1bnRpbWUgPSBmdW5jdGlvbiBpc1dvcmtlclJ1bnRpbWUyKCkgewogICAgICAgIGNvbnN0IGlzV2luZG93Q29udGV4dCA9IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgV2luZG93ICE9PSAidW5kZWZpbmVkIiAmJiBzZWxmIGluc3RhbmNlb2YgV2luZG93OwogICAgICAgIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgc2VsZi5wb3N0TWVzc2FnZSAmJiAhaXNXaW5kb3dDb250ZXh0ID8gdHJ1ZSA6IGZhbHNlOwogICAgICB9OwogICAgICB2YXIgcG9zdE1lc3NhZ2VUb01hc3RlciA9IGZ1bmN0aW9uIHBvc3RNZXNzYWdlVG9NYXN0ZXIyKGRhdGEsIHRyYW5zZmVyTGlzdCkgewogICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTsKICAgICAgfTsKICAgICAgdmFyIHN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMgPSBmdW5jdGlvbiBzdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzMihvbk1lc3NhZ2UpIHsKICAgICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IChtZXNzYWdlRXZlbnQpID0+IHsKICAgICAgICAgIG9uTWVzc2FnZShtZXNzYWdlRXZlbnQuZGF0YSk7CiAgICAgICAgfTsKICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHsKICAgICAgICAgIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIG1lc3NhZ2VIYW5kbGVyKTsKICAgICAgICB9OwogICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIG1lc3NhZ2VIYW5kbGVyKTsKICAgICAgICByZXR1cm4gdW5zdWJzY3JpYmU7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSB7CiAgICAgICAgaXNXb3JrZXJSdW50aW1lLAogICAgICAgIHBvc3RNZXNzYWdlVG9NYXN0ZXIsCiAgICAgICAgc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vdGhyZWFkc0AxLjcuMC9ub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbmRleC5qcwogIHZhciByZXF1aXJlX3dvcmtlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2luZGV4LmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9fYXdhaXRlciA9IGV4cG9ydHMyICYmIGV4cG9ydHMyLl9fYXdhaXRlciB8fCBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHsKICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkgewogICAgICAgICAgICByZXNvbHZlKHZhbHVlKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgcmVqZWN0KGUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yWyJ0aHJvdyJdKHZhbHVlKSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7CiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOwogICAgICAgICAgfQogICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpOwogICAgICAgIH0pOwogICAgICB9OwogICAgICB2YXIgX19pbXBvcnREZWZhdWx0ID0gZXhwb3J0czIgJiYgZXhwb3J0czIuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKG1vZCkgewogICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7ICJkZWZhdWx0IjogbW9kIH07CiAgICAgIH07CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5leHBvc2UgPSBleHBvcnRzMi5pc1dvcmtlclJ1bnRpbWUgPSBleHBvcnRzMi5UcmFuc2ZlciA9IGV4cG9ydHMyLnJlZ2lzdGVyU2VyaWFsaXplciA9IHZvaWQgMDsKICAgICAgdmFyIGlzX29ic2VydmFibGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX2lzX29ic2VydmFibGUoKSk7CiAgICAgIHZhciBjb21tb25fMSA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICB2YXIgdHJhbnNmZXJhYmxlXzEgPSByZXF1aXJlX3RyYW5zZmVyYWJsZSgpOwogICAgICB2YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmVfbWVzc2FnZXMyKCk7CiAgICAgIHZhciBpbXBsZW1lbnRhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfaW1wbGVtZW50YXRpb25fYnJvd3NlcigpKTsKICAgICAgdmFyIGNvbW1vbl8yID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgInJlZ2lzdGVyU2VyaWFsaXplciIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gY29tbW9uXzIucmVnaXN0ZXJTZXJpYWxpemVyOwogICAgICB9IH0pOwogICAgICB2YXIgdHJhbnNmZXJhYmxlXzIgPSByZXF1aXJlX3RyYW5zZmVyYWJsZSgpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJUcmFuc2ZlciIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdHJhbnNmZXJhYmxlXzIuVHJhbnNmZXI7CiAgICAgIH0gfSk7CiAgICAgIGV4cG9ydHMyLmlzV29ya2VyUnVudGltZSA9IGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWU7CiAgICAgIHZhciBleHBvc2VDYWxsZWQgPSBmYWxzZTsKICAgICAgdmFyIGFjdGl2ZVN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7CiAgICAgIHZhciBpc01hc3RlckpvYkNhbmNlbE1lc3NhZ2UgPSAodGhpbmcpID0+IHRoaW5nICYmIHRoaW5nLnR5cGUgPT09IG1lc3NhZ2VzXzEuTWFzdGVyTWVzc2FnZVR5cGUuY2FuY2VsOwogICAgICB2YXIgaXNNYXN0ZXJKb2JSdW5NZXNzYWdlID0gKHRoaW5nKSA9PiB0aGluZyAmJiB0aGluZy50eXBlID09PSBtZXNzYWdlc18xLk1hc3Rlck1lc3NhZ2VUeXBlLnJ1bjsKICAgICAgdmFyIGlzT2JzZXJ2YWJsZSA9ICh0aGluZykgPT4gaXNfb2JzZXJ2YWJsZV8xLmRlZmF1bHQodGhpbmcpIHx8IGlzWmVuT2JzZXJ2YWJsZSh0aGluZyk7CiAgICAgIGZ1bmN0aW9uIGlzWmVuT2JzZXJ2YWJsZSh0aGluZykgewogICAgICAgIHJldHVybiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICJvYmplY3QiICYmIHR5cGVvZiB0aGluZy5zdWJzY3JpYmUgPT09ICJmdW5jdGlvbiI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVjb25zdHJ1Y3RUcmFuc2Zlcih0aGluZykgewogICAgICAgIHJldHVybiB0cmFuc2ZlcmFibGVfMS5pc1RyYW5zZmVyRGVzY3JpcHRvcih0aGluZykgPyB7IHBheWxvYWQ6IHRoaW5nLnNlbmQsIHRyYW5zZmVyYWJsZXM6IHRoaW5nLnRyYW5zZmVyYWJsZXMgfSA6IHsgcGF5bG9hZDogdGhpbmcsIHRyYW5zZmVyYWJsZXM6IHZvaWQgMCB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RGdW5jdGlvbkluaXRNZXNzYWdlKCkgewogICAgICAgIGNvbnN0IGluaXRNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5pbml0LAogICAgICAgICAgZXhwb3NlZDogewogICAgICAgICAgICB0eXBlOiAiZnVuY3Rpb24iCiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3Rlcihpbml0TWVzc2FnZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdE1vZHVsZUluaXRNZXNzYWdlKG1ldGhvZE5hbWVzKSB7CiAgICAgICAgY29uc3QgaW5pdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLmluaXQsCiAgICAgICAgICBleHBvc2VkOiB7CiAgICAgICAgICAgIHR5cGU6ICJtb2R1bGUiLAogICAgICAgICAgICBtZXRob2RzOiBtZXRob2ROYW1lcwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoaW5pdE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RKb2JFcnJvck1lc3NhZ2UodWlkLCByYXdFcnJvcikgewogICAgICAgIGNvbnN0IHsgcGF5bG9hZDogZXJyb3IsIHRyYW5zZmVyYWJsZXMgfSA9IGRlY29uc3RydWN0VHJhbnNmZXIocmF3RXJyb3IpOwogICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUuZXJyb3IsCiAgICAgICAgICB1aWQsCiAgICAgICAgICBlcnJvcjogY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKQogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIoZXJyb3JNZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0Sm9iUmVzdWx0TWVzc2FnZSh1aWQsIGNvbXBsZXRlZCwgcmVzdWx0VmFsdWUpIHsKICAgICAgICBjb25zdCB7IHBheWxvYWQsIHRyYW5zZmVyYWJsZXMgfSA9IGRlY29uc3RydWN0VHJhbnNmZXIocmVzdWx0VmFsdWUpOwogICAgICAgIGNvbnN0IHJlc3VsdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnJlc3VsdCwKICAgICAgICAgIHVpZCwKICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZWQgPyB0cnVlIDogdm9pZCAwLAogICAgICAgICAgcGF5bG9hZAogICAgICAgIH07CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnBvc3RNZXNzYWdlVG9NYXN0ZXIocmVzdWx0TWVzc2FnZSwgdHJhbnNmZXJhYmxlcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEpvYlN0YXJ0TWVzc2FnZSh1aWQsIHJlc3VsdFR5cGUpIHsKICAgICAgICBjb25zdCBzdGFydE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLnJ1bm5pbmcsCiAgICAgICAgICB1aWQsCiAgICAgICAgICByZXN1bHRUeXBlCiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihzdGFydE1lc3NhZ2UpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvcikgewogICAgICAgIHRyeSB7CiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSB7CiAgICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUudW5jYXVnaHRFcnJvciwKICAgICAgICAgICAgZXJyb3I6IGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikKICAgICAgICAgIH07CiAgICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihlcnJvck1lc3NhZ2UpOwogICAgICAgIH0gY2F0Y2ggKHN1YkVycm9yKSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKCJOb3QgcmVwb3J0aW5nIHVuY2F1Z2h0IGVycm9yIGJhY2sgdG8gbWFzdGVyIHRocmVhZCBhcyBpdCBvY2N1cmVkIHdoaWxlIHJlcG9ydGluZyBhbiB1bmNhdWdodCBlcnJvciBhbHJlYWR5LlxuTGF0ZXN0IGVycm9yOiIsIHN1YkVycm9yLCAiXG5PcmlnaW5hbCBlcnJvcjoiLCBlcnJvcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJ1bkZ1bmN0aW9uKGpvYlVJRCwgZm4sIGFyZ3MpIHsKICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgewogICAgICAgICAgbGV0IHN5bmNSZXN1bHQ7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBzeW5jUmVzdWx0ID0gZm4oLi4uYXJncyk7CiAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICByZXR1cm4gcG9zdEpvYkVycm9yTWVzc2FnZShqb2JVSUQsIGVycm9yKTsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHJlc3VsdFR5cGUgPSBpc09ic2VydmFibGUoc3luY1Jlc3VsdCkgPyAib2JzZXJ2YWJsZSIgOiAicHJvbWlzZSI7CiAgICAgICAgICBwb3N0Sm9iU3RhcnRNZXNzYWdlKGpvYlVJRCwgcmVzdWx0VHlwZSk7CiAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHN5bmNSZXN1bHQpKSB7CiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN5bmNSZXN1bHQuc3Vic2NyaWJlKCh2YWx1ZSkgPT4gcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCBmYWxzZSwgY29tbW9uXzEuc2VyaWFsaXplKHZhbHVlKSksIChlcnJvcikgPT4gewogICAgICAgICAgICAgIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9LCAoKSA9PiB7CiAgICAgICAgICAgICAgcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCB0cnVlKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5zZXQoam9iVUlELCBzdWJzY3JpcHRpb24pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzeW5jUmVzdWx0OwogICAgICAgICAgICAgIHBvc3RKb2JSZXN1bHRNZXNzYWdlKGpvYlVJRCwgdHJ1ZSwgY29tbW9uXzEuc2VyaWFsaXplKHJlc3VsdCkpOwogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgIHBvc3RKb2JFcnJvck1lc3NhZ2Uoam9iVUlELCBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGV4cG9zZTIoZXhwb3NlZCkgewogICAgICAgIGlmICghaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZSgpKSB7CiAgICAgICAgICB0aHJvdyBFcnJvcigiZXhwb3NlKCkgY2FsbGVkIGluIHRoZSBtYXN0ZXIgdGhyZWFkLiIpOwogICAgICAgIH0KICAgICAgICBpZiAoZXhwb3NlQ2FsbGVkKSB7CiAgICAgICAgICB0aHJvdyBFcnJvcigiZXhwb3NlKCkgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLiBUaGlzIGlzIG5vdCBwb3NzaWJsZS4gUGFzcyBhbiBvYmplY3QgdG8gZXhwb3NlKCkgaWYgeW91IHdhbnQgdG8gZXhwb3NlIG11bHRpcGxlIGZ1bmN0aW9ucy4iKTsKICAgICAgICB9CiAgICAgICAgZXhwb3NlQ2FsbGVkID0gdHJ1ZTsKICAgICAgICBpZiAodHlwZW9mIGV4cG9zZWQgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgICBpZiAoaXNNYXN0ZXJKb2JSdW5NZXNzYWdlKG1lc3NhZ2VEYXRhKSAmJiAhbWVzc2FnZURhdGEubWV0aG9kKSB7CiAgICAgICAgICAgICAgcnVuRnVuY3Rpb24obWVzc2FnZURhdGEudWlkLCBleHBvc2VkLCBtZXNzYWdlRGF0YS5hcmdzLm1hcChjb21tb25fMS5kZXNlcmlhbGl6ZSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHBvc3RGdW5jdGlvbkluaXRNZXNzYWdlKCk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3NlZCA9PT0gIm9iamVjdCIgJiYgZXhwb3NlZCkgewogICAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMoKG1lc3NhZ2VEYXRhKSA9PiB7CiAgICAgICAgICAgIGlmIChpc01hc3RlckpvYlJ1bk1lc3NhZ2UobWVzc2FnZURhdGEpICYmIG1lc3NhZ2VEYXRhLm1ldGhvZCkgewogICAgICAgICAgICAgIHJ1bkZ1bmN0aW9uKG1lc3NhZ2VEYXRhLnVpZCwgZXhwb3NlZFttZXNzYWdlRGF0YS5tZXRob2RdLCBtZXNzYWdlRGF0YS5hcmdzLm1hcChjb21tb25fMS5kZXNlcmlhbGl6ZSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGNvbnN0IG1ldGhvZE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3NlZCkuZmlsdGVyKChrZXkpID0+IHR5cGVvZiBleHBvc2VkW2tleV0gPT09ICJmdW5jdGlvbiIpOwogICAgICAgICAgcG9zdE1vZHVsZUluaXRNZXNzYWdlKG1ldGhvZE5hbWVzKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGV4cG9zZSgpLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCwgZ290OiAke2V4cG9zZWR9YCk7CiAgICAgICAgfQogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5zdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzKChtZXNzYWdlRGF0YSkgPT4gewogICAgICAgICAgaWYgKGlzTWFzdGVySm9iQ2FuY2VsTWVzc2FnZShtZXNzYWdlRGF0YSkpIHsKICAgICAgICAgICAgY29uc3Qgam9iVUlEID0gbWVzc2FnZURhdGEudWlkOwogICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhY3RpdmVTdWJzY3JpcHRpb25zLmdldChqb2JVSUQpOwogICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7CiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7CiAgICAgICAgICAgICAgYWN0aXZlU3Vic2NyaXB0aW9ucy5kZWxldGUoam9iVUlEKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGV4cG9ydHMyLmV4cG9zZSA9IGV4cG9zZTI7CiAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIHNlbGYuYWRkRXZlbnRMaXN0ZW5lciA9PT0gImZ1bmN0aW9uIiAmJiBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoImVycm9yIiwgKGV2ZW50KSA9PiB7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShldmVudC5lcnJvciB8fCBldmVudCksIDI1MCk7CiAgICAgICAgfSk7CiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCJ1bmhhbmRsZWRyZWplY3Rpb24iLCAoZXZlbnQpID0+IHsKICAgICAgICAgIGNvbnN0IGVycm9yID0gZXZlbnQucmVhc29uOwogICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAic3RyaW5nIikgewogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgcHJvY2Vzcy5vbiA9PT0gImZ1bmN0aW9uIiAmJiBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICBwcm9jZXNzLm9uKCJ1bmNhdWdodEV4Y2VwdGlvbiIsIChlcnJvcikgPT4gewogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXJyb3IpLCAyNTApOwogICAgICAgIH0pOwogICAgICAgIHByb2Nlc3Mub24oInVuaGFuZGxlZFJlamVjdGlvbiIsIChlcnJvcikgPT4gewogICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAic3RyaW5nIikgewogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JlZEAyLjEuMi9ub2RlX21vZHVsZXMvQGdtb2QvYmVkL2VzbS9hdXRvU3FsLmpzCiAgdmFyIHJlcXVpcmVfYXV0b1NxbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCtiZWRAMi4xLjIvbm9kZV9tb2R1bGVzL0BnbW9kL2JlZC9lc20vYXV0b1NxbC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7CiAgICAgICAgZnVuY3Rpb24gY3RvcigpIHsKICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsKICAgICAgICB9CiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOwogICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHsKICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogICAgICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDsKICAgICAgICB0aGlzLmZvdW5kID0gZm91bmQ7CiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uOwogICAgICAgIHRoaXMubmFtZSA9ICJTeW50YXhFcnJvciI7CiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgcGVnJFN5bnRheEVycm9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcGVnJHN1YmNsYXNzKHBlZyRTeW50YXhFcnJvciwgRXJyb3IpOwogICAgICBwZWckU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlID0gZnVuY3Rpb24oZXhwZWN0ZWQsIGZvdW5kKSB7CiAgICAgICAgdmFyIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOUyA9IHsKICAgICAgICAgIGxpdGVyYWw6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7CiAgICAgICAgICAgIHJldHVybiAnIicgKyBsaXRlcmFsRXNjYXBlKGV4cGVjdGF0aW9uLnRleHQpICsgJyInOwogICAgICAgICAgfSwKICAgICAgICAgICJjbGFzcyI6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7CiAgICAgICAgICAgIHZhciBlc2NhcGVkUGFydHMgPSAiIiwgaTsKICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGF0aW9uLnBhcnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzICs9IGV4cGVjdGF0aW9uLnBhcnRzW2ldIGluc3RhbmNlb2YgQXJyYXkgPyBjbGFzc0VzY2FwZShleHBlY3RhdGlvbi5wYXJ0c1tpXVswXSkgKyAiLSIgKyBjbGFzc0VzY2FwZShleHBlY3RhdGlvbi5wYXJ0c1tpXVsxXSkgOiBjbGFzc0VzY2FwZShleHBlY3RhdGlvbi5wYXJ0c1tpXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICJbIiArIChleHBlY3RhdGlvbi5pbnZlcnRlZCA/ICJeIiA6ICIiKSArIGVzY2FwZWRQYXJ0cyArICJdIjsKICAgICAgICAgIH0sCiAgICAgICAgICBhbnk6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7CiAgICAgICAgICAgIHJldHVybiAiYW55IGNoYXJhY3RlciI7CiAgICAgICAgICB9LAogICAgICAgICAgZW5kOiBmdW5jdGlvbihleHBlY3RhdGlvbikgewogICAgICAgICAgICByZXR1cm4gImVuZCBvZiBpbnB1dCI7CiAgICAgICAgICB9LAogICAgICAgICAgb3RoZXI6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7CiAgICAgICAgICAgIHJldHVybiBleHBlY3RhdGlvbi5kZXNjcmlwdGlvbjsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIGZ1bmN0aW9uIGhleChjaCkgewogICAgICAgICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGxpdGVyYWxFc2NhcGUocykgewogICAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXFwvZywgIlxcXFwiKS5yZXBsYWNlKC8iL2csICdcXCInKS5yZXBsYWNlKC9cMC9nLCAiXFwwIikucmVwbGFjZSgvXHQvZywgIlxcdCIpLnJlcGxhY2UoL1xuL2csICJcXG4iKS5yZXBsYWNlKC9cci9nLCAiXFxyIikucmVwbGFjZSgvW1x4MDAtXHgwRl0vZywgZnVuY3Rpb24oY2gpIHsKICAgICAgICAgICAgcmV0dXJuICJcXHgwIiArIGhleChjaCk7CiAgICAgICAgICB9KS5yZXBsYWNlKC9bXHgxMC1ceDFGXHg3Ri1ceDlGXS9nLCBmdW5jdGlvbihjaCkgewogICAgICAgICAgICByZXR1cm4gIlxceCIgKyBoZXgoY2gpOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGNsYXNzRXNjYXBlKHMpIHsKICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcL2csICJcXFxcIikucmVwbGFjZSgvXF0vZywgIlxcXSIpLnJlcGxhY2UoL1xeL2csICJcXF4iKS5yZXBsYWNlKC8tL2csICJcXC0iKS5yZXBsYWNlKC9cMC9nLCAiXFwwIikucmVwbGFjZSgvXHQvZywgIlxcdCIpLnJlcGxhY2UoL1xuL2csICJcXG4iKS5yZXBsYWNlKC9cci9nLCAiXFxyIikucmVwbGFjZSgvW1x4MDAtXHgwRl0vZywgZnVuY3Rpb24oY2gpIHsKICAgICAgICAgICAgcmV0dXJuICJcXHgwIiArIGhleChjaCk7CiAgICAgICAgICB9KS5yZXBsYWNlKC9bXHgxMC1ceDFGXHg3Ri1ceDlGXS9nLCBmdW5jdGlvbihjaCkgewogICAgICAgICAgICByZXR1cm4gIlxceCIgKyBoZXgoY2gpOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGRlc2NyaWJlRXhwZWN0YXRpb24oZXhwZWN0YXRpb24pIHsKICAgICAgICAgIHJldHVybiBERVNDUklCRV9FWFBFQ1RBVElPTl9GTlNbZXhwZWN0YXRpb24udHlwZV0oZXhwZWN0YXRpb24pOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGVkKGV4cGVjdGVkMikgewogICAgICAgICAgdmFyIGRlc2NyaXB0aW9ucyA9IG5ldyBBcnJheShleHBlY3RlZDIubGVuZ3RoKSwgaSwgajsKICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHBlY3RlZDIubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgZGVzY3JpcHRpb25zW2ldID0gZGVzY3JpYmVFeHBlY3RhdGlvbihleHBlY3RlZDJbaV0pOwogICAgICAgICAgfQogICAgICAgICAgZGVzY3JpcHRpb25zLnNvcnQoKTsKICAgICAgICAgIGlmIChkZXNjcmlwdGlvbnMubGVuZ3RoID4gMCkgewogICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0gMTsgaSA8IGRlc2NyaXB0aW9ucy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbnNbaSAtIDFdICE9PSBkZXNjcmlwdGlvbnNbaV0pIHsKICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uc1tqXSA9IGRlc2NyaXB0aW9uc1tpXTsKICAgICAgICAgICAgICAgIGorKzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZGVzY3JpcHRpb25zLmxlbmd0aCA9IGo7CiAgICAgICAgICB9CiAgICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0aW9ucy5sZW5ndGgpIHsKICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF07CiAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zWzBdICsgIiBvciAiICsgZGVzY3JpcHRpb25zWzFdOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnMuc2xpY2UoMCwgLTEpLmpvaW4oIiwgIikgKyAiLCBvciAiICsgZGVzY3JpcHRpb25zW2Rlc2NyaXB0aW9ucy5sZW5ndGggLSAxXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZGVzY3JpYmVGb3VuZChmb3VuZDIpIHsKICAgICAgICAgIHJldHVybiBmb3VuZDIgPyAnIicgKyBsaXRlcmFsRXNjYXBlKGZvdW5kMikgKyAnIicgOiAiZW5kIG9mIGlucHV0IjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuICJFeHBlY3RlZCAiICsgZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkgKyAiIGJ1dCAiICsgZGVzY3JpYmVGb3VuZChmb3VuZCkgKyAiIGZvdW5kLiI7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZShpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307CiAgICAgICAgdmFyIHBlZyRGQUlMRUQgPSB7fSwgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgZGVjbGFyYXRpb246IHBlZyRwYXJzZWRlY2xhcmF0aW9uIH0sIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRwYXJzZWRlY2xhcmF0aW9uLCBwZWckYzAgPSAiKCIsIHBlZyRjMSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oIigiLCBmYWxzZSksIHBlZyRjMiA9ICIpIiwgcGVnJGMzID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiKSIsIGZhbHNlKSwgcGVnJGM0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgY29tbWVudCwgZmllbGRzKSB7CiAgICAgICAgICByZXR1cm4geyB0eXBlLCBuYW1lLCBjb21tZW50LCBmaWVsZHMgfTsKICAgICAgICB9LCBwZWckYzUgPSAic2ltcGxlIiwgcGVnJGM2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigic2ltcGxlIiwgZmFsc2UpLCBwZWckYzcgPSAib2JqZWN0IiwgcGVnJGM4ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigib2JqZWN0IiwgZmFsc2UpLCBwZWckYzkgPSAidGFibGUiLCBwZWckYzEwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigidGFibGUiLCBmYWxzZSksIHBlZyRjMTEgPSAiYXV0byIsIHBlZyRjMTIgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJhdXRvIiwgZmFsc2UpLCBwZWckYzEzID0gInByaW1hcnkiLCBwZWckYzE0ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigicHJpbWFyeSIsIGZhbHNlKSwgcGVnJGMxNSA9ICJpbmRleCIsIHBlZyRjMTYgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJpbmRleCIsIGZhbHNlKSwgcGVnJGMxNyA9ICJ1bmlxdWUiLCBwZWckYzE4ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigidW5pcXVlIiwgZmFsc2UpLCBwZWckYzE5ID0gZnVuY3Rpb24oZjEsIHcpIHsKICAgICAgICAgIHJldHVybiB3OwogICAgICAgIH0sIHBlZyRjMjAgPSBmdW5jdGlvbihmMSwgZmRzKSB7CiAgICAgICAgICBpZiAoZjEubmFtZSkgewogICAgICAgICAgICBmZHMudW5zaGlmdChmMSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZmRzOwogICAgICAgIH0sIHBlZyRjMjEgPSAiIyIsIHBlZyRjMjIgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCIjIiwgZmFsc2UpLCBwZWckYzIzID0gIjsiLCBwZWckYzI0ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiOyIsIGZhbHNlKSwgcGVnJGMyNSA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIGNvbW1lbnQpIHsKICAgICAgICAgIHJldHVybiB7IHR5cGUsIG5hbWUsIGNvbW1lbnQgfTsKICAgICAgICB9LCBwZWckYzI2ID0gIlsiLCBwZWckYzI3ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiWyIsIGZhbHNlKSwgcGVnJGMyOCA9ICJdIiwgcGVnJGMyOSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oIl0iLCBmYWxzZSksIHBlZyRjMzAgPSBmdW5jdGlvbih0eXBlLCBzaXplLCBuYW1lLCBjb21tZW50KSB7CiAgICAgICAgICByZXR1cm4geyB0eXBlLCBzaXplLCBuYW1lLCBjb21tZW50IH07CiAgICAgICAgfSwgcGVnJGMzMSA9IGZ1bmN0aW9uKHR5cGUsIHZhbHMsIG5hbWUsIGNvbW1lbnQpIHsKICAgICAgICAgIHJldHVybiB7IHR5cGUsIHZhbHMsIG5hbWUsIGNvbW1lbnQgfTsKICAgICAgICB9LCBwZWckYzMyID0gIiwiLCBwZWckYzMzID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiLCIsIGZhbHNlKSwgcGVnJGMzNCA9IGZ1bmN0aW9uKGYxLCBmZHMpIHsKICAgICAgICAgIGZkcy51bnNoaWZ0KGYxKTsKICAgICAgICAgIHJldHVybiBmZHM7CiAgICAgICAgfSwgcGVnJGMzNSA9ICJpbnQiLCBwZWckYzM2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiaW50IiwgZmFsc2UpLCBwZWckYzM3ID0gInVpbnQiLCBwZWckYzM4ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigidWludCIsIGZhbHNlKSwgcGVnJGMzOSA9ICJzaG9ydCIsIHBlZyRjNDAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJzaG9ydCIsIGZhbHNlKSwgcGVnJGM0MSA9ICJ1c2hvcnQiLCBwZWckYzQyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigidXNob3J0IiwgZmFsc2UpLCBwZWckYzQzID0gImJ5dGUiLCBwZWckYzQ0ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigiYnl0ZSIsIGZhbHNlKSwgcGVnJGM0NSA9ICJ1Ynl0ZSIsIHBlZyRjNDYgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJ1Ynl0ZSIsIGZhbHNlKSwgcGVnJGM0NyA9ICJmbG9hdCIsIHBlZyRjNDggPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJmbG9hdCIsIGZhbHNlKSwgcGVnJGM0OSA9ICJjaGFyIiwgcGVnJGM1MCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oImNoYXIiLCBmYWxzZSksIHBlZyRjNTEgPSAic3RyaW5nIiwgcGVnJGM1MiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oInN0cmluZyIsIGZhbHNlKSwgcGVnJGM1MyA9ICJsc3RyaW5nIiwgcGVnJGM1NCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oImxzdHJpbmciLCBmYWxzZSksIHBlZyRjNTUgPSAiZW51bSIsIHBlZyRjNTYgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJlbnVtIiwgZmFsc2UpLCBwZWckYzU3ID0gImRvdWJsZSIsIHBlZyRjNTggPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKCJkb3VibGUiLCBmYWxzZSksIHBlZyRjNTkgPSAiYmlnaW50IiwgcGVnJGM2MCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oImJpZ2ludCIsIGZhbHNlKSwgcGVnJGM2MSA9ICJzZXQiLCBwZWckYzYyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbigic2V0IiwgZmFsc2UpLCBwZWckYzYzID0gZnVuY3Rpb24odCwgbikgewogICAgICAgICAgcmV0dXJuIHQgKyAiICIgKyBuOwogICAgICAgIH0sIHBlZyRjNjQgPSAvXlthLXpBLVpfXS8sIHBlZyRjNjUgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbWyJhIiwgInoiXSwgWyJBIiwgIloiXSwgIl8iXSwgZmFsc2UsIGZhbHNlKSwgcGVnJGM2NiA9IC9eW2EtekEtWjAtOV9dLywgcGVnJGM2NyA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbImEiLCAieiJdLCBbIkEiLCAiWiJdLCBbIjAiLCAiOSJdLCAiXyJdLCBmYWxzZSwgZmFsc2UpLCBwZWckYzY4ID0gZnVuY3Rpb24odCkgewogICAgICAgICAgcmV0dXJuIHRleHQoKTsKICAgICAgICB9LCBwZWckYzY5ID0gJyInLCBwZWckYzcwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbignIicsIGZhbHNlKSwgcGVnJGM3MSA9IC9eW14iXS8sIHBlZyRjNzIgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbJyInXSwgdHJ1ZSwgZmFsc2UpLCBwZWckYzczID0gZnVuY3Rpb24odCkgewogICAgICAgICAgcmV0dXJuIHQuam9pbigiIik7CiAgICAgICAgfSwgcGVnJGM3NCA9IC9eW15cblxyXS8sIHBlZyRjNzUgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbIlxuIiwgIlxyIl0sIHRydWUsIGZhbHNlKSwgcGVnJGM3NiA9IGZ1bmN0aW9uKHQpIHsKICAgICAgICAgIHJldHVybiB0LmpvaW4oIiIpLnJlcGxhY2UoL14iLywgIiIpLnJlcGxhY2UoLyIkLywgIiIpOwogICAgICAgIH0sIHBlZyRjNzcgPSBwZWckb3RoZXJFeHBlY3RhdGlvbigiaW50ZWdlciIpLCBwZWckYzc4ID0gL15bMC05XS8sIHBlZyRjNzkgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbWyIwIiwgIjkiXV0sIGZhbHNlLCBmYWxzZSksIHBlZyRjODAgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0KCksIDEwKTsKICAgICAgICB9LCBwZWckYzgxID0gcGVnJG90aGVyRXhwZWN0YXRpb24oIndoaXRlc3BhY2UiKSwgcGVnJGM4MiA9IC9eWyBcdFxuXHJdLywgcGVnJGM4MyA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFsiICIsICIJIiwgIlxuIiwgIlxyIl0sIGZhbHNlLCBmYWxzZSksIHBlZyRjdXJyUG9zID0gMCwgcGVnJHNhdmVkUG9zID0gMCwgcGVnJHBvc0RldGFpbHNDYWNoZSA9IFt7IGxpbmU6IDEsIGNvbHVtbjogMSB9XSwgcGVnJG1heEZhaWxQb3MgPSAwLCBwZWckbWF4RmFpbEV4cGVjdGVkID0gW10sIHBlZyRzaWxlbnRGYWlscyA9IDAsIHBlZyRyZXN1bHQ7CiAgICAgICAgaWYgKCJzdGFydFJ1bGUiIGluIG9wdGlvbnMpIHsKICAgICAgICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMpKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgImAgKyBvcHRpb25zLnN0YXJ0UnVsZSArICciLicpOwogICAgICAgICAgfQogICAgICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uc1tvcHRpb25zLnN0YXJ0UnVsZV07CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHRleHQoKSB7CiAgICAgICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBsb2NhdGlvbigpIHsKICAgICAgICAgIHJldHVybiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbiwgbG9jYXRpb24yKSB7CiAgICAgICAgICBsb2NhdGlvbjIgPSBsb2NhdGlvbjIgIT09IHZvaWQgMCA/IGxvY2F0aW9uMiA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7CiAgICAgICAgICB0aHJvdyBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoW3BlZyRvdGhlckV4cGVjdGF0aW9uKGRlc2NyaXB0aW9uKV0sIGlucHV0LnN1YnN0cmluZyhwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKSwgbG9jYXRpb24yKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgbG9jYXRpb24yKSB7CiAgICAgICAgICBsb2NhdGlvbjIgPSBsb2NhdGlvbjIgIT09IHZvaWQgMCA/IGxvY2F0aW9uMiA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7CiAgICAgICAgICB0aHJvdyBwZWckYnVpbGRTaW1wbGVFcnJvcihtZXNzYWdlLCBsb2NhdGlvbjIpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKHRleHQyLCBpZ25vcmVDYXNlKSB7CiAgICAgICAgICByZXR1cm4geyB0eXBlOiAibGl0ZXJhbCIsIHRleHQ6IHRleHQyLCBpZ25vcmVDYXNlIH07CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRjbGFzc0V4cGVjdGF0aW9uKHBhcnRzLCBpbnZlcnRlZCwgaWdub3JlQ2FzZSkgewogICAgICAgICAgcmV0dXJuIHsgdHlwZTogImNsYXNzIiwgcGFydHMsIGludmVydGVkLCBpZ25vcmVDYXNlIH07CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRhbnlFeHBlY3RhdGlvbigpIHsKICAgICAgICAgIHJldHVybiB7IHR5cGU6ICJhbnkiIH07CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRlbmRFeHBlY3RhdGlvbigpIHsKICAgICAgICAgIHJldHVybiB7IHR5cGU6ICJlbmQiIH07CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRvdGhlckV4cGVjdGF0aW9uKGRlc2NyaXB0aW9uKSB7CiAgICAgICAgICByZXR1cm4geyB0eXBlOiAib3RoZXIiLCBkZXNjcmlwdGlvbiB9OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7CiAgICAgICAgICB2YXIgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXSwgcDsKICAgICAgICAgIGlmIChkZXRhaWxzKSB7CiAgICAgICAgICAgIHJldHVybiBkZXRhaWxzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcCA9IHBvcyAtIDE7CiAgICAgICAgICAgIHdoaWxlICghcGVnJHBvc0RldGFpbHNDYWNoZVtwXSkgewogICAgICAgICAgICAgIHAtLTsKICAgICAgICAgICAgfQogICAgICAgICAgICBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwXTsKICAgICAgICAgICAgZGV0YWlscyA9IHsKICAgICAgICAgICAgICBsaW5lOiBkZXRhaWxzLmxpbmUsCiAgICAgICAgICAgICAgY29sdW1uOiBkZXRhaWxzLmNvbHVtbgogICAgICAgICAgICB9OwogICAgICAgICAgICB3aGlsZSAocCA8IHBvcykgewogICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHApID09PSAxMCkgewogICAgICAgICAgICAgICAgZGV0YWlscy5saW5lKys7CiAgICAgICAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHArKzsKICAgICAgICAgICAgfQogICAgICAgICAgICBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc10gPSBkZXRhaWxzOwogICAgICAgICAgICByZXR1cm4gZGV0YWlsczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJGNvbXB1dGVMb2NhdGlvbihzdGFydFBvcywgZW5kUG9zKSB7CiAgICAgICAgICB2YXIgc3RhcnRQb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHN0YXJ0UG9zKSwgZW5kUG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhlbmRQb3MpOwogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgc3RhcnQ6IHsKICAgICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0UG9zLAogICAgICAgICAgICAgIGxpbmU6IHN0YXJ0UG9zRGV0YWlscy5saW5lLAogICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRQb3NEZXRhaWxzLmNvbHVtbgogICAgICAgICAgICB9LAogICAgICAgICAgICBlbmQ6IHsKICAgICAgICAgICAgICBvZmZzZXQ6IGVuZFBvcywKICAgICAgICAgICAgICBsaW5lOiBlbmRQb3NEZXRhaWxzLmxpbmUsCiAgICAgICAgICAgICAgY29sdW1uOiBlbmRQb3NEZXRhaWxzLmNvbHVtbgogICAgICAgICAgICB9CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZDIpIHsKICAgICAgICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7CiAgICAgICAgICAgIHBlZyRtYXhGYWlsUG9zID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTsKICAgICAgICAgIH0KICAgICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZDIpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckYnVpbGRTaW1wbGVFcnJvcihtZXNzYWdlLCBsb2NhdGlvbjIpIHsKICAgICAgICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIG51bGwsIG51bGwsIGxvY2F0aW9uMik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihleHBlY3RlZDIsIGZvdW5kLCBsb2NhdGlvbjIpIHsKICAgICAgICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKHBlZyRTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UoZXhwZWN0ZWQyLCBmb3VuZCksIGV4cGVjdGVkMiwgZm91bmQsIGxvY2F0aW9uMik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWRlY2xhcmF0aW9uKCkgewogICAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczgsIHM5LCBzMTAsIHMxMSwgczEyLCBzMTM7CiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgczEgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczIgPSBwZWckcGFyc2VkZWNsYXJlVHlwZSgpOwogICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlZGVjbGFyZU5hbWUoKTsKICAgICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2Vjb21tZW50KCk7CiAgICAgICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgczggPSBwZWckYzA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMxKTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHM5ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTAgPSBwZWckcGFyc2VmaWVsZExpc3QoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTAgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczExID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczExICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEyID0gcGVnJGMyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEyID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMzKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEzID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzQoczIsIHM0LCBzNiwgczEwKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlZGVjbGFyZVR5cGUoKSB7CiAgICAgICAgICB2YXIgczA7CiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGM1KSB7CiAgICAgICAgICAgIHMwID0gcGVnJGM1OwogICAgICAgICAgICBwZWckY3VyclBvcyArPSA2OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM2KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDYpID09PSBwZWckYzcpIHsKICAgICAgICAgICAgICBzMCA9IHBlZyRjNzsKICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA2OwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM5KSB7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjOTsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMxMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWRlY2xhcmVOYW1lKCkgewogICAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzOwogICAgICAgICAgczAgPSBwZWckcGFyc2VuYW1lKCk7CiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgICAgczEgPSBwZWckcGFyc2VuYW1lKCk7CiAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlaW5kZXhUeXBlKCk7CiAgICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICBzMSA9IFtzMSwgczJdOwogICAgICAgICAgICAgICAgczAgPSBzMTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZW5hbWUoKTsKICAgICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDQpID09PSBwZWckYzExKSB7CiAgICAgICAgICAgICAgICAgIHMyID0gcGVnJGMxMTsKICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMTIpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgczEgPSBbczEsIHMyXTsKICAgICAgICAgICAgICAgICAgczAgPSBzMTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VuYW1lKCk7CiAgICAgICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgczIgPSBwZWckcGFyc2VpbmRleFR5cGUoKTsKICAgICAgICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjMTEpIHsKICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGMxMTsKICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMxMik7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgczEgPSBbczEsIHMyLCBzM107CiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2VpbmRleFR5cGUoKSB7CiAgICAgICAgICB2YXIgczA7CiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA3KSA9PT0gcGVnJGMxMykgewogICAgICAgICAgICBzMCA9IHBlZyRjMTM7CiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDc7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzE0KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzE1KSB7CiAgICAgICAgICAgICAgczAgPSBwZWckYzE1OwogICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMTYpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGMxNykgewogICAgICAgICAgICAgICAgczAgPSBwZWckYzE3OwogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzE4KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlY29tbWVudCgpIHsKICAgICAgICAgIHZhciBzMDsKICAgICAgICAgIHMwID0gcGVnJHBhcnNlbm9uUXVvdGVkU3RyaW5nKCk7CiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczAgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWZpZWxkTGlzdCgpIHsKICAgICAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNjsKICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICBzMSA9IHBlZyRwYXJzZWZpZWxkKCk7CiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIHMzID0gW107CiAgICAgICAgICAgICAgczQgPSBwZWckY3VyclBvczsKICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlZmllbGQoKTsKICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzNDsKICAgICAgICAgICAgICAgICAgczUgPSBwZWckYzE5KHMxLCBzNik7CiAgICAgICAgICAgICAgICAgIHM0ID0gczU7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM0OwogICAgICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczQ7CiAgICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgczMucHVzaChzNCk7CiAgICAgICAgICAgICAgICBzNCA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VmaWVsZCgpOwogICAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzNDsKICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRjMTkoczEsIHM2KTsKICAgICAgICAgICAgICAgICAgICBzNCA9IHM1OwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczQ7CiAgICAgICAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM0OwogICAgICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7CiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMyMChzMSwgczMpOwogICAgICAgICAgICAgICAgICBzMCA9IHMxOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2Vjb21tZW50U3RhcnQoKSB7CiAgICAgICAgICB2YXIgczA7CiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM1KSB7CiAgICAgICAgICAgIHMwID0gcGVnJGMyMTsKICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMjIpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWludGVybmFsQ29tbWVudCgpIHsKICAgICAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7CiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgczEgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczIgPSBwZWckcGFyc2Vjb21tZW50U3RhcnQoKTsKICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgczMgPSBwZWckcGFyc2Vub25RdW90ZWRTdHJpbmcoKTsKICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgIHMxID0gW3MxLCBzMiwgczMsIHM0XTsKICAgICAgICAgICAgICAgICAgczAgPSBzMTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlZmllbGQoKSB7CiAgICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzOCwgczksIHMxMCwgczExLCBzMTIsIHMxMzsKICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICBzMSA9IHBlZyRwYXJzZWZpZWxkVHlwZSgpOwogICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBzMyA9IHBlZyRwYXJzZW5hbWUoKTsKICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTkpIHsKICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRjMjM7CiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMyNCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2Vjb21tZW50KCk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMyNShzMSwgczMsIHM3KTsKICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWZpZWxkVHlwZSgpOwogICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBzMiA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTEpIHsKICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzI2OwogICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMyNyk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VmaWVsZFNpemUoKTsKICAgICAgICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBzNyA9IHBlZyRjMjg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBzNyA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMyOSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckcGFyc2VuYW1lKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczkgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEwID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEwICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA1OSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczExID0gcGVnJGMyMzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMjQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczExICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTIgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEyICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMyA9IHBlZyRwYXJzZWNvbW1lbnQoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMzMChzMSwgczUsIHM5LCBzMTMpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWZpZWxkVHlwZSgpOwogICAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MCkgewogICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGMwOwogICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VmaWVsZFZhbHVlcygpOwogICAgICAgICAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNyA9IHBlZyRjMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMzKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRwYXJzZW5hbWUoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHM5ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEwID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTAgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczExID0gcGVnJGMyMzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzI0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTIgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTMgPSBwZWckcGFyc2Vjb21tZW50KCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMzEoczEsIHM1LCBzOSwgczEzKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2VpbnRlcm5hbENvbW1lbnQoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlZmllbGRWYWx1ZXMoKSB7CiAgICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczY7CiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgczEgPSBwZWckcGFyc2VuYW1lKCk7CiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczIgPSBbXTsKICAgICAgICAgICAgczMgPSBwZWckY3VyclBvczsKICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkgewogICAgICAgICAgICAgIHM0ID0gcGVnJGMzMjsKICAgICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzMzKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZW5hbWUoKTsKICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMzsKICAgICAgICAgICAgICAgICAgczQgPSBwZWckYzE5KHMxLCBzNik7CiAgICAgICAgICAgICAgICAgIHMzID0gczQ7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzOwogICAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7CiAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7CiAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIHMyLnB1c2goczMpOwogICAgICAgICAgICAgIHMzID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkgewogICAgICAgICAgICAgICAgczQgPSBwZWckYzMyOwogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzMzKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTsKICAgICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZW5hbWUoKTsKICAgICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczM7CiAgICAgICAgICAgICAgICAgICAgczQgPSBwZWckYzE5KHMxLCBzNik7CiAgICAgICAgICAgICAgICAgICAgczMgPSBzNDsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzOwogICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMzsKICAgICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzOwogICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDsKICAgICAgICAgICAgICBzMSA9IHBlZyRjMzQoczEsIHMyKTsKICAgICAgICAgICAgICBzMCA9IHMxOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWZpZWxkVHlwZSgpIHsKICAgICAgICAgIHZhciBzMCwgczEsIHMyLCBzMzsKICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDMpID09PSBwZWckYzM1KSB7CiAgICAgICAgICAgIHMwID0gcGVnJGMzNTsKICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjMzYpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjMzcpIHsKICAgICAgICAgICAgICBzMCA9IHBlZyRjMzc7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGMzOCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzM5KSB7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMzk7CiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA1OwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDYpID09PSBwZWckYzQxKSB7CiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0MTsKICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNjsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNDIpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjNDMpIHsKICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDM7CiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNDsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM0NCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzQ1KSB7CiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDU7CiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA1OwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNDYpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzQ3KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0NzsKICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNDgpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjNDkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNDsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM1MCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDYpID09PSBwZWckYzUxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA2OwogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNTIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDcpID09PSBwZWckYzUzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1MzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNTQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjNTUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTU7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM1Nik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDYpID09PSBwZWckYzU3KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTc7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA2OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNTgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDYpID09PSBwZWckYzU5KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1OTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNjApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMykgPT09IHBlZyRjNjEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNjE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM2Mik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VkZWNsYXJlVHlwZSgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckcGFyc2VkZWNsYXJlTmFtZSgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNjMoczEsIHMzKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWZpZWxkU2l6ZSgpIHsKICAgICAgICAgIHZhciBzMDsKICAgICAgICAgIHMwID0gcGVnJHBhcnNlbnVtYmVyKCk7CiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczAgPSBwZWckcGFyc2VuYW1lKCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW5hbWUoKSB7CiAgICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0OwogICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgIHMxID0gcGVnJGN1cnJQb3M7CiAgICAgICAgICBpZiAocGVnJGM2NC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7CiAgICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTsKICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNjUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgczMgPSBbXTsKICAgICAgICAgICAgaWYgKHBlZyRjNjYudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkgewogICAgICAgICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTsKICAgICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzY3KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgczMucHVzaChzNCk7CiAgICAgICAgICAgICAgaWYgKHBlZyRjNjYudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkgewogICAgICAgICAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpOwogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEOwogICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzY3KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgICAgczIgPSBbczIsIHMzXTsKICAgICAgICAgICAgICBzMSA9IHMyOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczE7CiAgICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwZWckY3VyclBvcyA9IHMxOwogICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7CiAgICAgICAgICAgIHMxID0gcGVnJGM2OChzMSk7CiAgICAgICAgICB9CiAgICAgICAgICBzMCA9IHMxOwogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2VxdW90ZWRTdHJpbmcoKSB7CiAgICAgICAgICB2YXIgczAsIHMxLCBzMiwgczM7CiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkgewogICAgICAgICAgICBzMSA9IHBlZyRjNjk7CiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzcwKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMyID0gW107CiAgICAgICAgICAgIGlmIChwZWckYzcxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHsKICAgICAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM3Mik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIHMyLnB1c2goczMpOwogICAgICAgICAgICAgIGlmIChwZWckYzcxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHsKICAgICAgICAgICAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM3Mik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzQpIHsKICAgICAgICAgICAgICAgIHMzID0gcGVnJGM2OTsKICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM3MCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7CiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNzMoczIpOwogICAgICAgICAgICAgICAgczAgPSBzMTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDsKICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlbm9uUXVvdGVkU3RyaW5nKCkgewogICAgICAgICAgdmFyIHMwLCBzMSwgczI7CiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zOwogICAgICAgICAgczEgPSBbXTsKICAgICAgICAgIGlmIChwZWckYzc0LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHsKICAgICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpOwogICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEOwogICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM3NSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICBzMS5wdXNoKHMyKTsKICAgICAgICAgICAgaWYgKHBlZyRjNzQudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkgewogICAgICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTsKICAgICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzc1KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDsKICAgICAgICAgICAgczEgPSBwZWckYzc2KHMxKTsKICAgICAgICAgIH0KICAgICAgICAgIHMwID0gczE7CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW51bWJlcigpIHsKICAgICAgICAgIHZhciBzMCwgczEsIHMyLCBzMzsKICAgICAgICAgIHBlZyRzaWxlbnRGYWlscysrOwogICAgICAgICAgczAgPSBwZWckY3VyclBvczsKICAgICAgICAgIHMxID0gcGVnJHBhcnNlXygpOwogICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMyID0gW107CiAgICAgICAgICAgIGlmIChwZWckYzc4LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHsKICAgICAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7CiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM3OSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICAgICAgczIucHVzaChzMyk7CiAgICAgICAgICAgICAgICBpZiAocGVnJGM3OC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7CiAgICAgICAgICAgICAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTsKICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKzsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjNzkpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHsKICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDsKICAgICAgICAgICAgICBzMSA9IHBlZyRjODAoKTsKICAgICAgICAgICAgICBzMCA9IHMxOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7CiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwOwogICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICB9CiAgICAgICAgICBwZWckc2lsZW50RmFpbHMtLTsKICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7CiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsKICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzc3KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHMwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZWckcGFyc2VfKCkgewogICAgICAgICAgdmFyIHMwLCBzMTsKICAgICAgICAgIHBlZyRzaWxlbnRGYWlscysrOwogICAgICAgICAgczAgPSBbXTsKICAgICAgICAgIGlmIChwZWckYzgyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHsKICAgICAgICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpOwogICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEOwogICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGM4Myk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzMSAhPT0gcGVnJEZBSUxFRCkgewogICAgICAgICAgICBzMC5wdXNoKHMxKTsKICAgICAgICAgICAgaWYgKHBlZyRjODIudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkgewogICAgICAgICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTsKICAgICAgICAgICAgICBwZWckY3VyclBvcysrOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7CiAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckYzgzKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHBlZyRzaWxlbnRGYWlscy0tOwogICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7CiAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDsKICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgewogICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjODEpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gczA7CiAgICAgICAgfQogICAgICAgIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTsKICAgICAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7CiAgICAgICAgICByZXR1cm4gcGVnJHJlc3VsdDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHsKICAgICAgICAgICAgcGVnJGZhaWwocGVnJGVuZEV4cGVjdGF0aW9uKCkpOwogICAgICAgICAgfQogICAgICAgICAgdGhyb3cgcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKHBlZyRtYXhGYWlsRXhwZWN0ZWQsIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KHBlZyRtYXhGYWlsUG9zKSA6IG51bGwsIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoID8gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MgKyAxKSA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zKSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHsKICAgICAgICBTeW50YXhFcnJvcjogcGVnJFN5bnRheEVycm9yLAogICAgICAgIHBhcnNlOiBwZWckcGFyc2UKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvYmVkL2JlZC13b3JrZXIudHM/d29ya2VyJmlubGluZT93b3JrZXJfZmlsZQogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK3RhYml4QDEuNS4xMS9ub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdGFiaXhJbmRleGVkRmlsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2Fib3J0YWJsZV9wcm9taXNlX2NhY2hlID0gX190b01vZHVsZShyZXF1aXJlX2VzbSgpKTsKICB2YXIgaW1wb3J0X3F1aWNrX2xydSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9xdWlja19scnUoKSk7CiAgdmFyIGltcG9ydF9idWZmZXI3ID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2dlbmVyaWMtZmlsZWhhbmRsZUAzLjEuMS9ub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2xvY2FsRmlsZSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb2NhbEZpbGUoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9nZW5lcmljLWZpbGVoYW5kbGVAMy4xLjEvbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vcmVtb3RlRmlsZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2J1ZmZlcjIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYnVmZmVyKCkpOwogIHZhciBSZW1vdGVGaWxlID0gY2xhc3MgewogICAgYXN5bmMgZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKSB7CiAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuYnVmZmVyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJ1ZmZlcigpOwogICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5hcnJheUJ1ZmZlciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpOwogICAgICAgIHJldHVybiBpbXBvcnRfYnVmZmVyMi5CdWZmZXIuZnJvbShyZXNwKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnZhbGlkIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LCBoYXMgbm8gYnVmZmVyIG1ldGhvZCwgYW5kIG5vIGFycmF5QnVmZmVyIG1ldGhvZCIpOwogICAgICB9CiAgICB9CiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdHMgPSB7fSkgewogICAgICB0aGlzLmJhc2VPdmVycmlkZXMgPSB7fTsKICAgICAgdGhpcy51cmwgPSBzb3VyY2U7CiAgICAgIGNvbnN0IGZldGNoID0gb3B0cy5mZXRjaCB8fCBnbG9iYWxUaGlzLmZldGNoLmJpbmQoZ2xvYmFsVGhpcyk7CiAgICAgIGlmICghZmV0Y2gpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBubyBmZXRjaCBmdW5jdGlvbiBzdXBwbGllZCwgYW5kIG5vbmUgZm91bmQgaW4gZ2xvYmFsIGVudmlyb25tZW50YCk7CiAgICAgIH0KICAgICAgaWYgKG9wdHMub3ZlcnJpZGVzKSB7CiAgICAgICAgdGhpcy5iYXNlT3ZlcnJpZGVzID0gb3B0cy5vdmVycmlkZXM7CiAgICAgIH0KICAgICAgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uID0gZmV0Y2g7CiAgICB9CiAgICBhc3luYyBmZXRjaChpbnB1dCwgaW5pdDIpIHsKICAgICAgbGV0IHJlc3BvbnNlOwogICAgICB0cnkgewogICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGlucHV0LCBpbml0Mik7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAoYCR7ZX1gLmluY2x1ZGVzKCJGYWlsZWQgdG8gZmV0Y2giKSkgewogICAgICAgICAgY29uc29sZS53YXJuKGBnZW5lcmljLWZpbGVoYW5kbGU6IHJlZmV0Y2hpbmcgJHtpbnB1dH0gdG8gYXR0ZW1wdCB0byB3b3JrIGFyb3VuZCBjaHJvbWUgQ09SUyBoZWFkZXIgY2FjaGluZyBidWdgKTsKICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGlucHV0LCB7CiAgICAgICAgICAgIC4uLmluaXQyLAogICAgICAgICAgICBjYWNoZTogInJlbG9hZCIKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBlOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gcmVzcG9uc2U7CiAgICB9CiAgICBhc3luYyByZWFkKGJ1ZmZlciwgb2Zmc2V0ID0gMCwgbGVuZ3RoLCBwb3NpdGlvbiA9IDAsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSwgc2lnbmFsLCBvdmVycmlkZXMgPSB7fSB9ID0gb3B0czsKICAgICAgaWYgKGxlbmd0aCA8IEluZmluaXR5KSB7CiAgICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS0ke3Bvc2l0aW9uICsgbGVuZ3RofWA7CiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSBJbmZpbml0eSAmJiBwb3NpdGlvbiAhPT0gMCkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tYDsKICAgICAgfQogICAgICBjb25zdCBhcmdzID0gewogICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcywKICAgICAgICAuLi5vdmVycmlkZXMsCiAgICAgICAgaGVhZGVyczogewogICAgICAgICAgLi4uaGVhZGVycywKICAgICAgICAgIC4uLm92ZXJyaWRlcy5oZWFkZXJzLAogICAgICAgICAgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLmhlYWRlcnMKICAgICAgICB9LAogICAgICAgIG1ldGhvZDogIkdFVCIsCiAgICAgICAgcmVkaXJlY3Q6ICJmb2xsb3ciLAogICAgICAgIG1vZGU6ICJjb3JzIiwKICAgICAgICBzaWduYWwKICAgICAgfTsKICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgaWYgKCFyZXNwb25zZS5vaykgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAke3RoaXMudXJsfWApOwogICAgICB9CiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiBwb3NpdGlvbiA9PT0gMCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNikgewogICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTsKICAgICAgICBjb25zdCBieXRlc0NvcGllZCA9IHJlc3BvbnNlRGF0YS5jb3B5KGJ1ZmZlciwgb2Zmc2V0LCAwLCBNYXRoLm1pbihsZW5ndGgsIHJlc3BvbnNlRGF0YS5sZW5ndGgpKTsKICAgICAgICBjb25zdCByZXMgPSByZXNwb25zZS5oZWFkZXJzLmdldCgiY29udGVudC1yYW5nZSIpOwogICAgICAgIGNvbnN0IHNpemVNYXRjaCA9IC9cLyhcZCspJC8uZXhlYyhyZXMgfHwgIiIpOwogICAgICAgIGlmIChzaXplTWF0Y2ggJiYgc2l6ZU1hdGNoWzFdKSB7CiAgICAgICAgICB0aGlzLl9zdGF0ID0geyBzaXplOiBwYXJzZUludChzaXplTWF0Y2hbMV0sIDEwKSB9OwogICAgICAgIH0KICAgICAgICByZXR1cm4geyBieXRlc1JlYWQ6IGJ5dGVzQ29waWVkLCBidWZmZXIgfTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIiR7dGhpcy51cmx9IGZldGNoIHJldHVybmVkIHN0YXR1cyAyMDAsIGV4cGVjdGVkIDIwNiIpOwogICAgICB9CiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKTsKICAgIH0KICAgIGFzeW5jIHJlYWRGaWxlKG9wdGlvbnMgPSB7fSkgewogICAgICBsZXQgZW5jb2Rpbmc7CiAgICAgIGxldCBvcHRzOwogICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICJzdHJpbmciKSB7CiAgICAgICAgZW5jb2RpbmcgPSBvcHRpb25zOwogICAgICAgIG9wdHMgPSB7fTsKICAgICAgfSBlbHNlIHsKICAgICAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7CiAgICAgICAgb3B0cyA9IG9wdGlvbnM7CiAgICAgICAgZGVsZXRlIG9wdHMuZW5jb2Rpbmc7CiAgICAgIH0KICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgIGNvbnN0IGFyZ3MgPSB7CiAgICAgICAgaGVhZGVycywKICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgIHJlZGlyZWN0OiAiZm9sbG93IiwKICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgc2lnbmFsLAogICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcywKICAgICAgICAuLi5vdmVycmlkZXMKICAgICAgfTsKICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgaWYgKCFyZXNwb25zZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiZ2VuZXJpYy1maWxlaGFuZGxlIGZhaWxlZCB0byBmZXRjaCIpOwogICAgICB9CiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkgewogICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSBmZXRjaGluZyAke3RoaXMudXJsfWApLCB7CiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cwogICAgICAgIH0pOwogICAgICB9CiAgICAgIGlmIChlbmNvZGluZyA9PT0gInV0ZjgiKSB7CiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTsKICAgICAgfQogICAgICBpZiAoZW5jb2RpbmcpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGVuY29kaW5nOiAke2VuY29kaW5nfWApOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICB9CiAgICBhc3luYyBzdGF0KCkgewogICAgICBpZiAoIXRoaXMuX3N0YXQpIHsKICAgICAgICBjb25zdCBidWYgPSBpbXBvcnRfYnVmZmVyMi5CdWZmZXIuYWxsb2NVbnNhZmUoMTApOwogICAgICAgIGF3YWl0IHRoaXMucmVhZChidWYsIDAsIDEwLCAwKTsKICAgICAgICBpZiAoIXRoaXMuX3N0YXQpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGRldGVybWluZSBzaXplIG9mIGZpbGUgYXQgJHt0aGlzLnVybH1gKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuX3N0YXQ7CiAgICB9CiAgICBhc3luYyBjbG9zZSgpIHsKICAgICAgcmV0dXJuOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9nZW5lcmljLWZpbGVoYW5kbGVAMy4xLjEvbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9lc20vYmxvYkZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXIzID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2dlbmVyaWMtZmlsZWhhbmRsZUAzLjEuMS9ub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2VzbS9maWxlaGFuZGxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmd6Zi1maWxlaGFuZGxlQDEuNC43L25vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmd6Zi1maWxlaGFuZGxlQDEuNC43L25vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2JnekZpbGVoYW5kbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9idWZmZXI2ID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JnemYtZmlsZWhhbmRsZUAxLjQuNy9ub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2VzbS91bnppcC1wYWtvLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYnVmZmVyNCA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CiAgdmFyIGltcG9ydF9wYWtvID0gX190b01vZHVsZShyZXF1aXJlX3Bha28oKSk7CiAgYXN5bmMgZnVuY3Rpb24gdW56aXAoaW5wdXREYXRhKSB7CiAgICB0cnkgewogICAgICBsZXQgc3RybTsKICAgICAgbGV0IHBvcyA9IDA7CiAgICAgIGxldCBpID0gMDsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGxldCB0b3RhbFNpemUgPSAwOwogICAgICBsZXQgaW5mbGF0b3I7CiAgICAgIGRvIHsKICAgICAgICBjb25zdCByZW1haW5pbmdJbnB1dCA9IGlucHV0RGF0YS5zdWJhcnJheShwb3MpOwogICAgICAgIGluZmxhdG9yID0gbmV3IGltcG9ydF9wYWtvLkluZmxhdGUoKTsKICAgICAgICAoeyBzdHJtIH0gPSBpbmZsYXRvcik7CiAgICAgICAgaW5mbGF0b3IucHVzaChyZW1haW5pbmdJbnB1dCwgaW1wb3J0X3Bha28uWl9TWU5DX0ZMVVNIKTsKICAgICAgICBpZiAoaW5mbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0b3IubXNnKTsKICAgICAgICB9CiAgICAgICAgcG9zICs9IHN0cm0ubmV4dF9pbjsKICAgICAgICBjaHVua3NbaV0gPSBpbmZsYXRvci5yZXN1bHQ7CiAgICAgICAgdG90YWxTaXplICs9IGNodW5rc1tpXS5sZW5ndGg7CiAgICAgICAgaSArPSAxOwogICAgICB9IHdoaWxlIChzdHJtLmF2YWlsX2luKTsKICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxTaXplKTsKICAgICAgZm9yIChsZXQgaTIgPSAwLCBvZmZzZXQgPSAwOyBpMiA8IGNodW5rcy5sZW5ndGg7IGkyKyspIHsKICAgICAgICByZXN1bHQuc2V0KGNodW5rc1tpMl0sIG9mZnNldCk7CiAgICAgICAgb2Zmc2V0ICs9IGNodW5rc1tpMl0ubGVuZ3RoOwogICAgICB9CiAgICAgIHJldHVybiBpbXBvcnRfYnVmZmVyNC5CdWZmZXIuZnJvbShyZXN1bHQpOwogICAgfSBjYXRjaCAoZSkgewogICAgICBpZiAoYCR7ZX1gLm1hdGNoKC9pbmNvcnJlY3QgaGVhZGVyIGNoZWNrLykpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInByb2JsZW0gZGVjb21wcmVzc2luZyBibG9jazogaW5jb3JyZWN0IGd6aXAgaGVhZGVyIGNoZWNrIik7CiAgICAgIH0KICAgICAgdGhyb3cgZTsKICAgIH0KICB9CiAgYXN5bmMgZnVuY3Rpb24gdW56aXBDaHVua1NsaWNlKGlucHV0RGF0YSwgY2h1bmspIHsKICAgIHRyeSB7CiAgICAgIGxldCBzdHJtOwogICAgICBjb25zdCB7IG1pbnYsIG1heHYgfSA9IGNodW5rOwogICAgICBsZXQgY3BvcyA9IG1pbnYuYmxvY2tQb3NpdGlvbjsKICAgICAgbGV0IGRwb3MgPSBtaW52LmRhdGFQb3NpdGlvbjsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGNvbnN0IGNwb3NpdGlvbnMgPSBbXTsKICAgICAgY29uc3QgZHBvc2l0aW9ucyA9IFtdOwogICAgICBsZXQgdG90YWxTaXplID0gMDsKICAgICAgbGV0IGkgPSAwOwogICAgICBkbyB7CiAgICAgICAgY29uc3QgcmVtYWluaW5nSW5wdXQgPSBpbnB1dERhdGEuc3ViYXJyYXkoY3BvcyAtIG1pbnYuYmxvY2tQb3NpdGlvbik7CiAgICAgICAgY29uc3QgaW5mbGF0b3IgPSBuZXcgaW1wb3J0X3Bha28uSW5mbGF0ZSgpOwogICAgICAgICh7IHN0cm0gfSA9IGluZmxhdG9yKTsKICAgICAgICBpbmZsYXRvci5wdXNoKHJlbWFpbmluZ0lucHV0LCBpbXBvcnRfcGFrby5aX1NZTkNfRkxVU0gpOwogICAgICAgIGlmIChpbmZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmZsYXRvci5tc2cpOwogICAgICAgIH0KICAgICAgICBjb25zdCBidWZmZXIyID0gaW5mbGF0b3IucmVzdWx0OwogICAgICAgIGNodW5rcy5wdXNoKGJ1ZmZlcjIpOwogICAgICAgIGxldCBsZW4gPSBidWZmZXIyLmxlbmd0aDsKICAgICAgICBjcG9zaXRpb25zLnB1c2goY3Bvcyk7CiAgICAgICAgZHBvc2l0aW9ucy5wdXNoKGRwb3MpOwogICAgICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAxICYmIG1pbnYuZGF0YVBvc2l0aW9uKSB7CiAgICAgICAgICBjaHVua3NbMF0gPSBjaHVua3NbMF0uc3ViYXJyYXkobWludi5kYXRhUG9zaXRpb24pOwogICAgICAgICAgbGVuID0gY2h1bmtzWzBdLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgY29uc3Qgb3JpZ0Nwb3MgPSBjcG9zOwogICAgICAgIGNwb3MgKz0gc3RybS5uZXh0X2luOwogICAgICAgIGRwb3MgKz0gbGVuOwogICAgICAgIGlmIChvcmlnQ3BvcyA+PSBtYXh2LmJsb2NrUG9zaXRpb24pIHsKICAgICAgICAgIGNodW5rc1tpXSA9IGNodW5rc1tpXS5zdWJhcnJheSgwLCBtYXh2LmJsb2NrUG9zaXRpb24gPT09IG1pbnYuYmxvY2tQb3NpdGlvbiA/IG1heHYuZGF0YVBvc2l0aW9uIC0gbWludi5kYXRhUG9zaXRpb24gKyAxIDogbWF4di5kYXRhUG9zaXRpb24gKyAxKTsKICAgICAgICAgIGNwb3NpdGlvbnMucHVzaChjcG9zKTsKICAgICAgICAgIGRwb3NpdGlvbnMucHVzaChkcG9zKTsKICAgICAgICAgIHRvdGFsU2l6ZSArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIHRvdGFsU2l6ZSArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgIGkrKzsKICAgICAgfSB3aGlsZSAoc3RybS5hdmFpbF9pbik7CiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsU2l6ZSk7CiAgICAgIGZvciAobGV0IGkyID0gMCwgb2Zmc2V0ID0gMDsgaTIgPCBjaHVua3MubGVuZ3RoOyBpMisrKSB7CiAgICAgICAgcmVzdWx0LnNldChjaHVua3NbaTJdLCBvZmZzZXQpOwogICAgICAgIG9mZnNldCArPSBjaHVua3NbaTJdLmxlbmd0aDsKICAgICAgfQogICAgICBjb25zdCBidWZmZXIgPSBpbXBvcnRfYnVmZmVyNC5CdWZmZXIuZnJvbShyZXN1bHQpOwogICAgICByZXR1cm4geyBidWZmZXIsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgaWYgKGAke2V9YC5tYXRjaCgvaW5jb3JyZWN0IGhlYWRlciBjaGVjay8pKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJwcm9ibGVtIGRlY29tcHJlc3NpbmcgYmxvY2s6IGluY29ycmVjdCBnemlwIGhlYWRlciBjaGVjayIpOwogICAgICB9CiAgICAgIHRocm93IGU7CiAgICB9CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmd6Zi1maWxlaGFuZGxlQDEuNC43L25vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZXNtL2d6aUluZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfbG9uZyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb25nKCkpOwogIHZhciBpbXBvcnRfYnVmZmVyNSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9idWZmZXIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCt0YWJpeEAxLjUuMTEvbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS91dGlsLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGxvbmdUb051bWJlcihsb25nKSB7CiAgICBpZiAobG9uZy5ncmVhdGVyVGhhbihOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgfHwgbG9uZy5sZXNzVGhhbihOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbnRlZ2VyIG92ZXJmbG93Iik7CiAgICB9CiAgICByZXR1cm4gbG9uZy50b051bWJlcigpOwogIH0KICB2YXIgQWJvcnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3IgewogIH07CiAgZnVuY3Rpb24gY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpIHsKICAgIGlmICghc2lnbmFsKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmIChzaWduYWwuYWJvcnRlZCkgewogICAgICBpZiAodHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCJhYm9ydGVkIiwgIkFib3J0RXJyb3IiKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCBlID0gbmV3IEFib3J0RXJyb3IoImFib3J0ZWQiKTsKICAgICAgICBlLmNvZGUgPSAiRVJSX0FCT1JURUQiOwogICAgICAgIHRocm93IGU7CiAgICAgIH0KICAgIH0KICB9CiAgZnVuY3Rpb24gY2FuTWVyZ2VCbG9ja3MoY2h1bmsxLCBjaHVuazIpIHsKICAgIHJldHVybiBjaHVuazIubWludi5ibG9ja1Bvc2l0aW9uIC0gY2h1bmsxLm1heHYuYmxvY2tQb3NpdGlvbiA8IDY1ZTMgJiYgY2h1bmsyLm1heHYuYmxvY2tQb3NpdGlvbiAtIGNodW5rMS5taW52LmJsb2NrUG9zaXRpb24gPCA1ZTY7CiAgfQogIGZ1bmN0aW9uIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbG93ZXN0KSB7CiAgICBjb25zdCBtZXJnZWRDaHVua3MgPSBbXTsKICAgIGxldCBsYXN0Q2h1bmsgPSBudWxsOwogICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIGNodW5rczsKICAgIH0KICAgIGNodW5rcy5zb3J0KGZ1bmN0aW9uKGMwLCBjMSkgewogICAgICBjb25zdCBkaWYgPSBjMC5taW52LmJsb2NrUG9zaXRpb24gLSBjMS5taW52LmJsb2NrUG9zaXRpb247CiAgICAgIGlmIChkaWYgIT09IDApIHsKICAgICAgICByZXR1cm4gZGlmOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBjMC5taW52LmRhdGFQb3NpdGlvbiAtIGMxLm1pbnYuZGF0YVBvc2l0aW9uOwogICAgICB9CiAgICB9KTsKICAgIGNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gewogICAgICBpZiAoIWxvd2VzdCB8fCBjaHVuay5tYXh2LmNvbXBhcmVUbyhsb3dlc3QpID4gMCkgewogICAgICAgIGlmIChsYXN0Q2h1bmsgPT09IG51bGwpIHsKICAgICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGNodW5rKTsKICAgICAgICAgIGxhc3RDaHVuayA9IGNodW5rOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoY2FuTWVyZ2VCbG9ja3MobGFzdENodW5rLCBjaHVuaykpIHsKICAgICAgICAgICAgaWYgKGNodW5rLm1heHYuY29tcGFyZVRvKGxhc3RDaHVuay5tYXh2KSA+IDApIHsKICAgICAgICAgICAgICBsYXN0Q2h1bmsubWF4diA9IGNodW5rLm1heHY7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGNodW5rKTsKICAgICAgICAgICAgbGFzdENodW5rID0gY2h1bms7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9KTsKICAgIHJldHVybiBtZXJnZWRDaHVua3M7CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdGJpLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfbG9uZzIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbG9uZygpKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK3RhYml4QDEuNS4xMS9ub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3ZpcnR1YWxPZmZzZXQuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIFZpcnR1YWxPZmZzZXQgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3RvcihibG9ja1Bvc2l0aW9uLCBkYXRhUG9zaXRpb24pIHsKICAgICAgdGhpcy5ibG9ja1Bvc2l0aW9uID0gYmxvY2tQb3NpdGlvbjsKICAgICAgdGhpcy5kYXRhUG9zaXRpb24gPSBkYXRhUG9zaXRpb247CiAgICB9CiAgICB0b1N0cmluZygpIHsKICAgICAgcmV0dXJuIGAke3RoaXMuYmxvY2tQb3NpdGlvbn06JHt0aGlzLmRhdGFQb3NpdGlvbn1gOwogICAgfQogICAgY29tcGFyZVRvKGIpIHsKICAgICAgcmV0dXJuIHRoaXMuYmxvY2tQb3NpdGlvbiAtIGIuYmxvY2tQb3NpdGlvbiB8fCB0aGlzLmRhdGFQb3NpdGlvbiAtIGIuZGF0YVBvc2l0aW9uOwogICAgfQogICAgc3RhdGljIG1pbiguLi5hcmdzKSB7CiAgICAgIGxldCBtaW47CiAgICAgIGxldCBpID0gMDsKICAgICAgZm9yICg7ICFtaW47IGkgKz0gMSkgewogICAgICAgIG1pbiA9IGFyZ3NbaV07CiAgICAgIH0KICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgaWYgKG1pbi5jb21wYXJlVG8oYXJnc1tpXSkgPiAwKSB7CiAgICAgICAgICBtaW4gPSBhcmdzW2ldOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gbWluOwogICAgfQogIH07CiAgZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCBvZmZzZXQgPSAwLCBiaWdlbmRpYW4gPSBmYWxzZSkgewogICAgaWYgKGJpZ2VuZGlhbikgewogICAgICB0aHJvdyBuZXcgRXJyb3IoImJpZy1lbmRpYW4gdmlydHVhbCBmaWxlIG9mZnNldHMgbm90IGltcGxlbWVudGVkIik7CiAgICB9CiAgICByZXR1cm4gbmV3IFZpcnR1YWxPZmZzZXQoYnl0ZXNbb2Zmc2V0ICsgN10gKiAxMDk5NTExNjI3Nzc2ICsgYnl0ZXNbb2Zmc2V0ICsgNl0gKiA0Mjk0OTY3Mjk2ICsgYnl0ZXNbb2Zmc2V0ICsgNV0gKiAxNjc3NzIxNiArIGJ5dGVzW29mZnNldCArIDRdICogNjU1MzYgKyBieXRlc1tvZmZzZXQgKyAzXSAqIDI1NiArIGJ5dGVzW29mZnNldCArIDJdLCBieXRlc1tvZmZzZXQgKyAxXSA8PCA4IHwgYnl0ZXNbb2Zmc2V0XSk7CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vY2h1bmsuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIENodW5rID0gY2xhc3MgewogICAgY29uc3RydWN0b3IobWludiwgbWF4diwgYmluLCBmZXRjaGVkU2l6ZSA9IHZvaWQgMCkgewogICAgICB0aGlzLm1pbnYgPSBtaW52OwogICAgICB0aGlzLm1heHYgPSBtYXh2OwogICAgICB0aGlzLmJpbiA9IGJpbjsKICAgICAgdGhpcy5fZmV0Y2hlZFNpemUgPSBmZXRjaGVkU2l6ZTsKICAgIH0KICAgIHRvVW5pcXVlU3RyaW5nKCkgewogICAgICByZXR1cm4gYCR7dGhpcy5taW52fS4uJHt0aGlzLm1heHZ9IChiaW4gJHt0aGlzLmJpbn0sIGZldGNoZWRTaXplICR7dGhpcy5mZXRjaGVkU2l6ZSgpfSlgOwogICAgfQogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiB0aGlzLnRvVW5pcXVlU3RyaW5nKCk7CiAgICB9CiAgICBjb21wYXJlVG8oYikgewogICAgICByZXR1cm4gdGhpcy5taW52LmNvbXBhcmVUbyhiLm1pbnYpIHx8IHRoaXMubWF4di5jb21wYXJlVG8oYi5tYXh2KSB8fCB0aGlzLmJpbiAtIGIuYmluOwogICAgfQogICAgZmV0Y2hlZFNpemUoKSB7CiAgICAgIGlmICh0aGlzLl9mZXRjaGVkU2l6ZSAhPT0gdm9pZCAwKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoZWRTaXplOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLm1heHYuYmxvY2tQb3NpdGlvbiArICgxIDw8IDE2KSAtIHRoaXMubWludi5ibG9ja1Bvc2l0aW9uOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCt0YWJpeEAxLjUuMTEvbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9pbmRleEZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIEluZGV4RmlsZSA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKHsgZmlsZWhhbmRsZSwgcmVuYW1lUmVmU2VxcyA9IChuKSA9PiBuIH0pIHsKICAgICAgdGhpcy5maWxlaGFuZGxlID0gZmlsZWhhbmRsZTsKICAgICAgdGhpcy5yZW5hbWVSZWZTZXEgPSByZW5hbWVSZWZTZXFzOwogICAgfQogICAgYXN5bmMgZ2V0TWV0YWRhdGEob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgaW5kaWNlcywgLi4ucmVzdCB9ID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgcmV0dXJuIHJlc3Q7CiAgICB9CiAgICBfZmluZEZpcnN0RGF0YShjdXJyZW50RmRsLCB2aXJ0dWFsT2Zmc2V0KSB7CiAgICAgIGlmIChjdXJyZW50RmRsKSB7CiAgICAgICAgcmV0dXJuIGN1cnJlbnRGZGwuY29tcGFyZVRvKHZpcnR1YWxPZmZzZXQpID4gMCA/IHZpcnR1YWxPZmZzZXQgOiBjdXJyZW50RmRsOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB2aXJ0dWFsT2Zmc2V0OwogICAgICB9CiAgICB9CiAgICBhc3luYyBwYXJzZShvcHRzID0ge30pIHsKICAgICAgaWYgKCF0aGlzLnBhcnNlUCkgewogICAgICAgIHRoaXMucGFyc2VQID0gdGhpcy5fcGFyc2Uob3B0cykuY2F0Y2goKGUpID0+IHsKICAgICAgICAgIHRoaXMucGFyc2VQID0gdm9pZCAwOwogICAgICAgICAgdGhyb3cgZTsKICAgICAgICB9KTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5wYXJzZVA7CiAgICB9CiAgICBhc3luYyBoYXNSZWZTZXEoc2VxSWQsIG9wdHMgPSB7fSkgewogICAgICByZXR1cm4gISEoKGF3YWl0IHRoaXMucGFyc2Uob3B0cykpLmluZGljZXNbc2VxSWRdIHx8IHt9KS5iaW5JbmRleDsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrdGFiaXhAMS41LjExL25vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdGJpLmpzCiAgdmFyIFRCSV9NQUdJQyA9IDIxNTc4MzI0OwogIHZhciBUQURfTElEWF9TSElGVCA9IDE0OwogIGZ1bmN0aW9uIHJlZzJiaW5zKGJlZywgZW5kKSB7CiAgICBiZWcgKz0gMTsKICAgIGVuZCAtPSAxOwogICAgcmV0dXJuIFsKICAgICAgWzAsIDBdLAogICAgICBbMSArIChiZWcgPj4gMjYpLCAxICsgKGVuZCA+PiAyNildLAogICAgICBbOSArIChiZWcgPj4gMjMpLCA5ICsgKGVuZCA+PiAyMyldLAogICAgICBbNzMgKyAoYmVnID4+IDIwKSwgNzMgKyAoZW5kID4+IDIwKV0sCiAgICAgIFs1ODUgKyAoYmVnID4+IDE3KSwgNTg1ICsgKGVuZCA+PiAxNyldLAogICAgICBbNDY4MSArIChiZWcgPj4gMTQpLCA0NjgxICsgKGVuZCA+PiAxNCldCiAgICBdOwogIH0KICB2YXIgVGFiaXhJbmRleCA9IGNsYXNzIGV4dGVuZHMgSW5kZXhGaWxlIHsKICAgIGFzeW5jIGxpbmVDb3VudChyZWZOYW1lLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV07CiAgICAgIGNvbnN0IGlkeCA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFpZHgpIHsKICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KICAgICAgY29uc3QgeyBzdGF0cyB9ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoc3RhdHMpIHsKICAgICAgICByZXR1cm4gc3RhdHMubGluZUNvdW50OwogICAgICB9CiAgICAgIHJldHVybiAtMTsKICAgIH0KICAgIGFzeW5jIF9wYXJzZShvcHRzID0ge30pIHsKICAgICAgY29uc3QgYnVmID0gYXdhaXQgdGhpcy5maWxlaGFuZGxlLnJlYWRGaWxlKG9wdHMpOwogICAgICBjb25zdCBieXRlcyA9IGF3YWl0IHVuemlwKGJ1Zik7CiAgICAgIGNoZWNrQWJvcnRTaWduYWwob3B0cy5zaWduYWwpOwogICAgICBpZiAoYnl0ZXMucmVhZFVJbnQzMkxFKDApICE9PSBUQklfTUFHSUMpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIFRCSSBmaWxlIik7CiAgICAgIH0KICAgICAgY29uc3QgcmVmQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRSg0KTsKICAgICAgY29uc3QgZm9ybWF0RmxhZ3MgPSBieXRlcy5yZWFkSW50MzJMRSg4KTsKICAgICAgY29uc3QgY29vcmRpbmF0ZVR5cGUgPSBmb3JtYXRGbGFncyAmIDY1NTM2ID8gInplcm8tYmFzZWQtaGFsZi1vcGVuIiA6ICIxLWJhc2VkLWNsb3NlZCI7CiAgICAgIGNvbnN0IGZvcm1hdE9wdHMgPSB7CiAgICAgICAgMDogImdlbmVyaWMiLAogICAgICAgIDE6ICJTQU0iLAogICAgICAgIDI6ICJWQ0YiCiAgICAgIH07CiAgICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdE9wdHNbZm9ybWF0RmxhZ3MgJiAxNV07CiAgICAgIGlmICghZm9ybWF0KSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIFRhYml4IHByZXNldCBmb3JtYXQgZmxhZ3MgJHtmb3JtYXRGbGFnc31gKTsKICAgICAgfQogICAgICBjb25zdCBjb2x1bW5OdW1iZXJzID0gewogICAgICAgIHJlZjogYnl0ZXMucmVhZEludDMyTEUoMTIpLAogICAgICAgIHN0YXJ0OiBieXRlcy5yZWFkSW50MzJMRSgxNiksCiAgICAgICAgZW5kOiBieXRlcy5yZWFkSW50MzJMRSgyMCkKICAgICAgfTsKICAgICAgY29uc3QgbWV0YVZhbHVlID0gYnl0ZXMucmVhZEludDMyTEUoMjQpOwogICAgICBjb25zdCBkZXB0aCA9IDU7CiAgICAgIGNvbnN0IG1heEJpbk51bWJlciA9ICgoMSA8PCAoZGVwdGggKyAxKSAqIDMpIC0gMSkgLyA3OwogICAgICBjb25zdCBtYXhSZWZMZW5ndGggPSAyICoqICgxNCArIGRlcHRoICogMyk7CiAgICAgIGNvbnN0IG1ldGFDaGFyID0gbWV0YVZhbHVlID8gU3RyaW5nLmZyb21DaGFyQ29kZShtZXRhVmFsdWUpIDogbnVsbDsKICAgICAgY29uc3Qgc2tpcExpbmVzID0gYnl0ZXMucmVhZEludDMyTEUoMjgpOwogICAgICBjb25zdCBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDMyKTsKICAgICAgY29uc3QgeyByZWZOYW1lVG9JZCwgcmVmSWRUb05hbWUgfSA9IHRoaXMuX3BhcnNlTmFtZUJ5dGVzKGJ5dGVzLnNsaWNlKDM2LCAzNiArIG5hbWVTZWN0aW9uTGVuZ3RoKSk7CiAgICAgIGxldCBjdXJyT2Zmc2V0ID0gMzYgKyBuYW1lU2VjdGlvbkxlbmd0aDsKICAgICAgbGV0IGZpcnN0RGF0YUxpbmU7CiAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgQXJyYXkocmVmQ291bnQpLmZpbGwoMCkubWFwKCgpID0+IHsKICAgICAgICBjb25zdCBiaW5Db3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICBjb25zdCBiaW5JbmRleCA9IHt9OwogICAgICAgIGxldCBzdGF0czsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJpbkNvdW50OyBqICs9IDEpIHsKICAgICAgICAgIGNvbnN0IGJpbiA9IGJ5dGVzLnJlYWRVSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgIGlmIChiaW4gPiBtYXhCaW5OdW1iZXIgKyAxKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigidGFiaXggaW5kZXggY29udGFpbnMgdG9vIG1hbnkgYmlucywgcGxlYXNlIHVzZSBhIENTSSBpbmRleCIpOwogICAgICAgICAgfSBlbHNlIGlmIChiaW4gPT09IG1heEJpbk51bWJlciArIDEpIHsKICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICAgIGlmIChjaHVua0NvdW50ID09PSAyKSB7CiAgICAgICAgICAgICAgc3RhdHMgPSB0aGlzLnBhcnNlUHNldWRvQmluKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDE2ICogY2h1bmtDb3VudDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgICAgICBjb25zdCBjaHVua3MgPSBuZXcgQXJyYXkoY2h1bmtDb3VudCk7CiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2h1bmtDb3VudDsgayArPSAxKSB7CiAgICAgICAgICAgICAgY29uc3QgdSA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldCk7CiAgICAgICAgICAgICAgY29uc3QgdiA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldCArIDgpOwogICAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgICAgZmlyc3REYXRhTGluZSA9IHRoaXMuX2ZpbmRGaXJzdERhdGEoZmlyc3REYXRhTGluZSwgdSk7CiAgICAgICAgICAgICAgY2h1bmtzW2tdID0gbmV3IENodW5rKHUsIHYsIGJpbik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYmluSW5kZXhbYmluXSA9IGNodW5rczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgbGluZWFyQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgbGluZWFySW5kZXggPSBuZXcgQXJyYXkobGluZWFyQ291bnQpOwogICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGluZWFyQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgbGluZWFySW5kZXhba10gPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgY3Vyck9mZnNldCArPSA4OwogICAgICAgICAgZmlyc3REYXRhTGluZSA9IHRoaXMuX2ZpbmRGaXJzdERhdGEoZmlyc3REYXRhTGluZSwgbGluZWFySW5kZXhba10pOwogICAgICAgIH0KICAgICAgICByZXR1cm4geyBiaW5JbmRleCwgbGluZWFySW5kZXgsIHN0YXRzIH07CiAgICAgIH0pOwogICAgICByZXR1cm4gewogICAgICAgIGluZGljZXMsCiAgICAgICAgbWV0YUNoYXIsCiAgICAgICAgbWF4QmluTnVtYmVyLAogICAgICAgIG1heFJlZkxlbmd0aCwKICAgICAgICBza2lwTGluZXMsCiAgICAgICAgZmlyc3REYXRhTGluZSwKICAgICAgICBjb2x1bW5OdW1iZXJzLAogICAgICAgIGNvb3JkaW5hdGVUeXBlLAogICAgICAgIGZvcm1hdCwKICAgICAgICByZWZJZFRvTmFtZSwKICAgICAgICByZWZOYW1lVG9JZCwKICAgICAgICBtYXhCbG9ja1NpemU6IDEgPDwgMTYKICAgICAgfTsKICAgIH0KICAgIHBhcnNlUHNldWRvQmluKGJ5dGVzLCBvZmZzZXQpIHsKICAgICAgY29uc3QgbGluZUNvdW50ID0gbG9uZ1RvTnVtYmVyKGltcG9ydF9sb25nMi5kZWZhdWx0LmZyb21CeXRlc0xFKGJ5dGVzLnNsaWNlKG9mZnNldCArIDE2LCBvZmZzZXQgKyAyNCksIHRydWUpKTsKICAgICAgcmV0dXJuIHsgbGluZUNvdW50IH07CiAgICB9CiAgICBfcGFyc2VOYW1lQnl0ZXMobmFtZXNCeXRlcykgewogICAgICBsZXQgY3VyclJlZklkID0gMDsKICAgICAgbGV0IGN1cnJOYW1lU3RhcnQgPSAwOwogICAgICBjb25zdCByZWZJZFRvTmFtZSA9IFtdOwogICAgICBjb25zdCByZWZOYW1lVG9JZCA9IHt9OwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzQnl0ZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBpZiAoIW5hbWVzQnl0ZXNbaV0pIHsKICAgICAgICAgIGlmIChjdXJyTmFtZVN0YXJ0IDwgaSkgewogICAgICAgICAgICBsZXQgcmVmTmFtZSA9IG5hbWVzQnl0ZXMudG9TdHJpbmcoInV0ZjgiLCBjdXJyTmFtZVN0YXJ0LCBpKTsKICAgICAgICAgICAgcmVmTmFtZSA9IHRoaXMucmVuYW1lUmVmU2VxKHJlZk5hbWUpOwogICAgICAgICAgICByZWZJZFRvTmFtZVtjdXJyUmVmSWRdID0gcmVmTmFtZTsKICAgICAgICAgICAgcmVmTmFtZVRvSWRbcmVmTmFtZV0gPSBjdXJyUmVmSWQ7CiAgICAgICAgICB9CiAgICAgICAgICBjdXJyTmFtZVN0YXJ0ID0gaSArIDE7CiAgICAgICAgICBjdXJyUmVmSWQgKz0gMTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH07CiAgICB9CiAgICBhc3luYyBibG9ja3NGb3JSYW5nZShyZWZOYW1lLCBtaW4sIG1heCwgb3B0cyA9IHt9KSB7CiAgICAgIGlmIChtaW4gPCAwKSB7CiAgICAgICAgbWluID0gMDsKICAgICAgfQogICAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpOwogICAgICBpZiAoIWluZGV4RGF0YSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCByZWZJZCA9IGluZGV4RGF0YS5yZWZOYW1lVG9JZFtyZWZOYW1lXTsKICAgICAgY29uc3QgYmEgPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghYmEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3QgbWluT2Zmc2V0ID0gYmEubGluZWFySW5kZXgubGVuZ3RoID8gYmEubGluZWFySW5kZXhbbWluID4+IFRBRF9MSURYX1NISUZUID49IGJhLmxpbmVhckluZGV4Lmxlbmd0aCA/IGJhLmxpbmVhckluZGV4Lmxlbmd0aCAtIDEgOiBtaW4gPj4gVEFEX0xJRFhfU0hJRlRdIDogbmV3IFZpcnR1YWxPZmZzZXQoMCwgMCk7CiAgICAgIGlmICghbWluT2Zmc2V0KSB7CiAgICAgICAgY29uc29sZS53YXJuKCJxdWVyeWluZyBvdXRzaWRlIG9mIHBvc3NpYmxlIHRhYml4IHJhbmdlIik7CiAgICAgIH0KICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdCaW5zID0gcmVnMmJpbnMobWluLCBtYXgpOwogICAgICBjb25zdCBjaHVua3MgPSBbXTsKICAgICAgZm9yIChjb25zdCBbc3RhcnQsIGVuZF0gb2Ygb3ZlcmxhcHBpbmdCaW5zKSB7CiAgICAgICAgZm9yIChsZXQgYmluID0gc3RhcnQ7IGJpbiA8PSBlbmQ7IGJpbisrKSB7CiAgICAgICAgICBpZiAoYmEuYmluSW5kZXhbYmluXSkgewogICAgICAgICAgICBjb25zdCBiaW5DaHVua3MgPSBiYS5iaW5JbmRleFtiaW5dOwogICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGJpbkNodW5rcy5sZW5ndGg7ICsrYykgewogICAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBDaHVuayhiaW5DaHVua3NbY10ubWludiwgYmluQ2h1bmtzW2NdLm1heHYsIGJpbikpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnN0IG5pbnR2ID0gYmEubGluZWFySW5kZXgubGVuZ3RoOwogICAgICBsZXQgbG93ZXN0ID0gbnVsbDsKICAgICAgY29uc3QgbWluTGluID0gTWF0aC5taW4obWluID4+IDE0LCBuaW50diAtIDEpOwogICAgICBjb25zdCBtYXhMaW4gPSBNYXRoLm1pbihtYXggPj4gMTQsIG5pbnR2IC0gMSk7CiAgICAgIGZvciAobGV0IGkgPSBtaW5MaW47IGkgPD0gbWF4TGluOyArK2kpIHsKICAgICAgICBjb25zdCB2cCA9IGJhLmxpbmVhckluZGV4W2ldOwogICAgICAgIGlmICh2cCkgewogICAgICAgICAgaWYgKCFsb3dlc3QgfHwgdnAuY29tcGFyZVRvKGxvd2VzdCkgPCAwKSB7CiAgICAgICAgICAgIGxvd2VzdCA9IHZwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gb3B0aW1pemVDaHVua3MoY2h1bmtzLCBsb3dlc3QpOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCt0YWJpeEAxLjUuMTEvbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9jc2kuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb25nMyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb25nKCkpOwogIHZhciBDU0kxX01BR0lDID0gMjE1ODI2NTk7CiAgdmFyIENTSTJfTUFHSUMgPSAzODM1OTg3NTsKICBmdW5jdGlvbiBsc2hpZnQobnVtLCBiaXRzKSB7CiAgICByZXR1cm4gbnVtICogMiAqKiBiaXRzOwogIH0KICBmdW5jdGlvbiByc2hpZnQobnVtLCBiaXRzKSB7CiAgICByZXR1cm4gTWF0aC5mbG9vcihudW0gLyAyICoqIGJpdHMpOwogIH0KICB2YXIgQ1NJID0gY2xhc3MgZXh0ZW5kcyBJbmRleEZpbGUgewogICAgY29uc3RydWN0b3IoYXJncykgewogICAgICBzdXBlcihhcmdzKTsKICAgICAgdGhpcy5tYXhCaW5OdW1iZXIgPSAwOwogICAgICB0aGlzLmRlcHRoID0gMDsKICAgICAgdGhpcy5taW5TaGlmdCA9IDA7CiAgICB9CiAgICBhc3luYyBsaW5lQ291bnQocmVmTmFtZSwgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBpZHggPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghaWR4KSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHsgc3RhdHMgfSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKHN0YXRzKSB7CiAgICAgICAgcmV0dXJuIHN0YXRzLmxpbmVDb3VudDsKICAgICAgfQogICAgICByZXR1cm4gLTE7CiAgICB9CiAgICBhc3luYyBpbmRleENvdigpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJDU0kgaW5kZXhlcyBkbyBub3Qgc3VwcG9ydCBpbmRleGNvdiIpOwogICAgfQogICAgcGFyc2VBdXhEYXRhKGJ5dGVzLCBvZmZzZXQpIHsKICAgICAgY29uc3QgZm9ybWF0RmxhZ3MgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQpOwogICAgICBjb25zdCBjb29yZGluYXRlVHlwZSA9IGZvcm1hdEZsYWdzICYgNjU1MzYgPyAiemVyby1iYXNlZC1oYWxmLW9wZW4iIDogIjEtYmFzZWQtY2xvc2VkIjsKICAgICAgY29uc3QgZm9ybWF0ID0geyAwOiAiZ2VuZXJpYyIsIDE6ICJTQU0iLCAyOiAiVkNGIiB9W2Zvcm1hdEZsYWdzICYgMTVdOwogICAgICBpZiAoIWZvcm1hdCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBUYWJpeCBwcmVzZXQgZm9ybWF0IGZsYWdzICR7Zm9ybWF0RmxhZ3N9YCk7CiAgICAgIH0KICAgICAgY29uc3QgY29sdW1uTnVtYmVycyA9IHsKICAgICAgICByZWY6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDQpLAogICAgICAgIHN0YXJ0OiBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyA4KSwKICAgICAgICBlbmQ6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDEyKQogICAgICB9OwogICAgICBjb25zdCBtZXRhVmFsdWUgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAxNik7CiAgICAgIGNvbnN0IG1ldGFDaGFyID0gbWV0YVZhbHVlID8gU3RyaW5nLmZyb21DaGFyQ29kZShtZXRhVmFsdWUpIDogbnVsbDsKICAgICAgY29uc3Qgc2tpcExpbmVzID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMjApOwogICAgICBjb25zdCBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDI0KTsKICAgICAgY29uc3QgeyByZWZJZFRvTmFtZSwgcmVmTmFtZVRvSWQgfSA9IHRoaXMuX3BhcnNlTmFtZUJ5dGVzKGJ5dGVzLnNsaWNlKG9mZnNldCArIDI4LCBvZmZzZXQgKyAyOCArIG5hbWVTZWN0aW9uTGVuZ3RoKSk7CiAgICAgIHJldHVybiB7CiAgICAgICAgcmVmSWRUb05hbWUsCiAgICAgICAgcmVmTmFtZVRvSWQsCiAgICAgICAgc2tpcExpbmVzLAogICAgICAgIG1ldGFDaGFyLAogICAgICAgIGNvbHVtbk51bWJlcnMsCiAgICAgICAgZm9ybWF0LAogICAgICAgIGNvb3JkaW5hdGVUeXBlCiAgICAgIH07CiAgICB9CiAgICBfcGFyc2VOYW1lQnl0ZXMobmFtZXNCeXRlcykgewogICAgICBsZXQgY3VyclJlZklkID0gMDsKICAgICAgbGV0IGN1cnJOYW1lU3RhcnQgPSAwOwogICAgICBjb25zdCByZWZJZFRvTmFtZSA9IFtdOwogICAgICBjb25zdCByZWZOYW1lVG9JZCA9IHt9OwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzQnl0ZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBpZiAoIW5hbWVzQnl0ZXNbaV0pIHsKICAgICAgICAgIGlmIChjdXJyTmFtZVN0YXJ0IDwgaSkgewogICAgICAgICAgICBsZXQgcmVmTmFtZSA9IG5hbWVzQnl0ZXMudG9TdHJpbmcoInV0ZjgiLCBjdXJyTmFtZVN0YXJ0LCBpKTsKICAgICAgICAgICAgcmVmTmFtZSA9IHRoaXMucmVuYW1lUmVmU2VxKHJlZk5hbWUpOwogICAgICAgICAgICByZWZJZFRvTmFtZVtjdXJyUmVmSWRdID0gcmVmTmFtZTsKICAgICAgICAgICAgcmVmTmFtZVRvSWRbcmVmTmFtZV0gPSBjdXJyUmVmSWQ7CiAgICAgICAgICB9CiAgICAgICAgICBjdXJyTmFtZVN0YXJ0ID0gaSArIDE7CiAgICAgICAgICBjdXJyUmVmSWQgKz0gMTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH07CiAgICB9CiAgICBhc3luYyBfcGFyc2Uob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdW56aXAoYXdhaXQgdGhpcy5maWxlaGFuZGxlLnJlYWRGaWxlKG9wdHMpKTsKICAgICAgbGV0IGNzaVZlcnNpb247CiAgICAgIGlmIChieXRlcy5yZWFkVUludDMyTEUoMCkgPT09IENTSTFfTUFHSUMpIHsKICAgICAgICBjc2lWZXJzaW9uID0gMTsKICAgICAgfSBlbHNlIGlmIChieXRlcy5yZWFkVUludDMyTEUoMCkgPT09IENTSTJfTUFHSUMpIHsKICAgICAgICBjc2lWZXJzaW9uID0gMjsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIENTSSBmaWxlIik7CiAgICAgIH0KICAgICAgdGhpcy5taW5TaGlmdCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDQpOwogICAgICB0aGlzLmRlcHRoID0gYnl0ZXMucmVhZEludDMyTEUoOCk7CiAgICAgIHRoaXMubWF4QmluTnVtYmVyID0gKCgxIDw8ICh0aGlzLmRlcHRoICsgMSkgKiAzKSAtIDEpIC8gNzsKICAgICAgY29uc3QgbWF4UmVmTGVuZ3RoID0gMiAqKiAodGhpcy5taW5TaGlmdCArIHRoaXMuZGVwdGggKiAzKTsKICAgICAgY29uc3QgYXV4TGVuZ3RoID0gYnl0ZXMucmVhZEludDMyTEUoMTIpOwogICAgICBjb25zdCBhdXggPSBhdXhMZW5ndGggJiYgYXV4TGVuZ3RoID49IDMwID8gdGhpcy5wYXJzZUF1eERhdGEoYnl0ZXMsIDE2KSA6IHsKICAgICAgICByZWZJZFRvTmFtZTogW10sCiAgICAgICAgcmVmTmFtZVRvSWQ6IHt9LAogICAgICAgIG1ldGFDaGFyOiBudWxsLAogICAgICAgIGNvbHVtbk51bWJlcnM6IHsgcmVmOiAwLCBzdGFydDogMSwgZW5kOiAyIH0sCiAgICAgICAgY29vcmRpbmF0ZVR5cGU6ICJ6ZXJvLWJhc2VkLWhhbGYtb3BlbiIsCiAgICAgICAgZm9ybWF0OiAiZ2VuZXJpYyIKICAgICAgfTsKICAgICAgY29uc3QgcmVmQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRSgxNiArIGF1eExlbmd0aCk7CiAgICAgIGxldCBmaXJzdERhdGFMaW5lOwogICAgICBsZXQgY3Vyck9mZnNldCA9IDE2ICsgYXV4TGVuZ3RoICsgNDsKICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBBcnJheShyZWZDb3VudCkuZmlsbCgwKS5tYXAoKCkgPT4gewogICAgICAgIGNvbnN0IGJpbkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgIGNvbnN0IGJpbkluZGV4ID0ge307CiAgICAgICAgbGV0IHN0YXRzOwogICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmluQ291bnQ7IGogKz0gMSkgewogICAgICAgICAgY29uc3QgYmluID0gYnl0ZXMucmVhZFVJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgaWYgKGJpbiA+IHRoaXMubWF4QmluTnVtYmVyKSB7CiAgICAgICAgICAgIHN0YXRzID0gdGhpcy5wYXJzZVBzZXVkb0JpbihieXRlcywgY3Vyck9mZnNldCArIDQpOwogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQgKyA4ICsgNCArIDE2ICsgMTY7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjb25zdCBsb2Zmc2V0ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgNCk7CiAgICAgICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIGxvZmZzZXQpOwogICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCArIDEyKTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNjsKICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ291bnQpOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNodW5rQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgICAgIGNvbnN0IHUgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgICAgIGNvbnN0IHYgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQgKyA4KTsKICAgICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDE2OwogICAgICAgICAgICAgIGNodW5rc1trXSA9IG5ldyBDaHVuayh1LCB2LCBiaW4pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJpbkluZGV4W2Jpbl0gPSBjaHVua3M7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiB7IGJpbkluZGV4LCBzdGF0cyB9OwogICAgICB9KTsKICAgICAgcmV0dXJuIHsKICAgICAgICAuLi5hdXgsCiAgICAgICAgY3NpOiB0cnVlLAogICAgICAgIHJlZkNvdW50LAogICAgICAgIG1heEJsb2NrU2l6ZTogMSA8PCAxNiwKICAgICAgICBmaXJzdERhdGFMaW5lLAogICAgICAgIGNzaVZlcnNpb24sCiAgICAgICAgaW5kaWNlcywKICAgICAgICBkZXB0aDogdGhpcy5kZXB0aCwKICAgICAgICBtYXhCaW5OdW1iZXI6IHRoaXMubWF4QmluTnVtYmVyLAogICAgICAgIG1heFJlZkxlbmd0aAogICAgICB9OwogICAgfQogICAgcGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIG9mZnNldCkgewogICAgICBjb25zdCBsaW5lQ291bnQgPSBsb25nVG9OdW1iZXIoaW1wb3J0X2xvbmczLmRlZmF1bHQuZnJvbUJ5dGVzTEUoYnl0ZXMuc2xpY2Uob2Zmc2V0ICsgMjgsIG9mZnNldCArIDM2KSwgdHJ1ZSkpOwogICAgICByZXR1cm4geyBsaW5lQ291bnQgfTsKICAgIH0KICAgIGFzeW5jIGJsb2Nrc0ZvclJhbmdlKHJlZk5hbWUsIG1pbiwgbWF4LCBvcHRzID0ge30pIHsKICAgICAgaWYgKG1pbiA8IDApIHsKICAgICAgICBtaW4gPSAwOwogICAgICB9CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBiYSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFiYSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCBvdmVybGFwcGluZ0JpbnMgPSB0aGlzLnJlZzJiaW5zKG1pbiwgbWF4KTsKICAgICAgY29uc3QgY2h1bmtzID0gW107CiAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIG92ZXJsYXBwaW5nQmlucykgewogICAgICAgIGZvciAobGV0IGJpbiA9IHN0YXJ0OyBiaW4gPD0gZW5kOyBiaW4rKykgewogICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHsKICAgICAgICAgICAgY29uc3QgYmluQ2h1bmtzID0gYmEuYmluSW5kZXhbYmluXTsKICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBiaW5DaHVua3MubGVuZ3RoOyArK2MpIHsKICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQ2h1bmsoYmluQ2h1bmtzW2NdLm1pbnYsIGJpbkNodW5rc1tjXS5tYXh2LCBiaW4pKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gb3B0aW1pemVDaHVua3MoY2h1bmtzLCBuZXcgVmlydHVhbE9mZnNldCgwLCAwKSk7CiAgICB9CiAgICByZWcyYmlucyhiZWcsIGVuZCkgewogICAgICBiZWcgLT0gMTsKICAgICAgaWYgKGJlZyA8IDEpIHsKICAgICAgICBiZWcgPSAxOwogICAgICB9CiAgICAgIGlmIChlbmQgPiAyICoqIDUwKSB7CiAgICAgICAgZW5kID0gMiAqKiAzNDsKICAgICAgfQogICAgICBlbmQgLT0gMTsKICAgICAgbGV0IGwgPSAwOwogICAgICBsZXQgdCA9IDA7CiAgICAgIGxldCBzID0gdGhpcy5taW5TaGlmdCArIHRoaXMuZGVwdGggKiAzOwogICAgICBjb25zdCBiaW5zID0gW107CiAgICAgIGZvciAoOyBsIDw9IHRoaXMuZGVwdGg7IHMgLT0gMywgdCArPSBsc2hpZnQoMSwgbCAqIDMpLCBsICs9IDEpIHsKICAgICAgICBjb25zdCBiID0gdCArIHJzaGlmdChiZWcsIHMpOwogICAgICAgIGNvbnN0IGUgPSB0ICsgcnNoaWZ0KGVuZCwgcyk7CiAgICAgICAgaWYgKGUgLSBiICsgYmlucy5sZW5ndGggPiB0aGlzLm1heEJpbk51bWJlcikgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBxdWVyeSAke2JlZ30tJHtlbmR9IGlzIHRvbyBsYXJnZSBmb3IgY3VycmVudCBiaW5uaW5nIHNjaGVtZSAoc2hpZnQgJHt0aGlzLm1pblNoaWZ0fSwgZGVwdGggJHt0aGlzLmRlcHRofSksIHRyeSBhIHNtYWxsZXIgcXVlcnkgb3IgYSBjb2Fyc2VyIGluZGV4IGJpbm5pbmcgc2NoZW1lYCk7CiAgICAgICAgfQogICAgICAgIGJpbnMucHVzaChbYiwgZV0pOwogICAgICB9CiAgICAgIHJldHVybiBiaW5zOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCt0YWJpeEAxLjUuMTEvbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS90YWJpeEluZGV4ZWRGaWxlLmpzCiAgdmFyIGRlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09ICJ1bmRlZmluZWQiID8gbmV3IFRleHREZWNvZGVyKCJ1dGYtOCIpIDogdm9pZCAwOwogIGZ1bmN0aW9uIHRpbWVvdXQodGltZSkgewogICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUpKTsKICB9CiAgdmFyIFRhYml4SW5kZXhlZEZpbGUgPSBjbGFzcyB7CiAgICBjb25zdHJ1Y3Rvcih7IHBhdGgsIGZpbGVoYW5kbGUsIHRiaVBhdGgsIHRiaUZpbGVoYW5kbGUsIGNzaVBhdGgsIGNzaUZpbGVoYW5kbGUsIHlpZWxkVGltZSA9IDUwMCwgY2h1bmtTaXplTGltaXQgPSA1ZTcsIHJlbmFtZVJlZlNlcXMgPSAobikgPT4gbiwgY2h1bmtDYWNoZVNpemUgPSA1ICogMiAqKiAyMCB9KSB7CiAgICAgIGlmIChmaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5maWxlaGFuZGxlID0gZmlsZWhhbmRsZTsKICAgICAgfSBlbHNlIGlmIChwYXRoKSB7CiAgICAgICAgdGhpcy5maWxlaGFuZGxlID0gbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChwYXRoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHByb3ZpZGUgZWl0aGVyIGZpbGVoYW5kbGUgb3IgcGF0aCIpOwogICAgICB9CiAgICAgIGlmICh0YmlGaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBUYWJpeEluZGV4KHsKICAgICAgICAgIGZpbGVoYW5kbGU6IHRiaUZpbGVoYW5kbGUsCiAgICAgICAgICByZW5hbWVSZWZTZXFzCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSBpZiAoY3NpRmlsZWhhbmRsZSkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgQ1NJKHsKICAgICAgICAgIGZpbGVoYW5kbGU6IGNzaUZpbGVoYW5kbGUsCiAgICAgICAgICByZW5hbWVSZWZTZXFzCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSBpZiAodGJpUGF0aCkgewogICAgICAgIHRoaXMuaW5kZXggPSBuZXcgVGFiaXhJbmRleCh7CiAgICAgICAgICBmaWxlaGFuZGxlOiBuZXcgaW1wb3J0X2xvY2FsRmlsZS5kZWZhdWx0KHRiaVBhdGgpLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKGNzaVBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IENTSSh7CiAgICAgICAgICBmaWxlaGFuZGxlOiBuZXcgaW1wb3J0X2xvY2FsRmlsZS5kZWZhdWx0KGNzaVBhdGgpLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKHBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IFRhYml4SW5kZXgoewogICAgICAgICAgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9sb2NhbEZpbGUuZGVmYXVsdChgJHtwYXRofS50YmlgKSwKICAgICAgICAgIHJlbmFtZVJlZlNlcXMKICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHByb3ZpZGUgb25lIG9mIHRiaUZpbGVoYW5kbGUsIHRiaVBhdGgsIGNzaUZpbGVoYW5kbGUsIG9yIGNzaVBhdGgiKTsKICAgICAgfQogICAgICB0aGlzLmNodW5rU2l6ZUxpbWl0ID0gY2h1bmtTaXplTGltaXQ7CiAgICAgIHRoaXMucmVuYW1lUmVmU2VxID0gcmVuYW1lUmVmU2VxczsKICAgICAgdGhpcy55aWVsZFRpbWUgPSB5aWVsZFRpbWU7CiAgICAgIHRoaXMuY2h1bmtDYWNoZSA9IG5ldyBpbXBvcnRfYWJvcnRhYmxlX3Byb21pc2VfY2FjaGUuZGVmYXVsdCh7CiAgICAgICAgY2FjaGU6IG5ldyBpbXBvcnRfcXVpY2tfbHJ1LmRlZmF1bHQoeyBtYXhTaXplOiBNYXRoLmZsb29yKGNodW5rQ2FjaGVTaXplIC8gKDEgPDwgMTYpKSB9KSwKICAgICAgICBmaWxsOiAoYXJncywgc2lnbmFsKSA9PiB0aGlzLnJlYWRDaHVuayhhcmdzLCB7IHNpZ25hbCB9KQogICAgICB9KTsKICAgIH0KICAgIGFzeW5jIGdldExpbmVzKHJlZk5hbWUsIHN0YXJ0LCBlbmQsIG9wdHMpIHsKICAgICAgbGV0IHNpZ25hbDsKICAgICAgbGV0IG9wdGlvbnMgPSB7fTsKICAgICAgbGV0IGNhbGxiYWNrOwogICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibGluZSBjYWxsYmFjayBtdXN0IGJlIHByb3ZpZGVkIik7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgY2FsbGJhY2sgPSBvcHRzOwogICAgICB9IGVsc2UgewogICAgICAgIG9wdGlvbnMgPSBvcHRzOwogICAgICAgIGNhbGxiYWNrID0gb3B0cy5saW5lQ2FsbGJhY2s7CiAgICAgIH0KICAgICAgaWYgKHJlZk5hbWUgPT09IHZvaWQgMCkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIm11c3QgcHJvdmlkZSBhIHJlZmVyZW5jZSBzZXF1ZW5jZSBuYW1lIik7CiAgICAgIH0KICAgICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImxpbmUgY2FsbGJhY2sgbXVzdCBiZSBwcm92aWRlZCIpOwogICAgICB9CiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5pbmRleC5nZXRNZXRhZGF0YShvcHRpb25zKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICBpZiAoIXN0YXJ0KSB7CiAgICAgICAgc3RhcnQgPSAwOwogICAgICB9CiAgICAgIGlmICghZW5kKSB7CiAgICAgICAgZW5kID0gbWV0YWRhdGEubWF4UmVmTGVuZ3RoOwogICAgICB9CiAgICAgIGlmICghKHN0YXJ0IDw9IGVuZCkpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnZhbGlkIHN0YXJ0IGFuZCBlbmQgY29vcmRpbmF0ZXMuIHN0YXJ0IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGVuZCIpOwogICAgICB9CiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGNvbnN0IGNodW5rcyA9IGF3YWl0IHRoaXMuaW5kZXguYmxvY2tzRm9yUmFuZ2UocmVmTmFtZSwgc3RhcnQsIGVuZCwgb3B0aW9ucyk7CiAgICAgIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBjb25zdCBzaXplID0gY2h1bmtzW2ldLmZldGNoZWRTaXplKCk7CiAgICAgICAgaWYgKHNpemUgPiB0aGlzLmNodW5rU2l6ZUxpbWl0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBtdWNoIGRhdGEuIENodW5rIHNpemUgJHtzaXplLnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzIGV4Y2VlZHMgY2h1bmtTaXplTGltaXQgb2YgJHt0aGlzLmNodW5rU2l6ZUxpbWl0LnRvTG9jYWxlU3RyaW5nKCl9LmApOwogICAgICAgIH0KICAgICAgfQogICAgICBsZXQgbGFzdCA9IERhdGUubm93KCk7CiAgICAgIGZvciAobGV0IGNodW5rTnVtID0gMDsgY2h1bmtOdW0gPCBjaHVua3MubGVuZ3RoOyBjaHVua051bSArPSAxKSB7CiAgICAgICAgbGV0IHByZXZpb3VzU3RhcnRDb29yZGluYXRlOwogICAgICAgIGNvbnN0IGMgPSBjaHVua3NbY2h1bmtOdW1dOwogICAgICAgIGNvbnN0IHsgYnVmZmVyLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zIH0gPSBhd2FpdCB0aGlzLmNodW5rQ2FjaGUuZ2V0KGMudG9TdHJpbmcoKSwgYyk7CiAgICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICAgIGxldCBibG9ja1N0YXJ0ID0gMDsKICAgICAgICBsZXQgcG9zID0gMDsKICAgICAgICB3aGlsZSAoYmxvY2tTdGFydCA8IGJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgIGNvbnN0IG4gPSBidWZmZXIuaW5kZXhPZigiXG4iLCBibG9ja1N0YXJ0KTsKICAgICAgICAgIGlmIChuID09PSAtMSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IGIgPSBidWZmZXIuc2xpY2UoYmxvY2tTdGFydCwgbik7CiAgICAgICAgICBjb25zdCBsaW5lID0gKGRlY29kZXIgPT09IG51bGwgfHwgZGVjb2RlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb2Rlci5kZWNvZGUoYikpIHx8IGIudG9TdHJpbmcoKTsKICAgICAgICAgIGlmIChkcG9zaXRpb25zKSB7CiAgICAgICAgICAgIHdoaWxlIChibG9ja1N0YXJ0ICsgYy5taW52LmRhdGFQb3NpdGlvbiA+PSBkcG9zaXRpb25zW3BvcysrXSkgewogICAgICAgICAgICB9CiAgICAgICAgICAgIHBvcy0tOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgeyBzdGFydENvb3JkaW5hdGUsIG92ZXJsYXBzIH0gPSB0aGlzLmNoZWNrTGluZShtZXRhZGF0YSwgcmVmTmFtZSwgc3RhcnQsIGVuZCwgbGluZSk7CiAgICAgICAgICBpZiAocHJldmlvdXNTdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBzdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZSA+IHN0YXJ0Q29vcmRpbmF0ZSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmVzIG5vdCBzb3J0ZWQgYnkgc3RhcnQgY29vcmRpbmF0ZSAoJHtwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZX0gPiAke3N0YXJ0Q29vcmRpbmF0ZX0pLCB0aGlzIGZpbGUgaXMgbm90IHVzYWJsZSB3aXRoIFRhYml4LmApOwogICAgICAgICAgfQogICAgICAgICAgcHJldmlvdXNTdGFydENvb3JkaW5hdGUgPSBzdGFydENvb3JkaW5hdGU7CiAgICAgICAgICBpZiAob3ZlcmxhcHMpIHsKICAgICAgICAgICAgY2FsbGJhY2sobGluZS50cmltKCksIGNwb3NpdGlvbnNbcG9zXSAqICgxIDw8IDgpICsgKGJsb2NrU3RhcnQgLSBkcG9zaXRpb25zW3Bvc10pICsgYy5taW52LmRhdGFQb3NpdGlvbiArIDEpOwogICAgICAgICAgfSBlbHNlIGlmIChzdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBzdGFydENvb3JkaW5hdGUgPj0gZW5kKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLnlpZWxkVGltZSAmJiBsYXN0IC0gRGF0ZS5ub3coKSA+IHRoaXMueWllbGRUaW1lKSB7CiAgICAgICAgICAgIGxhc3QgPSBEYXRlLm5vdygpOwogICAgICAgICAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMSk7CiAgICAgICAgICB9CiAgICAgICAgICBibG9ja1N0YXJ0ID0gbiArIDE7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBhc3luYyBnZXRNZXRhZGF0YShvcHRzID0ge30pIHsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXguZ2V0TWV0YWRhdGEob3B0cyk7CiAgICB9CiAgICBhc3luYyBnZXRIZWFkZXJCdWZmZXIob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgZmlyc3REYXRhTGluZSwgbWV0YUNoYXIsIG1heEJsb2NrU2l6ZSB9ID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YShvcHRzKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChvcHRzLnNpZ25hbCk7CiAgICAgIGNvbnN0IG1heEZldGNoID0gKChmaXJzdERhdGFMaW5lID09PSBudWxsIHx8IGZpcnN0RGF0YUxpbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0RGF0YUxpbmUuYmxvY2tQb3NpdGlvbikgfHwgMCkgKyBtYXhCbG9ja1NpemU7CiAgICAgIGxldCBieXRlcyA9IGF3YWl0IHRoaXMuX3JlYWRSZWdpb24oMCwgbWF4RmV0Y2gsIG9wdHMpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKTsKICAgICAgdHJ5IHsKICAgICAgICBieXRlcyA9IGF3YWl0IHVuemlwKGJ5dGVzKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvciBkZWNvbXByZXNzaW5nIGJsb2NrICR7ZS5jb2RlfSBhdCAwIChsZW5ndGggJHttYXhGZXRjaH0pICR7ZX1gKTsKICAgICAgfQogICAgICBpZiAobWV0YUNoYXIpIHsKICAgICAgICBsZXQgbGFzdE5ld2xpbmUgPSAtMTsKICAgICAgICBjb25zdCBuZXdsaW5lQnl0ZSA9ICJcbiIuY2hhckNvZGVBdCgwKTsKICAgICAgICBjb25zdCBtZXRhQnl0ZSA9IG1ldGFDaGFyLmNoYXJDb2RlQXQoMCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgaWYgKGkgPT09IGxhc3ROZXdsaW5lICsgMSAmJiBieXRlc1tpXSAhPT0gbWV0YUJ5dGUpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYnl0ZXNbaV0gPT09IG5ld2xpbmVCeXRlKSB7CiAgICAgICAgICAgIGxhc3ROZXdsaW5lID0gaTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZSgwLCBsYXN0TmV3bGluZSArIDEpOwogICAgICB9CiAgICAgIHJldHVybiBieXRlczsKICAgIH0KICAgIGFzeW5jIGdldEhlYWRlcihvcHRzID0ge30pIHsKICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB0aGlzLmdldEhlYWRlckJ1ZmZlcihvcHRzKTsKICAgICAgcmV0dXJuIGJ5dGVzLnRvU3RyaW5nKCJ1dGY4Iik7CiAgICB9CiAgICBhc3luYyBnZXRSZWZlcmVuY2VTZXF1ZW5jZU5hbWVzKG9wdHMgPSB7fSkgewogICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEob3B0cyk7CiAgICAgIHJldHVybiBtZXRhZGF0YS5yZWZJZFRvTmFtZTsKICAgIH0KICAgIGNoZWNrTGluZShtZXRhZGF0YSwgcmVnaW9uUmVmTmFtZSwgcmVnaW9uU3RhcnQsIHJlZ2lvbkVuZCwgbGluZSkgewogICAgICBjb25zdCB7IGNvbHVtbk51bWJlcnMsIG1ldGFDaGFyLCBjb29yZGluYXRlVHlwZSwgZm9ybWF0IH0gPSBtZXRhZGF0YTsKICAgICAgaWYgKGxpbmUuY2hhckF0KDApID09PSBtZXRhQ2hhcikgewogICAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9OwogICAgICB9CiAgICAgIGxldCB7IHJlZiwgc3RhcnQsIGVuZCB9ID0gY29sdW1uTnVtYmVyczsKICAgICAgaWYgKCFyZWYpIHsKICAgICAgICByZWYgPSAwOwogICAgICB9CiAgICAgIGlmICghc3RhcnQpIHsKICAgICAgICBzdGFydCA9IDA7CiAgICAgIH0KICAgICAgaWYgKCFlbmQpIHsKICAgICAgICBlbmQgPSAwOwogICAgICB9CiAgICAgIGlmIChmb3JtYXQgPT09ICJWQ0YiKSB7CiAgICAgICAgZW5kID0gODsKICAgICAgfQogICAgICBjb25zdCBtYXhDb2x1bW4gPSBNYXRoLm1heChyZWYsIHN0YXJ0LCBlbmQpOwogICAgICBsZXQgY3VycmVudENvbHVtbk51bWJlciA9IDE7CiAgICAgIGxldCBjdXJyZW50Q29sdW1uU3RhcnQgPSAwOwogICAgICBsZXQgcmVmU2VxID0gIiI7CiAgICAgIGxldCBzdGFydENvb3JkaW5hdGUgPSAtSW5maW5pdHk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5sZW5ndGggKyAxOyBpICs9IDEpIHsKICAgICAgICBpZiAobGluZVtpXSA9PT0gIgkiIHx8IGkgPT09IGxpbmUubGVuZ3RoKSB7CiAgICAgICAgICBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gcmVmKSB7CiAgICAgICAgICAgIGlmICh0aGlzLnJlbmFtZVJlZlNlcShsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSkpICE9PSByZWdpb25SZWZOYW1lKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gc3RhcnQpIHsKICAgICAgICAgICAgc3RhcnRDb29yZGluYXRlID0gcGFyc2VJbnQobGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpLCAxMCk7CiAgICAgICAgICAgIGlmIChjb29yZGluYXRlVHlwZSA9PT0gIjEtYmFzZWQtY2xvc2VkIikgewogICAgICAgICAgICAgIHN0YXJ0Q29vcmRpbmF0ZSAtPSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGFydENvb3JkaW5hdGUgPj0gcmVnaW9uRW5kKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogZmFsc2UgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZW5kID09PSAwIHx8IGVuZCA9PT0gc3RhcnQpIHsKICAgICAgICAgICAgICBpZiAoc3RhcnRDb29yZGluYXRlICsgMSA8PSByZWdpb25TdGFydCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogZmFsc2UgfTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAiVkNGIiAmJiBjdXJyZW50Q29sdW1uTnVtYmVyID09PSA0KSB7CiAgICAgICAgICAgIHJlZlNlcSA9IGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gZW5kKSB7CiAgICAgICAgICAgIGxldCBlbmRDb29yZGluYXRlOwogICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAiVkNGIikgewogICAgICAgICAgICAgIGVuZENvb3JkaW5hdGUgPSB0aGlzLl9nZXRWY2ZFbmQoc3RhcnRDb29yZGluYXRlLCByZWZTZXEsIGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZW5kQ29vcmRpbmF0ZSA9IHBhcnNlSW50KGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSwgMTApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChlbmRDb29yZGluYXRlIDw9IHJlZ2lvblN0YXJ0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGN1cnJlbnRDb2x1bW5TdGFydCA9IGkgKyAxOwogICAgICAgICAgY3VycmVudENvbHVtbk51bWJlciArPSAxOwogICAgICAgICAgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPiBtYXhDb2x1bW4pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHM6IHRydWUgfTsKICAgIH0KICAgIF9nZXRWY2ZFbmQoc3RhcnRDb29yZGluYXRlLCByZWZTZXEsIGluZm8pIHsKICAgICAgbGV0IGVuZENvb3JkaW5hdGUgPSBzdGFydENvb3JkaW5hdGUgKyByZWZTZXEubGVuZ3RoOwogICAgICBjb25zdCBpc1RSQSA9IGluZm8uaW5kZXhPZigiU1ZUWVBFPVRSQSIpICE9PSAtMTsKICAgICAgaWYgKGluZm9bMF0gIT09ICIuIiAmJiAhaXNUUkEpIHsKICAgICAgICBsZXQgcHJldkNoYXIgPSAiOyI7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLmxlbmd0aDsgaiArPSAxKSB7CiAgICAgICAgICBpZiAocHJldkNoYXIgPT09ICI7IiAmJiBpbmZvLnNsaWNlKGosIGogKyA0KSA9PT0gIkVORD0iKSB7CiAgICAgICAgICAgIGxldCB2YWx1ZUVuZCA9IGluZm8uaW5kZXhPZigiOyIsIGopOwogICAgICAgICAgICBpZiAodmFsdWVFbmQgPT09IC0xKSB7CiAgICAgICAgICAgICAgdmFsdWVFbmQgPSBpbmZvLmxlbmd0aDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbmRDb29yZGluYXRlID0gcGFyc2VJbnQoaW5mby5zbGljZShqICsgNCwgdmFsdWVFbmQpLCAxMCk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgcHJldkNoYXIgPSBpbmZvW2pdOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChpc1RSQSkgewogICAgICAgIHJldHVybiBzdGFydENvb3JkaW5hdGUgKyAxOwogICAgICB9CiAgICAgIHJldHVybiBlbmRDb29yZGluYXRlOwogICAgfQogICAgYXN5bmMgbGluZUNvdW50KHJlZk5hbWUsIG9wdHMgPSB7fSkgewogICAgICByZXR1cm4gdGhpcy5pbmRleC5saW5lQ291bnQocmVmTmFtZSwgb3B0cyk7CiAgICB9CiAgICBhc3luYyBfcmVhZFJlZ2lvbihwb3MsIHNpemUsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCBiID0gaW1wb3J0X2J1ZmZlcjcuQnVmZmVyLmFsbG9jKHNpemUpOwogICAgICBjb25zdCB7IGJ5dGVzUmVhZCwgYnVmZmVyIH0gPSBhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZChiLCAwLCBzaXplLCBwb3MsIG9wdHMpOwogICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGJ5dGVzUmVhZCk7CiAgICB9CiAgICBhc3luYyByZWFkQ2h1bmsoYywgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9yZWFkUmVnaW9uKGMubWludi5ibG9ja1Bvc2l0aW9uLCBjLmZldGNoZWRTaXplKCksIG9wdHMpOwogICAgICB0cnkgewogICAgICAgIHJldHVybiB1bnppcENodW5rU2xpY2UoZGF0YSwgYyk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVycm9yIGRlY29tcHJlc3NpbmcgYyAke2MudG9TdHJpbmcoKX0gJHtlfWApOwogICAgICB9CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbG9kYXNoLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gIm9iamVjdCIgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7CiAgdmFyIGZyZWVHbG9iYWxfZGVmYXVsdCA9IGZyZWVHbG9iYWw7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzCiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gIm9iamVjdCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7CiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsX2RlZmF1bHQgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oInJldHVybiB0aGlzIikoKTsKICB2YXIgcm9vdF9kZWZhdWx0ID0gcm9vdDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcwogIHZhciBTeW1ib2wyID0gcm9vdF9kZWZhdWx0LlN5bWJvbDsKICB2YXIgU3ltYm9sX2RlZmF1bHQgPSBTeW1ib2wyOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7CiAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7CiAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7CiAgdmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sX2RlZmF1bHQgPyBTeW1ib2xfZGVmYXVsdC50b1N0cmluZ1RhZyA6IHZvaWQgMDsKICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHsKICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSwgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddOwogICAgdHJ5IHsKICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdm9pZCAwOwogICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlOwogICAgfSBjYXRjaCAoZSkgewogICAgfQogICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpOwogICAgaWYgKHVubWFza2VkKSB7CiAgICAgIGlmIChpc093bikgewogICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZzsKICAgICAgfSBlbHNlIHsKICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgZ2V0UmF3VGFnX2RlZmF1bHQgPSBnZXRSYXdUYWc7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8yID0gT2JqZWN0LnByb3RvdHlwZTsKICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcyID0gb2JqZWN0UHJvdG8yLnRvU3RyaW5nOwogIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7CiAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcyLmNhbGwodmFsdWUpOwogIH0KICB2YXIgb2JqZWN0VG9TdHJpbmdfZGVmYXVsdCA9IG9iamVjdFRvU3RyaW5nOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcwogIHZhciBudWxsVGFnID0gIltvYmplY3QgTnVsbF0iOwogIHZhciB1bmRlZmluZWRUYWcgPSAiW29iamVjdCBVbmRlZmluZWRdIjsKICB2YXIgc3ltVG9TdHJpbmdUYWcyID0gU3ltYm9sX2RlZmF1bHQgPyBTeW1ib2xfZGVmYXVsdC50b1N0cmluZ1RhZyA6IHZvaWQgMDsKICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7CiAgICBpZiAodmFsdWUgPT0gbnVsbCkgewogICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7CiAgICB9CiAgICByZXR1cm4gc3ltVG9TdHJpbmdUYWcyICYmIHN5bVRvU3RyaW5nVGFnMiBpbiBPYmplY3QodmFsdWUpID8gZ2V0UmF3VGFnX2RlZmF1bHQodmFsdWUpIDogb2JqZWN0VG9TdHJpbmdfZGVmYXVsdCh2YWx1ZSk7CiAgfQogIHZhciBiYXNlR2V0VGFnX2RlZmF1bHQgPSBiYXNlR2V0VGFnOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7CiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gIm9iamVjdCI7CiAgfQogIHZhciBpc09iamVjdExpa2VfZGVmYXVsdCA9IGlzT2JqZWN0TGlrZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNTeW1ib2wuanMKICB2YXIgc3ltYm9sVGFnID0gIltvYmplY3QgU3ltYm9sXSI7CiAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHsKICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gInN5bWJvbCIgfHwgaXNPYmplY3RMaWtlX2RlZmF1bHQodmFsdWUpICYmIGJhc2VHZXRUYWdfZGVmYXVsdCh2YWx1ZSkgPT0gc3ltYm9sVGFnOwogIH0KICB2YXIgaXNTeW1ib2xfZGVmYXVsdCA9IGlzU3ltYm9sOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlNYXAuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7CiAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7CiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkgewogICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGFycmF5TWFwX2RlZmF1bHQgPSBhcnJheU1hcDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7CiAgdmFyIGlzQXJyYXlfZGVmYXVsdCA9IGlzQXJyYXk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvSW50ZWdlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9GaW5pdGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvTnVtYmVyLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRyaW0uanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190cmltbWVkRW5kSW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIHJlV2hpdGVzcGFjZSA9IC9ccy87CiAgZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykgewogICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDsKICAgIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkgewogICAgfQogICAgcmV0dXJuIGluZGV4OwogIH0KICB2YXIgdHJpbW1lZEVuZEluZGV4X2RlZmF1bHQgPSB0cmltbWVkRW5kSW5kZXg7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVHJpbS5qcwogIHZhciByZVRyaW1TdGFydCA9IC9eXHMrLzsKICBmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHsKICAgIHJldHVybiBzdHJpbmcgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4X2RlZmF1bHQoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICIiKSA6IHN0cmluZzsKICB9CiAgdmFyIGJhc2VUcmltX2RlZmF1bHQgPSBiYXNlVHJpbTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHsKICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gIm9iamVjdCIgfHwgdHlwZSA9PSAiZnVuY3Rpb24iKTsKICB9CiAgdmFyIGlzT2JqZWN0X2RlZmF1bHQgPSBpc09iamVjdDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9OdW1iZXIuanMKICB2YXIgTkFOID0gMCAvIDA7CiAgdmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTsKICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTsKICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTsKICB2YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7CiAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHsKICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gIm51bWJlciIpIHsKICAgICAgcmV0dXJuIHZhbHVlOwogICAgfQogICAgaWYgKGlzU3ltYm9sX2RlZmF1bHQodmFsdWUpKSB7CiAgICAgIHJldHVybiBOQU47CiAgICB9CiAgICBpZiAoaXNPYmplY3RfZGVmYXVsdCh2YWx1ZSkpIHsKICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gImZ1bmN0aW9uIiA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlOwogICAgICB2YWx1ZSA9IGlzT2JqZWN0X2RlZmF1bHQob3RoZXIpID8gb3RoZXIgKyAiIiA6IG90aGVyOwogICAgfQogICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAic3RyaW5nIikgewogICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTsKICAgIH0KICAgIHZhbHVlID0gYmFzZVRyaW1fZGVmYXVsdCh2YWx1ZSk7CiAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpOwogICAgcmV0dXJuIGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOCkgOiByZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlOwogIH0KICB2YXIgdG9OdW1iZXJfZGVmYXVsdCA9IHRvTnVtYmVyOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qcwogIHZhciBJTkZJTklUWSA9IDEgLyAwOwogIHZhciBNQVhfSU5URUdFUiA9IDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MjsKICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkgewogICAgaWYgKCF2YWx1ZSkgewogICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7CiAgICB9CiAgICB2YWx1ZSA9IHRvTnVtYmVyX2RlZmF1bHQodmFsdWUpOwogICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7CiAgICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gLTEgOiAxOwogICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSOwogICAgfQogICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDsKICB9CiAgdmFyIHRvRmluaXRlX2RlZmF1bHQgPSB0b0Zpbml0ZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9JbnRlZ2VyLmpzCiAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7CiAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGVfZGVmYXVsdCh2YWx1ZSksIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7CiAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyByZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQgOiAwOwogIH0KICB2YXIgdG9JbnRlZ2VyX2RlZmF1bHQgPSB0b0ludGVnZXI7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGFzeW5jVGFnID0gIltvYmplY3QgQXN5bmNGdW5jdGlvbl0iOwogIHZhciBmdW5jVGFnID0gIltvYmplY3QgRnVuY3Rpb25dIjsKICB2YXIgZ2VuVGFnID0gIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIjsKICB2YXIgcHJveHlUYWcgPSAiW29iamVjdCBQcm94eV0iOwogIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHsKICAgIGlmICghaXNPYmplY3RfZGVmYXVsdCh2YWx1ZSkpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgdmFyIHRhZyA9IGJhc2VHZXRUYWdfZGVmYXVsdCh2YWx1ZSk7CiAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnOwogIH0KICB2YXIgaXNGdW5jdGlvbl9kZWZhdWx0ID0gaXNGdW5jdGlvbjsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkgewogICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7CiAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07CiAgICB9CiAgICByZXR1cm4gYXJyYXk7CiAgfQogIHZhciBjb3B5QXJyYXlfZGVmYXVsdCA9IGNvcHlBcnJheTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxOwogIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxkKikkLzsKICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHsKICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoOwogICAgcmV0dXJuICEhbGVuZ3RoICYmICh0eXBlID09ICJudW1iZXIiIHx8IHR5cGUgIT0gInN5bWJvbCIgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTsKICB9CiAgdmFyIGlzSW5kZXhfZGVmYXVsdCA9IGlzSW5kZXg7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikgewogICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyOwogIH0KICB2YXIgZXFfZGVmYXVsdCA9IGVxOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0xlbmd0aC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgTUFYX1NBRkVfSU5URUdFUjIgPSA5MDA3MTk5MjU0NzQwOTkxOwogIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7CiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICJudW1iZXIiICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjI7CiAgfQogIHZhciBpc0xlbmd0aF9kZWZhdWx0ID0gaXNMZW5ndGg7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzCiAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHsKICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoX2RlZmF1bHQodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbl9kZWZhdWx0KHZhbHVlKTsKICB9CiAgdmFyIGlzQXJyYXlMaWtlX2RlZmF1bHQgPSBpc0FycmF5TGlrZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSXRlcmF0ZWVDYWxsLmpzCiAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHsKICAgIGlmICghaXNPYmplY3RfZGVmYXVsdChvYmplY3QpKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4OwogICAgaWYgKHR5cGUgPT0gIm51bWJlciIgPyBpc0FycmF5TGlrZV9kZWZhdWx0KG9iamVjdCkgJiYgaXNJbmRleF9kZWZhdWx0KGluZGV4LCBvYmplY3QubGVuZ3RoKSA6IHR5cGUgPT0gInN0cmluZyIgJiYgaW5kZXggaW4gb2JqZWN0KSB7CiAgICAgIHJldHVybiBlcV9kZWZhdWx0KG9iamVjdFtpbmRleF0sIHZhbHVlKTsKICAgIH0KICAgIHJldHVybiBmYWxzZTsKICB9CiAgdmFyIGlzSXRlcmF0ZWVDYWxsX2RlZmF1bHQgPSBpc0l0ZXJhdGVlQ2FsbDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzUHJvdG90eXBlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBvYmplY3RQcm90bzMgPSBPYmplY3QucHJvdG90eXBlOwogIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7CiAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLCBwcm90byA9IHR5cGVvZiBDdG9yID09ICJmdW5jdGlvbiIgJiYgQ3Rvci5wcm90b3R5cGUgfHwgb2JqZWN0UHJvdG8zOwogICAgcmV0dXJuIHZhbHVlID09PSBwcm90bzsKICB9CiAgdmFyIGlzUHJvdG90eXBlX2RlZmF1bHQgPSBpc1Byb3RvdHlwZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7CiAgICB2YXIgaW5kZXggPSAtMSwgcmVzdWx0ID0gQXJyYXkobik7CiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHsKICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBiYXNlVGltZXNfZGVmYXVsdCA9IGJhc2VUaW1lczsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGFyZ3NUYWcgPSAiW29iamVjdCBBcmd1bWVudHNdIjsKICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHsKICAgIHJldHVybiBpc09iamVjdExpa2VfZGVmYXVsdCh2YWx1ZSkgJiYgYmFzZUdldFRhZ19kZWZhdWx0KHZhbHVlKSA9PSBhcmdzVGFnOwogIH0KICB2YXIgYmFzZUlzQXJndW1lbnRzX2RlZmF1bHQgPSBiYXNlSXNBcmd1bWVudHM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzCiAgdmFyIG9iamVjdFByb3RvNCA9IE9iamVjdC5wcm90b3R5cGU7CiAgdmFyIGhhc093blByb3BlcnR5MiA9IG9iamVjdFByb3RvNC5oYXNPd25Qcm9wZXJ0eTsKICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90bzQucHJvcGVydHlJc0VudW1lcmFibGU7CiAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzX2RlZmF1bHQoZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gYXJndW1lbnRzOwogIH0oKSkgPyBiYXNlSXNBcmd1bWVudHNfZGVmYXVsdCA6IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICByZXR1cm4gaXNPYmplY3RMaWtlX2RlZmF1bHQodmFsdWUpICYmIGhhc093blByb3BlcnR5Mi5jYWxsKHZhbHVlLCAiY2FsbGVlIikgJiYgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICJjYWxsZWUiKTsKICB9OwogIHZhciBpc0FyZ3VtZW50c19kZWZhdWx0ID0gaXNBcmd1bWVudHM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gc3R1YkZhbHNlKCkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KICB2YXIgc3R1YkZhbHNlX2RlZmF1bHQgPSBzdHViRmFsc2U7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzCiAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gIm9iamVjdCIgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzOwogIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAib2JqZWN0IiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7CiAgdmFyIEJ1ZmZlcjkgPSBtb2R1bGVFeHBvcnRzID8gcm9vdF9kZWZhdWx0LkJ1ZmZlciA6IHZvaWQgMDsKICB2YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXI5ID8gQnVmZmVyOS5pc0J1ZmZlciA6IHZvaWQgMDsKICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2VfZGVmYXVsdDsKICB2YXIgaXNCdWZmZXJfZGVmYXVsdCA9IGlzQnVmZmVyOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBhcmdzVGFnMiA9ICJbb2JqZWN0IEFyZ3VtZW50c10iOwogIHZhciBhcnJheVRhZyA9ICJbb2JqZWN0IEFycmF5XSI7CiAgdmFyIGJvb2xUYWcgPSAiW29iamVjdCBCb29sZWFuXSI7CiAgdmFyIGRhdGVUYWcgPSAiW29iamVjdCBEYXRlXSI7CiAgdmFyIGVycm9yVGFnID0gIltvYmplY3QgRXJyb3JdIjsKICB2YXIgZnVuY1RhZzIgPSAiW29iamVjdCBGdW5jdGlvbl0iOwogIHZhciBtYXBUYWcgPSAiW29iamVjdCBNYXBdIjsKICB2YXIgbnVtYmVyVGFnID0gIltvYmplY3QgTnVtYmVyXSI7CiAgdmFyIG9iamVjdFRhZyA9ICJbb2JqZWN0IE9iamVjdF0iOwogIHZhciByZWdleHBUYWcgPSAiW29iamVjdCBSZWdFeHBdIjsKICB2YXIgc2V0VGFnID0gIltvYmplY3QgU2V0XSI7CiAgdmFyIHN0cmluZ1RhZyA9ICJbb2JqZWN0IFN0cmluZ10iOwogIHZhciB3ZWFrTWFwVGFnID0gIltvYmplY3QgV2Vha01hcF0iOwogIHZhciBhcnJheUJ1ZmZlclRhZyA9ICJbb2JqZWN0IEFycmF5QnVmZmVyXSI7CiAgdmFyIGRhdGFWaWV3VGFnID0gIltvYmplY3QgRGF0YVZpZXddIjsKICB2YXIgZmxvYXQzMlRhZyA9ICJbb2JqZWN0IEZsb2F0MzJBcnJheV0iOwogIHZhciBmbG9hdDY0VGFnID0gIltvYmplY3QgRmxvYXQ2NEFycmF5XSI7CiAgdmFyIGludDhUYWcgPSAiW29iamVjdCBJbnQ4QXJyYXldIjsKICB2YXIgaW50MTZUYWcgPSAiW29iamVjdCBJbnQxNkFycmF5XSI7CiAgdmFyIGludDMyVGFnID0gIltvYmplY3QgSW50MzJBcnJheV0iOwogIHZhciB1aW50OFRhZyA9ICJbb2JqZWN0IFVpbnQ4QXJyYXldIjsKICB2YXIgdWludDhDbGFtcGVkVGFnID0gIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIjsKICB2YXIgdWludDE2VGFnID0gIltvYmplY3QgVWludDE2QXJyYXldIjsKICB2YXIgdWludDMyVGFnID0gIltvYmplY3QgVWludDMyQXJyYXldIjsKICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTsKICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlOwogIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWcyXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnMl0gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlOwogIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHsKICAgIHJldHVybiBpc09iamVjdExpa2VfZGVmYXVsdCh2YWx1ZSkgJiYgaXNMZW5ndGhfZGVmYXVsdCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZ19kZWZhdWx0KHZhbHVlKV07CiAgfQogIHZhciBiYXNlSXNUeXBlZEFycmF5X2RlZmF1bHQgPSBiYXNlSXNUeXBlZEFycmF5OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7CiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHsKICAgICAgcmV0dXJuIGZ1bmModmFsdWUpOwogICAgfTsKICB9CiAgdmFyIGJhc2VVbmFyeV9kZWZhdWx0ID0gYmFzZVVuYXJ5OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGZyZWVFeHBvcnRzMiA9IHR5cGVvZiBleHBvcnRzID09ICJvYmplY3QiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKICB2YXIgZnJlZU1vZHVsZTIgPSBmcmVlRXhwb3J0czIgJiYgdHlwZW9mIG1vZHVsZSA9PSAib2JqZWN0IiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CiAgdmFyIG1vZHVsZUV4cG9ydHMyID0gZnJlZU1vZHVsZTIgJiYgZnJlZU1vZHVsZTIuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMyOwogIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMyICYmIGZyZWVHbG9iYWxfZGVmYXVsdC5wcm9jZXNzOwogIHZhciBub2RlVXRpbCA9IGZ1bmN0aW9uKCkgewogICAgdHJ5IHsKICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZTIgJiYgZnJlZU1vZHVsZTIucmVxdWlyZSAmJiBmcmVlTW9kdWxlMi5yZXF1aXJlKCJ1dGlsIikudHlwZXM7CiAgICAgIGlmICh0eXBlcykgewogICAgICAgIHJldHVybiB0eXBlczsKICAgICAgfQogICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCJ1dGlsIik7CiAgICB9IGNhdGNoIChlKSB7CiAgICB9CiAgfSgpOwogIHZhciBub2RlVXRpbF9kZWZhdWx0ID0gbm9kZVV0aWw7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcwogIHZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWxfZGVmYXVsdCAmJiBub2RlVXRpbF9kZWZhdWx0LmlzVHlwZWRBcnJheTsKICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeV9kZWZhdWx0KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheV9kZWZhdWx0OwogIHZhciBpc1R5cGVkQXJyYXlfZGVmYXVsdCA9IGlzVHlwZWRBcnJheTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMKICB2YXIgb2JqZWN0UHJvdG81ID0gT2JqZWN0LnByb3RvdHlwZTsKICB2YXIgaGFzT3duUHJvcGVydHkzID0gb2JqZWN0UHJvdG81Lmhhc093blByb3BlcnR5OwogIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkgewogICAgdmFyIGlzQXJyID0gaXNBcnJheV9kZWZhdWx0KHZhbHVlKSwgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHNfZGVmYXVsdCh2YWx1ZSksIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXJfZGVmYXVsdCh2YWx1ZSksIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXlfZGVmYXVsdCh2YWx1ZSksIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSwgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXNfZGVmYXVsdCh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSwgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsKICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgewogICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eTMuY2FsbCh2YWx1ZSwga2V5KSkgJiYgIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICJsZW5ndGgiIHx8IGlzQnVmZiAmJiAoa2V5ID09ICJvZmZzZXQiIHx8IGtleSA9PSAicGFyZW50IikgfHwgaXNUeXBlICYmIChrZXkgPT0gImJ1ZmZlciIgfHwga2V5ID09ICJieXRlTGVuZ3RoIiB8fCBrZXkgPT0gImJ5dGVPZmZzZXQiKSB8fCBpc0luZGV4X2RlZmF1bHQoa2V5LCBsZW5ndGgpKSkpIHsKICAgICAgICByZXN1bHQucHVzaChrZXkpOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgYXJyYXlMaWtlS2V5c19kZWZhdWx0ID0gYXJyYXlMaWtlS2V5czsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHsKICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHsKICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpOwogICAgfTsKICB9CiAgdmFyIG92ZXJBcmdfZGVmYXVsdCA9IG92ZXJBcmc7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzCiAgdmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnX2RlZmF1bHQoT2JqZWN0LmtleXMsIE9iamVjdCk7CiAgdmFyIG5hdGl2ZUtleXNfZGVmYXVsdCA9IG5hdGl2ZUtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcwogIHZhciBvYmplY3RQcm90bzYgPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eTQgPSBvYmplY3RQcm90bzYuaGFzT3duUHJvcGVydHk7CiAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7CiAgICBpZiAoIWlzUHJvdG90eXBlX2RlZmF1bHQob2JqZWN0KSkgewogICAgICByZXR1cm4gbmF0aXZlS2V5c19kZWZhdWx0KG9iamVjdCk7CiAgICB9CiAgICB2YXIgcmVzdWx0ID0gW107CiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHsKICAgICAgaWYgKGhhc093blByb3BlcnR5NC5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gImNvbnN0cnVjdG9yIikgewogICAgICAgIHJlc3VsdC5wdXNoKGtleSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBiYXNlS2V5c19kZWZhdWx0ID0gYmFzZUtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMKICBmdW5jdGlvbiBrZXlzKG9iamVjdCkgewogICAgcmV0dXJuIGlzQXJyYXlMaWtlX2RlZmF1bHQob2JqZWN0KSA/IGFycmF5TGlrZUtleXNfZGVmYXVsdChvYmplY3QpIDogYmFzZUtleXNfZGVmYXVsdChvYmplY3QpOwogIH0KICB2YXIga2V5c19kZWZhdWx0ID0ga2V5czsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDbGFtcC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHsKICAgIGlmIChudW1iZXIgPT09IG51bWJlcikgewogICAgICBpZiAodXBwZXIgIT09IHZvaWQgMCkgewogICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyOwogICAgICB9CiAgICAgIGlmIChsb3dlciAhPT0gdm9pZCAwKSB7CiAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBudW1iZXI7CiAgfQogIHZhciBiYXNlQ2xhbXBfZGVmYXVsdCA9IGJhc2VDbGFtcDsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVZhbHVlcy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHsKICAgIHJldHVybiBhcnJheU1hcF9kZWZhdWx0KHByb3BzLCBmdW5jdGlvbihrZXkpIHsKICAgICAgcmV0dXJuIG9iamVjdFtrZXldOwogICAgfSk7CiAgfQogIHZhciBiYXNlVmFsdWVzX2RlZmF1bHQgPSBiYXNlVmFsdWVzOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMKICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7CiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXNfZGVmYXVsdChvYmplY3QsIGtleXNfZGVmYXVsdChvYmplY3QpKTsKICB9CiAgdmFyIHZhbHVlc19kZWZhdWx0ID0gdmFsdWVzOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJhbmRvbS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yOwogIHZhciBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTsKICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikgewogICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTsKICB9CiAgdmFyIGJhc2VSYW5kb21fZGVmYXVsdCA9IGJhc2VSYW5kb207CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NhbXBsZVNpemUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNhbXBsZVNpemUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaHVmZmxlU2VsZi5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkgewogICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTsKICAgIHNpemUgPSBzaXplID09PSB2b2lkIDAgPyBsZW5ndGggOiBzaXplOwogICAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7CiAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbV9kZWZhdWx0KGluZGV4LCBsYXN0SW5kZXgpLCB2YWx1ZSA9IGFycmF5W3JhbmRdOwogICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTsKICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7CiAgICB9CiAgICBhcnJheS5sZW5ndGggPSBzaXplOwogICAgcmV0dXJuIGFycmF5OwogIH0KICB2YXIgc2h1ZmZsZVNlbGZfZGVmYXVsdCA9IHNodWZmbGVTZWxmOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTYW1wbGVTaXplLmpzCiAgZnVuY3Rpb24gYXJyYXlTYW1wbGVTaXplKGFycmF5LCBuKSB7CiAgICByZXR1cm4gc2h1ZmZsZVNlbGZfZGVmYXVsdChjb3B5QXJyYXlfZGVmYXVsdChhcnJheSksIGJhc2VDbGFtcF9kZWZhdWx0KG4sIDAsIGFycmF5Lmxlbmd0aCkpOwogIH0KICB2YXIgYXJyYXlTYW1wbGVTaXplX2RlZmF1bHQgPSBhcnJheVNhbXBsZVNpemU7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2FtcGxlU2l6ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7CiAgICB2YXIgYXJyYXkgPSB2YWx1ZXNfZGVmYXVsdChjb2xsZWN0aW9uKTsKICAgIHJldHVybiBzaHVmZmxlU2VsZl9kZWZhdWx0KGFycmF5LCBiYXNlQ2xhbXBfZGVmYXVsdChuLCAwLCBhcnJheS5sZW5ndGgpKTsKICB9CiAgdmFyIGJhc2VTYW1wbGVTaXplX2RlZmF1bHQgPSBiYXNlU2FtcGxlU2l6ZTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc2FtcGxlU2l6ZS5qcwogIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHsKICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsX2RlZmF1bHQoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdm9pZCAwKSB7CiAgICAgIG4gPSAxOwogICAgfSBlbHNlIHsKICAgICAgbiA9IHRvSW50ZWdlcl9kZWZhdWx0KG4pOwogICAgfQogICAgdmFyIGZ1bmMgPSBpc0FycmF5X2RlZmF1bHQoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemVfZGVmYXVsdCA6IGJhc2VTYW1wbGVTaXplX2RlZmF1bHQ7CiAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuKTsKICB9CiAgdmFyIHNhbXBsZVNpemVfZGVmYXVsdCA9IHNhbXBsZVNpemU7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWRzQDEuNy4wL25vZGVfbW9kdWxlcy90aHJlYWRzL3dvcmtlci5tanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF93b3JrZXIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfd29ya2VyKCkpOwogIHZhciBleHBvc2UgPSBpbXBvcnRfd29ya2VyLmRlZmF1bHQuZXhwb3NlOwogIHZhciByZWdpc3RlclNlcmlhbGl6ZXIgPSBpbXBvcnRfd29ya2VyLmRlZmF1bHQucmVnaXN0ZXJTZXJpYWxpemVyOwogIHZhciBUcmFuc2ZlciA9IGltcG9ydF93b3JrZXIuZGVmYXVsdC5UcmFuc2ZlcjsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdXRpbHMudHMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9kMy1hcnJheUAyLjEyLjEvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL2QzLWFycmF5QDIuMTIuMS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBhc2NlbmRpbmdfZGVmYXVsdChhLCBiKSB7CiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vZDMtYXJyYXlAMi4xMi4xL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0b3IuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmlzZWN0b3JfZGVmYXVsdChmKSB7CiAgICBsZXQgZGVsdGEgPSBmOwogICAgbGV0IGNvbXBhcmUgPSBmOwogICAgaWYgKGYubGVuZ3RoID09PSAxKSB7CiAgICAgIGRlbHRhID0gKGQsIHgpID0+IGYoZCkgLSB4OwogICAgICBjb21wYXJlID0gYXNjZW5kaW5nQ29tcGFyYXRvcihmKTsKICAgIH0KICAgIGZ1bmN0aW9uIGxlZnQoYSwgeCwgbG8sIGhpKSB7CiAgICAgIGlmIChsbyA9PSBudWxsKQogICAgICAgIGxvID0gMDsKICAgICAgaWYgKGhpID09IG51bGwpCiAgICAgICAgaGkgPSBhLmxlbmd0aDsKICAgICAgd2hpbGUgKGxvIDwgaGkpIHsKICAgICAgICBjb25zdCBtaWQgPSBsbyArIGhpID4+PiAxOwogICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKQogICAgICAgICAgbG8gPSBtaWQgKyAxOwogICAgICAgIGVsc2UKICAgICAgICAgIGhpID0gbWlkOwogICAgICB9CiAgICAgIHJldHVybiBsbzsKICAgIH0KICAgIGZ1bmN0aW9uIHJpZ2h0KGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIHdoaWxlIChsbyA8IGhpKSB7CiAgICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTsKICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkKICAgICAgICAgIGhpID0gbWlkOwogICAgICAgIGVsc2UKICAgICAgICAgIGxvID0gbWlkICsgMTsKICAgICAgfQogICAgICByZXR1cm4gbG87CiAgICB9CiAgICBmdW5jdGlvbiBjZW50ZXIoYSwgeCwgbG8sIGhpKSB7CiAgICAgIGlmIChsbyA9PSBudWxsKQogICAgICAgIGxvID0gMDsKICAgICAgaWYgKGhpID09IG51bGwpCiAgICAgICAgaGkgPSBhLmxlbmd0aDsKICAgICAgY29uc3QgaSA9IGxlZnQoYSwgeCwgbG8sIGhpIC0gMSk7CiAgICAgIHJldHVybiBpID4gbG8gJiYgZGVsdGEoYVtpIC0gMV0sIHgpID4gLWRlbHRhKGFbaV0sIHgpID8gaSAtIDEgOiBpOwogICAgfQogICAgcmV0dXJuIHsgbGVmdCwgY2VudGVyLCByaWdodCB9OwogIH0KICBmdW5jdGlvbiBhc2NlbmRpbmdDb21wYXJhdG9yKGYpIHsKICAgIHJldHVybiAoZCwgeCkgPT4gYXNjZW5kaW5nX2RlZmF1bHQoZihkKSwgeCk7CiAgfQoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy91dGlscy50cwogIHZhciBEYXRhU291cmNlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoZmlsZSwgY2hyb21TaXplcywgb3B0aW9ucykgewogICAgICB0aGlzLmZpbGUgPSBmaWxlOwogICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOwogICAgICB0aGlzLmNocm9tSW5mbyA9IHNpemVzVG9DaHJvbUluZm8oY2hyb21TaXplcyk7CiAgICAgIHRoaXMudGlsZXNldEluZm8gPSB0aWxlc2V0SW5mb0Zyb21DaHJvbUluZm8odGhpcy5jaHJvbUluZm8pOwogICAgfQogICAgY2hyb21JbmZvOwogICAgdGlsZXNldEluZm87CiAgfTsKICB2YXIgY2hyb21JbmZvQmlzZWN0b3IgPSBiaXNlY3Rvcl9kZWZhdWx0KChkKSA9PiBkLnBvcykubGVmdDsKICB2YXIgY2hyVG9BYnMgPSAoY2hyb20sIGNocm9tUG9zLCBjaHJvbUluZm8pID0+IGNocm9tSW5mby5jaHJQb3NpdGlvbnNbY2hyb21dLnBvcyArIGNocm9tUG9zOwogIHZhciBhYnNUb0NociA9IChhYnNQb3NpdGlvbiwgY2hyb21JbmZvKSA9PiB7CiAgICBpZiAoIWNocm9tSW5mbyB8fCAhY2hyb21JbmZvLmN1bVBvc2l0aW9ucyB8fCAhY2hyb21JbmZvLmN1bVBvc2l0aW9ucy5sZW5ndGgpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICBsZXQgaW5zZXJ0UG9pbnQgPSBjaHJvbUluZm9CaXNlY3RvcihjaHJvbUluZm8uY3VtUG9zaXRpb25zLCBhYnNQb3NpdGlvbik7CiAgICBjb25zdCBsYXN0Q2hyID0gY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tjaHJvbUluZm8uY3VtUG9zaXRpb25zLmxlbmd0aCAtIDFdLmNocjsKICAgIGNvbnN0IGxhc3RMZW5ndGggPSBjaHJvbUluZm8uY2hyb21MZW5ndGhzW2xhc3RDaHJdOwogICAgaW5zZXJ0UG9pbnQgLT0gaW5zZXJ0UG9pbnQgPiAwICYmIDE7CiAgICBsZXQgY2hyUG9zaXRpb24gPSBNYXRoLmZsb29yKGFic1Bvc2l0aW9uIC0gY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tpbnNlcnRQb2ludF0ucG9zKTsKICAgIGxldCBvZmZzZXQgPSAwOwogICAgaWYgKGNoclBvc2l0aW9uIDwgMCkgewogICAgICBvZmZzZXQgPSBjaHJQb3NpdGlvbiAtIDE7CiAgICAgIGNoclBvc2l0aW9uID0gMTsKICAgIH0KICAgIGlmIChpbnNlcnRQb2ludCA9PT0gY2hyb21JbmZvLmN1bVBvc2l0aW9ucy5sZW5ndGggLSAxICYmIGNoclBvc2l0aW9uID4gbGFzdExlbmd0aCkgewogICAgICBvZmZzZXQgPSBjaHJQb3NpdGlvbiAtIGxhc3RMZW5ndGg7CiAgICAgIGNoclBvc2l0aW9uID0gbGFzdExlbmd0aDsKICAgIH0KICAgIHJldHVybiBbY2hyb21JbmZvLmN1bVBvc2l0aW9uc1tpbnNlcnRQb2ludF0uY2hyLCBjaHJQb3NpdGlvbiwgb2Zmc2V0LCBpbnNlcnRQb2ludF07CiAgfTsKICBmdW5jdGlvbiB0aWxlc2V0SW5mb0Zyb21DaHJvbUluZm8oY2hyb21JbmZvLCB0aWxlU2l6ZSA9IDEwMjQpIHsKICAgIHJldHVybiB7CiAgICAgIHRpbGVfc2l6ZTogdGlsZVNpemUsCiAgICAgIGJpbnNfcGVyX2RpbWVuc2lvbjogdGlsZVNpemUsCiAgICAgIG1heF96b29tOiBNYXRoLmNlaWwoTWF0aC5sb2coY2hyb21JbmZvLnRvdGFsTGVuZ3RoIC8gdGlsZVNpemUpIC8gTWF0aC5sb2coMikpLAogICAgICBtYXhfd2lkdGg6IGNocm9tSW5mby50b3RhbExlbmd0aCwKICAgICAgbWluX3BvczogWzBdLAogICAgICBtYXhfcG9zOiBbY2hyb21JbmZvLnRvdGFsTGVuZ3RoXQogICAgfTsKICB9CiAgZnVuY3Rpb24gc2l6ZXNUb0Nocm9tSW5mbyhzaXplcykgewogICAgY29uc3QgaW5mbyA9IHsKICAgICAgY3VtUG9zaXRpb25zOiBbXSwKICAgICAgY2hyb21MZW5ndGhzOiB7fSwKICAgICAgY2hyUG9zaXRpb25zOiB7fSwKICAgICAgdG90YWxMZW5ndGg6IDAKICAgIH07CiAgICBzaXplcy5mb3JFYWNoKChbY2hyLCBsZW5ndGhdLCBpKSA9PiB7CiAgICAgIGNvbnN0IGNoclBvc2l0aW9uID0geyBpZDogaSwgY2hyLCBwb3M6IGluZm8udG90YWxMZW5ndGggfTsKICAgICAgaW5mby5jaHJQb3NpdGlvbnNbY2hyXSA9IGNoclBvc2l0aW9uOwogICAgICBpbmZvLmNocm9tTGVuZ3Roc1tjaHJdID0gbGVuZ3RoOwogICAgICBpbmZvLmN1bVBvc2l0aW9ucy5wdXNoKGNoclBvc2l0aW9uKTsKICAgICAgaW5mby50b3RhbExlbmd0aCArPSBsZW5ndGg7CiAgICB9KTsKICAgIHJldHVybiB7CiAgICAgIC4uLmluZm8sCiAgICAgIGFic1RvQ2hyOiAoYWJzUG9zKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGFic1RvQ2hyKGFic1BvcywgaW5mbykgOiBudWxsLAogICAgICBjaHJUb0FiczogKFtjaHJOYW1lLCBjaHJQb3NdKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGNoclRvQWJzKGNock5hbWUsIGNoclBvcywgaW5mbykgOiBudWxsCiAgICB9OwogIH0KICB2YXIgUmVtb3RlRmlsZTIgPSBjbGFzcyBleHRlbmRzIFJlbW90ZUZpbGUgewogICAgcmVhZCA9IGFzeW5jIChidWZmZXIsIG9mZnNldCA9IDAsIGxlbmd0aCwgcG9zaXRpb24gPSAwLCBvcHRzID0ge30pID0+IHsKICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgIGlmIChsZW5ndGggPCBJbmZpbml0eSkgewogICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tJHtwb3NpdGlvbiArIGxlbmd0aH1gOwogICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gSW5maW5pdHkgJiYgcG9zaXRpb24gIT09IDApIHsKICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LWA7CiAgICAgIH0KICAgICAgY29uc3QgYXJncyA9IHsKICAgICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsCiAgICAgICAgLi4ub3ZlcnJpZGVzLAogICAgICAgIGhlYWRlcnM6IHsKICAgICAgICAgIC4uLmhlYWRlcnMsCiAgICAgICAgICAuLi5vdmVycmlkZXMuaGVhZGVycywKICAgICAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcy5oZWFkZXJzCiAgICAgICAgfSwKICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgIHJlZGlyZWN0OiAiZm9sbG93IiwKICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgc2lnbmFsCiAgICAgIH07CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncyk7CiAgICAgIGlmICghcmVzcG9uc2Uub2spIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gJHt0aGlzLnVybH1gKTsKICAgICAgfQogICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHsKICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICAgICAgY29uc3QgYnl0ZXNDb3BpZWQgPSByZXNwb25zZURhdGEuY29weShidWZmZXIsIG9mZnNldCwgMCwgTWF0aC5taW4obGVuZ3RoLCByZXNwb25zZURhdGEubGVuZ3RoKSk7CiAgICAgICAgY29uc3QgcmVzID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoImNvbnRlbnQtcmFuZ2UiKTsKICAgICAgICBjb25zdCBzaXplTWF0Y2ggPSAvXC8oXGQrKSQvLmV4ZWMocmVzIHx8ICIiKTsKICAgICAgICBpZiAoc2l6ZU1hdGNoICYmIHNpemVNYXRjaFsxXSkgewogICAgICAgICAgdGhpcy5fc3RhdCA9IHsgc2l6ZTogcGFyc2VJbnQoc2l6ZU1hdGNoWzFdLCAxMCkgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsgYnl0ZXNSZWFkOiBieXRlc0NvcGllZCwgYnVmZmVyIH07CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSBmZXRjaGluZyAke3RoaXMudXJsfWApOwogICAgfTsKICB9OwoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy9iZWQvYmVkLXBhcnNlci50cwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JlZEAyLjEuMi9ub2RlX21vZHVsZXMvQGdtb2QvYmVkL2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JlZEAyLjEuMi9ub2RlX21vZHVsZXMvQGdtb2QvYmVkL2VzbS9wYXJzZXIuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9hdXRvU3FsMiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9hdXRvU3FsKCkpOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmVkQDIuMS4yL25vZGVfbW9kdWxlcy9AZ21vZC9iZWQvZXNtL2RlZmF1bHRUeXBlcy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgaW1wb3J0X2F1dG9TcWwgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYXV0b1NxbCgpKTsKCiAgLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BnbW9kK2JlZEAyLjEuMi9ub2RlX21vZHVsZXMvQGdtb2QvYmVkL2VzbS9hcy9hdXRvU3FsU2NoZW1hcy5qcwogIHZhciBhdXRvU3FsU2NoZW1hc19leHBvcnRzID0ge307CiAgX19leHBvcnQoYXV0b1NxbFNjaGVtYXNfZXhwb3J0cywgewogICAgYmlnQ2hhaW46ICgpID0+IGJpZ0NoYWluLAogICAgYmlnR2VuZVByZWQ6ICgpID0+IGJpZ0dlbmVQcmVkLAogICAgYmlnSW50ZXJhY3Q6ICgpID0+IGJpZ0ludGVyYWN0LAogICAgYmlnTGluazogKCkgPT4gYmlnTGluaywKICAgIGJpZ01hZjogKCkgPT4gYmlnTWFmLAogICAgYmlnTmFycm93UGVhazogKCkgPT4gYmlnTmFycm93UGVhaywKICAgIGJpZ1BzbDogKCkgPT4gYmlnUHNsLAogICAgZGVmYXVsdEJlZFNjaGVtYTogKCkgPT4gZGVmYXVsdEJlZFNjaGVtYSwKICAgIG1hZkZyYW1lczogKCkgPT4gbWFmRnJhbWVzLAogICAgbWFmU3VtbWFyeTogKCkgPT4gbWFmU3VtbWFyeQogIH0pOwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgYmlnQ2hhaW4gPSBgdGFibGUgYmlnQ2hhaW4KImJpZ0NoYWluIHBhaXJ3aXNlIGFsaWdubWVudCIKICAgICgKICAgIHN0cmluZyBjaHJvbTsgICAgICAgIlJlZmVyZW5jZSBzZXF1ZW5jZSBjaHJvbW9zb21lIG9yIHNjYWZmb2xkIgogICAgdWludCAgIGNocm9tU3RhcnQ7ICAiU3RhcnQgcG9zaXRpb24gaW4gY2hyb21vc29tZSIKICAgIHVpbnQgICBjaHJvbUVuZDsgICAgIkVuZCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIgogICAgc3RyaW5nIG5hbWU7ICAgICAgICAiTmFtZSBvciBJRCBvZiBpdGVtLCBpZGVhbGx5IGJvdGggaHVtYW4gcmVhZGFibGUgYW5kIHVuaXF1ZSIKICAgIHVpbnQgc2NvcmU7ICAgICAgICAgIlNjb3JlICgwLTEwMDApIgogICAgY2hhclsxXSBzdHJhbmQ7ICAgICAiKyBvciAtIGZvciBzdHJhbmQiCiAgICB1aW50IHRTaXplOyAgICAgICAgICJzaXplIG9mIHRhcmdldCBzZXF1ZW5jZSIKICAgIHN0cmluZyBxTmFtZTsgICAgICAgIm5hbWUgb2YgcXVlcnkgc2VxdWVuY2UiCiAgICB1aW50IHFTaXplOyAgICAgICAgICJzaXplIG9mIHF1ZXJ5IHNlcXVlbmNlIgogICAgdWludCBxU3RhcnQ7ICAgICAgICAic3RhcnQgb2YgYWxpZ25tZW50IG9uIHF1ZXJ5IHNlcXVlbmNlIgogICAgdWludCBxRW5kOyAgICAgICAgICAiZW5kIG9mIGFsaWdubWVudCBvbiBxdWVyeSBzZXF1ZW5jZSIKICAgIHVpbnQgY2hhaW5TY29yZTsgICAgInNjb3JlIGZyb20gY2hhaW4iCiAgICApYDsKICB2YXIgYmlnR2VuZVByZWQgPSBgdGFibGUgYmlnR2VuZVByZWQKImJpZ0dlbmVQcmVkIGdlbmUgbW9kZWxzIgogICAoCiAgIHN0cmluZyBjaHJvbTsgICAgICAgIlJlZmVyZW5jZSBzZXF1ZW5jZSBjaHJvbW9zb21lIG9yIHNjYWZmb2xkIgogICB1aW50ICAgY2hyb21TdGFydDsgICJTdGFydCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIgogICB1aW50ICAgY2hyb21FbmQ7ICAgICJFbmQgcG9zaXRpb24gaW4gY2hyb21vc29tZSIKICAgc3RyaW5nIG5hbWU7ICAgICAgICAiTmFtZSBvciBJRCBvZiBpdGVtLCBpZGVhbGx5IGJvdGggaHVtYW4gcmVhZGFibGUgYW5kIHVuaXF1ZSIKICAgdWludCBzY29yZTsgICAgICAgICAiU2NvcmUgKDAtMTAwMCkiCiAgIGNoYXJbMV0gc3RyYW5kOyAgICAgIisgb3IgLSBmb3Igc3RyYW5kIgogICB1aW50IHRoaWNrU3RhcnQ7ICAgICJTdGFydCBvZiB3aGVyZSBkaXNwbGF5IHNob3VsZCBiZSB0aGljayAoc3RhcnQgY29kb24pIgogICB1aW50IHRoaWNrRW5kOyAgICAgICJFbmQgb2Ygd2hlcmUgZGlzcGxheSBzaG91bGQgYmUgdGhpY2sgKHN0b3AgY29kb24pIgogICB1aW50IHJlc2VydmVkOyAgICAgICAiUkdCIHZhbHVlICh1c2UgUixHLEIgc3RyaW5nIGluIGlucHV0IGZpbGUpIgogICBpbnQgYmxvY2tDb3VudDsgICAgICJOdW1iZXIgb2YgYmxvY2tzIgogICBpbnRbYmxvY2tDb3VudF0gYmxvY2tTaXplczsgIkNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGJsb2NrIHNpemVzIgogICBpbnRbYmxvY2tDb3VudF0gY2hyb21TdGFydHM7ICJTdGFydCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gY2hyb21TdGFydCIKICAgc3RyaW5nIG5hbWUyOyAgICAgICAiQWx0ZXJuYXRpdmUvaHVtYW4gcmVhZGFibGUgbmFtZSIKICAgc3RyaW5nIGNkc1N0YXJ0U3RhdDsgIlN0YXR1cyBvZiBDRFMgc3RhcnQgYW5ub3RhdGlvbiAobm9uZSwgdW5rbm93biwgaW5jb21wbGV0ZSwgb3IgY29tcGxldGUpIgogICBzdHJpbmcgY2RzRW5kU3RhdDsgICAiU3RhdHVzIG9mIENEUyBlbmQgYW5ub3RhdGlvbiAobm9uZSwgdW5rbm93biwgaW5jb21wbGV0ZSwgb3IgY29tcGxldGUpIgogICBpbnRbYmxvY2tDb3VudF0gZXhvbkZyYW1lczsgIkV4b24gZnJhbWUgezAsMSwyfSwgb3IgLTEgaWYgbm8gZnJhbWUgZm9yIGV4b24iCiAgIHN0cmluZyB0eXBlOyAgICAgICAgIlRyYW5zY3JpcHQgdHlwZSIKICAgc3RyaW5nIGdlbmVOYW1lOyAgICAiUHJpbWFyeSBpZGVudGlmaWVyIGZvciBnZW5lIgogICBzdHJpbmcgZ2VuZU5hbWUyOyAgICJBbHRlcm5hdGl2ZS9odW1hbiByZWFkYWJsZSBnZW5lIG5hbWUiCiAgIHN0cmluZyBnZW5lVHlwZTsgICAgIkdlbmUgdHlwZSIKICAgKWA7CiAgdmFyIGJpZ0ludGVyYWN0ID0gYHRhYmxlIGludGVyYWN0CiJpbnRlcmFjdGlvbiBiZXR3ZWVuIHR3byByZWdpb25zIgogICAgKAogICAgc3RyaW5nIGNocm9tOyAgICAgICAgIkNocm9tb3NvbWUgKG9yIGNvbnRpZywgc2NhZmZvbGQsIGV0Yy4pLiBGb3IgaW50ZXJjaHJvbW9zb21hbCwgdXNlIDIgcmVjb3JkcyIKICAgIHVpbnQgY2hyb21TdGFydDsgICAgICJTdGFydCBwb3NpdGlvbiBvZiBsb3dlciByZWdpb24uIEZvciBpbnRlcmNocm9tb3NvbWFsLCBzZXQgdG8gY2hyb21TdGFydCBvZiB0aGlzIHJlZ2lvbiIKICAgIHVpbnQgY2hyb21FbmQ7ICAgICAgICJFbmQgcG9zaXRpb24gb2YgdXBwZXIgcmVnaW9uLiBGb3IgaW50ZXJjaHJvbW9zb21hbCwgc2V0IHRvIGNocm9tRW5kIG9mIHRoaXMgcmVnaW9uIgogICAgc3RyaW5nIG5hbWU7ICAgICAgICAgIk5hbWUgb2YgaXRlbSwgZm9yIGRpc3BsYXkuICBVc3VhbGx5ICdzb3VyY2VOYW1lL3RhcmdldE5hbWUvZXhwJyBvciBlbXB0eSIKICAgIHVpbnQgc2NvcmU7ICAgICAgICAgICJTY29yZSAoMC0xMDAwKSIKICAgIGRvdWJsZSB2YWx1ZTsgICAgICAgICJTdHJlbmd0aCBvZiBpbnRlcmFjdGlvbiBvciBvdGhlciBkYXRhIHZhbHVlLiBUeXBpY2FsbHkgYmFzaXMgZm9yIHNjb3JlIgogICAgc3RyaW5nIGV4cDsgICAgICAgICAgIkV4cGVyaW1lbnQgbmFtZSAobWV0YWRhdGEgZm9yIGZpbHRlcmluZykuIFVzZSAuIGlmIG5vdCBhcHBsaWNhYmxlIgogICAgc3RyaW5nIGNvbG9yOyAgICAgICAgIkl0ZW0gY29sb3IuICBTcGVjaWZpZWQgYXMgcixnLGIgb3IgaGV4YWRlY2ltYWwgI1JSR0dCQiBvciBodG1sIGNvbG9yIG5hbWUsIGFzIGluIC8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNodG1sNC4gVXNlIDAgYW5kIHNwZWN0cnVtIHNldHRpbmcgdG8gc2hhZGUgYnkgc2NvcmUiCiAgICBzdHJpbmcgc291cmNlQ2hyb207ICAiQ2hyb21vc29tZSBvZiBzb3VyY2UgcmVnaW9uIChkaXJlY3Rpb25hbCkgb3IgbG93ZXIgcmVnaW9uLiBGb3Igbm9uLWRpcmVjdGlvbmFsIGludGVyY2hyb21vc29tYWwsIGNocm9tIG9mIHRoaXMgcmVnaW9uLiIKICAgIHVpbnQgc291cmNlU3RhcnQ7ICAgICJTdGFydCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIG9mIHNvdXJjZS9sb3dlci90aGlzIHJlZ2lvbiIKICAgIHVpbnQgc291cmNlRW5kOyAgICAgICJFbmQgcG9zaXRpb24gaW4gY2hyb21vc29tZSBvZiBzb3VyY2UvbG93ZXIvdGhpcyByZWdpb24iCiAgICBzdHJpbmcgc291cmNlTmFtZTsgICAiSWRlbnRpZmllciBvZiBzb3VyY2UvbG93ZXIvdGhpcyByZWdpb24iCiAgICBzdHJpbmcgc291cmNlU3RyYW5kOyAiT3JpZW50YXRpb24gb2Ygc291cmNlL2xvd2VyL3RoaXMgcmVnaW9uOiArIG9yIC0uICBVc2UgLiBpZiBub3QgYXBwbGljYWJsZSIKICAgIHN0cmluZyB0YXJnZXRDaHJvbTsgICJDaHJvbW9zb21lIG9mIHRhcmdldCByZWdpb24gKGRpcmVjdGlvbmFsKSBvciB1cHBlciByZWdpb24uIEZvciBub24tZGlyZWN0aW9uYWwgaW50ZXJjaHJvbW9zb21hbCwgY2hyb20gb2Ygb3RoZXIgcmVnaW9uIgogICAgdWludCB0YXJnZXRTdGFydDsgICAgIlN0YXJ0IHBvc2l0aW9uIGluIGNocm9tb3NvbWUgb2YgdGFyZ2V0L3VwcGVyL3RoaXMgcmVnaW9uIgogICAgdWludCB0YXJnZXRFbmQ7ICAgICAgIkVuZCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIG9mIHRhcmdldC91cHBlci90aGlzIHJlZ2lvbiIKICAgIHN0cmluZyB0YXJnZXROYW1lOyAgICJJZGVudGlmaWVyIG9mIHRhcmdldC91cHBlci90aGlzIHJlZ2lvbiIKICAgIHN0cmluZyB0YXJnZXRTdHJhbmQ7ICJPcmllbnRhdGlvbiBvZiB0YXJnZXQvdXBwZXIvdGhpcyByZWdpb246ICsgb3IgLS4gIFVzZSAuIGlmIG5vdCBhcHBsaWNhYmxlIgoKICAgIClgOwogIHZhciBiaWdMaW5rID0gYHRhYmxlIGJpZ0xpbmsKImJpZ0xpbmsgcGFpcndpc2UgYWxpZ25tZW50IgogICAgKAogICAgc3RyaW5nIGNocm9tOyAgICAgICAiUmVmZXJlbmNlIHNlcXVlbmNlIGNocm9tb3NvbWUgb3Igc2NhZmZvbGQiCiAgICB1aW50ICAgY2hyb21TdGFydDsgICJTdGFydCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIgogICAgdWludCAgIGNocm9tRW5kOyAgICAiRW5kIHBvc2l0aW9uIGluIGNocm9tb3NvbWUiCiAgICBzdHJpbmcgbmFtZTsgICAgICAgICJOYW1lIG9yIElEIG9mIGl0ZW0sIGlkZWFsbHkgYm90aCBodW1hbiByZWFkYWJsZSBhbmQgdW5pcXVlIgogICAgdWludCBxU3RhcnQ7ICAgICAgICAic3RhcnQgb2YgYWxpZ25tZW50IG9uIHF1ZXJ5IHNlcXVlbmNlIgogICAgKWA7CiAgdmFyIGJpZ01hZiA9IGB0YWJsZSBiZWRNYWYKIkJlZDMgd2l0aCBNQUYgYmxvY2siCiAgICAoCiAgICBzdHJpbmcgY2hyb207ICAgICAgIlJlZmVyZW5jZSBzZXF1ZW5jZSBjaHJvbW9zb21lIG9yIHNjYWZmb2xkIgogICAgdWludCAgIGNocm9tU3RhcnQ7ICJTdGFydCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIgogICAgdWludCAgIGNocm9tRW5kOyAgICJFbmQgcG9zaXRpb24gaW4gY2hyb21vc29tZSIKICAgIGxzdHJpbmcgbWFmQmxvY2s7ICAgIk1BRiBibG9jayIKICAgIClgOwogIHZhciBiaWdOYXJyb3dQZWFrID0gYHRhYmxlIGJpZ05hcnJvd1BlYWsKIkJFRDYrNCBQZWFrcyBvZiBzaWduYWwgZW5yaWNobWVudCBiYXNlZCBvbiBwb29sZWQsIG5vcm1hbGl6ZWQgKGludGVycHJldGVkKSBkYXRhLiIKKAogICAgc3RyaW5nIGNocm9tOyAgICAgICAgIlJlZmVyZW5jZSBzZXF1ZW5jZSBjaHJvbW9zb21lIG9yIHNjYWZmb2xkIgogICAgdWludCAgIGNocm9tU3RhcnQ7ICAgIlN0YXJ0IHBvc2l0aW9uIGluIGNocm9tb3NvbWUiCiAgICB1aW50ICAgY2hyb21FbmQ7ICAgICAiRW5kIHBvc2l0aW9uIGluIGNocm9tb3NvbWUiCiAgICBzdHJpbmcgbmFtZTsJICJOYW1lIGdpdmVuIHRvIGEgcmVnaW9uIChwcmVmZXJhYmx5IHVuaXF1ZSkuIFVzZSAuIGlmIG5vIG5hbWUgaXMgYXNzaWduZWQiCiAgICB1aW50ICAgc2NvcmU7ICAgICAgICAiSW5kaWNhdGVzIGhvdyBkYXJrIHRoZSBwZWFrIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSBicm93c2VyICgwLTEwMDApICIKICAgIGNoYXJbMV0gIHN0cmFuZDsgICAgICIrIG9yIC0gb3IgLiBmb3IgdW5rbm93biIKICAgIGZsb2F0ICBzaWduYWxWYWx1ZTsgICJNZWFzdXJlbWVudCBvZiBhdmVyYWdlIGVucmljaG1lbnQgZm9yIHRoZSByZWdpb24iCiAgICBmbG9hdCAgcFZhbHVlOyAgICAgICAiU3RhdGlzdGljYWwgc2lnbmlmaWNhbmNlIG9mIHNpZ25hbCB2YWx1ZSAoLWxvZzEwKS4gU2V0IHRvIC0xIGlmIG5vdCB1c2VkLiIKICAgIGZsb2F0ICBxVmFsdWU7ICAgICAgICJTdGF0aXN0aWNhbCBzaWduaWZpY2FuY2Ugd2l0aCBtdWx0aXBsZS10ZXN0IGNvcnJlY3Rpb24gYXBwbGllZCAoRkRSIC1sb2cxMCkuIFNldCB0byAtMSBpZiBub3QgdXNlZC4iCiAgICBpbnQgICBwZWFrOyAgICAgICAgICJQb2ludC1zb3VyY2UgY2FsbGVkIGZvciB0aGlzIHBlYWs7IDAtYmFzZWQgb2Zmc2V0IGZyb20gY2hyb21TdGFydC4gU2V0IHRvIC0xIGlmIG5vIHBvaW50LXNvdXJjZSBjYWxsZWQuIgopYDsKICB2YXIgYmlnUHNsID0gYHRhYmxlIGJpZ1BzbAoiYmlnUHNsIHBhaXJ3aXNlIGFsaWdubWVudCIKICAgICgKICAgIHN0cmluZyBjaHJvbTsgICAgICAgIlJlZmVyZW5jZSBzZXF1ZW5jZSBjaHJvbW9zb21lIG9yIHNjYWZmb2xkIgogICAgdWludCAgIGNocm9tU3RhcnQ7ICAiU3RhcnQgcG9zaXRpb24gaW4gY2hyb21vc29tZSIKICAgIHVpbnQgICBjaHJvbUVuZDsgICAgIkVuZCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIgogICAgc3RyaW5nIG5hbWU7ICAgICAgICAiTmFtZSBvciBJRCBvZiBpdGVtLCBpZGVhbGx5IGJvdGggaHVtYW4gcmVhZGFibGUgYW5kIHVuaXF1ZSIKICAgIHVpbnQgc2NvcmU7ICAgICAgICAgIlNjb3JlICgwLTEwMDApIgogICAgY2hhclsxXSBzdHJhbmQ7ICAgICAiKyBvciAtIGluZGljYXRlcyB3aGV0aGVyIHRoZSBxdWVyeSBhbGlnbnMgdG8gdGhlICsgb3IgLSBzdHJhbmQgb24gdGhlIHJlZmVyZW5jZSIKICAgIHVpbnQgdGhpY2tTdGFydDsgICAgIlN0YXJ0IG9mIHdoZXJlIGRpc3BsYXkgc2hvdWxkIGJlIHRoaWNrIChzdGFydCBjb2RvbikiCiAgICB1aW50IHRoaWNrRW5kOyAgICAgICJFbmQgb2Ygd2hlcmUgZGlzcGxheSBzaG91bGQgYmUgdGhpY2sgKHN0b3AgY29kb24pIgogICAgdWludCByZXNlcnZlZDsgICAgICAgIlJHQiB2YWx1ZSAodXNlIFIsRyxCIHN0cmluZyBpbiBpbnB1dCBmaWxlKSIKICAgIGludCBibG9ja0NvdW50OyAgICAgIk51bWJlciBvZiBibG9ja3MiCiAgICBpbnRbYmxvY2tDb3VudF0gYmxvY2tTaXplczsgIkNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGJsb2NrIHNpemVzIgogICAgaW50W2Jsb2NrQ291bnRdIGNocm9tU3RhcnRzOyAiU3RhcnQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIGNocm9tU3RhcnQiCgogICAgdWludCAgICBvQ2hyb21TdGFydDsiU3RhcnQgcG9zaXRpb24gaW4gb3RoZXIgY2hyb21vc29tZSIKICAgIHVpbnQgICAgb0Nocm9tRW5kOyAgIkVuZCBwb3NpdGlvbiBpbiBvdGhlciBjaHJvbW9zb21lIgogICAgY2hhclsxXSBvU3RyYW5kOyAgICAiKyBvciAtLCAtIG1lYW5zIHRoYXQgcHNsIHdhcyByZXZlcnNlZCBpbnRvIEJFRC1jb21wYXRpYmxlIGNvb3JkaW5hdGVzIgogICAgdWludCAgICBvQ2hyb21TaXplOyAiU2l6ZSBvZiBvdGhlciBjaHJvbW9zb21lLiIKICAgIGludFtibG9ja0NvdW50XSBvQ2hyb21TdGFydHM7ICJTdGFydCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gb0Nocm9tU3RhcnQgb3IgZnJvbSBvQ2hyb21TdGFydCtvQ2hyb21TaXplIGRlcGVuZGluZyBvbiBzdHJhbmQiCgogICAgbHN0cmluZyAgb1NlcXVlbmNlOyAgIlNlcXVlbmNlIG9uIG90aGVyIGNocm9tIChvciBlbXB0eSkiCiAgICBzdHJpbmcgICBvQ0RTOyAgICAgICAiQ0RTIGluIE5DQkkgZm9ybWF0IgoKICAgIHVpbnQgICAgY2hyb21TaXplOyJTaXplIG9mIHRhcmdldCBjaHJvbW9zb21lIgoKICAgIHVpbnQgbWF0Y2g7ICAgICAgICAiTnVtYmVyIG9mIGJhc2VzIG1hdGNoZWQuIgogICAgdWludCBtaXNNYXRjaDsgIiBOdW1iZXIgb2YgYmFzZXMgdGhhdCBkb24ndCBtYXRjaCAiCiAgICB1aW50IHJlcE1hdGNoOyAiIE51bWJlciBvZiBiYXNlcyB0aGF0IG1hdGNoIGJ1dCBhcmUgcGFydCBvZiByZXBlYXRzICIKICAgIHVpbnQgbkNvdW50OyAgICIgTnVtYmVyIG9mICdOJyBiYXNlcyAiCiAgICB1aW50IHNlcVR5cGU7ICAgICIwPWVtcHR5LCAxPW51Y2xlb3RpZGUsIDI9YW1pbm9fYWNpZCIKICAgIClgOwogIHZhciBkZWZhdWx0QmVkU2NoZW1hID0gYHRhYmxlIGRlZmF1bHRCZWRTY2hlbWEKIkJFRDEyIgogICAgKAogICAgc3RyaW5nIGNocm9tOyAgICAgICJUaGUgbmFtZSBvZiB0aGUgY2hyb21vc29tZSAoZS5nLiBjaHIzLCBjaHJZLCBjaHIyX3JhbmRvbSkgb3Igc2NhZmZvbGQgKGUuZy4gc2NhZmZvbGQxMDY3MSkuIgogICAgdWludCAgIGNocm9tU3RhcnQ7ICJUaGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgdGhlIGZlYXR1cmUgaW4gdGhlIGNocm9tb3NvbWUgb3Igc2NhZmZvbGQuIFRoZSBmaXJzdCBiYXNlIGluIGEgY2hyb21vc29tZSBpcyBudW1iZXJlZCAwLiIKICAgIHVpbnQgICBjaHJvbUVuZDsgICAiVGhlIGVuZGluZyBwb3NpdGlvbiBvZiB0aGUgZmVhdHVyZSBpbiB0aGUgY2hyb21vc29tZSBvciBzY2FmZm9sZC4gVGhlIGNocm9tRW5kIGJhc2UgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBkaXNwbGF5IG9mIHRoZSBmZWF0dXJlLiBGb3IgZXhhbXBsZSwgdGhlIGZpcnN0IDEwMCBiYXNlcyBvZiBhIGNocm9tb3NvbWUgYXJlIGRlZmluZWQgYXMgY2hyb21TdGFydD0wLCBjaHJvbUVuZD0xMDAsIGFuZCBzcGFuIHRoZSBiYXNlcyBudW1iZXJlZCAwLTk5LiIKICAgIHN0cmluZyAgIG5hbWU7ICAgIkRlZmluZXMgdGhlIG5hbWUgb2YgdGhlIEJFRCBsaW5lLiIKICAgIGZsb2F0ICAgc2NvcmU7ICAgIkZlYXR1cmUgc2NvcmUsIGRvZXNuJ3QgY2FyZSBhYm91dCB0aGUgMC0xMDAwIGxpbWl0IGFzIGluIGJlZCIKICAgIGNoYXIgICBzdHJhbmQ7ICAgIkRlZmluZXMgdGhlIHN0cmFuZC4gRWl0aGVyICcuJyAoPW5vIHN0cmFuZCkgb3IgJysnIG9yICctJyIKICAgIHVpbnQgdGhpY2tTdGFydDsgIlRoZSBzdGFydGluZyBwb3NpdGlvbiBhdCB3aGljaCB0aGUgZmVhdHVyZSBpcyBkcmF3biB0aGlja2x5IChmb3IgZXhhbXBsZSwgdGhlIHN0YXJ0IGNvZG9uIGluIGdlbmUgZGlzcGxheXMpLiBXaGVuIHRoZXJlIGlzIG5vIHRoaWNrIHBhcnQsIHRoaWNrU3RhcnQgYW5kIHRoaWNrRW5kIGFyZSB1c3VhbGx5IHNldCB0byB0aGUgY2hyb21TdGFydCBwb3NpdGlvbi4iCiAgICB1aW50IHRoaWNrRW5kOyAiVGhlIGVuZGluZyBwb3NpdGlvbiBhdCB3aGljaCB0aGUgZmVhdHVyZSBpcyBkcmF3biB0aGlja2x5IChmb3IgZXhhbXBsZSB0aGUgc3RvcCBjb2RvbiBpbiBnZW5lIGRpc3BsYXlzKS4iCiAgICBzdHJpbmcgaXRlbVJnYjsgIkFuIFJHQiB2YWx1ZSBvZiB0aGUgZm9ybSBSLEcsQiAoZS5nLiAyNTUsMCwwKS4gIgogICAgdWludCBibG9ja0NvdW50OyAiIFRoZSBudW1iZXIgb2YgYmxvY2tzIChleG9ucykgaW4gdGhlIEJFRCBsaW5lLiIKICAgIHVpbnRbYmxvY2tDb3VudF0gYmxvY2tTaXplczsgIiBBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHRoZSBibG9jayBzaXplcy4gVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGlzIGxpc3Qgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYmxvY2tDb3VudC4iCiAgICB1aW50W2Jsb2NrQ291bnRdIGJsb2NrU3RhcnRzOyAiQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBibG9jayBzdGFydHMuIEFsbCBvZiB0aGUgYmxvY2tTdGFydCBwb3NpdGlvbnMgc2hvdWxkIGJlIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gY2hyb21TdGFydC4gVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGlzIGxpc3Qgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYmxvY2tDb3VudC4iCiAgICApYDsKICB2YXIgbWFmRnJhbWVzID0gYHRhYmxlIG1hZkZyYW1lcwoiY29kb24gZnJhbWUgYXNzaWdubWVudCBmb3IgTUFGIGNvbXBvbmVudHMiCiAgICAoCiAgICBzdHJpbmcgY2hyb207ICAgICAgIlJlZmVyZW5jZSBzZXF1ZW5jZSBjaHJvbW9zb21lIG9yIHNjYWZmb2xkIgogICAgdWludCAgIGNocm9tU3RhcnQ7ICJTdGFydCByYW5nZSBpbiBjaHJvbW9zb21lIgogICAgdWludCAgIGNocm9tRW5kOyAgICJFbmQgcmFuZ2UgaW4gY2hyb21vc29tZSIKICAgIHN0cmluZyBzcmM7ICAgICAgICAiTmFtZSBvZiBzZXF1ZW5jZSBzb3VyY2UgaW4gTUFGIgogICAgdWJ5dGUgZnJhbWU7ICAgICAgICJmcmFtZSAoMCwxLDIpIGZvciBmaXJzdCBiYXNlKCspIG9yIGxhc3QgYmFzdCgtKSIKICAgIGNoYXJbMV0gc3RyYW5kOyAgICAiKyBvciAtIgogICAgc3RyaW5nIG5hbWU7ICAgICAgICJOYW1lIG9mIGdlbmUgdXNlZCB0byBkZWZpbmUgZnJhbWUiCiAgICBpbnQgICAgcHJldkZyYW1lUG9zOyAgInRhcmdldCBwb3NpdGlvbiBvZiB0aGUgcHJldmlvdXMgYmFzZSAoaW4gdHJhbnNjcmlwdGlvbiBkaXJlY3Rpb24pIHRoYXQgY29udGludWVzIHRoaXMgZnJhbWUsIG9yIC0xIGlmIG5vbmUsIG9yIGZyYW1lIG5vdCBjb250aWd1b3VzIgogICAgaW50ICAgIG5leHRGcmFtZVBvczsgICJ0YXJnZXQgcG9zaXRpb24gb2YgdGhlIG5leHQgYmFzZSAoaW4gdHJhbnNjcmlwdGlvbiBkaXJlY3Rpb24pIHRoYXQgY29udGludWVzIHRoaXMgZnJhbWUsIG9yIC0xIGlmIG5vbmUsIG9yIGZyYW1lIG5vdCBjb250aWd1b3VzIgogICAgdWJ5dGUgIGlzRXhvblN0YXJ0OyAgImRvZXMgdGhpcyBzdGFydCB0aGUgQ0RTIHBvcnRpb24gb2YgYW4gZXhvbj8iCiAgICB1Ynl0ZSAgaXNFeG9uRW5kOyAgICAiZG9lcyB0aGlzIGVuZCB0aGUgQ0RTIHBvcnRpb24gb2YgYW4gZXhvbj8iCiAgICApYDsKICB2YXIgbWFmU3VtbWFyeSA9IGB0YWJsZSBtYWZTdW1tYXJ5CiJQb3NpdGlvbnMgYW5kIHNjb3JlcyBmb3IgYWxpZ25tZW50IGJsb2NrcyIKICAgICgKICAgIHN0cmluZyBjaHJvbTsgICAgICAiUmVmZXJlbmNlIHNlcXVlbmNlIGNocm9tb3NvbWUgb3Igc2NhZmZvbGQiCiAgICB1aW50ICAgY2hyb21TdGFydDsgIlN0YXJ0IHBvc2l0aW9uIGluIGNocm9tb3NvbWUiCiAgICB1aW50ICAgY2hyb21FbmQ7ICAgIkVuZCBwb3NpdGlvbiBpbiBjaHJvbW9zb21lIgogICAgc3RyaW5nIHNyYzsgICAgICAgICJTZXF1ZW5jZSBuYW1lIG9yIGRhdGFiYXNlIG9mIGFsaWdubWVudCIKICAgIGZsb2F0ICBzY29yZTsgICAgICAiRmxvYXRpbmcgcG9pbnQgc2NvcmUuIgogICAgY2hhclsxXSBsZWZ0U3RhdHVzOyAgIkdhcC9icmVhayBhbm5vdGF0aW9uIGZvciBwcmVjZWRpbmcgYmxvY2siCiAgICBjaGFyWzFdIHJpZ2h0U3RhdHVzOyAiR2FwL2JyZWFrIGFubm90YXRpb24gZm9yIGZvbGxvd2luZyBibG9jayIKICAgIClgOwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmVkQDIuMS4yL25vZGVfbW9kdWxlcy9AZ21vZC9iZWQvZXNtL2RlZmF1bHRUeXBlcy5qcwogIHZhciBkZWZhdWx0VHlwZXNfZGVmYXVsdCA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhhdXRvU3FsU2NoZW1hc19leHBvcnRzKS5tYXAoKFtrZXksIHZhbF0pID0+IFsKICAgIGtleSwKICAgICgwLCBpbXBvcnRfYXV0b1NxbC5wYXJzZSkodmFsLnRyaW0oKSkKICBdKSk7CgogIC8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AZ21vZCtiZWRAMi4xLjIvbm9kZV9tb2R1bGVzL0BnbW9kL2JlZC9lc20vdXRpbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBkZXRlY3RUeXBlcyhhdXRvU3FsKSB7CiAgICBjb25zdCBudW1lcmljVHlwZXMgPSBbInVpbnQiLCAiaW50IiwgImZsb2F0IiwgImxvbmciXTsKICAgIHJldHVybiB7CiAgICAgIC4uLmF1dG9TcWwsCiAgICAgIGZpZWxkczogYXV0b1NxbC5maWVsZHMubWFwKChhdXRvRmllbGQpID0+ICh7CiAgICAgICAgLi4uYXV0b0ZpZWxkLAogICAgICAgIGlzQXJyYXk6IGF1dG9GaWVsZC5zaXplICYmIGF1dG9GaWVsZC50eXBlICE9PSAiY2hhciIsCiAgICAgICAgYXJyYXlJc051bWVyaWM6IGF1dG9GaWVsZC5zaXplICYmIG51bWVyaWNUeXBlcy5pbmNsdWRlcyhhdXRvRmllbGQudHlwZSksCiAgICAgICAgaXNOdW1lcmljOiAhYXV0b0ZpZWxkLnNpemUgJiYgbnVtZXJpY1R5cGVzLmluY2x1ZGVzKGF1dG9GaWVsZC50eXBlKQogICAgICB9KSkKICAgIH07CiAgfQoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmVkQDIuMS4yL25vZGVfbW9kdWxlcy9AZ21vZC9iZWQvZXNtL3BhcnNlci5qcwogIHZhciBzdHJhbmRNYXAgPSB7ICIuIjogMCwgIi0iOiAtMSwgIisiOiAxIH07CiAgZnVuY3Rpb24gaXNCZWQxMkxpa2UoZmllbGRzKSB7CiAgICB2YXIgX2E7CiAgICByZXR1cm4gZmllbGRzLmxlbmd0aCA+PSAxMiAmJiAhTnVtYmVyLmlzTmFOKHBhcnNlSW50KGZpZWxkc1s5XSwgMTApKSAmJiAoKF9hID0gZmllbGRzWzEwXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KCIsIikuZmlsdGVyKChmKSA9PiAhIWYpLmxlbmd0aCkgPT09IHBhcnNlSW50KGZpZWxkc1s5XSwgMTApOwogIH0KICB2YXIgQkVEID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoYXJncyA9IHt9KSB7CiAgICAgIGlmIChhcmdzLmF1dG9TcWwpIHsKICAgICAgICB0aGlzLmF1dG9TcWwgPSBkZXRlY3RUeXBlcyhpbXBvcnRfYXV0b1NxbDIuZGVmYXVsdC5wYXJzZShhcmdzLmF1dG9TcWwpKTsKICAgICAgfSBlbHNlIGlmIChhcmdzLnR5cGUpIHsKICAgICAgICBpZiAoIWRlZmF1bHRUeXBlc19kZWZhdWx0W2FyZ3MudHlwZV0pIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiVHlwZSBub3QgZm91bmQiKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5hdXRvU3FsID0gZGV0ZWN0VHlwZXMoZGVmYXVsdFR5cGVzX2RlZmF1bHRbYXJncy50eXBlXSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5hdXRvU3FsID0gZGV0ZWN0VHlwZXMoZGVmYXVsdFR5cGVzX2RlZmF1bHQuZGVmYXVsdEJlZFNjaGVtYSk7CiAgICAgICAgdGhpcy5hdHRlbXB0RGVmYXVsdEJlZCA9IHRydWU7CiAgICAgIH0KICAgIH0KICAgIHBhcnNlTGluZShsaW5lLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgeyBhdXRvU3FsIH0gPSB0aGlzOwogICAgICBjb25zdCB7IHVuaXF1ZUlkIH0gPSBvcHRzOwogICAgICBjb25zdCBmaWVsZHMgPSBBcnJheS5pc0FycmF5KGxpbmUpID8gbGluZSA6IGxpbmUuc3BsaXQoIgkiKTsKICAgICAgbGV0IGZlYXR1cmUgPSB7fTsKICAgICAgaWYgKCF0aGlzLmF0dGVtcHREZWZhdWx0QmVkIHx8IHRoaXMuYXR0ZW1wdERlZmF1bHRCZWQgJiYgaXNCZWQxMkxpa2UoZmllbGRzKSkgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXV0b1NxbC5maWVsZHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGNvbnN0IGF1dG9GaWVsZCA9IGF1dG9TcWwuZmllbGRzW2ldOwogICAgICAgICAgbGV0IGNvbHVtblZhbCA9IGZpZWxkc1tpXTsKICAgICAgICAgIGNvbnN0IHsgaXNOdW1lcmljLCBpc0FycmF5OiBpc0FycmF5MiwgYXJyYXlJc051bWVyaWMsIG5hbWUgfSA9IGF1dG9GaWVsZDsKICAgICAgICAgIGlmIChjb2x1bW5WYWwgPT09IG51bGwgfHwgY29sdW1uVmFsID09PSB2b2lkIDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY29sdW1uVmFsICE9PSAiLiIpIHsKICAgICAgICAgICAgaWYgKGlzTnVtZXJpYykgewogICAgICAgICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihjb2x1bW5WYWwpOwogICAgICAgICAgICAgIGNvbHVtblZhbCA9IE51bWJlci5pc05hTihudW0pID8gY29sdW1uVmFsIDogbnVtOwogICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkyKSB7CiAgICAgICAgICAgICAgY29sdW1uVmFsID0gY29sdW1uVmFsLnNwbGl0KCIsIik7CiAgICAgICAgICAgICAgaWYgKGNvbHVtblZhbFtjb2x1bW5WYWwubGVuZ3RoIC0gMV0gPT09ICIiKSB7CiAgICAgICAgICAgICAgICBjb2x1bW5WYWwucG9wKCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChhcnJheUlzTnVtZXJpYykgewogICAgICAgICAgICAgICAgY29sdW1uVmFsID0gY29sdW1uVmFsLm1hcCgoc3RyKSA9PiBOdW1iZXIoc3RyKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZlYXR1cmVbbmFtZV0gPSBjb2x1bW5WYWw7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBbImNocm9tIiwgImNocm9tU3RhcnQiLCAiY2hyb21FbmQiLCAibmFtZSJdOwogICAgICAgIGZlYXR1cmUgPSBPYmplY3QuZnJvbUVudHJpZXMoZmllbGRzLm1hcCgoZiwgaSkgPT4gW2ZpZWxkTmFtZXNbaV0gfHwgImZpZWxkIiArIGksIGZdKSk7CiAgICAgICAgZmVhdHVyZS5jaHJvbVN0YXJ0ID0gK2ZlYXR1cmUuY2hyb21TdGFydDsKICAgICAgICBmZWF0dXJlLmNocm9tRW5kID0gK2ZlYXR1cmUuY2hyb21FbmQ7CiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oTnVtYmVyLnBhcnNlRmxvYXQoZmVhdHVyZS5maWVsZDQpKSkgewogICAgICAgICAgZmVhdHVyZS5zY29yZSA9ICtmZWF0dXJlLmZpZWxkNDsKICAgICAgICAgIGRlbGV0ZSBmZWF0dXJlLmZpZWxkNDsKICAgICAgICB9CiAgICAgICAgaWYgKGZlYXR1cmUuZmllbGQ1ID09PSAiKyIgfHwgZmVhdHVyZS5maWVsZDUgPT09ICItIikgewogICAgICAgICAgZmVhdHVyZS5zdHJhbmQgPSBmZWF0dXJlLmZpZWxkNTsKICAgICAgICAgIGRlbGV0ZSBmZWF0dXJlLmZpZWxkNTsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKHVuaXF1ZUlkKSB7CiAgICAgICAgZmVhdHVyZS51bmlxdWVJZCA9IHVuaXF1ZUlkOwogICAgICB9CiAgICAgIGZlYXR1cmUuc3RyYW5kID0gc3RyYW5kTWFwW2ZlYXR1cmUuc3RyYW5kXSB8fCAwOwogICAgICBmZWF0dXJlLmNocm9tID0gZGVjb2RlVVJJQ29tcG9uZW50KGZlYXR1cmUuY2hyb20pOwogICAgICByZXR1cm4gZmVhdHVyZTsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvLnBucG0vQGdtb2QrYmVkQDIuMS4yL25vZGVfbW9kdWxlcy9AZ21vZC9iZWQvZXNtL2luZGV4LmpzCiAgdmFyIGVzbV9kZWZhdWx0ID0gQkVEOwoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy9iZWQvYmVkLXBhcnNlci50cwogIHZhciBERUZBVUxUX0JFRF9TQ0hFTUEgPSBgdGFibGUgZGVmYXVsdEJlZFNjaGVtYQoiQkVEMTIiCiAgICAoCiAgICBzdHJpbmcgY2hyb207ICAgICAgIlRoZSBuYW1lIG9mIHRoZSBjaHJvbW9zb21lIChlLmcuIGNocjMsIGNoclksIGNocjJfcmFuZG9tKSBvciBzY2FmZm9sZCAoZS5nLiBzY2FmZm9sZDEwNjcxKS4iCiAgICB1aW50ICAgY2hyb21TdGFydDsgIlRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiB0aGUgZmVhdHVyZSBpbiB0aGUgY2hyb21vc29tZSBvciBzY2FmZm9sZC4gVGhlIGZpcnN0IGJhc2UgaW4gYSBjaHJvbW9zb21lIGlzIG51bWJlcmVkIDAuIgogICAgdWludCAgIGNocm9tRW5kOyAgICJUaGUgZW5kaW5nIHBvc2l0aW9uIG9mIHRoZSBmZWF0dXJlIGluIHRoZSBjaHJvbW9zb21lIG9yIHNjYWZmb2xkLiBUaGUgY2hyb21FbmQgYmFzZSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGRpc3BsYXkgb2YgdGhlIGZlYXR1cmUuIEZvciBleGFtcGxlLCB0aGUgZmlyc3QgMTAwIGJhc2VzIG9mIGEgY2hyb21vc29tZSBhcmUgZGVmaW5lZCBhcyBjaHJvbVN0YXJ0PTAsIGNocm9tRW5kPTEwMCwgYW5kIHNwYW4gdGhlIGJhc2VzIG51bWJlcmVkIDAtOTkuIgogICAgc3RyaW5nICAgbmFtZTsgICAiRGVmaW5lcyB0aGUgbmFtZSBvZiB0aGUgQkVEIGxpbmUuIgogICAgZmxvYXQgICBzY29yZTsgICAiRmVhdHVyZSBzY29yZSwgZG9lc24ndCBjYXJlIGFib3V0IHRoZSAwLTEwMDAgbGltaXQgYXMgaW4gYmVkIgogICAgY2hhciAgIHN0cmFuZDsgICAiRGVmaW5lcyB0aGUgc3RyYW5kLiBFaXRoZXIgJy4nICg9bm8gc3RyYW5kKSBvciAnKycgb3IgJy0nIgogICAgdWludCB0aGlja1N0YXJ0OyAiVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBmZWF0dXJlIGlzIGRyYXduIHRoaWNrbHkgKGZvciBleGFtcGxlLCB0aGUgc3RhcnQgY29kb24gaW4gZ2VuZSBkaXNwbGF5cykuIFdoZW4gdGhlcmUgaXMgbm8gdGhpY2sgcGFydCwgdGhpY2tTdGFydCBhbmQgdGhpY2tFbmQgYXJlIHVzdWFsbHkgc2V0IHRvIHRoZSBjaHJvbVN0YXJ0IHBvc2l0aW9uLiIKICAgIHVpbnQgdGhpY2tFbmQ7ICJUaGUgZW5kaW5nIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBmZWF0dXJlIGlzIGRyYXduIHRoaWNrbHkgKGZvciBleGFtcGxlIHRoZSBzdG9wIGNvZG9uIGluIGdlbmUgZGlzcGxheXMpLiIKICAgIHN0cmluZyBpdGVtUmdiOyAiQW4gUkdCIHZhbHVlIG9mIHRoZSBmb3JtIFIsRyxCIChlLmcuIDI1NSwwLDApLiAiCiAgICB1aW50IGJsb2NrQ291bnQ7ICIgVGhlIG51bWJlciBvZiBibG9ja3MgKGV4b25zKSBpbiB0aGUgQkVEIGxpbmUuIgogICAgdWludFtibG9ja0NvdW50XSBibG9ja1NpemVzOyAiIEEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIGJsb2NrIHNpemVzLiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoaXMgbGlzdCBzaG91bGQgY29ycmVzcG9uZCB0byBibG9ja0NvdW50LiIKICAgIHVpbnRbYmxvY2tDb3VudF0gYmxvY2tTdGFydHM7ICJBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGJsb2NrIHN0YXJ0cy4gQWxsIG9mIHRoZSBibG9ja1N0YXJ0IHBvc2l0aW9ucyBzaG91bGQgYmUgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byBjaHJvbVN0YXJ0LiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoaXMgbGlzdCBzaG91bGQgY29ycmVzcG9uZCB0byBibG9ja0NvdW50LiIKICAgIClgOwogIHZhciBCZWRQYXJzZXIgPSBjbGFzcyB7CiAgICAjY3VzdG9tRmllbGRzOwogICAgI25fY29sdW1uczsKICAgICNwYXJzZXI7CiAgICBjb25zdHJ1Y3RvcihvcHQpIHsKICAgICAgdGhpcy4jY3VzdG9tRmllbGRzID0gb3B0Py5jdXN0b21GaWVsZHM7CiAgICAgIHRoaXMuI25fY29sdW1ucyA9IG9wdD8ubl9jb2x1bW5zOwogICAgICBpZiAodGhpcy4jY3VzdG9tRmllbGRzKSB7CiAgICAgICAgY29uc3QgY3VzdG9tQXV0b1NxbFNjaGVtYSA9IHRoaXMuY29uc3RydWN0QmVkQXV0b1NxbCgpOwogICAgICAgIHRoaXMuI3BhcnNlciA9IG5ldyBlc21fZGVmYXVsdCh7IGF1dG9TcWw6IGN1c3RvbUF1dG9TcWxTY2hlbWEgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy4jcGFyc2VyID0gbmV3IGVzbV9kZWZhdWx0KHsgYXV0b1NxbDogREVGQVVMVF9CRURfU0NIRU1BIH0pOwogICAgICB9CiAgICB9CiAgICBwYXJzZUxpbmUobGluZSwgY2hyb21TdGFydCkgewogICAgICBmdW5jdGlvbiByZWxhdGl2ZVRvQ3VtdWxhdGl2ZShwb3MsIGNocm9tU3RhcnQyKSB7CiAgICAgICAgcmV0dXJuIGNocm9tU3RhcnQyICsgcG9zICsgMTsKICAgICAgfQogICAgICBjb25zdCBiZWRSZWNvcmQgPSB0aGlzLiNwYXJzZXIucGFyc2VMaW5lKGxpbmUpOwogICAgICBjb25zdCBmaWVsZHNUb0NvbnZlcnQgPSBbImNocm9tU3RhcnQiLCAiY2hyb21FbmQiLCAidGhpY2tFbmQiLCAidGhpY2tTdGFydCJdOwogICAgICBmaWVsZHNUb0NvbnZlcnQuZm9yRWFjaCgoZmllbGQpID0+IHsKICAgICAgICBpZiAoYmVkUmVjb3JkW2ZpZWxkXSkKICAgICAgICAgIGJlZFJlY29yZFtmaWVsZF0gPSByZWxhdGl2ZVRvQ3VtdWxhdGl2ZShiZWRSZWNvcmRbZmllbGRdLCBjaHJvbVN0YXJ0KTsKICAgICAgfSk7CiAgICAgIHJldHVybiBiZWRSZWNvcmQ7CiAgICB9CiAgICBjb25zdHJ1Y3RCZWRBdXRvU3FsKCkgewogICAgICBjb25zdCBBVVRPX1NRTF9IRUFERVIgPSBgdGFibGUgY3VzdG9tQmVkU2NoZW1hCiJCRUQxMiIKICAgICgKYDsKICAgICAgY29uc3QgQVVUT19TUUxfRk9PVEVSID0gIlxuICAgICkiOwogICAgICBjb25zdCBhdXRvU3FsRmllbGRzID0gdGhpcy4jZ2VuZXJhdGVBdXRvU1FMRmllbGRzKCk7CiAgICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmNvbmNhdChBVVRPX1NRTF9IRUFERVIsIGF1dG9TcWxGaWVsZHMsIEFVVE9fU1FMX0ZPT1RFUik7CiAgICB9CiAgICAjZ2VuZXJhdGVBdXRvU1FMRmllbGRzKCkgewogICAgICBjb25zdCBCRUQxMkZpZWxkcyA9IFsKICAgICAgICBbInN0cmluZyIsICJjaHJvbSJdLAogICAgICAgIFsidWludCIsICJjaHJvbVN0YXJ0Il0sCiAgICAgICAgWyJ1aW50IiwgImNocm9tRW5kIl0sCiAgICAgICAgWyJzdHJpbmciLCAibmFtZSJdLAogICAgICAgIFsiZmxvYXQiLCAic2NvcmUiXSwKICAgICAgICBbImNoYXIiLCAic3RyYW5kIl0sCiAgICAgICAgWyJ1aW50IiwgInRoaWNrU3RhcnQiXSwKICAgICAgICBbInVpbnQiLCAidGhpY2tFbmQiXSwKICAgICAgICBbInN0cmluZyIsICJpdGVtUmdiIl0sCiAgICAgICAgWyJ1aW50IiwgImJsb2NrQ291bnQiXSwKICAgICAgICBbInVpbnRbYmxvY2tDb3VudF0iLCAiYmxvY2tTaXplcyJdLAogICAgICAgIFsidWludFtibG9ja0NvdW50XSIsICJibG9ja1N0YXJ0cyJdCiAgICAgIF07CiAgICAgIGlmICghdGhpcy4jbl9jb2x1bW5zKQogICAgICAgIHRocm93IG5ldyBFcnJvcigiTnVtYmVyIG9mIGNvbHVtbnMgd2FzIG5vdCBhYmxlIHRvIGJlIGRldGVybWluZWQiKTsKICAgICAgaWYgKCF0aGlzLiNjdXN0b21GaWVsZHMpCiAgICAgICAgcmV0dXJuICIiOwogICAgICBjb25zdCBjdXN0b21GaWVsZFR5cGUgPSAic3RyaW5nIjsKICAgICAgY29uc3QgY3VzdG9tRmllbGRzV2l0aFR5cGVzID0gdGhpcy4jY3VzdG9tRmllbGRzLm1hcCgoY29sdW1uKSA9PiBbY3VzdG9tRmllbGRUeXBlLCBjb2x1bW5dKTsKICAgICAgbGV0IGFsbEZpZWxkczsKICAgICAgY29uc3QgUkVRVUlSRURfQ09MUyA9IDM7CiAgICAgIGlmICh0aGlzLiNuX2NvbHVtbnMgPiBCRUQxMkZpZWxkcy5sZW5ndGgpIHsKICAgICAgICBpZiAodGhpcy4jbl9jb2x1bW5zICE9PSBCRUQxMkZpZWxkcy5sZW5ndGggKyB0aGlzLiNjdXN0b21GaWVsZHMubGVuZ3RoKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJFRCBmaWxlIGVycm9yOiB1bmV4cGVjdGVkIG51bWJlciBvZiBjdXN0b20gZmllbGRzLiBGb3VuZCAke3RoaXMuI25fY29sdW1uc30gY29sdW1ucyAKICAgICAgICAgICAgICAgICAgICB3aGljaCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZXhwZWN0ZWQgJHtCRUQxMkZpZWxkcy5sZW5ndGggKyB0aGlzLiNjdXN0b21GaWVsZHMubGVuZ3RofWApOwogICAgICAgIH0KICAgICAgICBhbGxGaWVsZHMgPSBCRUQxMkZpZWxkcy5jb25jYXQoY3VzdG9tRmllbGRzV2l0aFR5cGVzKTsKICAgICAgfSBlbHNlIGlmICh0aGlzLiNuX2NvbHVtbnMgPj0gUkVRVUlSRURfQ09MUyArIHRoaXMuI2N1c3RvbUZpZWxkcy5sZW5ndGgpIHsKICAgICAgICBhbGxGaWVsZHMgPSBCRUQxMkZpZWxkcy5zbGljZSgwLCB0aGlzLiNuX2NvbHVtbnMgLSB0aGlzLiNjdXN0b21GaWVsZHMubGVuZ3RoKS5jb25jYXQoY3VzdG9tRmllbGRzV2l0aFR5cGVzKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7UkVRVUlSRURfQ09MUyArIHRoaXMuI2N1c3RvbUZpZWxkcy5sZW5ndGh9IGNvbHVtbnMgKCR7UkVRVUlSRURfQ09MU30gcmVxdWlyZWQgY29sdW1ucyBhbmQgJHt0aGlzLiNjdXN0b21GaWVsZHMubGVuZ3RofSBjdXN0b20gY29sdW1ucykgYnV0IGZvdW5kICR7dGhpcy4jbl9jb2x1bW5zfSBjb2x1bW5zYCk7CiAgICAgIH0KICAgICAgY29uc3QgZmllbGREZXNjcmlwdGlvbiA9ICJjdXN0b20gaW5wdXQiOwogICAgICBjb25zdCBhdXRvU3FsRmllbGRzID0gYWxsRmllbGRzLm1hcCgoZmllbGRJbmZvKSA9PiBgICAgICR7ZmllbGRJbmZvWzBdfSAke2ZpZWxkSW5mb1sxXX07ICIke2ZpZWxkRGVzY3JpcHRpb259ImApLmpvaW4oIlxuIik7CiAgICAgIHJldHVybiBhdXRvU3FsRmllbGRzOwogICAgfQogIH07CiAgdmFyIGJlZF9wYXJzZXJfZGVmYXVsdCA9IEJlZFBhcnNlcjsKCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvYmVkL2JlZC13b3JrZXIudHM/d29ya2VyJmlubGluZT93b3JrZXJfZmlsZQogIHZhciBCZWRGaWxlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IodGJpLCB1aWQpIHsKICAgICAgdGhpcy50YmkgPSB0Ymk7CiAgICAgIHRoaXMuI3VpZCA9IHVpZDsKICAgIH0KICAgICNwYXJzZXI7CiAgICAjY3VzdG9tRmllbGRzOwogICAgI3VpZDsKICAgIHN0YXRpYyBmcm9tVXJsKHVybCwgaW5kZXhVcmwsIHVpZCwgdXJsRmV0Y2hPcHRpb25zLCBpbmRleFVybEZldGNoT3B0aW9ucykgewogICAgICBjb25zdCB0YmkgPSBuZXcgVGFiaXhJbmRleGVkRmlsZSh7CiAgICAgICAgZmlsZWhhbmRsZTogbmV3IFJlbW90ZUZpbGUyKHVybCwgeyBvdmVycmlkZXM6IHVybEZldGNoT3B0aW9ucyB9KSwKICAgICAgICB0YmlGaWxlaGFuZGxlOiBuZXcgUmVtb3RlRmlsZTIoaW5kZXhVcmwsIHsgb3ZlcnJpZGVzOiBpbmRleFVybEZldGNoT3B0aW9ucyB9KQogICAgICB9KTsKICAgICAgcmV0dXJuIG5ldyBCZWRGaWxlKHRiaSwgdWlkKTsKICAgIH0KICAgIHNldCBjdXN0b21GaWVsZHMoY3VzdG9tKSB7CiAgICAgIHRoaXMuI2N1c3RvbUZpZWxkcyA9IGN1c3RvbTsKICAgIH0KICAgIGFzeW5jIGdldFBhcnNlcigpIHsKICAgICAgaWYgKCF0aGlzLiNwYXJzZXIpIHsKICAgICAgICBjb25zdCBvcHQgPSB0aGlzLiNjdXN0b21GaWVsZHMgPyB7IGN1c3RvbUZpZWxkczogdGhpcy4jY3VzdG9tRmllbGRzLCBuX2NvbHVtbnM6IGF3YWl0IHRoaXMuI2NhbGNOQ29sdW1ucygpIH0gOiB2b2lkIDA7CiAgICAgICAgdGhpcy4jcGFyc2VyID0gbmV3IGJlZF9wYXJzZXJfZGVmYXVsdChvcHQpOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLiNwYXJzZXI7CiAgICB9CiAgICBhc3luYyAjY2FsY05Db2x1bW5zKCkgewogICAgICBjb25zdCBzb3VyY2UgPSBkYXRhU291cmNlcy5nZXQodGhpcy4jdWlkKTsKICAgICAgY29uc3QgeyBjaHJvbUxlbmd0aHMsIGN1bVBvc2l0aW9ucyB9ID0gc291cmNlLmNocm9tSW5mbzsKICAgICAgbGV0IG5fY29scyA9IDA7CiAgICAgIGZvciAoY29uc3QgY3VtUG9zIG9mIGN1bVBvc2l0aW9ucykgewogICAgICAgIGNvbnN0IGNocm9tTmFtZSA9IGN1bVBvcy5jaHI7CiAgICAgICAgY29uc3QgY2hyb21TdGFydCA9IGN1bVBvcy5wb3M7CiAgICAgICAgY29uc3QgY2hyb21FbmQgPSBjdW1Qb3MucG9zICsgY2hyb21MZW5ndGhzW2Nocm9tTmFtZV07CiAgICAgICAgbl9jb2xzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsKICAgICAgICAgIHNvdXJjZS5maWxlLnRiaS5nZXRMaW5lcyhjaHJvbU5hbWUsIGNocm9tU3RhcnQsIGNocm9tRW5kLCAobGluZSkgPT4gewogICAgICAgICAgICByZXNvbHZlKGxpbmUuc3BsaXQoIgkiKS5sZW5ndGgpOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgICAgaWYgKG5fY29scyA+IDApCiAgICAgICAgICBicmVhazsKICAgICAgfQogICAgICByZXR1cm4gbl9jb2xzOwogICAgfQogICAgYXN5bmMgZ2V0VGlsZURhdGEobWluWCwgbWF4WCkgewogICAgICBjb25zdCBzb3VyY2UgPSBkYXRhU291cmNlcy5nZXQodGhpcy4jdWlkKTsKICAgICAgY29uc3QgcGFyc2VyMiA9IGF3YWl0IHRoaXMuZ2V0UGFyc2VyKCk7CiAgICAgIGxldCBjdXJNaW5YID0gbWluWDsKICAgICAgY29uc3QgeyBjaHJvbUxlbmd0aHMsIGN1bVBvc2l0aW9ucyB9ID0gc291cmNlLmNocm9tSW5mbzsKICAgICAgY29uc3QgYWxsVGlsZXMgPSBbXTsKICAgICAgZm9yIChjb25zdCBjdW1Qb3Mgb2YgY3VtUG9zaXRpb25zKSB7CiAgICAgICAgY29uc3QgY2hyb21OYW1lID0gY3VtUG9zLmNocjsKICAgICAgICBjb25zdCBjaHJvbVN0YXJ0ID0gY3VtUG9zLnBvczsKICAgICAgICBjb25zdCBjaHJvbUVuZCA9IGN1bVBvcy5wb3MgKyBjaHJvbUxlbmd0aHNbY2hyb21OYW1lXTsKICAgICAgICBsZXQgc3RhcnRQb3MsIGVuZFBvczsKICAgICAgICBpZiAoY2hyb21TdGFydCA+IGN1ck1pblggfHwgY3VyTWluWCA+PSBjaHJvbUVuZCkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHRpbGVzUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7CiAgICAgICAgICBjb25zdCB0aWxlcyA9IFtdOwogICAgICAgICAgY29uc3QgbGluZUNhbGxiYWNrID0gKGxpbmUpID0+IHsKICAgICAgICAgICAgY29uc3QgYmVkVGlsZSA9IHBhcnNlcjIucGFyc2VMaW5lKGxpbmUsIGNocm9tU3RhcnQpOwogICAgICAgICAgICB0aWxlcy5wdXNoKGJlZFRpbGUpOwogICAgICAgICAgfTsKICAgICAgICAgIGlmIChtYXhYID4gY2hyb21FbmQpIHsKICAgICAgICAgICAgc3RhcnRQb3MgPSBjdXJNaW5YIC0gY2hyb21TdGFydDsKICAgICAgICAgICAgZW5kUG9zID0gY2hyb21FbmQgLSBjaHJvbVN0YXJ0OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc3RhcnRQb3MgPSBNYXRoLmZsb29yKGN1ck1pblggLSBjaHJvbVN0YXJ0KTsKICAgICAgICAgICAgZW5kUG9zID0gTWF0aC5jZWlsKG1heFggLSBjaHJvbVN0YXJ0KTsKICAgICAgICAgIH0KICAgICAgICAgIHNvdXJjZS5maWxlLnRiaS5nZXRMaW5lcyhjaHJvbU5hbWUsIHN0YXJ0UG9zLCBlbmRQb3MsIGxpbmVDYWxsYmFjaykudGhlbigoKSA9PiB7CiAgICAgICAgICAgIHJlc29sdmUodGlsZXMpOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgICAgYWxsVGlsZXMucHVzaCh0aWxlc1Byb21pc2UpOwogICAgICAgIGlmIChtYXhYIDw9IGNocm9tRW5kKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgY3VyTWluWCA9IGNocm9tRW5kOwogICAgICB9CiAgICAgIGNvbnN0IHRpbGVBcnJheXMgPSBhd2FpdCBQcm9taXNlLmFsbChhbGxUaWxlcyk7CiAgICAgIHJldHVybiB0aWxlQXJyYXlzLmZsYXQoKTsKICAgIH0KICB9OwogIHZhciBiZWRGaWxlcyA9IG5ldyBNYXAoKTsKICB2YXIgdGlsZVZhbHVlcyA9IHt9OwogIHZhciBkYXRhU291cmNlcyA9IG5ldyBNYXAoKTsKICBmdW5jdGlvbiBpbml0KHVpZCwgYmVkLCBjaHJvbVNpemVzLCBvcHRpb25zID0ge30pIHsKICAgIGxldCBiZWRGaWxlID0gYmVkRmlsZXMuZ2V0KGJlZC51cmwpOwogICAgaWYgKCFiZWRGaWxlKSB7CiAgICAgIGJlZEZpbGUgPSBCZWRGaWxlLmZyb21VcmwoYmVkLnVybCwgYmVkLmluZGV4VXJsLCB1aWQsIG9wdGlvbnMudXJsRmV0Y2hPcHRpb25zLCBvcHRpb25zLmluZGV4VXJsRmV0Y2hPcHRpb25zKTsKICAgICAgaWYgKG9wdGlvbnMuY3VzdG9tRmllbGRzKQogICAgICAgIGJlZEZpbGUuY3VzdG9tRmllbGRzID0gb3B0aW9ucy5jdXN0b21GaWVsZHM7CiAgICB9CiAgICBjb25zdCBkYXRhU291cmNlID0gbmV3IERhdGFTb3VyY2UoYmVkRmlsZSwgY2hyb21TaXplcywgewogICAgICBzYW1wbGVMZW5ndGg6IDFlMywKICAgICAgLi4ub3B0aW9ucwogICAgfSk7CiAgICBkYXRhU291cmNlcy5zZXQodWlkLCBkYXRhU291cmNlKTsKICB9CiAgdmFyIHRpbGVzZXRJbmZvID0gKHVpZCkgPT4gewogICAgcmV0dXJuIGRhdGFTb3VyY2VzLmdldCh1aWQpLnRpbGVzZXRJbmZvOwogIH07CiAgdmFyIHRpbGUgPSBhc3luYyAodWlkLCB6LCB4KSA9PiB7CiAgICBjb25zdCBzb3VyY2UgPSBkYXRhU291cmNlcy5nZXQodWlkKTsKICAgIGNvbnN0IENBQ0hFX0tFWSA9IGAke3VpZH0uJHt6fS4ke3h9YDsKICAgIHRpbGVWYWx1ZXNbQ0FDSEVfS0VZXSA9IFtdOwogICAgY29uc3QgdGlsZVdpZHRoID0gK3NvdXJjZS50aWxlc2V0SW5mby5tYXhfd2lkdGggLyAyICoqICt6OwogICAgY29uc3QgbWluWCA9IHNvdXJjZS50aWxlc2V0SW5mby5taW5fcG9zWzBdICsgeCAqIHRpbGVXaWR0aDsKICAgIGNvbnN0IG1heFggPSBzb3VyY2UudGlsZXNldEluZm8ubWluX3Bvc1swXSArICh4ICsgMSkgKiB0aWxlV2lkdGg7CiAgICB0aWxlVmFsdWVzW0NBQ0hFX0tFWV0gPSBhd2FpdCBzb3VyY2UuZmlsZS5nZXRUaWxlRGF0YShtaW5YLCBtYXhYKTsKICAgIHJldHVybiB0aWxlVmFsdWVzW0NBQ0hFX0tFWV07CiAgfTsKICB2YXIgZmV0Y2hUaWxlc0RlYm91bmNlZCA9IGFzeW5jICh1aWQsIHRpbGVJZHMpID0+IHsKICAgIGNvbnN0IHRpbGVzID0ge307CiAgICBjb25zdCB2YWxpZFRpbGVJZHMgPSBbXTsKICAgIGNvbnN0IHRpbGVQcm9taXNlcyA9IFtdOwogICAgZm9yIChjb25zdCB0aWxlSWQgb2YgdGlsZUlkcykgewogICAgICBjb25zdCBwYXJ0cyA9IHRpbGVJZC5zcGxpdCgiLiIpOwogICAgICBjb25zdCB6ID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTsKICAgICAgY29uc3QgeCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7CiAgICAgIGlmIChOdW1iZXIuaXNOYU4oeCkgfHwgTnVtYmVyLmlzTmFOKHopKSB7CiAgICAgICAgY29uc29sZS53YXJuKCJJbnZhbGlkIHRpbGUgem9vbSBvciBwb3NpdGlvbjoiLCB6LCB4KTsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICB2YWxpZFRpbGVJZHMucHVzaCh0aWxlSWQpOwogICAgICB0aWxlUHJvbWlzZXMucHVzaCh0aWxlKHVpZCwgeiwgeCkpOwogICAgfQogICAgcmV0dXJuIFByb21pc2UuYWxsKHRpbGVQcm9taXNlcykudGhlbigodmFsdWVzMikgPT4gewogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlczIubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCB2YWxpZFRpbGVJZCA9IHZhbGlkVGlsZUlkc1tpXTsKICAgICAgICB0aWxlc1t2YWxpZFRpbGVJZF0gPSB7IHRpbGVQb3NpdGlvbklkOiB2YWxpZFRpbGVJZCB9OwogICAgICB9CiAgICAgIHJldHVybiB0aWxlczsKICAgIH0pOwogIH07CiAgdmFyIGdldFRhYnVsYXJEYXRhID0gKHVpZCwgdGlsZUlkcykgPT4gewogICAgY29uc3QgZGF0YSA9IFtdOwogICAgdGlsZUlkcy5mb3JFYWNoKCh0aWxlSWQpID0+IHsKICAgICAgY29uc3QgcGFydHMgPSB0aWxlSWQuc3BsaXQoIi4iKTsKICAgICAgY29uc3QgeiA9IHBhcnNlSW50KHBhcnRzWzBdLCAxMCk7CiAgICAgIGNvbnN0IHggPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOwogICAgICBjb25zdCB0aWxlVmFsdWUgPSB0aWxlVmFsdWVzW2Ake3VpZH0uJHt6fS4ke3h9YF07CiAgICAgIGlmICghdGlsZVZhbHVlKSB7CiAgICAgICAgY29uc29sZS53YXJuKGBObyB0aWxlIGRhdGEgY29uc3RydWN0ZWQgKCR7dGlsZUlkfSlgKTsKICAgICAgfQogICAgICBkYXRhLnB1c2godGlsZVZhbHVlKTsKICAgIH0pOwogICAgbGV0IG91dHB1dCA9IE9iamVjdC52YWx1ZXMoZGF0YSkuZmxhdCgpOwogICAgY29uc3Qgc2FtcGxlTGVuZ3RoID0gZGF0YVNvdXJjZXMuZ2V0KHVpZCkub3B0aW9ucy5zYW1wbGVMZW5ndGg7CiAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBzYW1wbGVMZW5ndGgpIHsKICAgICAgb3V0cHV0ID0gc2FtcGxlU2l6ZV9kZWZhdWx0KG91dHB1dCwgc2FtcGxlTGVuZ3RoIC8gMik7CiAgICB9CiAgICBjb25zdCBidWZmZXIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkob3V0cHV0KSkuYnVmZmVyOwogICAgcmV0dXJuIFRyYW5zZmVyKGJ1ZmZlciwgW2J1ZmZlcl0pOwogIH07CiAgdmFyIHRpbGVGdW5jdGlvbnMgPSB7CiAgICBpbml0LAogICAgdGlsZXNldEluZm8sCiAgICBmZXRjaFRpbGVzRGVib3VuY2VkLAogICAgdGlsZSwKICAgIGdldFRhYnVsYXJEYXRhCiAgfTsKICBleHBvc2UodGlsZUZ1bmN0aW9ucyk7Cn0pKCk7Ci8qIQogKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci4KICoKICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz4KICogQGxpY2Vuc2UgIE1JVAogKi8KLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi8KLyoqCiAqIEBsaWNlbnNlCiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz4KICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPSJlcyIgLW8gLi9gCiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL29wZW5qc2Yub3JnLz4KICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPgogKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPgogKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnMKICovCg==";
const blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
function Worker$1() {
  const objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const DEBOUNCE_TIME = 200;
class BedDataFetcher {
  constructor(HGC, config2) {
    __publicField(this, "dataConfig", {});
    // required for higlass
    __publicField(this, "uid");
    __publicField(this, "prevRequestTime");
    __publicField(this, "track");
    __publicField(this, "toFetch");
    __publicField(this, "fetchTimeout");
    __publicField(this, "worker");
    this.uid = HGC.libraries.slugid.nice();
    this.prevRequestTime = 0;
    this.toFetch = /* @__PURE__ */ new Set();
    const { url, indexUrl, assembly, ...options } = config2;
    this.worker = spawn(new Worker$1()).then(async (worker) => {
      const chromSizes = Object.entries(computeChromSizes(assembly).size);
      await worker.init(this.uid, { url, indexUrl }, chromSizes, options);
      return worker;
    });
  }
  /*
   * Collect Tileset Information, such as tile size and genomic positions
   */
  async tilesetInfo(callback) {
    (await this.worker).tilesetInfo(this.uid).then(callback);
  }
  fetchTilesDebounced(receivedTiles, tileIds) {
    this.track.drawLoadingCue();
    tileIds.forEach((tileId) => this.toFetch.add(tileId));
    if (this.fetchTimeout) {
      clearTimeout(this.fetchTimeout);
    }
    this.fetchTimeout = setTimeout(() => {
      this.sendFetch(receivedTiles, [...this.toFetch]);
      this.toFetch.clear();
    }, DEBOUNCE_TIME);
  }
  async sendFetch(receivedTiles, tileIds) {
    (await this.worker).fetchTilesDebounced(this.uid, tileIds).then(receivedTiles);
  }
  /**
   * Called by GoslingTrack. This is how the track gets data
   * @param tileIds The position of the tile
   * @returns A promise to the BedTiles
   */
  async getTabularData(tileIds) {
    const buf = await (await this.worker).getTabularData(this.uid, tileIds);
    const parsed = JSON.parse(new TextDecoder().decode(buf));
    return parsed;
  }
}
__publicField(BedDataFetcher, "config", { type: "bed" });
const dataFetchers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BamDataFetcher,
  BedDataFetcher,
  BigWigDataFetcher,
  CsvDataFetcher,
  GffDataFetcher,
  JsonDataFetcher,
  VcfDataFetcher
}, Symbol.toStringTag, { value: "Module" }));
const GOSLING_DATA_ROW_UID_FIELD = "gosling-data-row-uid";
function getTabularData(spec, data2) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const tabularData = [];
  if (!IsDataDeepTileset(spec.data)) {
    console.warn("No data is specified");
    return;
  }
  if (spec.data.type === "vector" || spec.data.type === "bigwig") {
    if (!("dense" in data2)) {
      return;
    }
    const bin = (_a = spec.data.binSize) != null ? _a : 1;
    const numericValues = data2.dense;
    const numOfGenomicPositions = data2.tileSize;
    const tileUnitSize = data2.tileWidth / data2.tileSize;
    const valueName = (_b = spec.data.value) != null ? _b : "value";
    const columnName = (_c = spec.data.column) != null ? _c : "position";
    const startName = (_d = spec.data.start) != null ? _d : "start";
    const endName = (_e = spec.data.end) != null ? _e : "end";
    const minValueName = `${valueName}_min`;
    const maxValueName = `${valueName}_max`;
    const agg = (_f = spec.data.aggregation) != null ? _f : "mean";
    let cumVal = 0;
    let minVal = Number.MAX_SAFE_INTEGER;
    let maxVal = Number.MIN_SAFE_INTEGER;
    let binStart = Number.MIN_SAFE_INTEGER;
    let binEnd = Number.MAX_SAFE_INTEGER;
    Array.from(Array(numOfGenomicPositions).keys()).forEach((g, j) => {
      if (bin === 1) {
        const value = numericValues[j] / (agg === "mean" ? tileUnitSize : 1);
        tabularData.push({
          [valueName]: value,
          [columnName]: data2.tileX + (j + 0.5) * tileUnitSize,
          [startName]: data2.tileX + j * tileUnitSize,
          [endName]: data2.tileX + (j + 1) * tileUnitSize,
          [minValueName]: value,
          [maxValueName]: value
        });
      } else {
        if (j % bin === 0) {
          cumVal = minVal = maxVal = numericValues[j];
          binStart = j;
          binEnd = j + bin;
        } else if (j % bin === bin - 1) {
          tabularData.push({
            [valueName]: cumVal / bin / (agg === "mean" ? tileUnitSize : 1),
            [columnName]: data2.tileX + (binStart + bin / 2) * tileUnitSize,
            [startName]: data2.tileX + binStart * tileUnitSize,
            [endName]: data2.tileX + binEnd * tileUnitSize,
            [minValueName]: minVal,
            [maxValueName]: maxVal
          });
        } else if (j === numOfGenomicPositions - 1) {
          const smallBin = numOfGenomicPositions % bin;
          const correctedBinEnd = binStart + smallBin;
          tabularData.push({
            [valueName]: cumVal / smallBin / (agg === "mean" ? tileUnitSize : 1),
            [columnName]: data2.tileX + (binStart + smallBin / 2) * tileUnitSize,
            [startName]: data2.tileX + binStart * tileUnitSize,
            [endName]: data2.tileX + correctedBinEnd * tileUnitSize,
            [minValueName]: minVal,
            [maxValueName]: maxVal
          });
        } else {
          cumVal += numericValues[j];
          if (minVal > numericValues[j])
            minVal = numericValues[j];
          if (maxVal < numericValues[j])
            maxVal = numericValues[j];
        }
      }
    });
  } else if (spec.data.type === "multivec") {
    if (!("dense" in data2) || data2.shape === void 0) {
      return;
    }
    const bin = (_g = spec.data.binSize) != null ? _g : 1;
    const numOfTotalCategories = data2.shape[0];
    const categories = (_h = spec.data.categories) != null ? _h : [...Array(numOfTotalCategories).keys()];
    const numericValues = data2.dense;
    const numOfGenomicPositions = data2.shape[1];
    const tileUnitSize = data2.tileWidth / data2.tileSize;
    const rowName = (_i = spec.data.row) != null ? _i : "category";
    const valueName = (_j = spec.data.value) != null ? _j : "value";
    const columnName = (_k = spec.data.column) != null ? _k : "position";
    const startName = (_l = spec.data.start) != null ? _l : "start";
    const endName = (_m = spec.data.end) != null ? _m : "end";
    const minValueName = `${valueName}_min`;
    const maxValueName = `${valueName}_max`;
    const agg = (_n = spec.data.aggregation) != null ? _n : "mean";
    categories.forEach((c, i) => {
      let cumVal = 0;
      let binStart = Number.MIN_SAFE_INTEGER;
      let binEnd = Number.MAX_SAFE_INTEGER;
      let minVal = Number.MAX_SAFE_INTEGER;
      let maxVal = Number.MIN_SAFE_INTEGER;
      Array.from(Array(numOfGenomicPositions).keys()).forEach((g, j) => {
        if (bin === 1) {
          const value = numericValues[numOfGenomicPositions * i + j] / (agg === "mean" ? tileUnitSize : 1);
          tabularData.push({
            [rowName]: c,
            [valueName]: value,
            [columnName]: data2.tileX + (j + 0.5) * tileUnitSize,
            [startName]: data2.tileX + j * tileUnitSize,
            [endName]: data2.tileX + (j + 1) * tileUnitSize,
            [minValueName]: value,
            [maxValueName]: value
          });
        } else {
          if (j % bin === 0) {
            cumVal = minVal = maxVal = numericValues[numOfGenomicPositions * i + j];
            binStart = j;
            binEnd = j + bin;
          } else if (j % bin === bin - 1) {
            tabularData.push({
              [rowName]: c,
              [valueName]: agg === "mean" ? cumVal / bin / tileUnitSize : cumVal,
              [columnName]: data2.tileX + (binStart + bin / 2) * tileUnitSize,
              [startName]: data2.tileX + binStart * tileUnitSize,
              [endName]: data2.tileX + binEnd * tileUnitSize,
              [minValueName]: minVal,
              [maxValueName]: maxVal
            });
          } else if (j === numOfGenomicPositions - 1) {
            const smallBin = numOfGenomicPositions % bin;
            const correctedBinEnd = binStart + smallBin;
            tabularData.push({
              [rowName]: c,
              [valueName]: agg === "mean" ? cumVal / smallBin / tileUnitSize : cumVal,
              [columnName]: data2.tileX + (binStart + smallBin / 2) * tileUnitSize,
              [startName]: data2.tileX + binStart * tileUnitSize,
              [endName]: data2.tileX + correctedBinEnd * tileUnitSize,
              [minValueName]: minVal,
              [maxValueName]: maxVal
            });
          } else {
            const value = numericValues[numOfGenomicPositions * i + j];
            cumVal += value;
            if (minVal > value)
              minVal = value;
            if (maxVal < value)
              maxVal = value;
          }
        }
      });
    });
  } else if (spec.data.type === "matrix") {
    if (!("dense" in data2) || typeof data2.tileY === "undefined" || typeof data2.tileHeight === "undefined") {
      return;
    }
    const numBins = Math.sqrt(data2.dense.length);
    const { tileX, tileY, tileWidth, tileHeight } = data2;
    const numericValues = data2.dense;
    const tileXUnitSize = tileWidth / numBins;
    const tileYUnitSize = tileHeight / numBins;
    const columnField = (_o = spec.data.column) != null ? _o : "x";
    const rowField = (_p = spec.data.row) != null ? _p : "y";
    const aggSize = 16;
    for (let i = 0; i < numericValues.length / aggSize; i++) {
      const aggLen = Math.sqrt(aggSize);
      const xIndex = i * aggLen % numBins;
      const yIndex = Math.floor(i * aggLen / numBins) * aggLen;
      let value = NaN;
      for (let c = 0; c < aggLen; c++) {
        for (let r = 0; r < aggLen; r++) {
          const curVal = numericValues[(yIndex + r) * numBins + (xIndex + c)];
          if (!isNaN(+curVal)) {
            if (isNaN(value)) {
              value = 0;
            }
            value += curVal;
          }
        }
      }
      if (isNaN(value)) {
        continue;
      }
      const xs = tileX + xIndex * tileXUnitSize;
      const xe = tileX + (xIndex + aggLen) * tileXUnitSize;
      const ys = tileY + yIndex * tileYUnitSize;
      const ye = tileY + (yIndex + aggLen) * tileYUnitSize;
      const x = (xs + xe) / 2;
      const y = (ys + ye) / 2;
      tabularData.push({
        value,
        [columnField]: x,
        [`${columnField}s`]: xs,
        [`${columnField}e`]: xe,
        [rowField]: y,
        [`${rowField}s`]: ys,
        [`${rowField}e`]: ye
      });
    }
  } else if (spec.data.type === "beddb") {
    if (!data2.sparse) {
      return;
    }
    const { genomicFields, exonIntervalFields, valueFields } = spec.data;
    data2.sparse.forEach((d, i) => {
      const { chrOffset, fields } = d;
      const datum = {};
      datum[GOSLING_DATA_ROW_UID_FIELD] = `${i}`;
      genomicFields.forEach((g) => {
        datum[g.name] = +fields[g.index] + chrOffset;
      });
      valueFields == null ? void 0 : valueFields.forEach((v) => {
        datum[v.name] = v.type === "quantitative" ? +fields[v.index] : fields[v.index];
      });
      tabularData.push({
        ...datum,
        type: "gene"
        // this should be described in the spec
      });
      if (exonIntervalFields) {
        const [exonStartField, exonEndField] = exonIntervalFields;
        const exonStartStrs = fields[exonStartField.index].split(",");
        const exonEndStrs = fields[exonEndField.index].split(",");
        exonStartStrs.forEach((es, i2) => {
          const ee = exonEndStrs[i2];
          tabularData.push({
            ...datum,
            [exonStartField.name]: +es + chrOffset,
            [exonEndField.name]: +ee + chrOffset,
            type: "exon"
          });
          if (i2 + 1 < exonStartStrs.length) {
            const nextEs = exonStartStrs[i2 + 1];
            tabularData.push({
              ...datum,
              [exonStartField.name]: +ee + chrOffset,
              [exonEndField.name]: +nextEs + chrOffset,
              type: "intron"
            });
          }
        });
      }
    });
  }
  return tabularData;
}
const $ref = "#/definitions/HiGlassSpec";
const $schema = "http://json-schema.org/draft-07/schema#";
const definitions = {
  Assembly: {
    anyOf: [
      {
        "const": "hg38",
        type: "string"
      },
      {
        "const": "hg19",
        type: "string"
      },
      {
        "const": "hg18",
        type: "string"
      },
      {
        "const": "hg17",
        type: "string"
      },
      {
        "const": "hg16",
        type: "string"
      },
      {
        "const": "mm10",
        type: "string"
      },
      {
        "const": "mm9",
        type: "string"
      },
      {
        "const": "unknown",
        type: "string"
      },
      {
        $ref: "#/definitions/ChromSizes"
      }
    ]
  },
  ChromSizes: {
    description: 'Custom chromosome sizes, e.g., [["foo", 1000], ["bar", 300], ["baz", 240]]',
    items: {
      items: [
        {
          type: "string"
        },
        {
          type: "number"
        }
      ],
      maxItems: 2,
      minItems: 2,
      type: "array"
    },
    type: "array"
  },
  CombinedTrack: {
    additionalProperties: false,
    properties: {
      contents: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      height: {
        type: "number"
      },
      options: {},
      position: {
        type: "string"
      },
      type: {
        "const": "combined",
        type: "string"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      }
    },
    required: [
      "type",
      "contents"
    ],
    type: "object"
  },
  Data: {
    additionalProperties: false,
    properties: {
      assembly: {
        $ref: "#/definitions/Assembly"
      },
      children: {
        items: {},
        type: "array"
      },
      filter: {
        items: {
          $ref: "#/definitions/FilterTransform"
        },
        type: "array"
      },
      indexUrl: {
        type: "string"
      },
      indexUrlFetchOptions: {
        $ref: "#/definitions/RequestInit"
      },
      tiles: {},
      tilesetInfo: {},
      type: {
        type: "string"
      },
      url: {
        type: "string"
      },
      urlFetchOptions: {
        $ref: "#/definitions/RequestInit"
      }
    },
    type: "object"
  },
  EnumTrack: {
    additionalProperties: false,
    properties: {
      chromInfoPath: {
        type: "string"
      },
      data: {
        $ref: "#/definitions/Data"
      },
      fromViewUid: {
        type: [
          "null",
          "string"
        ]
      },
      height: {
        type: "number"
      },
      options: {},
      server: {
        type: "string"
      },
      tilesetUid: {
        type: "string"
      },
      type: {
        $ref: "#/definitions/EnumTrackType"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      },
      x: {
        type: "number"
      },
      y: {
        type: "number"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  EnumTrackType: {
    "enum": [
      "heatmap",
      "2d-annotations",
      "2d-chromosome-annotations",
      "2d-chromosome-grid",
      "2d-chromosome-labels",
      "2d-rectangle-domains",
      "2d-tiles",
      "arrowhead-domains",
      "bedlike",
      "cross-rule",
      "dummy",
      "horizontal-1d-annotations",
      "horizontal-1d-heatmap",
      "horizontal-1d-tiles",
      "horizontal-1d-value-interval",
      "horizontal-2d-rectangle-domains",
      "horizontal-bar",
      "horizontal-chromosome-grid",
      "horizontal-chromosome-labels",
      "horizontal-divergent-bar",
      "horizontal-gene-annotations",
      "horizontal-heatmap",
      "horizontal-line",
      "horizontal-multivec",
      "horizontal-point",
      "horizontal-rule",
      "horizontal-vector-heatmap",
      "image-tiles",
      "left-axis",
      "left-stacked-interval",
      "mapbox-tiles",
      "osm-2d-tile-ids",
      "osm-tiles",
      "raster-tiles",
      "simple-svg",
      "square-markers",
      "top-axis",
      "top-stacked-interval",
      "vertical-1d-annotations",
      "vertical-1d-heatmap",
      "vertical-1d-tiles",
      "vertical-1d-value-interval",
      "vertical-2d-rectangle-domains",
      "vertical-bar",
      "vertical-bedlike",
      "vertical-chromosome-grid",
      "vertical-chromosome-labels",
      "vertical-gene-annotations",
      "vertical-heatmap",
      "vertical-line",
      "vertical-multivec",
      "vertical-point",
      "vertical-rule",
      "vertical-vector-heatmap",
      "viewport-projection-center",
      "viewport-projection-horizontal",
      "viewport-projection-vertical",
      "gosling-track",
      "gosling-2d-track",
      "axis-track",
      "text",
      "dummy-track"
    ],
    type: "string"
  },
  FilterTransform: {
    anyOf: [
      {
        $ref: "#/definitions/OneOfFilter"
      },
      {
        $ref: "#/definitions/RangeFilter"
      },
      {
        $ref: "#/definitions/IncludeFilter"
      }
    ]
  },
  GenericLocks: {
    additionalProperties: false,
    properties: {
      locksByViewUid: {
        $ref: "#/definitions/LocksByViewUid"
      },
      locksDict: {}
    },
    required: [
      "locksByViewUid",
      "locksDict"
    ],
    type: "object"
  },
  GenomePositionSearchBox: {
    additionalProperties: false,
    properties: {
      autocompleteId: {
        type: "string"
      },
      autocompleteServer: {
        type: "string"
      },
      chromInfoId: {
        type: "string"
      },
      chromInfoServer: {
        type: "string"
      },
      visible: {
        type: "boolean"
      }
    },
    required: [
      "chromInfoId",
      "chromInfoServer"
    ],
    type: "object"
  },
  HeatmapTrack: {
    additionalProperties: false,
    properties: {
      data: {
        $ref: "#/definitions/Data"
      },
      height: {
        type: "number"
      },
      options: {},
      position: {
        type: "string"
      },
      server: {
        type: "string"
      },
      tilesetUid: {
        type: "string"
      },
      type: {
        "const": "heatmap",
        type: "string"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  HiGlassSpec: {
    additionalProperties: false,
    properties: {
      chromInfoPath: {
        type: "string"
      },
      compactLayout: {
        type: "boolean"
      },
      editable: {
        type: "boolean"
      },
      exportViewUrl: {
        type: "string"
      },
      locationLocks: {
        $ref: "#/definitions/GenericLocks"
      },
      trackSourceServers: {
        items: {
          type: "string"
        },
        type: "array"
      },
      tracksEditable: {
        type: "boolean"
      },
      valueScaleLocks: {
        $ref: "#/definitions/ValueScaleLocks"
      },
      viewEditable: {
        type: "boolean"
      },
      views: {
        items: {
          $ref: "#/definitions/View"
        },
        type: "array"
      },
      zoomFixed: {
        type: "boolean"
      },
      zoomLocks: {
        $ref: "#/definitions/GenericLocks"
      }
    },
    required: [
      "views",
      "zoomLocks",
      "locationLocks"
    ],
    type: "object"
  },
  IncludeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      include: {
        description: "Check whether the value includes a substring.",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "include",
      "type"
    ],
    type: "object"
  },
  IndependentViewportProjectionTrack: {
    additionalProperties: false,
    properties: {
      fromViewUid: {
        type: "null"
      },
      options: {},
      projectionXDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      projectionYDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      transforms: {
        items: {},
        type: "array"
      },
      type: {
        "enum": [
          "viewport-projection-horizontal",
          "viewport-projection-vertical",
          "viewport-projection-center"
        ],
        type: "string"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      },
      x: {
        type: "number"
      },
      y: {
        type: "number"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  Layout: {
    additionalProperties: false,
    properties: {
      h: {
        type: "number"
      },
      w: {
        type: "number"
      },
      x: {
        type: "number"
      },
      y: {
        type: "number"
      }
    },
    required: [
      "h",
      "w",
      "x",
      "y"
    ],
    type: "object"
  },
  LocksByViewUid: {
    additionalProperties: {
      type: "string"
    },
    type: "object"
  },
  OneOfFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      oneOf: {
        description: "Check whether the value is an element in the provided list.",
        items: {
          type: [
            "string",
            "number",
            "null"
          ]
        },
        type: "array"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "oneOf",
      "type"
    ],
    type: "object"
  },
  Overlay: {
    additionalProperties: false,
    properties: {
      chromInfoPath: {
        type: "string"
      },
      includes: {
        items: {},
        type: "array"
      },
      options: {
        $ref: "#/definitions/OverlayOptions"
      },
      type: {
        type: "string"
      },
      uid: {
        type: "string"
      }
    },
    type: "object"
  },
  OverlayOptions: {
    additionalProperties: false,
    properties: {
      extent: {
        items: {},
        type: "array"
      },
      fill: {
        type: "string"
      },
      fillOpacity: {
        type: "number"
      },
      minWidth: {
        type: "number"
      },
      outline: {
        type: "string"
      },
      outlineOpacity: {
        type: "number"
      },
      outlinePos: {
        anyOf: [
          {
            items: {},
            type: "array"
          },
          {
            type: "string"
          }
        ]
      },
      outlineWidth: {
        type: "number"
      },
      stroke: {
        type: "string"
      },
      strokeOpacity: {
        type: "number"
      },
      strokePos: {
        anyOf: [
          {
            items: {},
            type: "array"
          },
          {
            type: "string"
          }
        ]
      },
      strokeWidth: {
        type: "number"
      }
    },
    type: "object"
  },
  RangeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      inRange: {
        description: "Check whether the value is in a number range.",
        items: {
          type: "number"
        },
        type: "array"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "inRange",
      "type"
    ],
    type: "object"
  },
  RequestInit: {
    additionalProperties: false,
    properties: {
      headers: {
        type: "object"
      }
    },
    type: "object"
  },
  Track: {
    anyOf: [
      {
        $ref: "#/definitions/HeatmapTrack"
      },
      {
        $ref: "#/definitions/CombinedTrack"
      },
      {
        $ref: "#/definitions/IndependentViewportProjectionTrack"
      },
      {
        $ref: "#/definitions/EnumTrack"
      }
    ]
  },
  Tracks: {
    additionalProperties: false,
    properties: {
      bottom: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      center: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      gallery: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      left: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      right: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      top: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      whole: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      }
    },
    required: [
      "top",
      "left",
      "center",
      "right",
      "bottom",
      "gallery",
      "whole"
    ],
    type: "object"
  },
  ValueScaleLocks: {
    additionalProperties: false,
    properties: {
      locksByViewUid: {
        $ref: "#/definitions/LocksByViewUid"
      },
      locksDict: {}
    },
    required: [
      "locksByViewUid"
    ],
    type: "object"
  },
  View: {
    additionalProperties: false,
    properties: {
      autocompleteSource: {
        type: "string"
      },
      chromInfoPath: {
        type: "string"
      },
      genomePositionSearchBox: {
        $ref: "#/definitions/GenomePositionSearchBox"
      },
      genomePositionSearchBoxVisible: {
        type: "boolean"
      },
      initialXDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      initialYDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      layout: {
        $ref: "#/definitions/Layout"
      },
      overlays: {
        items: {
          $ref: "#/definitions/Overlay"
        },
        type: "array"
      },
      selectionView: {
        type: "boolean"
      },
      tracks: {
        $ref: "#/definitions/Tracks"
      },
      uid: {
        type: "string"
      },
      zoomFixed: {
        type: "boolean"
      },
      zoomLimits: {
        items: {
          type: [
            "number",
            "null"
          ]
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      }
    },
    required: [
      "tracks",
      "layout"
    ],
    type: "object"
  }
};
const HiGlassSchema = {
  $ref,
  $schema,
  definitions
};
function getNumericDomain(domain, assembly) {
  const chromInterval = computeChromSizes(assembly).interval;
  if ("chromosome" in domain) {
    const isThereChr = Object.keys(chromInterval).find((chr) => chr === domain.chromosome);
    if (!isThereChr) {
      return;
    }
  }
  if (IsDomainChr(domain)) {
    return [chromInterval[domain.chromosome][0] + 1, chromInterval[domain.chromosome][1]];
  } else if (IsDomainInterval(domain)) {
    return domain.interval;
  } else if (IsDomainChrInterval(domain)) {
    const chrStart = chromInterval[domain.chromosome][0];
    const [start, end] = domain.interval;
    return [chrStart + start, chrStart + end];
  }
}
function shareScaleAcrossTracks(trackModels, force) {
  const globalDomain = {};
  const channelKeys = SUPPORTED_CHANNELS;
  trackModels.forEach((model) => {
    channelKeys.forEach((channelKey) => {
      const channel = model.spec()[channelKey];
      if (!IsChannelDeep(channel) || channel.domain === void 0) {
        return;
      }
      const { domain, type: type2 } = channel;
      if (type2 === "quantitative") {
        const numericDomain = Array.from(domain);
        if (!globalDomain[channelKey]) {
          globalDomain[channelKey] = numericDomain;
        } else {
          const channelGlobalDomain = globalDomain[channelKey];
          if (channelGlobalDomain[0] > numericDomain[0]) {
            channelGlobalDomain[0] = numericDomain[0];
          }
          if (channelGlobalDomain[1] < numericDomain[1]) {
            channelGlobalDomain[1] = numericDomain[1];
          }
        }
      } else if (type2 === "nominal") {
        const nominalDomain = Array.from(domain);
        if (!globalDomain[channelKey]) {
          globalDomain[channelKey] = nominalDomain;
        } else {
          globalDomain[channelKey] = Array.from(
            /* @__PURE__ */ new Set([...globalDomain[channelKey], ...nominalDomain])
          );
        }
      }
    });
  });
  trackModels.forEach((model) => {
    channelKeys.forEach((channelKey) => {
      const channel = model.spec()[channelKey];
      if (IsChannelDeep(channel) && channel.type === "genomic")
        return;
      model.setChannelDomain(channelKey, globalDomain[channelKey], force);
      model.generateScales();
    });
    model.updateChannelValue();
  });
}
const example = {
  compactLayout: false,
  trackSourceServers: ["https://server.gosling-lang.org/api/v1/"],
  views: [
    {
      genomePositionSearchBoxVisible: false,
      genomePositionSearchBox: {
        autocompleteServer: "https://higlass.io/api/v1",
        autocompleteId: "P0PLbQMwTYGy-5uPIQid7A",
        chromInfoServer: "https://higlass.io/api/v1",
        chromInfoId: "hg38"
      },
      layout: { x: 0, y: 0, w: 6.4, h: 600 },
      tracks: {
        top: [],
        left: [
          {
            type: "combined",
            width: 130,
            height: 600,
            contents: [
              {
                type: "gosling-track",
                server: "https://server.gosling-lang.org/api/v1/",
                tilesetUid: "cistrome-multivec",
                width: 130,
                height: 600,
                options: {
                  showMousePosition: true,
                  mousePositionColor: "#000000",
                  fontSize: 24,
                  labelPosition: "none",
                  labelShowResolution: false,
                  labelColor: "black",
                  labelBackgroundColor: "white",
                  labelTextOpacity: 1,
                  labelLeftMargin: 1,
                  labelTopMargin: 1,
                  labelRightMargin: 0,
                  labelBottomMargin: 0,
                  backgroundColor: "transparent",
                  spec: {
                    spacing: 10,
                    orientation: "vertical",
                    assembly: "hg38",
                    layout: "linear",
                    static: false,
                    xDomain: { interval: [0, 1e9] },
                    centerRadius: 0.3,
                    xOffset: 0,
                    yOffset: 0,
                    style: { outlineWidth: 0.5 },
                    data: {
                      url: "https://server.gosling-lang.org/api/v1/tileset_info/?d=cistrome-multivec",
                      type: "multivec",
                      row: "sample",
                      column: "position",
                      value: "peak",
                      categories: ["sample 1", "sample 2", "sample 3", "sample 4"],
                      binSize: 4
                    },
                    mark: "rect",
                    x: {
                      field: "start",
                      type: "genomic",
                      axis: "left",
                      domain: { interval: [0, 1e9] },
                      linkingId: "7f94b74e-25ec-4e67-8c75-3dc0f1b0d6bd"
                    },
                    xe: { field: "end", type: "genomic" },
                    row: {
                      field: "sample",
                      type: "nominal",
                      legend: true
                    },
                    color: {
                      field: "peak",
                      type: "quantitative",
                      legend: true
                    },
                    tooltip: [
                      {
                        field: "start",
                        type: "genomic",
                        alt: "Start Position"
                      },
                      {
                        field: "end",
                        type: "genomic",
                        alt: "End Position"
                      },
                      {
                        field: "peak",
                        type: "quantitative",
                        alt: "Value",
                        format: ".2"
                      },
                      { field: "sample", type: "nominal", alt: "Sample" }
                    ],
                    width: 160,
                    height: 600,
                    overlayOnPreviousTrack: false
                  },
                  theme: {
                    base: "light",
                    root: {
                      background: "white",
                      titleColor: "black",
                      titleBackgroundColor: "transparent",
                      titleFontSize: 18,
                      titleFontFamily: "Arial",
                      titleAlign: "left",
                      titleFontWeight: "bold",
                      subtitleColor: "gray",
                      subtitleBackgroundColor: "transparent",
                      subtitleFontSize: 16,
                      subtitleFontFamily: "Arial",
                      subtitleFontWeight: "normal",
                      subtitleAlign: "left",
                      mousePositionColor: "#000000"
                    },
                    track: {
                      background: "transparent",
                      alternatingBackground: "transparent",
                      titleColor: "black",
                      titleBackground: "white",
                      titleFontSize: 24,
                      titleAlign: "left",
                      outline: "black",
                      outlineWidth: 1
                    },
                    legend: {
                      position: "top",
                      background: "white",
                      backgroundOpacity: 0.7,
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      backgroundStroke: "#DBDBDB",
                      tickColor: "black"
                    },
                    axis: {
                      tickColor: "black",
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      baselineColor: "black",
                      gridColor: "#E3E3E3",
                      gridStrokeWidth: 1,
                      gridStrokeType: "solid",
                      gridStrokeDash: [4, 4]
                    },
                    markCommon: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    point: {
                      color: "#E79F00",
                      size: 3,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rect: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    triangle: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    area: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    line: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    bar: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rule: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    link: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    text: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6],
                      textAnchor: "middle",
                      textFontWeight: "normal"
                    },
                    brush: {
                      color: "gray",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 0.3,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    }
                  }
                }
              }
            ]
          },
          {
            uid: "15483511-f6fb-11eb-914b-976b6ecda162",
            type: "axis-track",
            chromInfoPath: "https://s3.amazonaws.com/gosling-lang.org/data/hg38.chrom.sizes",
            options: {
              layout: "linear",
              outerRadius: null,
              width: 160,
              height: 600,
              theme: {
                base: "light",
                root: {
                  background: "white",
                  titleColor: "black",
                  titleBackgroundColor: "transparent",
                  titleFontSize: 18,
                  titleFontFamily: "Arial",
                  titleAlign: "left",
                  titleFontWeight: "bold",
                  subtitleColor: "gray",
                  subtitleBackgroundColor: "transparent",
                  subtitleFontSize: 16,
                  subtitleFontFamily: "Arial",
                  subtitleFontWeight: "normal",
                  subtitleAlign: "left",
                  mousePositionColor: "#000000"
                },
                track: {
                  background: "transparent",
                  alternatingBackground: "transparent",
                  titleColor: "black",
                  titleBackground: "white",
                  titleFontSize: 24,
                  titleAlign: "left",
                  outline: "black",
                  outlineWidth: 1
                },
                legend: {
                  position: "top",
                  background: "white",
                  backgroundOpacity: 0.7,
                  labelColor: "black",
                  labelFontSize: 12,
                  labelFontWeight: "normal",
                  labelFontFamily: "Arial",
                  backgroundStroke: "#DBDBDB",
                  tickColor: "black"
                },
                axis: {
                  tickColor: "black",
                  labelColor: "black",
                  labelFontSize: 12,
                  labelFontWeight: "normal",
                  labelFontFamily: "Arial",
                  baselineColor: "black",
                  gridColor: "#E3E3E3",
                  gridStrokeWidth: 1,
                  gridStrokeType: "solid",
                  gridStrokeDash: [4, 4]
                },
                markCommon: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                point: {
                  color: "#E79F00",
                  size: 3,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                rect: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                triangle: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                area: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                line: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                bar: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                rule: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 1,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                link: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 1,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                text: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6],
                  textAnchor: "middle",
                  textFontWeight: "normal"
                },
                brush: {
                  color: "gray",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 1,
                  opacity: 0.3,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                }
              },
              assembly: "hg38",
              stroke: "transparent",
              color: "black",
              fontSize: 12,
              fontFamily: "Arial",
              fontWeight: "normal",
              tickColor: "black",
              tickFormat: "plain",
              tickPositions: "even",
              reverseOrientation: false
            },
            width: 30
          }
        ],
        center: [],
        right: [],
        bottom: [],
        gallery: [],
        whole: []
      },
      initialXDomain: [0, 1e9],
      initialYDomain: [0, 1e9],
      zoomFixed: false,
      zoomLimits: [1, null],
      uid: "15483510-f6fb-11eb-914b-976b6ecda162",
      chromInfoPath: "https://s3.amazonaws.com/gosling-lang.org/data/hg38.chrom.sizes"
    },
    {
      genomePositionSearchBoxVisible: false,
      genomePositionSearchBox: {
        autocompleteServer: "https://higlass.io/api/v1",
        autocompleteId: "P0PLbQMwTYGy-5uPIQid7A",
        chromInfoServer: "https://higlass.io/api/v1",
        chromInfoId: "hg38"
      },
      layout: { x: 6.8, y: 0, w: 5.2, h: 600 },
      tracks: {
        top: [],
        left: [
          {
            type: "combined",
            width: 130,
            height: 600,
            contents: [
              {
                type: "gosling-track",
                server: "https://server.gosling-lang.org/api/v1/",
                tilesetUid: "cistrome-multivec",
                width: 130,
                height: 600,
                options: {
                  showMousePosition: true,
                  mousePositionColor: "#000000",
                  fontSize: 24,
                  labelPosition: "none",
                  labelShowResolution: false,
                  labelColor: "black",
                  labelBackgroundColor: "white",
                  labelTextOpacity: 1,
                  labelLeftMargin: 1,
                  labelTopMargin: 1,
                  labelRightMargin: 0,
                  labelBottomMargin: 0,
                  backgroundColor: "transparent",
                  spec: {
                    spacing: 10,
                    orientation: "vertical",
                    assembly: "hg38",
                    layout: "linear",
                    static: false,
                    xDomain: { interval: [0, 1e9] },
                    centerRadius: 0.3,
                    xOffset: 0,
                    yOffset: 0,
                    style: { outlineWidth: 0.5 },
                    data: {
                      url: "https://server.gosling-lang.org/api/v1/tileset_info/?d=cistrome-multivec",
                      type: "multivec",
                      row: "sample",
                      column: "position",
                      value: "peak",
                      categories: ["sample 1", "sample 2", "sample 3", "sample 4"],
                      binSize: 4
                    },
                    mark: "rect",
                    x: {
                      field: "start",
                      type: "genomic",
                      domain: { interval: [0, 1e9] },
                      linkingId: "7f94b74e-25ec-4e67-8c75-3dc0f1b0d6bd"
                    },
                    xe: { field: "end", type: "genomic" },
                    row: {
                      field: "sample",
                      type: "nominal",
                      legend: true
                    },
                    color: {
                      field: "peak",
                      type: "quantitative",
                      legend: true
                    },
                    tooltip: [
                      {
                        field: "start",
                        type: "genomic",
                        alt: "Start Position"
                      },
                      {
                        field: "end",
                        type: "genomic",
                        alt: "End Position"
                      },
                      {
                        field: "peak",
                        type: "quantitative",
                        alt: "Value",
                        format: ".2"
                      },
                      { field: "sample", type: "nominal", alt: "Sample" }
                    ],
                    width: 130,
                    height: 600
                  },
                  theme: {
                    base: "light",
                    root: {
                      background: "white",
                      titleColor: "black",
                      titleBackgroundColor: "transparent",
                      titleFontSize: 18,
                      titleFontFamily: "Arial",
                      titleAlign: "left",
                      titleFontWeight: "bold",
                      subtitleColor: "gray",
                      subtitleBackgroundColor: "transparent",
                      subtitleFontSize: 16,
                      subtitleFontFamily: "Arial",
                      subtitleFontWeight: "normal",
                      subtitleAlign: "left",
                      mousePositionColor: "#000000"
                    },
                    track: {
                      background: "transparent",
                      alternatingBackground: "transparent",
                      titleColor: "black",
                      titleBackground: "white",
                      titleFontSize: 24,
                      titleAlign: "left",
                      outline: "black",
                      outlineWidth: 1
                    },
                    legend: {
                      position: "top",
                      background: "white",
                      backgroundOpacity: 0.7,
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      backgroundStroke: "#DBDBDB",
                      tickColor: "black"
                    },
                    axis: {
                      tickColor: "black",
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      baselineColor: "black",
                      gridColor: "#E3E3E3",
                      gridStrokeWidth: 1,
                      gridStrokeType: "solid",
                      gridStrokeDash: [4, 4]
                    },
                    markCommon: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    point: {
                      color: "#E79F00",
                      size: 3,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rect: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    triangle: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    area: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    line: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    bar: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rule: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    link: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    text: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6],
                      textAnchor: "middle",
                      textFontWeight: "normal"
                    },
                    brush: {
                      color: "gray",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 0.3,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    }
                  }
                }
              }
            ]
          }
        ],
        center: [],
        right: [],
        bottom: [],
        gallery: [],
        whole: []
      },
      initialXDomain: [0, 1e9],
      initialYDomain: [0, 1e9],
      zoomFixed: false,
      zoomLimits: [1, null],
      uid: "154b1b40-f6fb-11eb-914b-976b6ecda162"
    }
  ],
  zoomLocks: { locksByViewUid: {}, locksDict: {} },
  locationLocks: { locksByViewUid: {}, locksDict: {} },
  editable: false,
  chromInfoPath: "https://s3.amazonaws.com/gosling-lang.org/data/hg38.chrom.sizes"
};
const HIGLASS_AXIS_SIZE = 30;
const getViewTemplate = (assembly) => {
  return {
    genomePositionSearchBoxVisible: false,
    genomePositionSearchBox: {
      autocompleteServer: "https://higlass.io/api/v1",
      autocompleteId: getAutoCompleteId(assembly),
      chromInfoServer: "https://higlass.io/api/v1",
      chromInfoId: assembly != null ? assembly : "hg38"
    },
    layout: { w: 12, h: 12, x: 0, y: 0 },
    tracks: {
      top: [],
      left: [],
      center: [],
      right: [],
      bottom: [],
      gallery: [],
      whole: []
    },
    initialXDomain: [0, computeChromSizes(assembly).total],
    initialYDomain: [0, computeChromSizes(assembly).total],
    zoomFixed: false
  };
};
class HiGlassModel {
  constructor() {
    __publicField(this, "assembly");
    __publicField(this, "orientation");
    __publicField(this, "hg");
    this.assembly = "hg38";
    this.hg = {
      compactLayout: false,
      trackSourceServers: [],
      views: [],
      zoomLocks: {
        locksByViewUid: {},
        locksDict: {}
      },
      locationLocks: {
        locksByViewUid: {},
        locksDict: {}
      }
    };
    this.setEditable(false);
  }
  spec() {
    return this.hg;
  }
  setViewOrientation(orientation) {
    this.orientation = orientation;
    return this;
  }
  addDefaultView(uid, assembly) {
    this.hg.views.push(JSON.parse(JSON.stringify({ ...getViewTemplate(assembly), uid })));
    return this;
  }
  setAssembly(assembly) {
    this.assembly = assembly;
    this.setChromInfoPath(computeChromSizes(this.assembly).path);
    return this;
  }
  getAssembly() {
    return this.assembly;
  }
  setTextTrack(width, height, text, textColor = "black", fontSize = 14, fontWeight = "normal", align = "left", backgroundColor = "transparent", fontFamily = "Arial") {
    var _a;
    if (this.getLastView()) {
      (_a = this.getLastView().tracks.top) == null ? void 0 : _a.push({
        type: "text",
        width,
        height,
        options: {
          backgroundColor,
          textColor,
          fontSize,
          fontWeight,
          fontFamily,
          offsetY: 0,
          // offset from the top of the track
          align,
          text
        }
      });
    }
    return this;
  }
  /**
   * Add a dummy track to the last view
   * @param track
   */
  setDummyTrack(track) {
    var _a;
    if (this.getLastView()) {
      (_a = this.getLastView().tracks.top) == null ? void 0 : _a.push({
        type: "dummy-track",
        width: track.width,
        height: track.height,
        options: {
          width: track.width,
          height: track.height,
          title: track.title,
          ...track.style
        }
      });
    }
    return this;
  }
  addBrush(layout, viewId, theme, fromViewUid, style) {
    var _a, _b, _c, _d, _e, _f;
    if (!fromViewUid)
      return;
    (_f = this.getView(viewId)) == null ? void 0 : _f.tracks.whole.push({
      // type: 'viewport-projection-center',
      type: layout === "circular" ? "brush-track" : "viewport-projection-horizontal",
      uid: uuid(),
      fromViewUid,
      options: {
        projectionFillColor: (_a = style == null ? void 0 : style.color) != null ? _a : theme.brush.color,
        projectionStrokeColor: (_b = style == null ? void 0 : style.stroke) != null ? _b : theme.brush.stroke,
        projectionFillOpacity: (_c = style == null ? void 0 : style.opacity) != null ? _c : theme.brush.opacity,
        projectionStrokeOpacity: (_d = style == null ? void 0 : style.opacity) != null ? _d : theme.brush.opacity,
        strokeWidth: (_e = style == null ? void 0 : style.strokeWidth) != null ? _e : theme.brush.strokeWidth,
        startAngle: style == null ? void 0 : style.startAngle,
        endAngle: style == null ? void 0 : style.endAngle,
        innerRadius: style == null ? void 0 : style.innerRadius,
        outerRadius: style == null ? void 0 : style.outerRadius
      }
    });
    return this;
  }
  getLastView() {
    return this.hg.views[this.hg.views.length - 1];
  }
  getMainTrackPosition() {
    return this.orientation === "vertical" ? "left" : "center";
  }
  /**
   * Get the last view that renders any visualization, so skiping empty tracks.
   */
  getLastVisView() {
    const vs = this.hg.views.filter((v) => {
      var _a, _b;
      return ((_b = (_a = v.tracks[this.getMainTrackPosition()]) == null ? void 0 : _a[0]) == null ? void 0 : _b.type) === "combined";
    });
    return vs[vs.length - 1];
  }
  getView(viewId) {
    return this.hg.views.find((d) => d.uid === viewId);
  }
  validateSpec(silence = false) {
    return validateSpec(HiGlassSchema, this.spec(), silence).state === "success";
  }
  setDomain(xDomain, yDomain) {
    if (xDomain) {
      this.getLastView().initialXDomain = getNumericDomain(xDomain, this.getAssembly());
    }
    if (yDomain) {
      this.getLastView().initialYDomain = getNumericDomain(yDomain, this.getAssembly());
    }
    return this;
  }
  /**
   * This is a hacky function that adjust x domain to properly show vertical tracks.
   *
   * In HiGlass, the range of vertical tracks is affected by a center track. For example, if a center track is small, the vertical tracks become small as well.
   * Currently, the actual size of center track for vertical gosling tracks is `1px`. So, we re-scale the x domain so that gosling's vertical tracks properly use the entire height of a view.
   * @param orientation
   * @param width
   * @returns
   */
  adjustDomain(orientation = "horizontal", width, height) {
    if (orientation !== "vertical") {
      return this;
    }
    const domain = this.getLastView().initialXDomain;
    if (!domain) {
      return this;
    }
    const [start, end] = domain;
    const size = end - start;
    const center = (start + end) / 2;
    this.getLastView().initialXDomain = [
      center - size / width / 2 / height * width,
      center + size / width / 2 / height * width
    ];
    return this;
  }
  /**
   * Allow a zoom interaction?
   */
  setZoomFixed(zoomFixed) {
    this.getLastView().zoomFixed = zoomFixed;
    return this;
  }
  /**
   * Set limits of zoom levels in base pairs.
   */
  setZoomLimits(zoomLimits) {
    this.getLastView().zoomLimits = zoomLimits;
    return this;
  }
  setLayout(layout) {
    this.getLastView().layout = layout;
    return this;
  }
  setEditable(editable) {
    this.hg.editable = editable;
    return this;
  }
  setChromInfoPath(chromInfoPath) {
    if (this.getLastView()) {
      this.getLastView().chromInfoPath = chromInfoPath;
    }
    this.hg.chromInfoPath = chromInfoPath;
    return this;
  }
  addTrackSourceServers(trackSourceServers) {
    var _a, _b;
    if (trackSourceServers && ((_a = this.hg.trackSourceServers) == null ? void 0 : _a.indexOf(trackSourceServers)) === -1)
      (_b = this.hg.trackSourceServers) == null ? void 0 : _b.push(trackSourceServers);
    return this;
  }
  setMainTrack(track) {
    var _a;
    if (!this.getLastView())
      return this;
    this.getLastView().tracks[this.getMainTrackPosition()] = [
      {
        type: "combined",
        uid: `${(_a = track.uid) != null ? _a : uuid()}-${this.getMainTrackPosition()}-combined`,
        // !! Hacky, but it is important to subtract 1px. Currently, HiGlass does not well handle a case where a center track is zero width (e.g., linking between views that contain zero-width center tracks).
        // https://github.com/higlass/higlass/pull/1041
        width: track.width - 1,
        height: track.height,
        contents: [track]
      }
    ];
    return this;
  }
  addTrackToCombined(track) {
    var _a;
    if (!this.getLastVisView())
      return this;
    (_a = this.getLastVisView().tracks[this.getMainTrackPosition()][0]) == null ? void 0 : _a.contents.push(track);
    return this;
  }
  setAxisTrack(position, type2 = "regular", options) {
    if (!this.hg.views)
      return this;
    const widthOrHeight = position === "left" || position === "right" ? "width" : "height";
    const axisTrackTemplate = {
      // uid: options.id ?? uuid(), // TODO: turning this on makes some tick labels hidden
      type: "axis-track",
      chromInfoPath: this.hg.chromInfoPath,
      options: {
        ...options,
        assembly: this.getAssembly(),
        stroke: "transparent",
        // text outline
        color: options.theme.axis.labelColor,
        labelMargin: options.theme.axis.labelMargin,
        excludeChrPrefix: options.theme.axis.labelExcludeChrPrefix,
        fontSize: options.theme.axis.labelFontSize,
        fontFamily: options.theme.axis.labelFontFamily,
        fontWeight: options.theme.axis.labelFontWeight,
        tickColor: options.theme.axis.tickColor,
        tickFormat: type2 === "narrower" ? "si" : "plain",
        tickPositions: type2 === "regular" ? "even" : "ends",
        reverseOrientation: position === "bottom" || position === "right" ? true : false
      }
    };
    if (options.layout === "circular") {
      this.addTrackToCombined({
        ...axisTrackTemplate,
        options: { ...axisTrackTemplate.options, layout: "circular" }
      });
    } else {
      const axisTrack = { ...axisTrackTemplate, [widthOrHeight]: HIGLASS_AXIS_SIZE };
      if (position === "left") {
        if (this.getLastView().tracks.left.filter((d) => d.type === "axis-track").length !== 0) {
          return this;
        }
        this.getLastView().tracks.left = insertItemToArray(this.getLastView().tracks.left, 0, axisTrack);
      } else if (position === "right") {
        if (this.getLastView().tracks.right.filter((d) => d.type === "axis-track").length !== 0) {
          return this;
        }
        this.getLastView().tracks.right.push(axisTrack);
      } else {
        if (this.getLastView().tracks[position].filter((d) => d.type === "axis-track").length !== 0) {
          return this;
        }
        this.getLastView().tracks[position].push(axisTrack);
      }
    }
    return this;
  }
  setExampleHiglassViewConfig() {
    this.hg = example;
  }
}
function logicalComparison(value, op, ref2, transitionPadding) {
  const padding = transitionPadding && transitionPadding !== 0 ? transitionPadding : void 0;
  let alpha = 0;
  switch (op) {
    case "less-than":
    case "LT":
    case "lt":
      alpha = ref2 > value ? padding ? (ref2 - value) / padding : 1 : 0;
      break;
    case "less-than-or-equal-to":
    case "LTET":
    case "ltet":
      alpha = ref2 >= value ? padding ? (ref2 - value) / padding : 1 : 0;
      break;
    case "greater-than":
    case "GT":
    case "gt":
      alpha = ref2 < value ? padding ? (value - ref2) / padding : 1 : 0;
      break;
    case "greater-than-or-equal-to":
    case "GTET":
    case "gtet":
      alpha = ref2 <= value ? padding ? (value - ref2) / padding : 1 : 0;
      break;
  }
  return Math.max(Math.min(1, alpha), 0);
}
const CHANNEL_DEFAULTS = {
  // https://mikemol.github.io/technique/colorblind/2018/02/11/color-safe-palette.html
  NOMINAL_COLOR: [
    "#E79F00",
    "#029F73",
    "#0072B2",
    "#CB7AA7",
    "#D45E00",
    "#57B4E9",
    "#EFE441"
    /*'#000000'*/
  ],
  // https://colorcet.holoviz.org/user_guide/Categorical.html
  NOMINAL_COLOR_EXTENDED: [
    "#d60000",
    "#018700",
    "#b500ff",
    "#05acc6",
    "#97ff00",
    "#ffa52f",
    "#ff8ec8",
    "#79525e",
    "#00fdcf",
    "#afa5ff",
    "#93ac83",
    "#9a6900",
    "#366962",
    "#d3008c",
    "#fdf490",
    "#c86e66",
    "#9ee2ff",
    "#00c846",
    "#a877ac",
    "#b8ba01",
    "#f4bfb1",
    "#ff28fd",
    "#f2cdff",
    "#009e7c",
    "#ff6200",
    "#56642a",
    "#953f1f",
    "#90318e",
    "#ff3464",
    "#a0e491",
    "#8c9ab1",
    "#829026",
    "#ae083f",
    "#77c6ba",
    "#bc9157",
    "#e48eff",
    "#72b8ff",
    "#c6a5c1",
    "#ff9070",
    "#d3c37c",
    "#bceddb",
    "#6b8567",
    "#916e56",
    "#f9ff00",
    "#bac1df",
    "#ac567c",
    "#ffcd03",
    "#ff49b1",
    "#c15603",
    "#5d8c90",
    "#c144bc",
    "#00753f",
    "#ba6efd",
    "#00d493",
    "#00ff75",
    "#49a150",
    "#cc9790",
    "#00ebed",
    "#db7e01",
    "#f77589",
    "#b89500",
    "#c84248",
    "#00cff9",
    "#755726",
    "#85d401",
    "#ebffd4",
    "#a77b87",
    "#db72c8",
    "#cae256",
    "#8abf5d",
    "#a1216b",
    "#855b89",
    "#89bacf",
    "#ffbad6",
    "#b6cfaa",
    "#97414d",
    "#67aa00",
    "#fde1b1",
    "#ff3628",
    "#80793d",
    "#d6e8ff",
    "#a795c6",
    "#7ea59a",
    "#d182a3",
    "#54823b",
    "#e6a872",
    "#9cffff",
    "#da5480",
    "#05b3aa",
    "#ffaaf6",
    "#d1afef",
    "#da015d",
    "#ac1a13",
    "#60b385",
    "#d442fd",
    "#acaa59",
    "#fb9ca7",
    "#b3723b",
    "#f26952",
    "#aed1d4",
    "#9affc3",
    "#dbb333",
    "#eb01c3",
    "#9900c4",
    "#cfff9e",
    "#a55949",
    "#3b6d01",
    "#008579",
    "#959167",
    "#89dbb3",
    "#6d7400",
    "#aa5dca",
    "#07ef00",
    "#804f3d",
    "#d88052",
    "#ffc862",
    "#b8009e",
    "#99acdd",
    "#904f00",
    "#8c4470",
    "#4f6e52",
    "#ff8734",
    "#c68ecd",
    "#d4e29e",
    "#b1826d",
    "#9cfb75",
    "#56dd77",
    "#f90087",
    "#a1cdff",
    "#13cad1",
    "#118e54",
    "#d154a5",
    "#00dfc3",
    "#a3832f",
    "#77975b",
    "#baaa80",
    "#70a3af",
    "#d6fbff",
    "#e8013a",
    "#d84621",
    "#ff82ed",
    "#b63862",
    "#b6cd72",
    "#97626b",
    "#897490",
    "#00a316",
    "#00f4a1",
    "#bf90f2",
    "#89e4d8",
    "#a34d95",
    "#6e5d00",
    "#8cc68e",
    "#95aa2a",
    "#c672dd",
    "#b33b01",
    "#d69a36",
    "#dfacb6",
    "#009aa0",
    "#599000",
    "#97bca8",
    "#ac8ca8",
    "#dad4ff",
    "#547c72",
    "#00ba69",
    "#ffc38e",
    "#b800d4",
    "#dfcf5b",
    "#629a7b",
    "#bfedbc",
    "#c1bdfd",
    "#80d3dd",
    "#e2857e",
    "#f9eb4d",
    "#bf6d82",
    "#caff4f",
    "#ef72aa",
    "#ed67ff",
    "#9946ae",
    "#6d6942",
    "#e25660",
    "#dd662d",
    "#9cdb5d",
    "#e29ccf",
    "#b87500",
    "#c6002d",
    "#dfbcda",
    "#59b5df",
    "#ff59da",
    "#38c1a1",
    "#9e698c",
    "#acaac8",
    "#95622f",
    "#b55662",
    "#2b7e60",
    "#b1e400",
    "#eda590",
    "#95fde2",
    "#ff548e",
    "#bd6ea1",
    "#aa3b36",
    "#d8cf00",
    "#aa80cd",
    "#a08052",
    "#e100e8",
    "#c35b3d",
    "#b53a85",
    "#8c7700",
    "#dbbc95",
    "#529e93",
    "#afbc82",
    "#91b5b6",
    "#a75423",
    "#ffd4ef",
    "#79ae6b",
    "#5db54b",
    "#80fb9a",
    "#48ffef",
    "#979548",
    "#9387a7",
    "#31d400",
    "#6ee956",
    "#b6d4eb",
    "#705470",
    "#f2db8a",
    "#aad4c1",
    "#7ecdf2",
    "#89ba00",
    "#64b6ba",
    "#ffb500",
    "#c38285",
    "#caaa5e",
    "#647748",
    "#59e2ff",
    "#df4dcd",
    "#e9ff79",
    "#bc66b8",
    "#c395a5",
    "#64c674",
    "#d19570",
    "#70cf4f",
    "#aa6e66",
    "#9c60a5",
    "#00b800",
    "#e299b3",
    "#bc006b",
    "#b3e8ef",
    "#cdbfe4",
    "#77a342",
    "#856277",
    "#568e5b",
    "#9eafc4",
    "#e82fa0",
    "#247c2a",
    "#826723",
    "#bfbc4d",
    "#ddd3a5"
  ],
  QUANTITATIVE_COLOR: "viridis",
  SIZE: 3,
  SIZE_RANGE: [2, 6]
};
function getTheme(theme = "light") {
  if (typeof theme === "string") {
    if (isThereTheme(theme)) {
      return getTheme$1(theme);
    } else {
      return getTheme$1("light");
    }
  } else {
    let baseSpec = JSON.parse(JSON.stringify(getTheme$1("light")));
    if (isThereTheme(theme.base)) {
      baseSpec = getTheme$1(theme.base);
    }
    Object.keys(baseSpec).forEach((k) => {
      if (theme[k] && k !== "base") {
        baseSpec[k] = Object.assign(
          JSON.parse(JSON.stringify(baseSpec[k])),
          JSON.parse(JSON.stringify(theme[k]))
        );
      }
    });
    return baseSpec;
  }
}
class GoslingTrackModel {
  constructor(spec, data2, theme) {
    __publicField(this, "id");
    __publicField(this, "theme");
    /* spec */
    __publicField(this, "specOriginal");
    // original spec of users
    __publicField(this, "specComplete");
    // processed spec, being used in visualizations
    /* data */
    __publicField(this, "dataAggregated");
    /* channel scales */
    __publicField(this, "channelScales");
    /* mouse events */
    __publicField(this, "mouseEventModel");
    this.id = uuid();
    this.theme = theme != null ? theme : getTheme();
    this.dataAggregated = data2;
    this.specOriginal = spec;
    this.specComplete = spec;
    this.channelScales = {};
    this.mouseEventModel = new MouseEventModel();
    const validity = this.validateSpec();
    if (!validity.valid) {
      console.warn("Gosling specification is not valid!", validity.errorMessages);
      return;
    }
    this.generateCompleteSpec(this.specComplete);
    this.flipRanges(this.specComplete);
    this.generateScales();
    this.dataAggregated = aggregateData(this.spec(), this.dataAggregated);
  }
  getId() {
    return this.id;
  }
  originalSpec() {
    return this.specOriginal;
  }
  spec() {
    return this.specComplete;
  }
  data() {
    return this.dataAggregated;
  }
  getMouseEventModel() {
    return this.mouseEventModel;
  }
  /**
   * Fill the missing options with default values or with the values calculated based on the data.
   */
  generateCompleteSpec(spec) {
    if (!spec.width || !spec.height) {
      console.warn("Size of track is not determined yet.");
      return;
    }
    if (spec.orientation === "vertical") {
      const width = spec.width;
      spec.width = spec.height;
      spec.height = width;
    }
    const xOrY = this.getGenomicChannelKey();
    let isAxisShown = false;
    if (xOrY === "x") {
      isAxisShown = IsChannelDeep(spec.x) && spec.x.axis !== void 0 && spec.x.axis !== "none";
    }
    if (xOrY === "y") {
      isAxisShown = IsChannelDeep(spec.y) && spec.y.axis !== void 0 && spec.y.axis !== "none";
    }
    if (spec.layout !== "circular") {
      if (IsChannelDeep(spec.x) && spec.x.axis !== void 0 && spec.x.axis !== "none") {
        spec.height -= HIGLASS_AXIS_SIZE;
      }
    } else {
      if (xOrY === "x" && isAxisShown && IsChannelDeep(spec.x) && spec.x.axis === "top") {
        spec["outerRadius"] = spec["outerRadius"] - HIGLASS_AXIS_SIZE;
      } else if (xOrY === "x" && isAxisShown && IsChannelDeep(spec.x) && spec.x.axis === "bottom") {
        spec["innerRadius"] = spec["innerRadius"] + HIGLASS_AXIS_SIZE;
      }
    }
    SUPPORTED_CHANNELS.forEach((channelKey) => {
      const channel = spec[channelKey];
      if (IsChannelDeep(channel) && !("zeroBaseline" in channel) && channel.type === "quantitative") {
        channel.zeroBaseline = true;
      }
    });
    this.addScaleMaterials(spec);
  }
  /**
   * TODO: This is experimental. For bar charts, for example, additional care should be taken to correctly flip the visual marks.
   * Flip the y scales when `flip` options is used.
   */
  flipRanges(spec) {
    if (IsChannelDeep(spec.y) && spec.y.flip && Array.isArray(spec.y.range)) {
      spec.y.range = spec.y.range.reverse();
    }
  }
  /**
   * Find an axis channel that is encoded with genomic coordinate and return the key (e.g., 'x').
   * `undefined` if not found.
   */
  getGenomicChannelKey() {
    return getGenomicChannelKeyFromTrack(this.spec());
  }
  /**
   * Find a genomic field from the track specification.
   * `undefined` if not found.
   */
  getGenomicChannel() {
    return getGenomicChannelFromTrack(this.spec());
  }
  /**
   * Replace a domain with a new one in the complete spec(s) if the original spec does not define the domain.
   * A domain is replaced only when the channel is bound with data (i.e., `ChannelDeep`).
   */
  setChannelDomain(channelKey, domain, force) {
    const channelRaw = this.originalSpec()[channelKey];
    if (!force && IsChannelDeep(channelRaw) && channelRaw.domain !== void 0) {
      return;
    }
    const channel = this.specComplete[channelKey];
    if (IsChannelDeep(channel)) {
      channel.domain = domain;
    }
  }
  /**
   * Update default constant values by looking up other channels' scales.
   */
  updateChannelValue() {
    if (this.originalSpec().y === void 0) {
      const y = this.spec().y;
      const rowCategories = this.getChannelDomainArray("row");
      if (y && IsChannelValue(y) && rowCategories && this.spec().mark !== "withinLink") {
        y.value = this.spec().height / rowCategories.length / 2;
      }
    }
  }
  /**
   * Get the encoded value using the scales already constructed.
   */
  encodedValue(channelKey, value) {
    var _a;
    if (channelKey === "text" && value !== void 0) {
      return `${+value ? ~~value : value}`;
    }
    const channel = this.spec()[channelKey];
    const channelFieldType = IsChannelDeep(channel) ? channel.type : IsChannelValue(channel) ? "constant" : void 0;
    if (!channelFieldType) {
      return void 0;
    }
    if (channelFieldType === "constant") {
      return this.channelScales[channelKey]();
    }
    if (value === void 0) {
      return void 0;
    }
    if (value === null) {
      if (channelFieldType === "quantitative") {
        value = 0;
      } else if (channelFieldType === "nominal") {
        value = "null";
      }
    }
    if (typeof this.channelScales[channelKey] !== "function") {
      return void 0;
    }
    switch (channelKey) {
      case "x":
      case "y":
      case "x1":
      case "y1":
      case "xe":
      case "ye":
      case "x1e":
        if (channelFieldType === "quantitative" || channelFieldType === "genomic") {
          return this.channelScales[channelKey](value);
        }
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "stroke":
      case "color":
        if (channelFieldType === "quantitative") {
          const s = this.channelScales[channelKey].copy();
          const d = s.domain();
          const e = d[1] - d[0];
          const so = Array.from((_a = channel.scaleOffset) != null ? _a : [0, 1]);
          return s.domain([d[0] + e * so.sort()[0], d[0] + e * so.sort()[1]])(value);
        }
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "size":
        if (channelFieldType === "quantitative") {
          return this.channelScales[channelKey](value);
        }
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "row":
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "strokeWidth":
      case "opacity":
        if (channelFieldType === "quantitative") {
          return this.channelScales[channelKey](value);
        }
        break;
      default:
        console.warn(`${channelKey} is not supported for encoding values, so returning a undefined value`);
        return void 0;
    }
  }
  trackVisibility(currentStage) {
    const spec = this.spec();
    if (!spec.visibility || spec.visibility.length === 0 || spec.visibility.filter((d) => d.target === "track").length === 0) {
      return true;
    }
    let visibility = true;
    spec.visibility.filter((d) => d.target === "track").forEach((d) => {
      const { operation, measure, threshold } = d;
      let compareValue;
      if (measure === "zoomLevel") {
        compareValue = currentStage[measure];
      } else {
        compareValue = spec[measure];
      }
      if (compareValue !== void 0) {
        visibility = visibility && logicalComparison(compareValue, operation, threshold) === 1;
      }
    });
    return visibility;
  }
  /**
   * Check whether the visual mark should be visible or not.
   * Return 0 (invisible) only when the predefined condition is correct.
   */
  markVisibility(datum, metrics) {
    const spec = this.spec();
    if (!spec.visibility || spec.visibility.length === 0 || spec.visibility.filter((d) => d.target === "mark").length === 0) {
      return 1;
    }
    let visibility = 1;
    spec.visibility.filter((d) => d.target === "mark").forEach((d) => {
      const { operation, threshold, conditionPadding, transitionPadding, measure } = d;
      const padding = conditionPadding != null ? conditionPadding : 0;
      const mark = spec.mark;
      let newVisibility = 1;
      if (mark === "text" && threshold === "|xe-x|" && measure === "width") {
        const xe = this.encodedPIXIProperty("xe", datum);
        const x = this.encodedPIXIProperty("x", datum);
        if (xe !== void 0 && (metrics == null ? void 0 : metrics.width)) {
          newVisibility = logicalComparison(
            metrics.width + padding,
            operation,
            Math.abs(xe - x),
            transitionPadding
          );
        }
      } else if (measure === "width" && typeof threshold === "number" && (metrics == null ? void 0 : metrics.width)) {
        newVisibility = logicalComparison(metrics.width + padding, operation, threshold, transitionPadding);
      } else if (measure === "zoomLevel" && typeof threshold === "number" && (metrics == null ? void 0 : metrics.zoomLevel)) {
        newVisibility = logicalComparison(metrics.zoomLevel, operation, threshold, transitionPadding);
      }
      if (visibility > newVisibility) {
        visibility = newVisibility;
      }
    });
    return visibility;
  }
  /**
   *
   */
  visualPropertyByChannel(channelKey, datum) {
    const value = datum !== void 0 ? getValueUsingChannel(datum, this.spec()[channelKey]) : void 0;
    return this.encodedValue(channelKey, value);
  }
  /**
   * Retrieve an encoded visual property of a visual mark.
   */
  encodedPIXIProperty(propertyKey, datum, additionalInfo) {
    const mark = this.spec().mark;
    if ([
      "text",
      "color",
      "row",
      "stroke",
      "opacity",
      "strokeWidth",
      "x",
      "y",
      "xe",
      "x1",
      "x1e",
      "ye",
      "size"
    ].includes(propertyKey)) {
      return this.visualPropertyByChannel(propertyKey, datum);
    }
    switch (mark) {
      case "bar":
        return barProperty(this, propertyKey, datum, additionalInfo);
      case "point":
      case "text":
        return pointProperty(this, propertyKey, datum);
      case "rect":
        return rectProperty(this, propertyKey, datum, additionalInfo);
      default:
        return void 0;
    }
  }
  // TODO: better organize this, perhaps, by combining several if statements
  /**
   * Set missing `range`, `domain`, and/or `value` of each channel by looking into data.
   */
  addScaleMaterials(spec) {
    const data2 = this.data();
    const genomicChannel = this.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    if (typeof spec.width === "undefined" || typeof spec.height === "undefined") {
      console.warn("Track size is not determined yet");
      return;
    }
    SUPPORTED_CHANNELS.forEach((channelKey) => {
      var _a, _b, _c, _d;
      const channel = spec[channelKey];
      if (IsStackedChannel(spec, channelKey) && IsChannelDeep(channel)) {
        const pivotedData = group(data2, (d) => d[genomicChannel.field]);
        const xKeys = [...pivotedData.keys()];
        if (!channel.domain) {
          const min$1 = "zeroBaseline" in channel && channel.zeroBaseline ? 0 : min(
            xKeys.map(
              (d) => sum(
                pivotedData.get(d).map(
                  (_d2) => channel.field ? _d2[channel.field] : void 0
                )
              )
            )
          );
          const max$1 = max(
            xKeys.map(
              (d) => sum(
                pivotedData.get(d).map(
                  (_d2) => channel.field ? _d2[channel.field] : void 0
                )
              )
            )
          );
          channel.domain = [min$1, max$1];
        }
        if (!channel.range) {
          const rowChannel = spec.row;
          const rowField = IsChannelDeep(rowChannel) ? rowChannel.field : void 0;
          const rowCategories = (_a = this.getChannelDomainArray("row")) != null ? _a : rowField ? Array.from(new Set(data2.map((d) => d[rowField]))) : [1];
          const rowHeight = spec.height / rowCategories.length;
          switch (channelKey) {
            case "x":
              channel.range = [0, spec.width];
              break;
            case "y":
              channel.range = [0, rowHeight];
              break;
          }
        }
      } else {
        const rowChannel = spec.row;
        const rowField = IsChannelDeep(rowChannel) ? rowChannel.field : void 0;
        const rowCategories = (_b = this.getChannelDomainArray("row")) != null ? _b : rowField ? Array.from(new Set(data2.map((d) => d[rowField]))) : [1];
        const rowHeight = spec.height / rowCategories.length;
        if (!channel) {
          let value;
          switch (channelKey) {
            case "x":
              value = spec.width / 2;
              break;
            case "y":
              if (spec.mark === "withinLink")
                value = rowHeight;
              else
                value = rowHeight / 2;
              break;
            case "size":
              if (spec.mark === "line")
                value = this.theme.line.size;
              else if (spec.mark === "bar")
                value = void 0;
              else if (spec.mark === "rect")
                value = void 0;
              else if (spec.mark === "triangleRight")
                value = void 0;
              else if (spec.mark === "triangleLeft")
                value = void 0;
              else if (spec.mark === "triangleBottom")
                value = void 0;
              else if (spec.stretch && spec.mark === "point" && IsChannelDeep(spec.x) && IsChannelDeep(spec.xe))
                value = void 0;
              else if (spec.mark === "text")
                value = 12;
              else
                value = this.theme.point.size;
              break;
            case "color":
              value = this.theme.markCommon.color;
              break;
            case "row":
              value = 0;
              break;
            case "stroke":
              if (spec.mark === "text")
                value = this.theme.text.stroke;
              else
                value = this.theme.markCommon.stroke;
              break;
            case "strokeWidth":
              if (spec.mark === "rule")
                value = this.theme.rule.strokeWidth;
              else if (spec.mark === "withinLink" || spec.mark === "betweenLink")
                value = this.theme.link.strokeWidth;
              else if (spec.mark === "text")
                value = this.theme.text.strokeWidth;
              else
                value = this.theme.markCommon.strokeWidth;
              break;
            case "opacity":
              value = this.theme.markCommon.opacity;
              break;
            case "text":
              value = "";
              break;
          }
          if (typeof value !== "undefined") {
            spec[channelKey] = { value };
          }
        } else if (IsChannelDeep(channel) && (channel.type === "quantitative" || channel.type === "genomic")) {
          if (channel.domain === void 0) {
            const min$1 = "zeroBaseline" in channel && channel.zeroBaseline ? 0 : (_c = min(data2.map((d) => +d[channel.field]))) != null ? _c : 0;
            const max$1 = (_d = max(data2.map((d) => +d[channel.field]))) != null ? _d : 0;
            channel.domain = [min$1, max$1];
          } else if (channel.type === "genomic" && !IsDomainArray(channel.domain)) {
            channel.domain = getNumericDomain(channel.domain);
          }
          if ((channelKey === "color" || channelKey === "stroke") && channel.type === "quantitative" && !channel.scaleOffset) {
            channel.scaleOffset = [0, 1];
          }
          if (!channel.range) {
            let range;
            switch (channelKey) {
              case "x":
              case "xe":
              case "x1":
              case "x1e":
                range = [0, spec.width];
                break;
              case "y":
              case "ye":
                range = [0, rowHeight];
                break;
              case "color":
              case "stroke":
                range = CHANNEL_DEFAULTS.QUANTITATIVE_COLOR;
                break;
              case "size":
                range = this.theme.markCommon.quantitativeSizeRange;
                break;
              case "strokeWidth":
                range = [1, 3];
                break;
              case "opacity":
                range = [0, 1];
                break;
            }
            if (range) {
              channel.range = range;
            }
          }
        } else if (IsChannelDeep(channel) && channel.type === "nominal") {
          if (channel.domain === void 0) {
            channel.domain = Array.from(
              new Set(data2.map((d) => {
                var _a2;
                return (_a2 = d[channel.field]) != null ? _a2 : "null";
              }))
            );
          }
          if (!channel.range) {
            let startSize = 2;
            let range;
            switch (channelKey) {
              case "x":
              case "xe":
                range = [0, spec.width];
                break;
              case "y":
              case "ye":
                range = [rowHeight, 0];
                break;
              case "color":
              case "stroke":
                range = this.theme.markCommon.nominalColorRange;
                break;
              case "row":
                range = [0, spec.height];
                break;
              case "size":
                range = channel.domain.map(() => startSize++);
                break;
            }
            if (range) {
              channel.range = range;
            }
          }
        }
      }
    });
    [
      ["x", "xe"],
      ["y", "ye"]
    ].forEach((pair) => {
      const [k1, k2] = pair;
      const c1 = spec[k1], c2 = spec[k2];
      if (IsChannelDeep(c1) && IsChannelDeep(c2) && c1.type === c2.type && c1.domain && c2.domain && Array.isArray(c1.domain) && Array.isArray(c2.domain)) {
        if (c1.type === "genomic" || c1.type === "quantitative") {
          const min$1 = min([c1.domain[0], c2.domain[0]]);
          const max$1 = max([c1.domain[1], c2.domain[1]]);
          c1.domain = c2.domain = [min$1, max$1];
        } else if (c1.type === "nominal") {
          const range = Array.from(/* @__PURE__ */ new Set([...c1.domain, ...c2.domain]));
          c1.range = c2.range = range;
        }
      }
    });
  }
  /**
   * Store the scale of individual visual channels based on the `complete` spec.
   */
  generateScales() {
    const spec = this.spec();
    SUPPORTED_CHANNELS.forEach((channelKey) => {
      const channel = spec[channelKey];
      if (IsChannelValue(channel)) {
        this.channelScales[channelKey] = () => channel.value;
      } else if (IsChannelDeep(channel)) {
        if (channelKey === "text") {
          return;
        }
        const domain = channel.domain;
        const range = channel.range;
        if (domain === void 0 || range === void 0) {
          return;
        }
        if (channel.type === "quantitative" || channel.type === "genomic") {
          switch (channelKey) {
            case "x":
            case "x1":
            case "xe":
            case "x1e":
            case "y":
            case "ye":
            case "size":
            case "opacity":
            case "strokeWidth":
              this.channelScales[channelKey] = scaleLinear().domain(domain).range(range);
              break;
            case "color":
            case "stroke":
              let interpolate = interpolateViridis;
              if (Object.keys(PREDEFINED_COLOR_STR_MAP).includes(range)) {
                interpolate = PREDEFINED_COLOR_STR_MAP[range];
              }
              this.channelScales[channelKey] = scaleSequential(interpolate).domain(
                domain
              );
              break;
          }
        } else if (channel.type === "nominal") {
          switch (channelKey) {
            case "x":
            case "xe":
            case "y":
            case "ye":
            case "row":
              this.channelScales[channelKey] = scaleBand().domain(domain).range(range);
              break;
            case "size":
              this.channelScales[channelKey] = scaleOrdinal().domain(domain).range(range);
              break;
            case "color":
            case "stroke":
              this.channelScales[channelKey] = scaleOrdinal(range).domain(domain);
              break;
          }
        }
      }
    });
  }
  /**
   * Return the scale of a visual channel.
   * `undefined` if we do not have the scale.
   */
  getChannelScale(channelKey) {
    return this.channelScales[channelKey];
  }
  /**
   * Set a new scale for a certain channel. Usually called to replace the scale of a genomic axis with the one that is generated by the HiGlass data fetcher.
   */
  setChannelScale(channelKey, scale) {
    this.channelScales[channelKey] = scale;
  }
  /**
   * Return whether to show y-axis.
   */
  isShowYAxis() {
    const spec = this.spec();
    const yDomain = this.getChannelDomainArray("y");
    const yRange = this.getChannelRangeArray("y");
    return IsChannelDeep(spec.y) && spec.y.axis !== "none" && spec.y.type === "quantitative" && !!yDomain && !!yRange;
  }
  /**
   * Return the domain of a visual channel.
   * `undefined` if we do not have domain in array.
   */
  getChannelDomainArray(channelKey) {
    const c = this.spec()[channelKey];
    return IsChannelDeep(c) && IsDomainArray(c.domain) ? c.domain : void 0;
  }
  /**
   * Return the range of a visual channel.
   * `undefined` if we do not have domain in array.
   */
  getChannelRangeArray(channelKey) {
    const c = this.spec()[channelKey];
    return IsChannelDeep(c) && IsRangeArray(c.range) ? c.range : void 0;
  }
  /**
   * Validate the original spec.
   */
  validateSpec() {
    return validateTrack(this.originalSpec());
  }
}
function publish(name2, data2) {
  PubSub$1.publish(name2, data2);
}
function subscribe(name2, callback) {
  PubSub$1.subscribe(name2, callback);
}
function unsubscribe(name2) {
  PubSub$1.unsubscribe(name2);
}
const DEFAULT_MOUSE_EVENT_STYLE = {
  stroke: "black",
  strokeWidth: 1,
  strokeOpacity: 1,
  color: "none",
  opacity: 1,
  arrange: "front"
};
function initProcessedTileInfo() {
  return { goslingModels: [], tabularData: [], skipRendering: false };
}
const config$1 = {
  type: "gosling-track",
  datatype: ["multivec", "epilogos"],
  orientation: "1d-horizontal",
  // @ts-expect-error missing default spec
  defaultOptions: {
    // TODO: Are any of these used?
    // labelPosition: 'none',
    // labelColor: 'black',
    // labelTextOpacity: 0.4,
    // trackBorderWidth: 0,
    // trackBorderColor: 'black',
    // backgroundColor: 'white',
    // barBorder: false,
    // sortLargestOnTop: true,
    // axisPositionHorizontal: 'left',
    theme: getTheme$1("light")
  }
};
const factory$1 = (HGC, context, options) => {
  var _assembly2, _processedTileInfo, _mouseDownX, _mouseDownY, _isRangeBrushActivated, _gBrush, _loadingTextStyleObj, _loadingTextBg, _loadingText, _tilesToId, tilesToId_fn, _binsPerTile, binsPerTile_get, _generateTabularData, generateTabularData_fn, _onMouseDown, onMouseDown_fn, _onMouseMove, onMouseMove_fn, _onMouseUp, onMouseUp_fn, _onMouseOut, onMouseOut_fn, _getElementsWithinMouse, getElementsWithinMouse_fn, _publishTrackEvents, publishTrackEvents_fn, _onRangeBrush, onRangeBrush_fn, _highlightMarks, highlightMarks_fn, _publishOnNewTrack, publishOnNewTrack_fn;
  const { tileProxy } = HGC.services;
  const { BarTrack } = HGC.tracks;
  const loadingTextStyle = getTextStyle({ color: "black", size: 12 });
  const _GoslingTrackClass = class _GoslingTrackClass extends BarTrack {
    /* *
     *
     *  Constructor
     *
     * */
    constructor() {
      var _a, _b, _c, _d, _e, _f;
      super(context, options);
      __privateAdd(this, _binsPerTile);
      /**
       * Construct tabular data from a higlass tileset and a gosling track model.
       */
      __privateAdd(this, _generateTabularData);
      /* *
       *
       *  Mouse methods
       *
       * */
      __privateAdd(this, _onMouseDown);
      __privateAdd(this, _onMouseMove);
      __privateAdd(this, _onMouseUp);
      __privateAdd(this, _onMouseOut);
      /**
       * From all tiles and overlaid tracks, collect element(s) that are withing a mouse position.
       */
      __privateAdd(this, _getElementsWithinMouse);
      /**
       * Call track events (e.g., `trackClick` or `trackMouseOver`) based on a mouse position and the track display area.
       */
      __privateAdd(this, _publishTrackEvents);
      __privateAdd(this, _onRangeBrush);
      /**
       * Highlight marks that are either mouse overed or selected.
       */
      __privateAdd(this, _highlightMarks);
      /**
       * Javscript subscription API methods (besides for mouse)
       */
      /**
       * Publishes track information. Triggered when track gets created
       */
      __privateAdd(this, _publishOnNewTrack);
      /* *
       *
       *  Properties
       *
       * */
      __publicField(this, "tileSize");
      __publicField(this, "mRangeBrush");
      __privateAdd(this, _assembly2, void 0);
      // Used to get the relative genomic position
      __privateAdd(this, _processedTileInfo, void 0);
      __publicField(this, "firstDraw", true);
      // False if draw has been called once already. Used with onNewTrack API. Public because used in draw()
      // Used in mark/legend.ts
      __publicField(this, "gLegend", HGC.libraries.d3Selection.select(context.svgElement).append("g"));
      __publicField(this, "displayedLegends", []);
      // Store the color legends added so far so that we can avoid overlaps and redundancy
      // Used in mark/text.ts
      __publicField(this, "textGraphics", []);
      __publicField(this, "textsBeingUsed", 0);
      // Mouse fields
      __publicField(this, "pMouseHover", new HGC.libraries.PIXI.Graphics());
      __publicField(this, "pMouseSelection", new HGC.libraries.PIXI.Graphics());
      __privateAdd(this, _mouseDownX, 0);
      __privateAdd(this, _mouseDownY, 0);
      __privateAdd(this, _isRangeBrushActivated, false);
      __privateAdd(this, _gBrush, HGC.libraries.d3Selection.select(context.svgElement).append("g"));
      __privateAdd(this, _loadingTextStyleObj, new HGC.libraries.PIXI.TextStyle(loadingTextStyle));
      __privateAdd(this, _loadingTextBg, new HGC.libraries.PIXI.Graphics());
      __privateAdd(this, _loadingText, new HGC.libraries.PIXI.Text("", loadingTextStyle));
      __publicField(this, "prevVisibleAndFetchedTiles");
      __publicField(this, "resolvedTracks");
      __publicField(this, "hideMousePosition");
      context.dataFetcher.track = this;
      __privateSet(this, _processedTileInfo, {});
      __privateSet(this, _assembly2, this.options.spec.assembly);
      if ("overlay" in this.options.spec) {
        this.options.spec.overlay = this.options.spec._overlay.map((o) => {
          return { ...o, _renderingId: uuid() };
        });
      } else {
        this.options.spec._renderingId = uuid();
      }
      this.fetchedTiles = {};
      this.tileSize = (_b = (_a = this.tilesetInfo) == null ? void 0 : _a.tile_size) != null ? _b : 1024;
      const { valid, errorMessages } = validateTrack(this.options.spec);
      if (!valid) {
        console.warn("The specification of the following track is invalid", errorMessages, this.options.spec);
      }
      this.pMain.addChild(this.pMouseHover);
      this.pMain.addChild(this.pMouseSelection);
      this.pMask.interactive = true;
      this.mRangeBrush = new LinearBrushModel(__privateGet(this, _gBrush), HGC.libraries, (_c = this.options.spec.style) == null ? void 0 : _c.brush);
      this.mRangeBrush.on("brush", __privateMethod(this, _onRangeBrush, onRangeBrush_fn).bind(this));
      this.pMask.on("mousedown", (e) => {
        const { x, y } = e.data.getLocalPosition(this.pMain);
        __privateMethod(this, _onMouseDown, onMouseDown_fn).call(this, x, y, e.data.originalEvent.altKey);
      });
      this.pMask.on("mouseup", (e) => {
        const { x, y } = e.data.getLocalPosition(this.pMain);
        __privateMethod(this, _onMouseUp, onMouseUp_fn).call(this, x, y);
      });
      this.pMask.on("mousemove", (e) => {
        const { x } = e.data.getLocalPosition(this.pMain);
        __privateMethod(this, _onMouseMove, onMouseMove_fn).call(this, x);
      });
      this.pMask.on("mouseout", __privateMethod(this, _onMouseOut, onMouseOut_fn).bind(this));
      this.flipText = this.options.spec.orientation === "vertical";
      if (this.hideMousePosition) {
        this.hideMousePosition();
        this.hideMousePosition = void 0;
      }
      if (((_d = this.options) == null ? void 0 : _d.showMousePosition) && !this.hideMousePosition) {
        this.hideMousePosition = HGC.utils.showMousePosition(
          this,
          Is2DTrack(this.getResolvedTracks()[0]),
          this.isShowGlobalMousePosition()
        );
      }
      this.pLabel.removeChild(this.trackNotFoundText);
      __privateGet(this, _loadingText).anchor.x = 1;
      __privateGet(this, _loadingText).anchor.y = 1;
      this.pLabel.addChild(__privateGet(this, _loadingTextBg));
      this.pLabel.addChild(__privateGet(this, _loadingText));
      HGC.libraries.PIXI.GRAPHICS_CURVES.adaptive = (_f = (_e = this.options.spec.style) == null ? void 0 : _e.enableSmoothPath) != null ? _f : false;
      if (HGC.libraries.PIXI.GRAPHICS_CURVES.adaptive) {
        HGC.libraries.PIXI.GRAPHICS_CURVES.maxLength = 1;
        HGC.libraries.PIXI.GRAPHICS_CURVES.maxSegments = 2048 * 10;
      }
    }
    /* *
     *
     *  Rendering Cycle Methods
     *
     * */
    /**
     * Draw all tiles from the bottom. Called from TiledPixiTrack constructor, so all methods called must be
     * public. https://github.com/higlass/higlass/blob/387a03e877dcfa4c2cfeabc0869375b58c0b362d/app/scripts/TiledPixiTrack.js#L216
     * Overrides draw() in BarTrack.
     * This means some class properties can be still `undefined`.
     */
    draw() {
      var _a, _b;
      this.clearMouseEventData();
      this.textsBeingUsed = 0;
      (_a = this.pMouseHover) == null ? void 0 : _a.clear();
      const processTilesAndDraw = () => {
        const isBamDataFetcher = this.dataFetcher instanceof BamDataFetcher;
        this.processAllTiles(isBamDataFetcher);
        super.draw();
        this.prevVisibleAndFetchedTiles = this.visibleAndFetchedTiles();
      };
      if (isTabularDataFetcher(this.dataFetcher) && !isEqual(this.visibleAndFetchedTiles(), this.prevVisibleAndFetchedTiles)) {
        this.updateTileAsync(this.dataFetcher, processTilesAndDraw);
      } else {
        processTilesAndDraw();
      }
      (_b = this.mRangeBrush) == null ? void 0 : _b.drawBrush(true);
      if (this.firstDraw) {
        __privateMethod(this, _publishOnNewTrack, publishOnNewTrack_fn).call(this);
        this.firstDraw = false;
      }
    }
    /*
     * Do whatever is necessary before rendering a new tile. This function is called from `receivedTiles()`.
     * Overrides initTile in BarTrack
     * (Refer to https://github.com/higlass/higlass/blob/54f5aae61d3474f9e868621228270f0c90ef9343/app/scripts/HorizontalLine1DPixiTrack.js#L50)
     */
    initTile(tile) {
      this.drawTile(tile);
    }
    updateTile() {
    }
    // Never mind about this function for the simplicity.
    renderTile() {
    }
    // Never mind about this function for the simplicity.
    /**
     * Display a tile upon receiving a new one or when explicitly called by a developer, e.g., calling
     * `this.draw()`. Overrides drawTile in BarTrack
     */
    drawTile(tile) {
      var _a, _b;
      tile.drawnAtScale = this._xScale.copy();
      const tileInfo = __privateGet(this, _processedTileInfo)[tile.tileId];
      if (!tileInfo) {
        return;
      }
      (_a = tile.graphics) == null ? void 0 : _a.clear();
      (_b = tile.graphics) == null ? void 0 : _b.removeChildren();
      this.pBackground.clear();
      this.pBackground.removeChildren();
      this.pBorder.clear();
      this.pBorder.removeChildren();
      this.displayedLegends = [];
      tileInfo.goslingModels.forEach((model) => {
        const trackWidth = this.dimensions[0];
        const zoomLevel = this._xScale.invert(trackWidth) - this._xScale.invert(0);
        if (!model.trackVisibility({ zoomLevel })) {
          return;
        }
        drawPreEmbellishment(HGC, this, tile, model, this.options.theme);
        drawMark(HGC, this, tile, model);
        drawPostEmbellishment(HGC, this, tile, model, this.options.theme);
      });
      this.forceDraw();
    }
    /**
     * Render this track again using a new option when a user changed the option. Overrides rerender in BarTrack.
     */
    rerender(newOptions) {
      this.options = newOptions;
      if (this.options.spec.layout === "circular") {
        this.mRangeBrush.remove();
      }
      this.getResolvedTracks(true);
      this.clearMouseEventData();
      this.textsBeingUsed = 0;
      this.processAllTiles(true);
      this.draw();
      this.forceDraw();
    }
    /**
     * Clears MouseEventModel from each GoslingTrackModel. Must be a public method because it is called from draw()
     */
    clearMouseEventData() {
      this.visibleAndFetchedGoslingModels().forEach((model) => model.getMouseEventModel().clear());
    }
    /**
     * Collect all gosling models that correspond to the tiles that are both visible and fetched.
     */
    visibleAndFetchedGoslingModels() {
      return this.visibleAndFetchedTiles().flatMap(
        (tile) => {
          var _a, _b;
          return (_b = (_a = __privateGet(this, _processedTileInfo)[tile.tileId]) == null ? void 0 : _a.goslingModels) != null ? _b : [];
        }
      );
    }
    /**
     * End of the rendering cycle. This function is called when the track is removed entirely.
     */
    remove() {
      super.remove();
      if (this.gLegend) {
        this.gLegend.remove();
        this.gLegend = void 0;
      }
      this.mRangeBrush.remove();
    }
    /*
     * Rerender all tiles when track size is changed. Overrides method in TiledPixiTrack
     * (Refer to https://github.com/higlass/higlass/blob/54f5aae61d3474f9e868621228270f0c90ef9343/app/scripts/PixiTrack.js#L186).
     */
    setDimensions(newDimensions) {
      super.setDimensions(newDimensions);
      this.mRangeBrush.setSize(newDimensions[1]);
    }
    /**
     * Record new position.
     */
    setPosition(newPosition) {
      super.setPosition(newPosition);
      [this.pMain.position.x, this.pMain.position.y] = this.position;
      this.mRangeBrush.setOffset(...newPosition);
    }
    /**
     * A function to redraw this track. Typically called when an asynchronous event occurs (i.e. tiles loaded)
     * (Refer to https://github.com/higlass/higlass/blob/54f5aae61d3474f9e868621228270f0c90ef9343/app/scripts/TiledPixiTrack.js#L71)
     */
    forceDraw() {
      this.animate();
    }
    /**
     * Called when location or zoom level has been changed by click-and-drag interaction
     * (https://github.com/higlass/higlass/blob/54f5aae61d3474f9e868621228270f0c90ef9343/app/scripts/HorizontalLine1DPixiTrack.js#L215)
     * For brushing, refer to https://github.com/higlass/higlass/blob/caf230b5ee41168ea491572618612ac0cc804e5a/app/scripts/HeatmapTiledPixiTrack.js#L1493
     */
    zoomed(newXScale, newYScale) {
      const range = this.mRangeBrush.getRange();
      this.mRangeBrush.updateRange(
        range ? [newXScale(this._xScale.invert(range[0])), newXScale(this._xScale.invert(range[1]))] : null
      );
      this.xScale(newXScale);
      this.yScale(newYScale);
      this.refreshTiles();
      this.draw();
      this.forceDraw();
      const genomicRange = newXScale.domain().map((absPos) => getRelativeGenomicPosition(absPos, __privateGet(this, _assembly2), true));
      publish("location", {
        id: context.viewUid,
        genomicRange
      });
    }
    /**
     * This is how the mask gets drawn. Overrides method in PixiTrack.
     * Compared to the method in PixiTrack, this method draws a circular mask when the layout is circular.
     * @param position
     * @param dimensions
     */
    setMask(position, dimensions) {
      this.pMask.clear();
      this.pMask.beginFill();
      if (this.options.spec.layout === "circular") {
        const [x, y] = this.position;
        const [width, height] = this.dimensions;
        const cx = x + width / 2;
        const cy = y + height / 2;
        const outerRadius = this.options.spec.outerRadius;
        this.pMask.drawCircle(cx, cy, outerRadius);
      } else {
        this.pMask.drawRect(position[0], position[1], dimensions[0], dimensions[1]);
      }
      this.pMask.endFill();
    }
    /* *
     *
     *  Tile and data processing methods
     *
     * */
    /**
     * Gets all tiles and generates tabular data and GoslingTrackModels for each tile. Called by this.draw(), so
     * this method must be public.
     * @param force if true then tabular data gets regenerated
     */
    processAllTiles(force = false) {
      var _a, _b;
      this.tileSize = (_b = (_a = this.tilesetInfo) == null ? void 0 : _a.tile_size) != null ? _b : 1024;
      const tiles = this.visibleAndFetchedTiles();
      tiles.forEach((tile) => __privateMethod(this, _generateTabularData, generateTabularData_fn).call(this, tile, force));
      this.combineAllTilesIfNeeded();
      const models = tiles.flatMap((tile) => this.transformDataAndCreateModels(tile));
      shareScaleAcrossTracks(models);
      const flatTileData = [].concat(...models.map((d) => d.data()));
      if (flatTileData.length !== 0) {
        this.options.siblingIds.forEach((id) => publish("rawData", { id, data: flatTileData }));
      }
    }
    /**
     * This is currently for testing the new way of rendering visual elements. Called by this.draw()
     */
    async updateTileAsync(tabularDataFetcher, callback) {
      if (!this.tilesetInfo)
        return;
      const tiles = this.visibleAndFetchedTiles();
      const tabularData = await tabularDataFetcher.getTabularData(Object.values(tiles).map((x) => x.remoteId));
      const tilesetInfo = this.tilesetInfo;
      tiles.forEach((tile, i) => {
        if (i === 0) {
          const [refTile] = HGC.utils.trackUtils.calculate1DVisibleTiles(tilesetInfo, this._xScale);
          tile.tileData.zoomLevel = refTile[0];
          tile.tileData.tilePos = [refTile[1], refTile[1]];
          tile.tileData.tabularData = tabularData;
        } else {
          tile.tileData.tabularData = [];
        }
      });
      callback();
    }
    /**
     * Overrides method in Tiled1DPixiTrack. It is called in the constructor, `super(context, options)`.
     * So be aware to use defined variables.
     */
    calculateVisibleTiles() {
      var _a, _b, _c, _d, _e;
      if (!this.tilesetInfo)
        return;
      if (isTabularDataFetcher(this.dataFetcher)) {
        const tiles = HGC.utils.trackUtils.calculate1DVisibleTiles(this.tilesetInfo, this._xScale);
        const maxTileWith = (_b = (_a = this.tilesetInfo.max_tile_width) != null ? _a : this.dataFetcher.MAX_TILE_WIDTH) != null ? _b : Number.MAX_SAFE_INTEGER;
        for (const tile of tiles) {
          const { tileWidth } = this.getTilePosAndDimensions(tile[0], [tile[1], tile[1]]);
          this.forceDraw();
          if (tileWidth > maxTileWith) {
            return;
          }
        }
        this.setVisibleTiles(tiles);
      } else {
        if (!this.tilesetInfo) {
          return;
        }
        const zoomLevel = this.calculateZoomLevel();
        if ("resolutions" in this.tilesetInfo) {
          const sortedResolutions = this.tilesetInfo.resolutions.map((x) => +x).sort((a, b) => b - a);
          const xTiles = tileProxy.calculateTilesFromResolution(
            sortedResolutions[zoomLevel],
            this._xScale,
            this.tilesetInfo.min_pos[0],
            this.tilesetInfo.max_pos[0]
          );
          let yTiles;
          if (Is2DTrack(this.getResolvedTracks()[0])) {
            yTiles = tileProxy.calculateTilesFromResolution(
              sortedResolutions[zoomLevel],
              this._yScale,
              this.tilesetInfo.min_pos[0],
              this.tilesetInfo.max_pos[0]
            );
          }
          const tiles = __privateMethod(_c = _GoslingTrackClass, _tilesToId, tilesToId_fn).call(_c, xTiles, yTiles, zoomLevel);
          this.setVisibleTiles(tiles);
        } else {
          const xTiles = tileProxy.calculateTiles(
            zoomLevel,
            this.relevantScale(),
            this.tilesetInfo.min_pos[0],
            this.tilesetInfo.max_pos[0],
            this.tilesetInfo.max_zoom,
            this.tilesetInfo.max_width
          );
          let yTiles;
          if (Is2DTrack(this.getResolvedTracks()[0])) {
            yTiles = tileProxy.calculateTiles(
              zoomLevel,
              this._yScale,
              this.tilesetInfo.min_pos[1],
              this.tilesetInfo.max_pos[1],
              this.tilesetInfo.max_zoom,
              // @ts-expect-error what is max_width1?
              (_d = this.tilesetInfo.max_width1) != null ? _d : this.tilesetInfo.max_width
            );
          }
          const tiles = __privateMethod(_e = _GoslingTrackClass, _tilesToId, tilesToId_fn).call(_e, xTiles, yTiles, zoomLevel);
          this.setVisibleTiles(tiles);
        }
      }
    }
    /**
     * Get the tile's position in its coordinate system. Overrides method in Tiled1DPixiTrack.
     */
    getTilePosAndDimensions(zoomLevel, tilePos) {
      if (!this.tilesetInfo) {
        throw Error("tilesetInfo not parsed");
      }
      if ("resolutions" in this.tilesetInfo) {
        const sortedResolutions = this.tilesetInfo.resolutions.map((x) => +x).sort((a, b) => b - a);
        const chosenResolution = sortedResolutions[zoomLevel];
        const [xTilePos, yTilePos] = tilePos;
        const tileWidth = chosenResolution * __privateGet(this, _binsPerTile, binsPerTile_get);
        const tileHeight = tileWidth;
        const tileX = tileWidth * xTilePos;
        const tileY = tileHeight * yTilePos;
        return {
          tileX,
          tileY,
          tileWidth,
          tileHeight
        };
      } else {
        const [xTilePos, yTilePos] = tilePos;
        const minX = this.tilesetInfo.min_pos[0];
        const minY = this.tilesetInfo.min_pos[1];
        const tileWidth = this.tilesetInfo.max_width / 2 ** zoomLevel;
        const tileHeight = this.tilesetInfo.max_width / 2 ** zoomLevel;
        const tileX = minX + xTilePos * tileWidth;
        const tileY = minY + yTilePos * tileHeight;
        return {
          tileX,
          tileY,
          tileWidth,
          tileHeight
        };
      }
    }
    /**
     * Gets the indices of the visible data a tile. Overrides method in Tiled1DPixiTrack
     */
    getIndicesOfVisibleDataInTile(tile) {
      const visible = this._xScale.range();
      if (!this.tilesetInfo || !tile.tileData.tilePos || !("dense" in tile.tileData)) {
        return [0, 0];
      }
      const { tileX, tileWidth } = this.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos);
      const tileXScale = HGC.libraries.d3Scale.scaleLinear().domain([0, __privateGet(this, _binsPerTile, binsPerTile_get)]).range([tileX, tileX + tileWidth]);
      const start = Math.max(0, Math.round(tileXScale.invert(this._xScale.invert(visible[0]))));
      const end = Math.min(
        tile.tileData.dense.length,
        Math.round(tileXScale.invert(this._xScale.invert(visible[1])))
      );
      return [start, end];
    }
    /**
     * Overrides method in TiledPixiTrack
     * @param loadedTiles
     */
    receivedTiles(loadedTiles) {
      super.receivedTiles(loadedTiles);
      isTabularDataFetcher(this.dataFetcher) && this.drawLoadingCue();
    }
    /**
     * Overrides method in TiledPixiTrack
     */
    removeOldTiles() {
      super.removeOldTiles();
      isTabularDataFetcher(this.dataFetcher) && this.drawLoadingCue();
    }
    /**
     * Combile multiple tiles into the last tile.
     * This is sometimes necessary, for example, when applying a displacement algorithm to all tiles at once.
     * Called by this.processAllTiles() so this method needs to be public.
     */
    combineAllTilesIfNeeded() {
      var _a, _b, _c;
      if (!this.shouldCombineTiles())
        return;
      const tiles = this.visibleAndFetchedTiles();
      if (!tiles || tiles.length <= 1) {
        return;
      }
      this.tileSize = ((_b = (_a = this.tilesetInfo) == null ? void 0 : _a.tile_size) != null ? _b : 1024) * tiles.length;
      let merged = [];
      tiles.forEach((tile, i) => {
        const tileInfo = __privateGet(this, _processedTileInfo)[tile.tileId];
        if (tileInfo) {
          merged = [...merged, ...tileInfo.tabularData];
          tileInfo.skipRendering = i !== 0;
        }
      });
      const firstTileInfo = __privateGet(this, _processedTileInfo)[tiles[0].tileId];
      firstTileInfo.tabularData = merged;
      if ((_c = firstTileInfo.tabularData[0]) == null ? void 0 : _c.uid) {
        firstTileInfo.tabularData = uniqBy(firstTileInfo.tabularData, "uid");
      }
    }
    /**
     * Check whether tiles should be merged. Needs to be public since called by combineAllTilesIfNeeded()
     */
    shouldCombineTiles() {
      const includesDisplaceTransform = hasDataTransform(this.options.spec, "displace");
      const hasDenseTiles = () => {
        const tiles = this.visibleAndFetchedTiles();
        return tiles.length >= 1 && "dense" in tiles[0].tileData;
      };
      const isBamDataFetcher = this.dataFetcher instanceof BamDataFetcher;
      return includesDisplaceTransform && !hasDenseTiles() && !isBamDataFetcher;
    }
    /**
     * Creates an array of SingleTracks if there are overlaid tracks.
     * This method cannot be private because it is called by functions which are called by super.draw();
     */
    getResolvedTracks(forceUpdate = false) {
      if (forceUpdate || !this.resolvedTracks) {
        const tracks = resolveSuperposedTracks(this.options.spec).filter((t) => t.mark !== "brush");
        tracks.forEach((track) => {
          if ("values" in track.data) {
            track.data.values = [];
          }
        });
        this.resolvedTracks = tracks;
      }
      return this.resolvedTracks;
    }
    /**
     * Apply data transformation to each of the overlaid tracks and generate GoslingTrackModels.
     */
    transformDataAndCreateModels(tile) {
      const tileInfo = __privateGet(this, _processedTileInfo)[tile.tileId];
      if (!tileInfo || tileInfo.skipRendering) {
        return [];
      }
      tileInfo.goslingModels = [];
      const resolvedTracks = this.getResolvedTracks();
      resolvedTracks.forEach((resolvedSpec) => {
        var _a;
        let tabularDataTransformed = Array.from(tileInfo.tabularData);
        (_a = resolvedSpec.dataTransform) == null ? void 0 : _a.forEach((t) => {
          switch (t.type) {
            case "filter":
              tabularDataTransformed = filterData(t, tabularDataTransformed);
              break;
            case "concat":
              tabularDataTransformed = concatString(t, tabularDataTransformed);
              break;
            case "replace":
              tabularDataTransformed = replaceString(t, tabularDataTransformed);
              break;
            case "log":
              tabularDataTransformed = calculateData(t, tabularDataTransformed);
              break;
            case "exonSplit":
              tabularDataTransformed = splitExon(t, tabularDataTransformed, resolvedSpec.assembly);
              break;
            case "genomicLength":
              tabularDataTransformed = calculateGenomicLength(t, tabularDataTransformed);
              break;
            case "svType":
              tabularDataTransformed = inferSvType(t, tabularDataTransformed);
              break;
            case "coverage":
              tabularDataTransformed = aggregateCoverage(t, tabularDataTransformed, this._xScale.copy());
              break;
            case "subjson":
              tabularDataTransformed = parseSubJSON(t, tabularDataTransformed);
              break;
            case "displace":
              tabularDataTransformed = displace(t, tabularDataTransformed, this._xScale.copy());
              break;
          }
        });
        try {
          if (PubSub) {
            const NUM_OF_ROWS_IN_PREVIEW = 100;
            const numOrRows = tabularDataTransformed.length;
            PubSub.publish("data-preview", {
              id: context.viewUid,
              // TODO: Do we need the stringified version? Stringify of large JSON data is very slow.
              dataConfig: JSON.stringify({ data: resolvedSpec.data }),
              data: NUM_OF_ROWS_IN_PREVIEW > numOrRows ? tabularDataTransformed : sampleSize(tabularDataTransformed, NUM_OF_ROWS_IN_PREVIEW)
              // ...
            });
          }
        } catch (e) {
        }
        const [trackWidth, trackHeight] = this.dimensions;
        const axisSize = IsXAxis(resolvedSpec) ? HIGLASS_AXIS_SIZE : 0;
        const [w, h] = [trackWidth, trackHeight + axisSize];
        const circularFactor = Math.min(w, h) / Math.min(resolvedSpec.width, resolvedSpec.height);
        if (resolvedSpec.innerRadius) {
          resolvedSpec.innerRadius = resolvedSpec.innerRadius * circularFactor;
        }
        if (resolvedSpec.outerRadius) {
          resolvedSpec.outerRadius = resolvedSpec.outerRadius * circularFactor;
        }
        resolvedSpec.width = w;
        resolvedSpec.height = h;
        const model = new GoslingTrackModel(resolvedSpec, tabularDataTransformed, this.options.theme);
        tileInfo.goslingModels.push(model);
      });
      return tileInfo.goslingModels;
    }
    // set in HorizontalTiled1DPixiTrack
    /**
     * Overrides method in HorizontalLine1DPixiTrack
     */
    getMouseOverHtml(mouseX, mouseY) {
      var _a, _b, _c, _d, _e;
      __privateMethod(this, _publishTrackEvents, publishTrackEvents_fn).call(this, "trackMouseOver", mouseX, mouseY);
      if (__privateGet(this, _isRangeBrushActivated)) {
        return "";
      }
      if (!this.tilesetInfo) {
        return "";
      }
      this.pMouseHover.clear();
      const genomicPosition = getRelativeGenomicPosition(Math.floor(this._xScale.invert(mouseX)), __privateGet(this, _assembly2));
      const capturedElements = __privateMethod(this, _getElementsWithinMouse, getElementsWithinMouse_fn).call(this, mouseX, mouseY);
      if (capturedElements.length !== 0) {
        document.body.style.cursor = "pointer";
      } else {
        document.body.style.cursor = "default";
      }
      if (capturedElements.length !== 0) {
        const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
        const mouseOverEnabled = !!mouseEvents || IsMouseEventsDeep(mouseEvents) && !!mouseEvents.mouseOver;
        if (mouseOverEnabled) {
          const g = this.pMouseHover;
          if (((_c = (_b = this.options.spec.style) == null ? void 0 : _b.mouseOver) == null ? void 0 : _c.arrange) !== "behind") {
            this.pMain.removeChild(g);
            this.pMain.addChild(g);
          }
          __privateMethod(this, _highlightMarks, highlightMarks_fn).call(this, g, capturedElements, Object.assign({}, DEFAULT_MOUSE_EVENT_STYLE, (_d = this.options.spec.style) == null ? void 0 : _d.mouseOver));
          publish("mouseOver", {
            id: context.viewUid,
            genomicPosition,
            data: capturedElements.map((d) => d.value)
          });
        }
        const models = this.visibleAndFetchedGoslingModels();
        const firstTooltipSpec = (_e = models.find((m2) => {
          var _a2;
          return m2.spec().tooltip && ((_a2 = m2.spec().tooltip) == null ? void 0 : _a2.length) !== 0;
        })) == null ? void 0 : _e.spec().tooltip;
        if (firstTooltipSpec) {
          let content = firstTooltipSpec.map((d) => {
            var _a2;
            const rawValue = capturedElements[0].value[d.field];
            let value = rawValue;
            if (d.type === "quantitative" && d.format) {
              value = HGC.libraries.d3Format.format(d.format)(+rawValue);
            } else if (d.type === "genomic") {
              const { chromosome, position } = getRelativeGenomicPosition(+rawValue, __privateGet(this, _assembly2));
              value = `${chromosome}:${HGC.libraries.d3Format.format(",")(position)}`;
            }
            return `<tr><td style='padding: 4px 8px'>${(_a2 = d.alt) != null ? _a2 : d.field}</td><td style='padding: 4px 8px'><b>${value}</b></td></tr>`;
          }).join("");
          content = `<table style='text-align: left; margin-top: 12px'>${content}</table>`;
          if (capturedElements.length > 1) {
            content += `<div style='padding: 4px 8px; margin-top: 4px; text-align: center; color: grey'>${capturedElements.length - 1} Additional Selections...</div>`;
          }
          return `<div>${content}</div>`;
        }
      }
      return "";
    }
    /* *
     *
     *  Other misc methods and overrides
     *
     * */
    /**
     * Returns the minimum in the visible area (not visible tiles).
     * Overrides method in Tiled1DPixiTrack
     */
    minVisibleValue() {
      return 0;
    }
    /**
     * Returns the maximum in the visible area (not visible tiles).
     * Overrides method in Tiled1DPixiTrack.
     */
    maxVisibleValue() {
      return 0;
    }
    /**
     * Overrides method in PixiTrack. SVG export is not supported.
     */
    exportSVG() {
      throw new Error("exportSVG() not supported for gosling-track");
    }
    /**
     * Show visual cue during waiting for visualizations being rendered. Also called by data fetchers
     */
    drawLoadingCue() {
      if (this.fetching.size) {
        const margin = 6;
        const text = `Fetching... ${Array.from(this.fetching).join(" ")}`;
        __privateGet(this, _loadingText).text = text;
        __privateGet(this, _loadingText).x = this.position[0] + this.dimensions[0] - margin / 2;
        __privateGet(this, _loadingText).y = this.position[1] + this.dimensions[1] - margin / 2;
        const metric = HGC.libraries.PIXI.TextMetrics.measureText(text, __privateGet(this, _loadingTextStyleObj));
        const { width: w, height: h } = metric;
        __privateGet(this, _loadingTextBg).clear();
        __privateGet(this, _loadingTextBg).lineStyle(1, colorToHex("grey"), 1, 0.5);
        __privateGet(this, _loadingTextBg).beginFill(colorToHex("white"), 0.8);
        __privateGet(this, _loadingTextBg).drawRect(
          this.position[0] + this.dimensions[0] - w - margin - 1,
          this.position[1] + this.dimensions[1] - h - margin - 1,
          w + margin,
          h + margin
        );
        __privateGet(this, _loadingText).visible = true;
        __privateGet(this, _loadingTextBg).visible = true;
      } else {
        __privateGet(this, _loadingText).visible = false;
        __privateGet(this, _loadingTextBg).visible = false;
      }
    }
    /**
     * Called in legend.ts
     */
    updateScaleOffsetFromOriginalSpec(_renderingId, scaleOffset, channelKey) {
      this.getResolvedTracks().map((spec) => {
        if (spec._renderingId === _renderingId) {
          const channel = spec[channelKey];
          if (IsChannelDeep(channel)) {
            channel.scaleOffset = scaleOffset;
          }
        }
      });
    }
    /**
     * Called in legend.ts
     */
    shareScaleOffsetAcrossTracksAndTiles(scaleOffset, channelKey) {
      const models = this.visibleAndFetchedGoslingModels();
      models.forEach((d) => {
        const channel = d.spec()[channelKey];
        if (IsChannelDeep(channel)) {
          channel.scaleOffset = scaleOffset;
        }
        const channelOriginal = d.originalSpec()[channelKey];
        if (IsChannelDeep(channelOriginal)) {
          channelOriginal.scaleOffset = scaleOffset;
        }
      });
    }
  };
  _assembly2 = new WeakMap();
  _processedTileInfo = new WeakMap();
  _mouseDownX = new WeakMap();
  _mouseDownY = new WeakMap();
  _isRangeBrushActivated = new WeakMap();
  _gBrush = new WeakMap();
  _loadingTextStyleObj = new WeakMap();
  _loadingTextBg = new WeakMap();
  _loadingText = new WeakMap();
  _tilesToId = new WeakSet();
  tilesToId_fn = function(xTiles, yTiles, zoomLevel) {
    if (!yTiles) {
      return xTiles.map((x) => [zoomLevel, x]);
    }
    const tiles = [];
    xTiles.forEach((x) => yTiles.forEach((y) => tiles.push([zoomLevel, x, y])));
    return tiles;
  };
  _binsPerTile = new WeakSet();
  binsPerTile_get = function() {
    let maybeValue;
    if (this.tilesetInfo) {
      maybeValue = "bins_per_dimension" in this.tilesetInfo ? this.tilesetInfo.bins_per_dimension : this.tilesetInfo.tile_size;
    }
    return maybeValue != null ? maybeValue : 256;
  };
  _generateTabularData = new WeakSet();
  generateTabularData_fn = function(tile, force = false) {
    if (__privateGet(this, _processedTileInfo)[tile.tileId] && !force) {
      return;
    }
    if (!tile.tileData.tilePos) {
      return;
    }
    const tileInfo = initProcessedTileInfo();
    const resolvedTracks = this.getResolvedTracks();
    if (resolvedTracks.length === 0) {
      return [];
    }
    const firstResolvedTrack = resolvedTracks[0];
    if ("tabularData" in tile.tileData) {
      tileInfo.tabularData = tile.tileData.tabularData;
    } else {
      const { tileX, tileY, tileWidth, tileHeight } = this.getTilePosAndDimensions(
        tile.tileData.zoomLevel,
        tile.tileData.tilePos
      );
      const sparse = "length" in tile.tileData ? Array.from(tile.tileData) : [];
      const extendedTileData = Object.assign({}, tile.tileData, {
        sparse,
        tileX,
        tileY,
        tileWidth,
        tileHeight,
        tileSize: this.tileSize
      });
      const tabularData = getTabularData(firstResolvedTrack, extendedTileData);
      if (tabularData) {
        tileInfo.tabularData = tabularData;
      }
    }
    __privateGet(this, _processedTileInfo)[tile.tileId] = tileInfo;
  };
  _onMouseDown = new WeakSet();
  onMouseDown_fn = function(mouseX, mouseY, isAltPressed) {
    var _a;
    __privateSet(this, _mouseDownX, mouseX);
    __privateSet(this, _mouseDownY, mouseY);
    const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
    const rangeSelectEnabled = !!mouseEvents || IsMouseEventsDeep(mouseEvents) && !!mouseEvents.rangeSelect;
    __privateSet(this, _isRangeBrushActivated, rangeSelectEnabled && isAltPressed);
    this.pMouseHover.clear();
  };
  _onMouseMove = new WeakSet();
  onMouseMove_fn = function(mouseX) {
    if (this.options.spec.layout === "circular") {
      return;
    }
    if (__privateGet(this, _isRangeBrushActivated)) {
      this.mRangeBrush.updateRange([mouseX, __privateGet(this, _mouseDownX)]).drawBrush().visible().disable();
    }
  };
  _onMouseUp = new WeakSet();
  onMouseUp_fn = function(mouseX, mouseY) {
    var _a;
    __privateMethod(this, _publishTrackEvents, publishTrackEvents_fn).call(this, "trackClick", mouseX, mouseY);
    const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
    const clickEnabled = !!mouseEvents || IsMouseEventsDeep(mouseEvents) && !!mouseEvents.click;
    const isDrag = Math.sqrt((__privateGet(this, _mouseDownX) - mouseX) ** 2 + (__privateGet(this, _mouseDownY) - mouseY) ** 2) > 1;
    if (!__privateGet(this, _isRangeBrushActivated) && !isDrag) {
      this.mRangeBrush.clear();
      this.pMouseSelection.clear();
    } else {
      this.mRangeBrush.enable();
    }
    __privateSet(this, _isRangeBrushActivated, false);
    if (!this.tilesetInfo) {
      return;
    }
    if (!isDrag && clickEnabled) {
      const genomicPosition = getRelativeGenomicPosition(
        Math.floor(this._xScale.invert(mouseX)),
        __privateGet(this, _assembly2)
      );
      const capturedElements = __privateMethod(this, _getElementsWithinMouse, getElementsWithinMouse_fn).call(this, mouseX, mouseY);
      if (capturedElements.length !== 0) {
        this.options.siblingIds.forEach(
          (id) => publish("click", {
            id,
            genomicPosition,
            data: capturedElements.map((d) => d.value)
          })
        );
      }
    }
  };
  _onMouseOut = new WeakSet();
  onMouseOut_fn = function() {
    __privateSet(this, _isRangeBrushActivated, false);
    document.body.style.cursor = "default";
    this.pMouseHover.clear();
  };
  _getElementsWithinMouse = new WeakSet();
  getElementsWithinMouse_fn = function(mouseX, mouseY) {
    var _a;
    const models = this.visibleAndFetchedGoslingModels();
    const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
    const multiHovering = IsMouseEventsDeep(mouseEvents) && mouseEvents.enableMouseOverOnMultipleMarks;
    const idField = IsMouseEventsDeep(mouseEvents) && mouseEvents.groupMarksByField;
    const mergedCapturedElements = models.map((model) => model.getMouseEventModel().findAll(mouseX, mouseY, true)).flat();
    if (!multiHovering) {
      mergedCapturedElements.splice(1, mergedCapturedElements.length - 1);
    }
    if (mergedCapturedElements.length !== 0 && idField) {
      const source = Array.from(mergedCapturedElements);
      models.forEach((model) => {
        const siblings = model.getMouseEventModel().getSiblings(source, idField);
        mergedCapturedElements.push(...siblings);
      });
    }
    return mergedCapturedElements;
  };
  _publishTrackEvents = new WeakSet();
  publishTrackEvents_fn = function(eventType, mouseX, mouseY) {
    const [x, y] = this.position;
    const [width, height] = this.dimensions;
    if (this.options.spec.layout === "circular") {
      const cx = x + width / 2;
      const cy = y + height / 2;
      const innerRadius = this.options.spec.innerRadius;
      const outerRadius = this.options.spec.outerRadius;
      const startAngle = this.options.spec.startAngle;
      const endAngle = this.options.spec.endAngle;
      if (isPointInsideDonutSlice(
        [mouseX, mouseY],
        [width / 2, height / 2],
        [innerRadius, outerRadius],
        [startAngle, endAngle]
      )) {
        publish(eventType, {
          id: context.viewUid,
          spec: this.options.spec,
          shape: { x, y, width, height, cx, cy, innerRadius, outerRadius, startAngle, endAngle }
        });
      }
    } else {
      publish(eventType, {
        id: context.viewUid,
        spec: this.options.spec,
        shape: { x, y, width, height }
      });
    }
  };
  _onRangeBrush = new WeakSet();
  onRangeBrush_fn = function(range, skipApiTrigger = false) {
    var _a, _b, _c, _d;
    this.pMouseSelection.clear();
    if (range === null) {
      if (!skipApiTrigger) {
        publish("rangeSelect", { id: context.viewUid, genomicRange: null, data: [] });
      }
      return;
    }
    const models = this.visibleAndFetchedGoslingModels();
    const [startX, endX] = range;
    let capturedElements = models.map((model) => model.getMouseEventModel().findAllWithinRange(startX, endX, true)).flat();
    const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
    const idField = IsMouseEventsDeep(mouseEvents) && mouseEvents.groupMarksByField;
    if (capturedElements.length !== 0 && idField) {
      models.forEach((model) => {
        const siblings = model.getMouseEventModel().getSiblings(capturedElements, idField);
        const siblingIds = Array.from(new Set(siblings.map((d) => d.value[idField])));
        capturedElements = capturedElements.filter((d) => siblingIds.indexOf(d.value[idField]) === -1);
      });
    }
    if (capturedElements.length !== 0) {
      const g = this.pMouseSelection;
      if (((_c = (_b = this.options.spec.style) == null ? void 0 : _b.select) == null ? void 0 : _c.arrange) !== "behind") {
        this.pMain.removeChild(g);
        this.pMain.addChild(g);
      }
      __privateMethod(this, _highlightMarks, highlightMarks_fn).call(this, g, capturedElements, Object.assign({}, DEFAULT_MOUSE_EVENT_STYLE, (_d = this.options.spec.style) == null ? void 0 : _d.select));
    }
    if (!skipApiTrigger) {
      const genomicRange = [
        getRelativeGenomicPosition(Math.floor(this._xScale.invert(startX)), __privateGet(this, _assembly2)),
        getRelativeGenomicPosition(Math.floor(this._xScale.invert(endX)), __privateGet(this, _assembly2))
      ];
      publish("rangeSelect", {
        id: context.viewUid,
        genomicRange,
        data: capturedElements.map((d) => d.value)
      });
    }
    this.forceDraw();
  };
  _highlightMarks = new WeakSet();
  highlightMarks_fn = function(g, marks, style) {
    g.lineStyle(
      style.strokeWidth,
      colorToHex(style.stroke),
      style.strokeOpacity,
      // alpha
      0.5
      // alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
    );
    g.beginFill(colorToHex(style.color), style.color === "none" ? 0 : style.opacity);
    marks.forEach((d) => {
      if (d.type === "point") {
        const [x, y, r = 3] = d.polygon;
        g.drawCircle(x, y, r);
      } else if (d.type === "line") {
        g.moveTo(d.polygon[0], d.polygon[1]);
        flatArrayToPairArray(d.polygon).map((d2) => g.lineTo(d2[0], d2[1]));
      } else {
        g.drawPolygon(d.polygon);
      }
    });
  };
  _publishOnNewTrack = new WeakSet();
  publishOnNewTrack_fn = function() {
    publish("onNewTrack", {
      id: context.viewUid
    });
  };
  /**
   * Convert tile positions to tile IDs
   */
  __privateAdd(_GoslingTrackClass, _tilesToId);
  let GoslingTrackClass = _GoslingTrackClass;
  return new GoslingTrackClass();
};
const GoslingTrack = createPluginTrack(config$1, factory$1);
const config = {
  type: "dummy-track",
  defaultOptions: {
    height: 0,
    // default height gets set in when spec is preprocessed
    width: 0,
    // default width gets set in when spec is preprocessed
    title: "",
    background: "#fff",
    textFontSize: 12,
    textFontWeight: "normal",
    textStroke: "#000",
    textStrokeWidth: 0.1,
    outline: "#fff"
  }
};
const factory = (HGC, context, options) => {
  var _drawBackground, drawBackground_fn, _drawText, drawText_fn;
  const { SVGTrack } = HGC.tracks;
  class DummyTrackClass extends SVGTrack {
    constructor() {
      super(context, options);
      __privateAdd(this, _drawBackground);
      /**
       * Draws the title of the dummy track
       */
      __privateAdd(this, _drawText);
      __privateMethod(this, _drawBackground, drawBackground_fn).call(this);
      __privateMethod(this, _drawText, drawText_fn).call(this);
      publish("onNewTrack", {
        id: context.viewUid
      });
    }
  }
  _drawBackground = new WeakSet();
  drawBackground_fn = function() {
    this.gMain.append("rect").attr("fill", options.background).attr("x", 0).attr("y", 0).attr("width", options.width).attr("height", options.height).style("stroke", options.outline);
  };
  _drawText = new WeakSet();
  drawText_fn = function() {
    this.gMain.append("text").attr("x", options.width / 2).attr("y", (options.height + options.textFontSize) / 2).style("text-anchor", "middle").style("font-size", `${options.textFontSize}px`).style("font-weight", options.textFontWeight).style("stroke", options.textStroke).style("stroke-width", options.textStrokeWidth).text(options.title);
  };
  return new DummyTrackClass();
};
const DummyTrack = createPluginTrack(config, factory);
let once = false;
function init() {
  if (once)
    return;
  higlassRegister({
    name: "GoslingTrack",
    track: GoslingTrack,
    config: GoslingTrack.config
  });
  higlassRegister({
    name: "Gosling2DTrack",
    track: GoslingTrack,
    config: {
      ...GoslingTrack.config,
      type: "gosling-2d-track",
      orientation: "2d"
    }
  });
  higlassRegister({
    name: "AxisTrack",
    track: AxisTrack,
    config: AxisTrack.config
  });
  higlassRegister({
    name: "TextTrack",
    track: TextTrack,
    config: TextTrack.config
  });
  higlassRegister({
    name: "BrushTrack",
    track: BrushTrack,
    config: BrushTrack.config
  });
  higlassRegister({
    name: "DummyTrack",
    track: DummyTrack,
    config: DummyTrack.config
  });
  for (const dataFetcher of Object.values(dataFetchers)) {
    const { config: config2 } = dataFetcher;
    higlassRegister({ dataFetcher, config: config2 }, { pluginType: "dataFetcher" });
  }
  once = true;
}
function getBoundingBox(trackInfos) {
  let width = 0;
  let height = 0;
  trackInfos.forEach((_) => {
    const w = _.boundingBox.x + _.boundingBox.width;
    const h = _.boundingBox.y + _.boundingBox.height;
    if (height < h) {
      height = h;
    }
    if (width < w) {
      width = w;
    }
  });
  return { width, height };
}
function getRelativeTrackInfo(spec, theme) {
  var _a, _b;
  let trackInfos = [];
  traverseAndCollectTrackInfo(spec, trackInfos);
  const size = getBoundingBox(trackInfos);
  if (spec.title || spec.subtitle) {
    const titleHeight = (spec.title ? ((_a = theme.root.titleFontSize) != null ? _a : 18) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM : 0) + (spec.subtitle ? ((_b = theme.root.subtitleFontSize) != null ? _b : 14) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM : 0);
    const marginBottom = 4;
    size.height += titleHeight + marginBottom;
    size.height = size.height + (8 - size.height % 8);
    trackInfos.forEach((_) => {
      _.boundingBox.y += titleHeight + marginBottom;
    });
    trackInfos = [
      {
        track: getTextTrack({ width: size.width, height: titleHeight }, spec.title, spec.subtitle),
        boundingBox: { x: 0, y: 0, width: size.width, height: titleHeight },
        layout: { x: 0, y: 0, w: 12, h: titleHeight / size.height * 12 }
      },
      ...trackInfos
    ];
  } else {
    size.height = size.height + (8 - size.height % 8);
  }
  const pixelPreciseMarginPadding = !(typeof spec.responsiveSize !== "object" ? spec.responsiveSize : spec.responsiveSize.height);
  trackInfos.forEach((_) => {
    _.layout.x = _.boundingBox.x / size.width * 12;
    _.layout.w = _.boundingBox.width / size.width * 12;
    _.layout.y = pixelPreciseMarginPadding ? _.boundingBox.y : _.boundingBox.y / size.height * 12;
    _.layout.h = pixelPreciseMarginPadding ? _.boundingBox.height : _.boundingBox.height / size.height * 12;
  });
  return { trackInfos, size };
}
function traverseAndCollectTrackInfo(spec, output, dx = 0, dy = 0, circularRootNotFound = true) {
  let cumWidth = 0;
  let cumHeight = 0;
  let allChildCircularLayout = true;
  let traversedAtLeastOnce = false;
  traverseTracksAndViews(spec, (tv) => {
    traversedAtLeastOnce = true;
    if (tv.layout !== "circular") {
      allChildCircularLayout = false;
    }
  });
  let noChildConcatArrangement = true;
  traverseViewArrangements(spec, (a) => {
    if (a.arrangement === "vertical" || a.arrangement === "horizontal") {
      noChildConcatArrangement = false;
    }
  });
  const isThisCircularRoot = circularRootNotFound && allChildCircularLayout && traversedAtLeastOnce && noChildConcatArrangement && ("views" in spec && (spec.arrangement === "parallel" || spec.arrangement === "serial") || "tracks" in spec);
  const numTracksBeforeInsert = output.length;
  if ("tracks" in spec) {
    const tracks = spec.tracks;
    if (spec.orientation === "vertical") {
      cumHeight = Math.max(...tracks.map((d) => d.height));
      tracks.forEach((track, i, array) => {
        if (getNumOfXAxes([track]) === 1) {
          track.width += HIGLASS_AXIS_SIZE;
        }
        track.height = cumHeight;
        output.push({
          track,
          boundingBox: {
            x: dx + cumWidth,
            y: dy,
            width: track.width,
            height: cumHeight
          },
          layout: { x: 0, y: 0, w: 0, h: 0 }
          // Just put a dummy info here, this should be added after entire bounding box has been determined
        });
        if (array[i + 1] && array[i + 1].overlayOnPreviousTrack)
          ;
        else {
          cumWidth += track.width;
          if (i !== array.length - 1) {
            cumWidth += spec.spacing !== void 0 ? spec.spacing : 0;
          }
        }
      });
    } else {
      cumWidth = Math.max(...tracks.map((d) => d.width));
      tracks.forEach((track, i, array) => {
        if (getNumOfXAxes([track]) === 1) {
          track.height += HIGLASS_AXIS_SIZE;
        }
        const singleTrack = resolveSuperposedTracks(track);
        if (singleTrack.length > 0 && Is2DTrack(singleTrack[0]) && getNumOfYAxes([track]) === 1) {
          cumWidth += HIGLASS_AXIS_SIZE;
        }
        track.width = cumWidth;
        output.push({
          track,
          boundingBox: {
            x: dx,
            y: dy + cumHeight,
            width: cumWidth,
            height: track.height
          },
          layout: { x: 0, y: 0, w: 0, h: 0 }
          // Just put a dummy info here, this should be added after entire bounding box has been determined
        });
        if (array[i + 1] && array[i + 1].overlayOnPreviousTrack)
          ;
        else {
          cumHeight += track.height;
          if (i !== array.length - 1) {
            cumHeight += spec.spacing !== void 0 ? spec.spacing : 0;
          }
        }
      });
    }
  } else {
    if (spec.arrangement === "parallel" || spec.arrangement === "vertical") {
      const spacing = spec.spacing !== void 0 ? spec.spacing : DEFAULT_VIEW_SPACING;
      spec.views.forEach((v, i, array) => {
        var _a, _b, _c, _d, _e;
        const viewBB = traverseAndCollectTrackInfo(
          v,
          output,
          dx + ((_a = v.xOffset) != null ? _a : 0),
          dy + ((_b = v.yOffset) != null ? _b : 0) + cumHeight,
          !isThisCircularRoot && circularRootNotFound
        );
        if (cumWidth < ((_c = v.xOffset) != null ? _c : 0) + viewBB.width) {
          cumWidth = ((_d = v.xOffset) != null ? _d : 0) + viewBB.width;
        }
        if (i !== array.length - 1) {
          cumHeight += spacing;
        }
        cumHeight += ((_e = v.yOffset) != null ? _e : 0) + viewBB.height;
      });
    } else if (spec.arrangement === "serial" || spec.arrangement === "horizontal") {
      spec.views.forEach((v, i, array) => {
        var _a, _b, _c, _d, _e;
        const spacing = spec.spacing !== void 0 ? spec.spacing : DEFAULT_VIEW_SPACING;
        const viewBB = traverseAndCollectTrackInfo(
          v,
          output,
          dx + ((_a = v.xOffset) != null ? _a : 0) + cumWidth,
          dy + ((_b = v.yOffset) != null ? _b : 0),
          !isThisCircularRoot && circularRootNotFound
        );
        if (cumHeight < ((_c = v.xOffset) != null ? _c : 0) + viewBB.height) {
          cumHeight = ((_d = v.xOffset) != null ? _d : 0) + viewBB.height;
        }
        if (i !== array.length - 1) {
          cumWidth += spacing;
        }
        cumWidth += ((_e = v.xOffset) != null ? _e : 0) + viewBB.width;
      });
    }
  }
  if (isThisCircularRoot) {
    const cTracks = output.slice(numTracksBeforeInsert);
    const ifMultipleViews = "views" in spec && (spec.arrangement === "parallel" || spec.arrangement === "serial") && spec.views.length > 1;
    const SPACING = spec.spacing !== void 0 ? spec.spacing : DEFAULT_VIEW_SPACING;
    const PADDING = DEFAULT_CIRCULAR_VIEW_PADDING;
    const INNER_RADIUS = spec.centerRadius !== void 0 ? spec.centerRadius : DEFAULT_INNER_RADIUS_PROP;
    const TOTAL_RADIUS = cumWidth / 2 + PADDING;
    const TOTAL_RING_SIZE = TOTAL_RADIUS * (1 - INNER_RADIUS);
    cTracks.forEach((t, i) => {
      var _a, _b;
      if (IsDummyTrack(t.track)) {
        return;
      }
      t.track.layout = "circular";
      t.track.outerRadius = TOTAL_RADIUS - PADDING - (t.boundingBox.y - dy) / cumHeight * TOTAL_RING_SIZE;
      t.track.innerRadius = TOTAL_RADIUS - PADDING - (t.boundingBox.y + t.boundingBox.height - dy) / cumHeight * TOTAL_RING_SIZE;
      const spacingAngle = SPACING / cumWidth * 360;
      t.track.startAngle = spacingAngle + (t.boundingBox.x - dx) / cumWidth * (cumWidth - SPACING) / cumWidth * 360;
      t.track.endAngle = (t.boundingBox.x + t.boundingBox.width - dx) / cumWidth * (cumWidth - SPACING) / cumWidth * 360;
      t.boundingBox.x = dx + ((_a = t.track.xOffset) != null ? _a : 0);
      t.boundingBox.y = dy + ((_b = t.track.yOffset) != null ? _b : 0);
      t.boundingBox.height = t.track.height = t.boundingBox.width = t.track.width = TOTAL_RADIUS * 2;
      if (i !== 0) {
        t.track.overlayOnPreviousTrack = true;
      }
      if (ifMultipleViews) {
        if (IsOverlaidTrack(t.track)) {
          t.track._overlay = t.track._overlay.filter((o) => o.mark !== "brush");
        }
      }
    });
    cumHeight = TOTAL_RADIUS * 2;
  }
  spec._assignedWidth = cumWidth;
  spec._assignedHeight = cumHeight;
  return { x: dx, y: dy, width: cumWidth, height: cumHeight };
}
function getNumOfXAxes(tracks) {
  return tracks.filter((t) => IsXAxis(t)).length;
}
function getNumOfYAxes(tracks) {
  return tracks.filter((t) => IsYAxis(t)).length;
}
const getTextTrack = (size, title2, subtitle) => {
  return JSON.parse(
    JSON.stringify({
      mark: "header",
      width: size.width,
      height: size.height,
      title: title2,
      subtitle
    })
  );
};
function parseServerAndTilesetUidFromUrl(url) {
  if (!url.includes("tileset_info/?d=") || !url.includes("https:") && !url.includes("http:")) {
    return { server: void 0, tilesetUid: void 0 };
  }
  const server = url.split("tileset_info/?d=")[0];
  const tilesetUid = url.split("tileset_info/?d=")[1];
  return { server, tilesetUid };
}
function goslingToHiGlass(hgModel, gosTrack, bb, layout, theme, idMapper, urlToFetchOptions) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
  if (IsDummyTrack(gosTrack)) {
    hgModel.addDefaultView(gosTrack.id).setDummyTrack(gosTrack).setLayout(layout);
    return hgModel;
  }
  const resolvedSpecs = resolveSuperposedTracks(gosTrack);
  const firstResolvedSpec = resolvedSpecs[0];
  const trackId = (_a = firstResolvedSpec.id) != null ? _a : uuid();
  if (!firstResolvedSpec.id) {
    firstResolvedSpec.id = trackId;
  }
  resolvedSpecs.forEach((spec) => {
    if (spec.id) {
      idMapper.addMapping(spec.id, trackId);
    }
  });
  const assembly = firstResolvedSpec.assembly;
  if (IsDataDeep(firstResolvedSpec.data)) {
    let server, tilesetUid;
    if (IsDataDeepTileset(firstResolvedSpec.data)) {
      const parsed = parseServerAndTilesetUidFromUrl(firstResolvedSpec.data.url);
      server = parsed.server;
      tilesetUid = parsed.tilesetUid;
    }
    const genomicChannel = getGenomicChannelFromTrack(firstResolvedSpec);
    const genomicChannelKey = getGenomicChannelKeyFromTrack(firstResolvedSpec);
    const isXGenomic = genomicChannelKey === "x" || genomicChannelKey === "xe";
    const xDomain = isXGenomic && IsChannelDeep(genomicChannel) ? genomicChannel.domain : void 0;
    const yDomain = Is2DTrack(firstResolvedSpec) && IsChannelDeep(firstResolvedSpec.y) ? firstResolvedSpec.y.domain : void 0;
    const width = bb.width - (firstResolvedSpec.layout !== "circular" && firstResolvedSpec.orientation === "vertical" && IsXAxis(firstResolvedSpec) ? HIGLASS_AXIS_SIZE : 0);
    const height = bb.height - (firstResolvedSpec.layout !== "circular" && firstResolvedSpec.orientation === "horizontal" && IsXAxis(firstResolvedSpec) ? HIGLASS_AXIS_SIZE : 0);
    const hgTrack = {
      uid: `${trackId}-track`,
      // This is being used to cache the visualization
      type: Is2DTrack(firstResolvedSpec) ? "gosling-2d-track" : "gosling-track",
      server,
      tilesetUid,
      width,
      height,
      options: {
        id: trackId,
        siblingIds: idMapper.getSiblingGoslingIds(trackId),
        /* Mouse hover position */
        showMousePosition: firstResolvedSpec.layout === "circular" ? false : theme.root.showMousePosition,
        // show mouse position only for linear tracks // TODO: or vertical
        mousePositionColor: theme.root.mousePositionColor,
        /* Track title */
        name: firstResolvedSpec.layout === "linear" ? firstResolvedSpec.title : " ",
        labelPosition: firstResolvedSpec.title ? theme.track.titleAlign === "left" ? "topLeft" : "topRight" : "none",
        labelShowResolution: false,
        labelColor: theme.track.titleColor,
        labelBackgroundColor: theme.track.titleBackground,
        labelBackgroundOpacity: 0.5,
        // TODO: Support `theme.track.titleBackgroundOpacity`
        labelTextOpacity: 1,
        labelLeftMargin: 1,
        labelTopMargin: 1,
        labelRightMargin: 0,
        labelBottomMargin: 0,
        // TODO: Use this eventually
        // trackBorderWidth: firstResolvedSpec.style?.outlineWidth ?? 3,
        // trackBorderColor: firstResolvedSpec.style?.outline ?? '#DBDBDB',
        /* Others */
        backgroundColor: "transparent",
        // in this way, we can superpose multiple tracks
        spec: { ...gosTrack },
        theme
      }
    };
    if (firstResolvedSpec.data && IsDataDeep(firstResolvedSpec.data) && (firstResolvedSpec.data.type === "csv" || firstResolvedSpec.data.type === "json" || firstResolvedSpec.data.type === "bigwig" || firstResolvedSpec.data.type === "bam" || firstResolvedSpec.data.type === "vcf" || firstResolvedSpec.data.type === "gff" || firstResolvedSpec.data.type === "bed" || // TODO: This is a hack to enable custom data fetchers
    firstResolvedSpec.data.useCustomDataFetcher)) {
      const getFieldName = (c) => {
        const cDef = firstResolvedSpec[c];
        return cDef && IsChannelDeep(cDef) ? cDef.field : void 0;
      };
      const xFields = {
        x: getFieldName("x"),
        xe: getFieldName("xe"),
        x1: getFieldName("x1"),
        x1e: getFieldName("x1e")
      };
      const urlFetchOptions = "url" in firstResolvedSpec.data && (urlToFetchOptions == null ? void 0 : urlToFetchOptions[firstResolvedSpec.data.url]) || {};
      const indexUrlFetchOptions = "indexUrl" in firstResolvedSpec.data && (urlToFetchOptions == null ? void 0 : urlToFetchOptions[firstResolvedSpec.data.indexUrl]) || {};
      hgTrack.data = {
        ...firstResolvedSpec.data,
        ...xFields,
        urlFetchOptions,
        indexUrlFetchOptions,
        // Additionally, add assembly, otherwise, a default genome build is used
        assembly
        // TODO: should look all sub tracks' `dataTransform` and apply OR operation.
        // Add a data transformation spec so that the fetcher can properly sample datasets
        // filter: (firstResolvedSpec as any).dataTransform?.filter((f: DataTransform) => f.type === 'filter')
      };
    }
    if (IsHiGlassMatrix(firstResolvedSpec)) {
      hgTrack.type = "heatmap";
      const colorStr = IsChannelDeep(firstResolvedSpec.color) && typeof firstResolvedSpec.color.range === "string" ? firstResolvedSpec.color.range : "viridis";
      hgTrack.options.colorRange = getHiGlassColorRange(colorStr);
      hgTrack.options.trackBorderWidth = (_c = (_b = firstResolvedSpec.style) == null ? void 0 : _b.outlineWidth) != null ? _c : theme.track.outlineWidth;
      hgTrack.options.trackBorderColor = (_e = (_d = firstResolvedSpec.style) == null ? void 0 : _d.outline) != null ? _e : theme.track.outline;
      hgTrack.options.extent = (_g = (_f = firstResolvedSpec.style) == null ? void 0 : _f.matrixExtent) != null ? _g : "full";
      hgTrack.options.colorbarPosition = ((_h = firstResolvedSpec.color) == null ? void 0 : _h.legend) ? hgTrack.options.extent === "lower-left" ? "bottomLeft" : "topRight" : "hidden";
    }
    if (firstResolvedSpec.overlayOnPreviousTrack) {
      hgModel.setViewOrientation(firstResolvedSpec.orientation).addTrackToCombined(hgTrack);
    } else {
      hgModel.setViewOrientation(firstResolvedSpec.orientation).setAssembly(assembly).addDefaultView(trackId, assembly).setDomain(xDomain, yDomain != null ? yDomain : xDomain).adjustDomain(firstResolvedSpec.orientation, width, height).setMainTrack(hgTrack).addTrackSourceServers(server).setZoomFixed(firstResolvedSpec.static === true).setZoomLimits((_i = firstResolvedSpec.zoomLimits) != null ? _i : [1, null]).setLayout(layout);
    }
    const getAxisNarrowType = (c, orientation = "horizontal", width2, height2) => {
      const narrowSizeThreshold = 400;
      const narrowerSizeThreshold = 200;
      if (orientation === "horizontal") {
        if (c === "x" && width2 <= narrowerSizeThreshold || c === "y" && height2 <= narrowerSizeThreshold) {
          return "narrower";
        } else if (c === "x" && width2 <= narrowSizeThreshold || c === "y" && height2 <= narrowSizeThreshold) {
          return "narrow";
        } else {
          return "regular";
        }
      } else {
        if (c === "x" && height2 <= narrowerSizeThreshold || c === "y" && width2 <= narrowerSizeThreshold) {
          return "narrower";
        } else if (c === "x" && height2 <= narrowSizeThreshold || c === "y" && width2 <= narrowSizeThreshold) {
          return "narrow";
        } else {
          return "regular";
        }
      }
    };
    ["x", "y"].forEach((c) => {
      const channel = firstResolvedSpec[c];
      if (IsChannelDeep(channel) && "axis" in channel && channel.axis && channel.axis !== "none" && channel.type === "genomic") {
        const narrowType = getAxisNarrowType(c, gosTrack.orientation, bb.width, bb.height);
        hgModel.setAxisTrack(channel.axis, narrowType, {
          id: `${trackId}-${channel.axis}-axis`,
          layout: firstResolvedSpec.layout,
          innerRadius: channel.axis === "top" ? firstResolvedSpec.outerRadius - HIGLASS_AXIS_SIZE : firstResolvedSpec.innerRadius,
          outerRadius: channel.axis === "top" ? firstResolvedSpec.outerRadius : firstResolvedSpec.innerRadius + HIGLASS_AXIS_SIZE,
          width: firstResolvedSpec.width,
          height: firstResolvedSpec.height,
          startAngle: firstResolvedSpec.startAngle,
          endAngle: firstResolvedSpec.endAngle,
          theme
        });
      }
    });
    hgModel.validateSpec(true);
  } else if (firstResolvedSpec.mark === "header") {
    hgModel.addDefaultView(`${trackId}-title`).setLayout(layout);
    if (typeof firstResolvedSpec.title === "string") {
      hgModel.setTextTrack(
        bb.width,
        ((_j = theme.root.titleFontSize) != null ? _j : 18) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM,
        firstResolvedSpec.title,
        theme.root.titleColor,
        (_k = theme.root.titleFontSize) != null ? _k : 18,
        theme.root.titleFontWeight,
        theme.root.titleAlign,
        theme.root.titleBackgroundColor,
        (_l = theme.root.titleFontFamily) != null ? _l : DEFAULT_TEXT_STYLE.fontFamily
      );
    }
    if (typeof firstResolvedSpec.subtitle === "string") {
      hgModel.setTextTrack(
        bb.width,
        // TODO: better way to safely get the value when undefined?
        ((_m = theme.root.subtitleFontSize) != null ? _m : 14) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM,
        firstResolvedSpec.subtitle,
        theme.root.subtitleColor,
        (_n = theme.root.subtitleFontSize) != null ? _n : 14,
        theme.root.subtitleFontWeight,
        theme.root.subtitleAlign,
        theme.root.subtitleBackgroundColor,
        (_o = theme.root.subtitleFontFamily) != null ? _o : DEFAULT_TEXT_STYLE.fontFamily
      );
    }
  }
  return hgModel;
}
function getLinkingInfo(hgModel) {
  const linkingInfo = [];
  hgModel.spec().views.forEach((v) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    const hgViewId = v.uid;
    let spec = (
      /* TODO: */
      (_e = (_d = (_c = (_b = (_a = v.tracks.center) == null ? void 0 : _a[0]) == null ? void 0 : _b.contents) == null ? void 0 : _c[0]) == null ? void 0 : _d.options) == null ? void 0 : _e.spec
    );
    if (!spec) {
      spec = /* TODO: */
      (_j = (_i = (_h = (_g = (_f = v.tracks.left) == null ? void 0 : _f[0]) == null ? void 0 : _g.contents) == null ? void 0 : _h[0]) == null ? void 0 : _i.options) == null ? void 0 : _j.spec;
      if (!spec) {
        spec = /* TODO: */
        (_o = (_n = (_m = (_l = (_k = v.tracks.left) == null ? void 0 : _k[1]) == null ? void 0 : _l.contents) == null ? void 0 : _m[0]) == null ? void 0 : _n.options) == null ? void 0 : _o.spec;
      }
    }
    if (!hgViewId || !spec)
      return;
    const resolved = resolveSuperposedTracks(spec);
    resolved.forEach((spec2) => {
      SUPPORTED_CHANNELS.forEach((cKey) => {
        var _a2, _b2, _c2, _d2;
        const channel = spec2[cKey];
        if (IsChannelDeep(channel) && "linkingId" in channel && channel.linkingId) {
          linkingInfo.push({
            layout: spec2.layout === "circular" ? "circular" : "linear",
            hgViewId,
            linkId: channel.linkingId,
            isBrush: spec2.mark === "brush",
            style: {
              color: (_a2 = spec2.color) == null ? void 0 : _a2.value,
              stroke: (_b2 = spec2.stroke) == null ? void 0 : _b2.value,
              strokeWidth: (_c2 = spec2.strokeWidth) == null ? void 0 : _c2.value,
              opacity: (_d2 = spec2.opacity) == null ? void 0 : _d2.value,
              startAngle: spec2.startAngle,
              endAngle: spec2.endAngle,
              innerRadius: spec2.innerRadius,
              outerRadius: spec2.outerRadius
            }
          });
          return;
        }
      });
    });
  });
  return linkingInfo;
}
class GoslingToHiGlassIdMapper {
  constructor() {
    /** A mapping table between Gosling track IDs to HiGlass view IDs */
    __privateAdd(this, _table, {});
  }
  addMapping(gtId, hvId) {
    if (__privateGet(this, _table)[gtId] && __privateGet(this, _table)[gtId] !== hvId) {
      console.warn(`The track ID ${gtId} already exists but overwriting with a different ID.`);
    }
    __privateGet(this, _table)[gtId] = hvId;
  }
  getTable() {
    return __privateGet(this, _table);
  }
  getGoslingIds() {
    return Object.keys(__privateGet(this, _table));
  }
  getHiGlassId(gtId) {
    return __privateGet(this, _table)[gtId];
  }
  /**
   * Get IDs of Gosling tracks that became the same HiGlass view.
   * @param HiGlassId
   * @returns
   */
  getSiblingGoslingIds(HiGlassId) {
    return Object.entries(__privateGet(this, _table)).filter(([, hvId]) => hvId === HiGlassId).map(([gtId]) => gtId);
  }
}
_table = new WeakMap();
function getViewIds(spec) {
  const viewIds = /* @__PURE__ */ new Set();
  if (spec.id) {
    viewIds.add(spec.id);
  }
  traverseTracksAndViews(spec, (subSpec) => {
    if ("views" in subSpec || "tracks" in subSpec) {
      if (subSpec.id) {
        viewIds.add(subSpec.id);
      }
    }
  });
  return Array.from(viewIds);
}
function getTrackIds(spec) {
  const trackIds = /* @__PURE__ */ new Set();
  traverseTracksAndViews(spec, (subSpec) => {
    if (!("views" in subSpec) && !("tracks" in subSpec)) {
      if (subSpec.id) {
        trackIds.add(subSpec.id);
      }
    }
  });
  return Array.from(trackIds);
}
function getInternalSpecById(spec, id) {
  let internalSpec;
  if (spec.id === id) {
    internalSpec = spec;
  }
  traverseTracksAndViews(spec, (subSpec) => {
    if (subSpec.id === id) {
      internalSpec = subSpec;
    }
  });
  return internalSpec;
}
function getViewApiData(spec, tracks) {
  return getViewIds(spec).map((viewId) => {
    const internalSpec = getInternalSpecById(spec, viewId);
    const trackIds = getTrackIds(internalSpec);
    const bb = {
      x: Number.MAX_SAFE_INTEGER,
      y: Number.MAX_SAFE_INTEGER,
      xe: -Number.MAX_SAFE_INTEGER,
      ye: -Number.MAX_SAFE_INTEGER
    };
    trackIds.map((trackId) => tracks.find((t) => t.id === trackId)).forEach((track) => {
      if (!track)
        return;
      const { shape } = track;
      if (bb.x > shape.x) {
        bb.x = shape.x;
      }
      if (bb.y > shape.y) {
        bb.y = shape.y;
      }
      if (bb.xe < shape.x + shape.width) {
        bb.xe = shape.x + shape.width;
      }
      if (bb.ye < shape.y + shape.height) {
        bb.ye = shape.y + shape.height;
      }
    });
    return {
      id: viewId,
      spec: internalSpec,
      shape: { ...bb, width: bb.xe - bb.x, height: bb.ye - bb.y }
    };
  });
}
function renderHiGlass(spec, trackInfos, callback, theme, urlToFetchOptions) {
  if (trackInfos.length === 0) {
    return;
  }
  const hgModel = new HiGlassModel();
  const idMapper = new GoslingToHiGlassIdMapper();
  trackInfos.forEach((tb) => {
    const { track, boundingBox: bb, layout } = tb;
    goslingToHiGlass(hgModel, track, bb, layout, theme, idMapper, urlToFetchOptions);
  });
  const linkingInfos = getLinkingInfo(hgModel);
  linkingInfos.filter((d) => d.isBrush).forEach((info) => {
    var _a;
    hgModel.addBrush(
      info.layout,
      info.hgViewId,
      theme,
      (_a = linkingInfos.find((d) => !d.isBrush && d.linkId === info.linkId)) == null ? void 0 : _a.hgViewId,
      info.style
    );
  });
  linkingInfos.filter((d) => !d.isBrush).forEach((d) => {
    hgModel.spec().zoomLocks.locksByViewUid[d.hgViewId] = d.linkId;
    hgModel.spec().locationLocks.locksByViewUid[d.hgViewId] = d.linkId;
  });
  const uniqueLinkIds = Array.from(new Set(linkingInfos.map((d) => d.linkId)));
  uniqueLinkIds.forEach((linkId) => {
    hgModel.spec().zoomLocks.locksDict[linkId] = { uid: linkId };
    hgModel.spec().locationLocks.locksDict[linkId] = { uid: linkId };
    linkingInfos.filter((d) => !d.isBrush).filter((d) => d.linkId === linkId).forEach((d) => {
      hgModel.spec().zoomLocks.locksDict[linkId][d.hgViewId] = [1246253105e-1, 1246253105e-1, 249250.621];
      hgModel.spec().locationLocks.locksDict[linkId][d.hgViewId] = [1246253105e-1, 1246253105e-1, 249250.621];
    });
  });
  const tracks = trackInfos.map((d) => {
    return {
      id: d.track.id,
      spec: d.track,
      shape: d.track.layout === "linear" || IsDummyTrack(d.track) ? d.boundingBox : {
        ...d.boundingBox,
        cx: d.boundingBox.x + d.boundingBox.width / 2,
        cy: d.boundingBox.y + d.boundingBox.height / 2,
        innerRadius: d.track.innerRadius,
        outerRadius: d.track.outerRadius,
        startAngle: d.track.startAngle,
        endAngle: d.track.endAngle
      }
    };
  });
  const views = getViewApiData(spec, tracks);
  const tracksAndViews = [
    ...tracks.map((d) => ({ ...d, type: "track" })),
    ...views.map((d) => ({ ...d, type: "view" }))
  ];
  callback(hgModel.spec(), getBoundingBox(trackInfos), spec, tracksAndViews, idMapper.getTable());
}
function manageResponsiveSpecs(spec, wFactor, hFactor, parentWidth, parentHeight) {
  if (typeof spec._assignedWidth === "undefined" || typeof spec._assignedHeight === "undefined") {
    console.warn("Responsive spec cannot be used when width and height of a view is not determined yet.");
    return false;
  }
  let replaced = false;
  const { responsiveSpec } = spec;
  const width = spec._assignedWidth * wFactor;
  const height = spec._assignedHeight * hFactor;
  const dimensions = { width, height, aspectRatio: width / height };
  const parentDimensions = { width: parentWidth, height: parentHeight, aspectRatio: parentWidth / parentHeight };
  if (responsiveSpec) {
    responsiveSpec.forEach((specAndCondition) => {
      const { spec: alternativeSpec, selectivity } = specAndCondition;
      if (isSelectResponsiveSpec(selectivity, dimensions, parentDimensions) && !replaced) {
        Object.keys(alternativeSpec).forEach((k) => {
          spec[k] = alternativeSpec[k];
        });
        delete spec.responsiveSpec;
        replaced = true;
        return;
      }
    });
  }
  if ("views" in spec) {
    spec.views.forEach((view) => {
      replaced = manageResponsiveSpecs(view, wFactor, hFactor, parentWidth, parentHeight) || replaced;
    });
  }
  return replaced;
}
function isSelectResponsiveSpec(conditions, assignedDimensions, parentDimensions) {
  if (conditions.length === 0)
    return false;
  let isSelect = true;
  conditions.forEach((condition) => {
    const { measure, operation, threshold, target } = condition;
    isSelect = isSelect && logicalComparison(
      (target === "container" ? parentDimensions : assignedDimensions)[measure],
      operation,
      threshold
    ) === 1;
  });
  return isSelect;
}
function compile(spec, callback, templates, theme, containerStatus, urlToFetchOptions) {
  var _a, _b;
  const specCopy = JSON.parse(JSON.stringify(spec));
  overrideDataTemplates(specCopy);
  replaceTrackTemplates(specCopy, templates);
  traverseToFixSpecDownstream(specCopy);
  const trackInfosAndSize = getRelativeTrackInfo(specCopy, theme);
  let { trackInfos } = trackInfosAndSize;
  const { size } = trackInfosAndSize;
  const isResponsiveWidth = typeof spec.responsiveSize === "object" && ((_a = spec.responsiveSize) == null ? void 0 : _a.width) || spec.responsiveSize;
  const isResponsiveHeight = typeof spec.responsiveSize === "object" && ((_b = spec.responsiveSize) == null ? void 0 : _b.height) || spec.responsiveSize;
  const wFactor = isResponsiveWidth && containerStatus.containerSize ? containerStatus.containerSize.width / size.width : 1;
  const hFactor = isResponsiveHeight && containerStatus.containerSize ? containerStatus.containerSize.height / size.height : 1;
  const pWidth = containerStatus.containerParentSize ? containerStatus.containerParentSize.width : Number.MAX_SAFE_INTEGER;
  const pHeight = containerStatus.containerParentSize ? containerStatus.containerParentSize.height : Number.MAX_SAFE_INTEGER;
  const replaced = manageResponsiveSpecs(specCopy, wFactor, hFactor, pWidth, pHeight);
  if (replaced) {
    traverseToFixSpecDownstream(specCopy);
    trackInfos = getRelativeTrackInfo(specCopy, theme).trackInfos;
  }
  publish("specProcessed", {
    id: specCopy.id,
    spec: specCopy
  });
  renderHiGlass(specCopy, trackInfos, callback, theme, urlToFetchOptions);
}
init();
const HiGlassComponentWrapper = forwardRef(
  (props, ref2) => {
    var _a;
    const [wrapperDivId, setWrapperDivId] = useState((_a = props.id) != null ? _a : uuid());
    useEffect(() => {
      var _a2;
      setWrapperDivId((_a2 = props.id) != null ? _a2 : uuid());
    }, [props.id]);
    const viewConfig = props.viewConfig || {};
    const pixelPreciseMarginPadding = false;
    const higlassComponent = useMemo(
      () => /* @__PURE__ */ React.createElement(
        HiGlassComponent,
        {
          ref: ref2,
          options: {
            // This uses `rowHeight: 1` in react-grid-layout, allowing to set height precisely.
            // Since using this disallows responsive resizing of track heights in HiGlass,
            // we need to use this only when users do not want to use responsive height.
            // (See https://github.com/higlass/higlass/blob/2a3786e13c2415a52abc1227f75512f128e784a0/app/scripts/HiGlassComponent.js#L2199)
            pixelPreciseMarginPadding,
            containerPaddingX: 0,
            containerPaddingY: 0,
            viewMarginTop: 0,
            viewMarginBottom: 0,
            viewMarginLeft: 0,
            viewMarginRight: 0,
            viewPaddingTop: 0,
            viewPaddingBottom: 0,
            viewPaddingLeft: 0,
            viewPaddingRight: 0,
            sizeMode: "bounded",
            rangeSelectionOnAlt: true
            // this allows switching between `selection` and `zoom&pan` mode
          },
          viewConfig
        }
      ),
      [viewConfig, pixelPreciseMarginPadding]
    );
    const {
      padding = 60,
      margin = 0,
      border = "none",
      background,
      alt = "Gosling visualization"
    } = props.options || {};
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      "div",
      {
        id: wrapperDivId,
        className: `gosling-component ${props.className || ""}`,
        style: {
          position: "relative",
          padding,
          margin,
          border,
          background,
          width: props.options.responsiveWidth ? `calc(100% - ${padding * 2}px)` : props.size.width,
          height: props.options.responsiveHeight ? `calc(100% - ${padding * 2}px)` : props.size.height,
          textAlign: "left"
        },
        "aria-label": alt,
        role: "graphics-document",
        "aria-roledescription": "visualization"
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          key: JSON.stringify(viewConfig),
          id: "higlass-wrapper",
          className: "higlass-wrapper",
          style: {
            position: "relative",
            display: "block",
            background,
            margin: 0,
            padding: 0,
            // non-zero padding acts unexpectedly w/ HiGlassComponent
            width: props.options.responsiveWidth ? "100%" : props.size.width,
            height: props.options.responsiveHeight ? "100%" : props.size.height
          }
        },
        higlassComponent
      )
    ));
  }
);
HiGlassComponentWrapper.displayName = "HiGlassComponentWrapper";
function createApi(hg, hgSpec, tracksAndViews, theme, idTable) {
  const idTableCopy = structuredClone(idTable);
  const getHgViewId = (trackId) => {
    const viewId = idTableCopy[trackId];
    if (!viewId) {
      console.warn(`Unable to find the track ID, named ${trackId}.`);
    }
    return viewId != null ? viewId : trackId;
  };
  const getTrackIds2 = () => {
    return Object.keys(idTableCopy);
  };
  const getTracksAndViews = () => {
    return [...tracksAndViews];
  };
  const getTracks = () => {
    return [...getTracksAndViews().filter((d) => d.type === "track")];
  };
  const getTrack = (trackId) => {
    const trackInfoFound = getTracks().find((d) => d.id === trackId);
    if (!trackInfoFound) {
      console.warn(`[getTrack()] Unable to find a track using the ID (${trackId})`);
    }
    return trackInfoFound;
  };
  const getViews = () => {
    return [...getTracksAndViews().filter((d) => d.type === "view")];
  };
  const getView = (viewId) => {
    const view = getViews().find((d) => d.id === viewId);
    if (!view) {
      console.warn(`Unable to find a view with the ID of ${viewId}`);
    }
    return view;
  };
  const getCanvas = (options) => {
    var _a, _b;
    const resolution = (_a = options == null ? void 0 : options.resolution) != null ? _a : 4;
    const transparentBackground = (_b = options == null ? void 0 : options.transparentBackground) != null ? _b : false;
    const renderer = hg.pixiRenderer;
    const renderTexture = PIXI.RenderTexture.create({
      width: renderer.width / 2,
      height: renderer.height / 2,
      resolution
    });
    renderer.render(hg.pixiStage, renderTexture);
    const canvas = renderer.plugins.extract.canvas(renderTexture);
    const canvasWithBg = document.createElement("canvas");
    canvasWithBg.width = canvas.width;
    canvasWithBg.height = canvas.height;
    const ctx = canvasWithBg.getContext("2d");
    if (!transparentBackground) {
      ctx.fillStyle = theme.root.background;
      ctx.fillRect(0, 0, canvasWithBg.width, canvasWithBg.height);
    }
    ctx.drawImage(canvas, 0, 0);
    return {
      canvas: canvasWithBg,
      resolution,
      canvasWidth: canvas.width,
      canvasHeight: canvas.height
    };
  };
  return {
    subscribe,
    unsubscribe,
    zoomTo: (trackId, position, padding = 0, duration = 1e3) => {
      var _a;
      const assembly = (_a = getTrack(trackId)) == null ? void 0 : _a.spec.assembly;
      const manager = GenomicPositionHelper.fromString(position);
      const absCoordinates = manager.toAbsoluteCoordinates(assembly, padding);
      const hgViewId = getHgViewId(trackId);
      hg.api.zoomTo(hgViewId, ...absCoordinates, ...absCoordinates, duration);
    },
    zoomToExtent: (trackId, duration = 1e3) => {
      var _a;
      const assembly = (_a = getTrack(trackId)) == null ? void 0 : _a.spec.assembly;
      const [start, end] = [0, computeChromSizes(assembly).total];
      const hgViewId = getHgViewId(trackId);
      hg.api.zoomTo(hgViewId, start, end, start, end, duration);
    },
    zoomToGene: (trackId, gene, padding = 0, duration = 1e3) => {
      const hgViewId = getHgViewId(trackId);
      hg.api.zoomToGene(hgViewId, gene, padding, duration);
    },
    suggestGene: (trackId, keyword2, callback) => {
      const hgViewId = getHgViewId(trackId);
      hg.api.suggestGene(hgViewId, keyword2, callback);
    },
    getTrackIds: getTrackIds2,
    getTracksAndViews,
    getTracks,
    getTrack,
    getView,
    getViews,
    getCanvas,
    exportPng: (transparentBackground) => {
      const { canvas } = getCanvas({ resolution: 4, transparentBackground });
      canvas.toBlob((blob2) => {
        const a = document.createElement("a");
        document.body.append(a);
        a.download = "gosling-visualization";
        a.href = URL.createObjectURL(blob2);
        a.click();
        a.remove();
      }, "image/png");
    },
    exportPdf: async (transparentBackground) => {
      const { jsPDF } = await import("jspdf");
      const { canvas } = getCanvas({ resolution: 4, transparentBackground });
      const imgData = canvas.toDataURL("image/jpeg", 1);
      const pdf = new jsPDF({
        orientation: canvas.width < canvas.height ? "p" : "l",
        unit: "pt",
        format: [canvas.width, canvas.height]
      });
      pdf.addImage(imgData, "JPEG", 0, 0, canvas.width, canvas.height);
      pdf.save("gosling-visualization.pdf");
    }
  };
}
function omitDeep(spec, omitKeys) {
  return cloneDeepWith(spec, (value) => {
    if (isObject(value)) {
      omitKeys.forEach((key) => {
        delete value[key];
      });
    }
  });
}
const preverseZoomStatus = (newSpec, prevSpec) => {
  newSpec.views.forEach((view) => {
    var _a, _b, _c;
    const viewUid = view.uid;
    const isNewView = !prevSpec.views.find((v) => v.uid === viewUid);
    if (isNewView) {
      const { locksByViewUid } = newSpec.zoomLocks;
      const lockUid = locksByViewUid[viewUid];
      const linkedViewUid = (_a = Object.entries(locksByViewUid).find(([_, uid]) => _ && uid === lockUid)) == null ? void 0 : _a[0];
      const linkedViewExistedPrev = !!prevSpec.views.find((v) => v.uid === linkedViewUid);
      if (linkedViewUid && linkedViewExistedPrev) {
        view.initialXDomain = (_b = prevSpec.views.find((v) => v.uid === linkedViewUid)) == null ? void 0 : _b.initialXDomain;
        view.initialYDomain = (_c = prevSpec.views.find((v) => v.uid === linkedViewUid)) == null ? void 0 : _c.initialYDomain;
      }
    }
  });
};
const DELAY_FOR_CONTAINER_RESIZE_BEFORE_RERENDER = 300;
const GoslingComponent = forwardRef((props, ref2) => {
  var _a, _b, _c;
  const [viewConfig, setViewConfig] = useState();
  const [size, setSize] = useState({ width: 200, height: 200 });
  const wrapperSize = useRef();
  const wrapperParentSize = useRef();
  const prevSpec = useRef();
  const tracksAndViews = useRef([]);
  const idTable = useRef({});
  const hgRef = useRef(null);
  const theme = getTheme(props.theme || "light");
  const wrapperDivId = (_a = props.id) != null ? _a : uuid();
  const publishOnNewView = (currentTracksAndViews) => {
    const prevViews = tracksAndViews.current.filter((data2) => data2.type == "view");
    const currentViews = currentTracksAndViews.filter((data2) => data2.type == "view");
    const prevViewIds = new Set(prevViews.map((data2) => data2.id));
    const newViews = currentViews.filter((view) => !prevViewIds.has(view.id));
    newViews.forEach((view) => {
      publish("onNewView", { id: view.id });
    });
  };
  useImperativeHandle(
    ref2,
    () => {
      const hgApi = refAsReadonlyProxy(hgRef);
      const visUnits = refAsReadonlyProxy(tracksAndViews);
      const api = createApi(hgApi, viewConfig, visUnits, theme, idTable.current);
      return { api, hgApi };
    },
    [viewConfig, theme]
  );
  const compile$12 = useCallback(() => {
    if (props.spec) {
      const valid = validateGoslingSpec(props.spec);
      if (valid.state === "error") {
        console.warn("Gosling spec is not valid. Please refer to the console message.");
        return;
      }
      compile(
        props.spec,
        (newHiGlassSpec, newSize, newGoslingSpec, newTracksAndViews, newIdTable) => {
          var _a2, _b2;
          if (prevSpec.current && isEqual(omitDeep(prevSpec.current, ["linkingId"]), omitDeep(newGoslingSpec, ["linkingId"]))) {
            return;
          }
          (_a2 = props.compiled) == null ? void 0 : _a2.call(props, props.spec, newHiGlassSpec, { _processedSpec: newGoslingSpec });
          setSize(newSize);
          const isMountedOnce = typeof viewConfig !== "undefined";
          if (((_b2 = props.experimental) == null ? void 0 : _b2.reactive) && isMountedOnce) {
            setTimeout(() => {
              var _a3, _b3;
              preverseZoomStatus(
                newHiGlassSpec,
                (_a3 = hgRef.current) == null ? void 0 : _a3.api.getViewConfig()
              );
              (_b3 = hgRef.current) == null ? void 0 : _b3.api.setViewConfig(newHiGlassSpec);
            }, DELAY_FOR_CONTAINER_RESIZE_BEFORE_RERENDER);
          } else {
            setViewConfig(newHiGlassSpec);
          }
          publishOnNewView(newTracksAndViews);
          prevSpec.current = newGoslingSpec;
          tracksAndViews.current = newTracksAndViews;
          idTable.current = newIdTable;
        },
        [...GoslingTemplates],
        // TODO: allow user definitions
        theme,
        {
          containerSize: wrapperSize.current,
          containerParentSize: wrapperParentSize.current
        },
        props.urlToFetchOptions
      );
    }
  }, [props.spec, theme]);
  useEffect(() => {
    var _a2;
    if (!((_a2 = props.spec) == null ? void 0 : _a2.responsiveSize))
      return;
    const containerElement = document.getElementById(wrapperDivId);
    if (!containerElement)
      return;
    const resizer = new ResizeSensor(containerElement, (newSize) => {
      if (!wrapperSize.current || wrapperSize.current.height !== newSize.height || wrapperSize.current.width !== newSize.width) {
        wrapperSize.current = newSize;
        compile$12();
      }
    });
    const parentElement = containerElement.parentElement;
    if (!parentElement)
      return;
    const parentResizer = new ResizeSensor(parentElement, (newSize) => {
      if (!wrapperParentSize.current || wrapperParentSize.current.height !== newSize.height || wrapperParentSize.current.width !== newSize.width) {
        wrapperParentSize.current = newSize;
        compile$12();
      }
    });
    return () => {
      resizer.detach();
      parentResizer.detach();
    };
  });
  useEffect(() => {
    compile$12();
  }, [props.spec, theme]);
  const responsiveHeight = typeof ((_b = props.spec) == null ? void 0 : _b.responsiveSize) !== "object" ? (_c = props.spec) == null ? void 0 : _c.responsiveSize : props.spec.responsiveSize.height;
  const higlassComponent = useMemo(
    () => {
      var _a2, _b2, _c2;
      return /* @__PURE__ */ React.createElement(
        HiGlassComponentWrapper,
        {
          ref: hgRef,
          viewConfig,
          size,
          id: wrapperDivId,
          className: props.className,
          options: {
            padding: props.padding,
            border: props.border,
            margin: props.margin,
            responsiveWidth: typeof ((_a2 = props.spec) == null ? void 0 : _a2.responsiveSize) !== "object" ? (_b2 = props.spec) == null ? void 0 : _b2.responsiveSize : props.spec.responsiveSize.width,
            responsiveHeight,
            background: theme.root.background,
            alt: (_c2 = props.spec) == null ? void 0 : _c2.description
          }
        }
      );
    },
    [viewConfig, size, theme, responsiveHeight]
  );
  return higlassComponent;
});
GoslingComponent.displayName = "GoslingComponent";
function refAsReadonlyProxy(ref2) {
  return new Proxy({}, {
    get(_target, prop, reciever) {
      if (!ref2.current)
        throw Error("ref is not set!");
      return Reflect.get(ref2.current, prop, reciever);
    }
  });
}
var createRoot;
var m = require$$0;
if (process.env.NODE_ENV === "production") {
  createRoot = m.createRoot;
  m.hydrateRoot;
} else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  createRoot = function(c, o) {
    i.usingClientEntryPoint = true;
    try {
      return m.createRoot(c, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };
}
const MAX_TRIES = 20;
const INTERVAL = 200;
const launchHiglass = (element, viewConfig, size, opts) => {
  const ref2 = React.createRef();
  const component = React.createElement(HiGlassComponentWrapper, {
    ref: ref2,
    viewConfig,
    size,
    id: opts.id,
    className: opts.className,
    options: opts
  });
  createRoot(element).render(component);
  return new Promise((resolve2, reject) => {
    let tries = 0;
    const poll = setInterval(() => {
      if (ref2 && ref2.current) {
        clearInterval(poll);
        resolve2(ref2.current);
      }
      if (tries >= MAX_TRIES) {
        reject(new Error("Failed to initialize HiGlassApi."));
      }
      tries++;
    }, INTERVAL);
  });
};
function embed(element, spec, opts = {}) {
  return new Promise((resolve2, reject) => {
    var _a, _b;
    const valid = validateGoslingSpec(spec);
    if (valid.state === "error") {
      reject(new Error("Gosling spec is not valid. Please refer to the console message."));
    }
    const theme = getTheme(opts.theme || "light");
    const options = {
      ...opts,
      background: theme.root.background,
      alt: (_b = (_a = opts.alt) != null ? _a : spec.description) != null ? _b : "Gosling visualization"
    };
    compile(
      spec,
      async (hsSpec, size, _, trackInfos, idTable) => {
        const hg = await launchHiglass(element, hsSpec, size, options);
        const api = createApi(hg, hsSpec, trackInfos, theme, idTable);
        resolve2(api);
      },
      [...GoslingTemplates],
      theme,
      {},
      // TODO: properly specify this
      opts.urlToFetchOptions
    );
  });
}
export {
  GoslingComponent,
  GoslingSchema,
  GoslingTemplates,
  theme_schema as ThemeSchema,
  Themes,
  compile,
  embed,
  getTheme$1 as getTheme,
  init,
  isThereTheme,
  name,
  validateGoslingSpec,
  version
};
//# sourceMappingURL=gosling.js.map
